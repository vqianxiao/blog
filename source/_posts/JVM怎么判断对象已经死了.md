---
layout:    post
title:     JVM怎么判断对象已经死了
category:  JVM
description: 在JVM中是如何判断对象已经死亡的呢
tags: JVM
---

> 本文转载自 https://mp.weixin.qq.com/s/bPexDXkSJ0T4vQnmWMsoZQ 

GC的历史比Java还要久远，我们在思考GC时候需要思考三个问题：

**哪些内存需要回收？**

**什么时候回收？**

**如何回收？**

在Java中程序计数器、虚拟机栈、本地方法栈这三个区域随线程而生，随线程而灭：栈中的栈帧随着方法的调用和退出而有条不紊的进行着入栈和出栈的过程。

每个栈帧分配多少内存在类结构确定下来时就已知的，方法结束或者线程结束内存自然跟着回收了。

而Java堆和方法区不一样，一个接口中的多个实现类的内存可能不一样，每个方法的多个分支需要的内存也可能不一样，我们只有在程序运行时候才知道会创建哪些对象，这部分内存的分配和回收都是动态的。

### 一、判断对象已死的算法

1）引用计数算法

给对象添加一个引用计数器，每当一个地方引用它时候，计数器就加1，当引用失效，计数器就减1；任何时刻计数器为0的对象就是不可能再被使用了。

这种方法实现简单，效率高，但是它很难解决对象的循环引用问题：

```java
public class Test {

    private static final int _1MB = 1024 *1024;

    private Object instance = null;

    public static void testGC(){
        Test objectA = new Test();
        Test objectB = new Test();

        objectA.instance = objectB;
        objectB.instance = objectA;

        objectA = null;
        objectB = null;

        // 假如这里发生GC，objectA和objectB会不会被回收

    }
}
```

2）可达性分析算法

这个算法的基本思路是通过一系列称为`GC Roots`（一组必须活跃的引用）作为起始点，从这些节点开始向下搜索，搜索走过的路径称为引用链，当一个对象到`GC Roots`没有任何引用链时候，那么证明此对象是不可用的。

在Java语言中，能作为`GC Roots`的对象包括以下几种

1）虚拟机栈（栈帧中的本地变量表）中引用的对象

2）方法区中类静态属性引用的对象

3）方法区中常量引用的对象

4）本地方法栈JNI（即一般说的Native方法）引用的对象

### 二、引用

无论是通过引用计数器算法判断对象的引用数量，还是通过可达性分析算法判断对象引用链是否可达，判断对象是否可活都离不开引用，Java中将引用分为四种：

**1）强引用（Strong Reference）**

是指程序代码中普遍存在的，类似“Object obj = new Object()”这类的引用，只有强引用还存在对象就不会被回收。

**2）软引用（Soft Reference）**

软引用是用来描述一些还有用但是非必须的对象。对于软引用关联的对象，在系统将于发生内存溢出异常之前，将会把这些对象列进回收范围中进行二次回收。

**3）弱引用（Weak Reference）**

也是用来描述非必须对象的，强度比软引用还弱一些，被软引用关联的对象只能存活到下一次内存回收之前。

**4）虚引用（Phantom Referenece）**

也成为幽灵引用和幻影引用，为一个对象设置虚引用关联的唯一目的就是能在这个对象被回收时收到一个系统通知。

### 三、生存还是死亡

即使在可达性分析算法中不可达的对象，也并非一定是“非死不可”的，这时候他们暂时处于“缓刑”阶段，真正宣告一个对象死亡至少要经历两个阶段：

1）如果对象在可达性分析算法中不可达，那么它会被第一次标记并进行一次筛选，筛选的条件是是否需要执行finalize()方法（当对象没有覆盖finalize()或者finalize()方法已经执行过了（对象的此方法只会执行一次）），虚拟机将这两种情况都会视为没有必要执行）。

2）如果这个对象有必要执行finalize()方法会将其放入F-Queue队列中，稍后GC将对F-Queue队列进行第二次标记，如果在重写finalize()方法中将对象自己赋值给某个类变量或者对象的成员变量，那么第二次标记时候就会将它移出“即将回收”的集合。

finalize()能做的工作，使用 try-finally 或者其他方式都能做到更好，更及时，所以不建议使用此方法。

### 四、方法区回收

永久代中回收的内容主要是两部分：废弃的常量和无用的类。判断无用的类（类卸载）必须满足三个条件：

1）该类所有的实例都已经被回收

2）加载该类的ClassLoader被回收

3）该类对应的java.lang.Class对象没有在任何地方引用，无法在任何地方通过反射访问该类的方法