---
layout:    post
title:     设计原则-规范与重构
category:  设计模式之美
description: 规范与重构
tags: 设计模式之美
---



### 重构

重构是一种对软件内部结构的改善，目的是在不改变软件的可见行为的情况下，使其更易理解，修改成本更低

可以理解为在保持功能不变的前提下，利用设计思想、原则、模式、变成规范等理论来优化代码，修改设计上的不足，提高代码质量。

**大规模高层次重构**（对顶层代码设计的重构）

重构内容：系统、模块、代码结构、类与类之间的关系等的重构，

重构手段：分层、模块化、解耦、抽象可复用组件等等

这类重构涉及的代码改动会比较多，影响面会比较大，所以难度也较大，耗时较长，引入bug的风险也会相对比较大

**小规模低层次重构**

重构内容：针对类、函数、变量等代码级别的重构，比如规范命名、规范注释、消除超大类或函数、提取重复代码等

重构手段：根据编码规范修改代码

修改的地方比较集中，比较简单，可操作性较强，耗时较短，引入bug的风险较小。只需要熟练掌握各种编码规范，就可以得心应手

**重构的时机**

持续重构。没有事情的时候可以看哪些代码写的不够好、可以优化的代码，主动重构一下。修改、添加某个功能代码的时候，可以顺手把不符合编码规范、不好的设计重构一下。把持续重构也作为开发的一部分，成为一种开发习惯，对项目、对自己都会很有好处。

**重构的方法**

大型重构时，需要提前做好完善的重构计划，有条不紊地分阶段来进行。每个阶段完成一小部分代码的重构，然后提交、测试、运行，没有问题后，再继续进行下一阶段的重构，保证仓库中的代码一直处于可运行、逻辑正确的状态。每个阶段，都要控制好重构影响到的代码范围，考虑好如何兼容老的代码逻辑，必要的时候还要写一些兼容过渡代码。只有这样，才能让每一阶段的重构都不至于耗时太长（最好一天就能完成），不至于与心的功能开发相冲突。大规模高层次的重构一定是有组织、有计划，并且非常谨慎的，需要有经验、熟悉业务的资深同事来主导。

小规模低层次的重构，因为影响范围小，改动耗时短，所以只要有时间，随时都可以去做。除了人工去发现低层次的质量问题，还可以借助很多成熟的静态代码分析工具（C heckStyle、FindBugs、PMD）来自动发现代码中的问题，然后针对性的进行重构优化。

### 单元测试

集成测试的测试对象是整个系统或者某个功能模块，比如测试用户注册、登陆功能是否正常，是一种端到端的测试。单元测试的测试对象是类或者函数，用来测试一个类和函数是否都按照预期的逻辑执行，是代码层级的测试。

单元测试能够有效地发现代码中的bug，可以节省很多修复低级bug的四件，能够有更多时间去做其他更有意义的事情

单元测试能发现代码设计上的问题，可以发现 没有使用依赖注入 大量使用静态函数 全局变量 代码耦合度高等问题

单元测试是对集成测试的有力补充，可以在边界条件、异常情况下测试出bug。如果可以保证每个类、每个函数都能按照我们的预期来执行，底层bug少了，那组装起来的整个系统，出问题的概率也就相应减少了。

写单元测试的过程本身就是代码重构的过程，设计和实现的时候很难把所有的问题都想清楚。编写单元测试相当于一个review，可以发现一些设计上的问题及代码编写方面的问题等，然后进行重构。

阅读单元测试可以快速熟悉代码，阅读代码的最有效手段，就是先了解它的业务背景和设计思路，然后再去看代码，这样代码读起来就会轻松很多。

单元测试是TDD可落地执行的改进方案。测试驱动开发（Test-Driven Development）核心指导思想是测试用例优先于代码编写。

编写单元测试尽管繁琐，但并不是太耗时

我们可以稍微放低对单元测试代码质量的要求

覆盖率作为衡量单元测试质量的唯一标准是不合理的

单元测试不要依赖被测代码的具体实现逻辑

单元测试框架无法测试，多半是因为代码的可测试性不好

**编写可测试性代码的最有效手段**

依赖注入是编写可测试性代码的最有效手段，通过依赖注入，在编写单元测试的时候，可以通过mock的方法解决依赖外部服务，这也是在编写单元测试的过程中最有技术挑战的地方。

**常见的反模式 Anti-Patterns**

代码中包含未决行为逻辑

未决行为逻辑就是，代码的输出是随机或者说不确定的，比如和时间、随机数有关系的代码

滥用可变全局变量

全局变量是一种面向过程的编程风格。存在线程安全及被意料之外的修改等问题，可能会被多行代码影响函数的执行结果

滥用静态方法

静态方法很难mock 只有静态方法执行耗时太长，依赖外部资源，逻辑复杂，行为未决等情况下才需要单元测试mock这个静态方法。如果是类似工具类的Math.abs()这样的简单静态方法，并不会影响代码的可测试性

使用复杂的继承关系

继承关系的代码结构更加耦合、不灵活，更加不易扩展、不易维护。如果父类需要mock某个依赖对象才能进行单元测试，那么所有的子类、子类的子类在单元测试的时候，都需要mock这个依赖对象。

高度耦合的代码

如果一个类职责很重，需要依赖十几个外部对象才能完成工作，代码高度耦合，编写单元测试的时候也需要mock这十几个依赖的对象。不管从代码设计的角度来说还是编写单元测试的角度来说，都是不合理的。

### 解耦

如果说重构是保证代码质量不至于腐化到无可救药地步的有效手段，那么利用解耦的方法对代码重构，就是保证代码不至于复杂到无法控制的有效手段。不管是阅读代码还是修改代码，高内聚、松耦合的特性可以让我们聚焦在某一模块或类中，不需要了解太多其他模块或类的代码，让我们的焦点不至于过于发散，降低了阅读和修改代码的难度。

**如何给代码“解耦”**

1.封装与抽象

封装和抽象可以有效地隐藏实现的复杂性，隔离实现的易变性，给依赖的模块提供稳定且易用的抽象接口。

2.中间层

引入中间层能简化模块或类之间的依赖关系。如A、B、C分别依赖内存以及缓存、Redis二级缓存、DB持久化存储，可以引入数据存储中间层，A、B、C都只需要依赖数据存储中间层就可以实现原有功能，明显的简化了依赖关系，让代码结构更加清晰。

3.模块化

将系统划分成各个独立的模块，让不同的人负责不同的模块，这样即便在不了解全部细节的情况下，管理者也能协调各个模块，让整个系统有效运转。模块化思想更加本质的东西就是分而治之。

4.其他设计思想和原则

单一职责原则

模块或者类的职责设计得单一，而不是大而全，那依赖它的类和它依赖的类就会比较少，代码耦合也就降低了。

基于接口而非实现编程

基于接口而非实现编程能通过接口这样一个中间层，隔离变化和具体的实现。在有依赖关系的两个模块或类之间，一个模块或者类的改动。不会影响到另一个模块或类。

依赖注入

跟基于接口而非实现编程思想类似，依赖注入也是将代码的强耦合变为弱耦合。尽管没办法解耦成没有依赖关系，但是可以让耦合关系没那么紧密，容易做到插拔替换。

多用组合少用继承

继承是一种强依赖关系，父类和子类高度耦合，且这种耦合关系非常脆弱，牵一发而动全身，父类的每一次改动都会影响所有的子类。

迪米特法则

不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口。

观察者模式



### 编程规范

**程序出错返回值**

1.错误码还是异常

编程语言中有异常语法机制，就不要使用错误码。异常相对于错误码，可以携带更多的错误信息，异常中可以有message，stack trace等信息。

2.NULL

null表示不存在这种语义。查询返回null还是异常，主要看项目约定，但是对于查找函数来说，查找下标的时候，比如indexOf()函数，返回的是int就没办法用null了，所以-1更加合理。没有查找到是一种正常而非异常的行为，是判断返回null还是异常的标准。

3.返回空对象

比较特殊的空对象就是空字符串和空集合。当函数返回的数据是字符串类型或者集合类型的时候，可以用空字符串或空集合替代NULL值，用来表示不存在的情况，这样在使用函数的时候，就可以不用做null值判断了。

4.抛出异常对象

异常可以将正常逻辑和异常逻辑分离开来，这样代码的可读性就会更好。异常处理是否继续往上抛，需要看上层代码是否关心这个异常，关心就将异常抛出，否则就直接吞掉。是否需要包装成新的异常，看上层代码是否能理解这个异常、是否和业务相关





















































