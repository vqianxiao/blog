{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/js/algolia-search.js","path":"js/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/bookmark.js","path":"js/bookmark.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/local-search.js","path":"js/local-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/motion.js","path":"js/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/next-boot.js","path":"js/next-boot.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/anime.min.js","path":"lib/anime.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/schemes/pisces.js","path":"js/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/all.min.css","path":"lib/font-awesome/css/all.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-brands-400.woff2","path":"lib/font-awesome/webfonts/fa-brands-400.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-regular-400.woff2","path":"lib/font-awesome/webfonts/fa-regular-400.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-solid-900.woff2","path":"lib/font-awesome/webfonts/fa-solid-900.woff2","modified":1,"renderable":1},{"_id":"source/images/aqs/syncqueue.png","path":"images/aqs/syncqueue.png","modified":1,"renderable":0},{"_id":"source/images/aqs/tailfork.png","path":"images/aqs/tailfork.png","modified":1,"renderable":0},{"_id":"source/images/bug/dockerBuild.png","path":"images/bug/dockerBuild.png","modified":1,"renderable":0},{"_id":"source/images/bug/jibBuild.png","path":"images/bug/jibBuild.png","modified":1,"renderable":0},{"_id":"source/images/bug/logBlockDown.png","path":"images/bug/logBlockDown.png","modified":1,"renderable":0},{"_id":"source/images/hashmap/bst.png","path":"images/hashmap/bst.png","modified":1,"renderable":0},{"_id":"source/images/hashmap/bstdel.png","path":"images/hashmap/bstdel.png","modified":1,"renderable":0},{"_id":"source/images/hashmap/delcase1.png","path":"images/hashmap/delcase1.png","modified":1,"renderable":0},{"_id":"source/images/hashmap/delcase2.png","path":"images/hashmap/delcase2.png","modified":1,"renderable":0},{"_id":"source/images/hashmap/delcase3.png","path":"images/hashmap/delcase3.png","modified":1,"renderable":0},{"_id":"source/images/hashmap/delcase4.png","path":"images/hashmap/delcase4.png","modified":1,"renderable":0},{"_id":"source/images/hashmap/hashcode.png","path":"images/hashmap/hashcode.png","modified":1,"renderable":0},{"_id":"source/images/hashmap/insertcase1.png","path":"images/hashmap/insertcase1.png","modified":1,"renderable":0},{"_id":"source/images/hashmap/insertcase2.png","path":"images/hashmap/insertcase2.png","modified":1,"renderable":0},{"_id":"source/images/hashmap/insertcase3.png","path":"images/hashmap/insertcase3.png","modified":1,"renderable":0},{"_id":"source/images/hashmap/rotateRBTree.png","path":"images/hashmap/rotateRBTree.png","modified":1,"renderable":0},{"_id":"source/images/mq/mq1.png","path":"images/mq/mq1.png","modified":1,"renderable":0},{"_id":"source/images/mq/mq10.png","path":"images/mq/mq10.png","modified":1,"renderable":0},{"_id":"source/images/mq/mq2.png","path":"images/mq/mq2.png","modified":1,"renderable":0},{"_id":"source/images/mq/mq3.png","path":"images/mq/mq3.png","modified":1,"renderable":0},{"_id":"source/images/mq/mq4.png","path":"images/mq/mq4.png","modified":1,"renderable":0},{"_id":"source/images/mq/mq5.png","path":"images/mq/mq5.png","modified":1,"renderable":0},{"_id":"source/images/mq/mq6.png","path":"images/mq/mq6.png","modified":1,"renderable":0},{"_id":"source/images/mq/mq7.png","path":"images/mq/mq7.png","modified":1,"renderable":0},{"_id":"source/images/mq/mq8.png","path":"images/mq/mq8.png","modified":1,"renderable":0},{"_id":"source/images/mq/mq9.png","path":"images/mq/mq9.png","modified":1,"renderable":0}],"Cache":[{"_id":"source/about/index.md","hash":"1a3672c6271b32a6c50ba2c49256f178641cbbba","modified":1727194336870},{"_id":"source/.DS_Store","hash":"51b7fbef34b76a4c6c596a1e1974b56c85dadc58","modified":1628672377225},{"_id":"source/_posts/AQS源码分析之Condition接口的实现.md","hash":"457baae1b3170e472be30234e04c254f8464c39d","modified":1727194336858},{"_id":"source/_posts/AQS源码分析之共享锁的获取与释放.md","hash":"6568d28dacd5fab3bed903c776cc0faf3ff62d2b","modified":1727194336858},{"_id":"source/_posts/AQS源码分析之独占锁的获取.md","hash":"b3d78fcbe91ef527c8af4a9f52e0aa1e3d21bc00","modified":1727194336859},{"_id":"source/_posts/AQS源码分析之独占锁的释放.md","hash":"efdb7013dd214a9d65bbb07288af54c4d7ab9591","modified":1727194336859},{"_id":"source/_posts/JVM怎么判断对象已经死了.md","hash":"0877430d58d9dca1f39352c73d8a949a03e8f94c","modified":1727194336859},{"_id":"source/_posts/日志阻塞导致重启问题排查.md","hash":"3e1dfd300d78f2aedb2d1576f13386c53bec253f","modified":1727194336860},{"_id":"source/_posts/容器重启背后的思考.md","hash":"3ac2ff17f60f6fd9132be5c2f0e1919afa825004","modified":1727194336859},{"_id":"source/_posts/死磕ArrayList源码.md","hash":"8bc7a52ed448967f69afb8130905c9999a37a15b","modified":1727194336860},{"_id":"source/_posts/死磕ConcurrentHashMap源码.md","hash":"dc0e0bbab9d3b386a8a5ea2f75d2270f94fc1565","modified":1727194336860},{"_id":"source/_posts/死磕HashMap源码(一).md","hash":"c6ae0803dff3a541d9a0220372de10e7637faac4","modified":1727194336860},{"_id":"source/_posts/死磕HashMap源码(二).md","hash":"5c69c63f5cb6a79ec5266f20ddc17e0fdf02ec6a","modified":1727194336861},{"_id":"source/_posts/死磕LinkedList源码.md","hash":"1e45ee51203225d8f16e517fe5452334c53fcea1","modified":1727194336861},{"_id":"source/_posts/死磕ThreadLocal源码.md","hash":"3ce8c3d318bd665272683bc986cb891d5d001706","modified":1727194336861},{"_id":"source/_posts/设计原则.md","hash":"ccec39e61f1d358f6ca1047d8c20845f6b9f6623","modified":1727194336862},{"_id":"source/_posts/消息队列选型-[转载].md","hash":"eb251adf627e813065fa3fbf83ce3ae3061dbfa4","modified":1727194336861},{"_id":"source/_posts/设计原则与思想-规范与重构.md","hash":"92f36b80f552ee188e976cf55704616566e0d038","modified":1727194336862},{"_id":"source/_posts/设计原则与思想-设计原则.md","hash":"0e12496748b8201428b723b057dae4cbebca96d7","modified":1727194336862},{"_id":"source/_posts/设计原则与思想-面向对象.md","hash":"88783149b857dbd5427d2e67a52862e46b0cf8d7","modified":1727194336862},{"_id":"source/_posts/设计模式之中介模式.md","hash":"04f4aa5b466ba4d586734fa77b21e82db7d85aba","modified":1727194336863},{"_id":"source/_posts/设计模式之享元模式.md","hash":"29e9f1ad629b8b7b6ae0aa0ce3ebb5192045a7f4","modified":1727194336863},{"_id":"source/_posts/设计模式之代理模式.md","hash":"d87223b4f5db5fa132163a22890568ab647b26ce","modified":1727194336863},{"_id":"source/_posts/设计模式之单例模式.md","hash":"08ac3a768a8e7e70746bbe7b452e4e25f5f0b6a9","modified":1727194336863},{"_id":"source/_posts/设计模式之原型模式.md","hash":"c677352af1325dc9274983a8ae8f12c870abf3fb","modified":1727194336863},{"_id":"source/_posts/设计模式之命令模式.md","hash":"f3f50667ce32f8646bfc64101022529852353ee5","modified":1727194336864},{"_id":"source/_posts/设计模式之备忘录模式.md","hash":"5f987492ec963719fd3f1394b1b81642fad16848","modified":1727194336864},{"_id":"source/_posts/设计模式之工厂模式.md","hash":"5f4b44f0088bd13348c625106d823ebcd510ab22","modified":1727194336864},{"_id":"source/_posts/设计模式之建造者模式.md","hash":"cd6a2f443f4d6d2d43c46d51af1c311031e20dd4","modified":1727194336864},{"_id":"source/_posts/设计模式之桥接模式.md","hash":"bf72b6b2cd4189cf1e955e197f254443dacb73db","modified":1727194336865},{"_id":"source/_posts/设计模式之模版模式.md","hash":"15a89570530c371c428ef5d0f3c4d1770266ea7e","modified":1727194336865},{"_id":"source/_posts/设计模式之状态模式.md","hash":"989b26d4689ab1615af3bdc2aca7777e4b2611a2","modified":1727194336865},{"_id":"source/_posts/设计模式之策略模式.md","hash":"f34c0bd4c7075e7e7840ba4d02149fda307e7ea8","modified":1727194336866},{"_id":"source/_posts/设计模式之装饰器模式.md","hash":"50e7963c8808ede0ea0e2a4a81e81fece972283b","modified":1727194336866},{"_id":"source/_posts/设计模式之组合模式.md","hash":"98ffbcd6ecc79df756d01f4da8c1e62b7b0cda1f","modified":1727194336866},{"_id":"source/_posts/设计模式之解释器模式.md","hash":"6d72e133ee5cc2ecb7a8d165de5addba18cf7f67","modified":1727194336867},{"_id":"source/_posts/设计模式之观察者模式.md","hash":"ef92190d2c6ea8111aeb7625e504220ecd4fd6f1","modified":1727194336867},{"_id":"source/_posts/设计模式之访问者模式.md","hash":"e22c277fd2aa0cc4047eef0c797c8d9185386ce9","modified":1727194336868},{"_id":"source/_posts/设计模式之迭代器模式.md","hash":"99b3bef95e8669fe85ab04fd459ef945e40c2238","modified":1727194336868},{"_id":"source/_posts/设计模式之适配器模式.md","hash":"6e8adee164443be1d7af631525e28d056b44f128","modified":1727194336869},{"_id":"source/_posts/设计模式之门面模式.md","hash":"1aadc3d2f14db620b98e2425ae2c611990a8ad6a","modified":1727194336869},{"_id":"source/images/bug/jibBuild.png","hash":"f0834a1d446487f22d886d3f860618fe9ed8d1ef","modified":1727194336873},{"_id":"source/images/bug/dockerBuild.png","hash":"867b9cf393ebe7058ba9053fc145ad6a7802ec4f","modified":1727194336872},{"_id":"source/images/hashmap/delcase1.png","hash":"043e687f6b685a127547f05fcf095278f2022562","modified":1727194336881},{"_id":"source/images/hashmap/delcase2.png","hash":"2254dd196d6335e914b6fb56bebd7c62dc2acad7","modified":1727194336881},{"_id":"source/images/hashmap/delcase3.png","hash":"998fc6bcb03cd51ea035befab676925dbe666d07","modified":1727194336882},{"_id":"source/images/hashmap/delcase4.png","hash":"3d6d84fd0031f63b652a2e3a230b411eaf542d6d","modified":1727194336882},{"_id":"source/images/hashmap/hashcode.png","hash":"03ec5d623459e0c81bae169252556d909c985fee","modified":1727194336883},{"_id":"source/images/hashmap/insertcase1.png","hash":"d3fd176d4f1ed3acfad512c9c5fe8f894a347dfb","modified":1727194336883},{"_id":"source/images/hashmap/insertcase2.png","hash":"d4d8793fedbc5d9aa0a397e3aa2564afde74642d","modified":1727194336884},{"_id":"source/images/hashmap/insertcase3.png","hash":"843e247d2c7a792912ad3d71a016c176aeb56aef","modified":1727194336884},{"_id":"source/images/aqs/syncqueue.png","hash":"02dd0ba7e636e2593c3f42774ba168a28b337f89","modified":1727194336871},{"_id":"source/images/aqs/tailfork.png","hash":"687a4b3d0d9a435cbd52937437e5f75e1a7b4b2c","modified":1727194336872},{"_id":"source/images/hashmap/bst.png","hash":"6e45729a5480ff65c99f6c508b0f8ab0c95fee5e","modified":1727194336879},{"_id":"source/images/hashmap/bstdel.png","hash":"c5e840857a21579954521a25972d583bcee06a1a","modified":1727194336880},{"_id":"source/images/mq/mq1.png","hash":"22902299a637451e4ef9568dd3b0fc18c4df3136","modified":1727194336886},{"_id":"source/images/hashmap/rotateRBTree.png","hash":"c4dbdb4ca9513fab14b2504d0ad3729d6224bbbc","modified":1727194336885},{"_id":"source/images/mq/mq5.png","hash":"4f026f8f27c71c8a53d6ff225fd99965e151300a","modified":1727194336900},{"_id":"source/images/mq/mq6.png","hash":"dd5afc32189e362a8565082c5178f54b0d0ea95d","modified":1727194336902},{"_id":"source/images/mq/mq7.png","hash":"cb8406c880b99cccb3a5978a6063042463f129d7","modified":1727194336903},{"_id":"source/images/mq/mq10.png","hash":"a04bcc11a5563656ae2a4b8784de75b68e3a01c3","modified":1727194336890},{"_id":"source/images/mq/mq3.png","hash":"38878d18ebfed3566c455077070ca85a39da32e3","modified":1727194336896},{"_id":"source/images/mq/mq4.png","hash":"3bec0c6d53990cae691a6ab812bcc4c9fa696430","modified":1727194336899},{"_id":"source/images/mq/mq9.png","hash":"fced6cdea590436e10d67f33f2e7eabfd4c8b668","modified":1727194336910},{"_id":"source/images/mq/mq2.png","hash":"5a33e4b870cfda5bdb31868c4e313ec6e48ecbc7","modified":1727194336893},{"_id":"source/images/mq/mq8.png","hash":"c5294d903c20fa0c51ebdfdbb21bc448d78531fd","modified":1727194336907},{"_id":"themes/next/.editorconfig","hash":"8570735a8d8d034a3a175afd1dd40b39140b3e6a","modified":1622276785000},{"_id":"themes/next/.gitattributes","hash":"a54f902957d49356376b59287b894b1a3d7a003f","modified":1622276785000},{"_id":"themes/next/.eslintrc.json","hash":"cc5f297f0322672fe3f684f823bc4659e4a54c41","modified":1622276785000},{"_id":"themes/next/.gitignore","hash":"56f3470755c20311ddd30d421b377697a6e5e68b","modified":1623915580000},{"_id":"themes/next/.stylintrc","hash":"2cf4d637b56d8eb423f59656a11f6403aa90f550","modified":1622276785000},{"_id":"themes/next/.travis.yml","hash":"ecca3b919a5b15886e3eca58aa84aafc395590da","modified":1622276785000},{"_id":"themes/next/README.md","hash":"9b4b7d66aca47f9c65d6321b14eef48d95c4dff1","modified":1623915580000},{"_id":"themes/next/LICENSE.md","hash":"18144d8ed58c75af66cb419d54f3f63374cd5c5b","modified":1622276785000},{"_id":"themes/next/crowdin.yml","hash":"e026078448c77dcdd9ef50256bb6635a8f83dca6","modified":1622276785000},{"_id":"themes/next/package.json","hash":"62fad6de02adbbba9fb096cbe2dcc15fe25f2435","modified":1623915580000},{"_id":"themes/next/gulpfile.js","hash":"1b4fc262b89948937b9e3794de812a7c1f2f3592","modified":1623915580000},{"_id":"themes/next/_config.yml","hash":"ccd41ed5fc3027f81834c30fe4b67c0dac742dea","modified":1623915580000},{"_id":"themes/next/.github/CODE_OF_CONDUCT.md","hash":"aa4cb7aff595ca628cb58160ee1eee117989ec4e","modified":1622276785000},{"_id":"themes/next/.github/config.yml","hash":"1d3f4e8794986817c0fead095c74f756d45f91ed","modified":1623915580000},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"1a435c20ae8fa183d49bbf96ac956f7c6c25c8af","modified":1623915580000},{"_id":"themes/next/.github/issue-close-app.yml","hash":"7cba457eec47dbfcfd4086acd1c69eaafca2f0cd","modified":1623915580000},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"e554931b98f251fd49ff1d2443006d9ea2c20461","modified":1623915580000},{"_id":"themes/next/.github/lock.yml","hash":"61173b9522ebac13db2c544e138808295624f7fd","modified":1622276785000},{"_id":"themes/next/.github/mergeable.yml","hash":"0ee56e23bbc71e1e76427d2bd255a9879bd36e22","modified":1622276785000},{"_id":"themes/next/.github/issue_label_bot.yaml","hash":"fca600ddef6f80c5e61aeed21722d191e5606e5b","modified":1623915580000},{"_id":"themes/next/.github/release-drafter.yml","hash":"3cc10ce75ecc03a5ce86b00363e2a17eb65d15ea","modified":1622276785000},{"_id":"themes/next/.github/stale.yml","hash":"fdf82de9284f8bc8e0b0712b4cc1cb081a94de59","modified":1623915580000},{"_id":"themes/next/.github/support.yml","hash":"d75db6ffa7b4ca3b865a925f9de9aef3fc51925c","modified":1622276785000},{"_id":"themes/next/languages/ar.yml","hash":"9815e84e53d750c8bcbd9193c2d44d8d910e3444","modified":1623915580000},{"_id":"themes/next/languages/de.yml","hash":"74c59f2744217003b717b59d96e275b54635abf5","modified":1623915580000},{"_id":"themes/next/languages/default.yml","hash":"45bc5118828bdc72dcaa25282cd367c8622758cb","modified":1623915580000},{"_id":"themes/next/languages/es.yml","hash":"c64cf05f356096f1464b4b1439da3c6c9b941062","modified":1623915580000},{"_id":"themes/next/languages/fa.yml","hash":"3676b32fda37e122f3c1a655085a1868fb6ad66b","modified":1623915580000},{"_id":"themes/next/languages/en.yml","hash":"45bc5118828bdc72dcaa25282cd367c8622758cb","modified":1623915580000},{"_id":"themes/next/languages/fr.yml","hash":"752bf309f46a2cd43890b82300b342d7218d625f","modified":1623915580000},{"_id":"themes/next/languages/hu.yml","hash":"b1ebb77a5fd101195b79f94de293bcf9001d996f","modified":1623915580000},{"_id":"themes/next/languages/id.yml","hash":"572ed855d47aafe26f58c73b1394530754881ec2","modified":1623915580000},{"_id":"themes/next/languages/it.yml","hash":"44759f779ce9c260b895532de1d209ad4bd144bf","modified":1623915580000},{"_id":"themes/next/languages/ja.yml","hash":"0cf0baa663d530f22ff380a051881216d6adcdd8","modified":1623915580000},{"_id":"themes/next/languages/ko.yml","hash":"0feea9e43cd399f3610b94d755a39fff1d371e97","modified":1623915580000},{"_id":"themes/next/languages/pt-BR.yml","hash":"67555b1ba31a0242b12fc6ce3add28531160e35b","modified":1623915580000},{"_id":"themes/next/languages/nl.yml","hash":"5af3473d9f22897204afabc08bb984b247493330","modified":1623915580000},{"_id":"themes/next/languages/pt.yml","hash":"718d131f42f214842337776e1eaddd1e9a584054","modified":1623915580000},{"_id":"themes/next/languages/ru.yml","hash":"e993d5ca072f7f6887e30fc0c19b4da791ca7a88","modified":1623915580000},{"_id":"themes/next/languages/uk.yml","hash":"3a6d635b1035423b22fc86d9455dba9003724de9","modified":1623915580000},{"_id":"themes/next/languages/vi.yml","hash":"93393b01df148dcbf0863f6eee8e404e2d94ef9e","modified":1623915580000},{"_id":"themes/next/languages/zh-CN.yml","hash":"a1f15571ee7e1e84e3cc0985c3ec4ba1a113f6f8","modified":1623915580000},{"_id":"themes/next/languages/zh-HK.yml","hash":"3789f94010f948e9f23e21235ef422a191753c65","modified":1623915580000},{"_id":"themes/next/languages/zh-TW.yml","hash":"8c09da7c4ec3fca2c6ee897b2eea260596a2baa1","modified":1623915580000},{"_id":"themes/next/docs/ALGOLIA-SEARCH.md","hash":"c7a994b9542040317d8f99affa1405c143a94a38","modified":1623915580000},{"_id":"themes/next/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1622276785000},{"_id":"themes/next/languages/tr.yml","hash":"2b041eeb8bd096f549464f191cfc1ea0181daca4","modified":1628672991575},{"_id":"themes/next/docs/AUTHORS.md","hash":"10135a2f78ac40e9f46b3add3e360c025400752f","modified":1622276785000},{"_id":"themes/next/docs/DATA-FILES.md","hash":"cddbdc91ee9e65c37a50bec12194f93d36161616","modified":1623915580000},{"_id":"themes/next/docs/INSTALLATION.md","hash":"af88bcce035780aaa061261ed9d0d6c697678618","modified":1622276785000},{"_id":"themes/next/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"94dc3404ccb0e5f663af2aa883c1af1d6eae553d","modified":1623915580000},{"_id":"themes/next/docs/LICENSE.txt","hash":"368bf2c29d70f27d8726dd914f1b3211cae4bbab","modified":1622276785000},{"_id":"themes/next/docs/UPDATE-FROM-5.1.X.md","hash":"8b6e4b2c9cfcb969833092bdeaed78534082e3e6","modified":1623915580000},{"_id":"themes/next/layout/_layout.swig","hash":"6a6e92a4664cdb981890a27ac11fd057f44de1d5","modified":1623915580000},{"_id":"themes/next/docs/MATH.md","hash":"d645b025ec7fb9fbf799b9bb76af33b9f5b9ed93","modified":1623915580000},{"_id":"themes/next/layout/archive.swig","hash":"e4e31317a8df68f23156cfc49e9b1aa9a12ad2ed","modified":1623915580000},{"_id":"themes/next/layout/category.swig","hash":"1bde61cf4d2d171647311a0ac2c5c7933f6a53b0","modified":1623915580000},{"_id":"themes/next/layout/index.swig","hash":"7f403a18a68e6d662ae3e154b2c1d3bbe0801a23","modified":1623915580000},{"_id":"themes/next/layout/page.swig","hash":"db581bdeac5c75fabb0f17d7c5e746e47f2a9168","modified":1623915580000},{"_id":"themes/next/scripts/renderer.js","hash":"49a65df2028a1bc24814dc72fa50d52231ca4f05","modified":1622276785000},{"_id":"themes/next/layout/post.swig","hash":"2f6d992ced7e067521fdce05ffe4fd75481f41c5","modified":1623915580000},{"_id":"themes/next/layout/tag.swig","hash":"0dfb653bd5de980426d55a0606d1ab122bd8c017","modified":1623915580000},{"_id":"themes/next/.github/ISSUE_TEMPLATE/bug-report.md","hash":"c3e6b8196c983c40fd140bdeca012d03e6e86967","modified":1623915580000},{"_id":"themes/next/.github/ISSUE_TEMPLATE/feature-request.md","hash":"12d99fb8b62bd9e34d9672f306c9ae4ace7e053e","modified":1623915580000},{"_id":"themes/next/.github/ISSUE_TEMPLATE/other.md","hash":"d3efc0df0275c98440e69476f733097916a2d579","modified":1623915580000},{"_id":"themes/next/.github/ISSUE_TEMPLATE/question.md","hash":"53df7d537e26aaf062d70d86835c5fd8f81412f3","modified":1623915580000},{"_id":"themes/next/docs/ru/DATA-FILES.md","hash":"0bd2d696f62a997a11a7d84fec0130122234174e","modified":1623915580000},{"_id":"themes/next/docs/ru/INSTALLATION.md","hash":"9c4fe2873123bf9ceacab5c50d17d8a0f1baef27","modified":1622276785000},{"_id":"themes/next/docs/ru/UPDATE-FROM-5.1.X.md","hash":"5237a368ab99123749d724b6c379415f2c142a96","modified":1623915580000},{"_id":"themes/next/docs/ru/README.md","hash":"85dd68ed1250897a8e4a444a53a68c1d49eb7e11","modified":1623915580000},{"_id":"themes/next/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"34b88784ec120dfdc20fa82aadeb5f64ef614d14","modified":1623915580000},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"fb23b85db6f7d8279d73ae1f41631f92f64fc864","modified":1623915580000},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"d3f03be036b75dc71cf3c366cd75aee7c127c874","modified":1623915580000},{"_id":"themes/next/docs/zh-CN/DATA-FILES.md","hash":"ca1030efdfca5e20f9db2e7a428998e66a24c0d0","modified":1623915580000},{"_id":"themes/next/docs/zh-CN/INSTALLATION.md","hash":"579c7bd8341873fb8be4732476d412814f1a3df7","modified":1622276785000},{"_id":"themes/next/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"8b18f84503a361fc712b0fe4d4568e2f086ca97d","modified":1623915580000},{"_id":"themes/next/docs/zh-CN/MATH.md","hash":"b92585d251f1f9ebe401abb5d932cb920f9b8b10","modified":1623915580000},{"_id":"themes/next/docs/zh-CN/README.md","hash":"c038629ff8f3f24e8593c4c8ecf0bef3a35c750d","modified":1623915580000},{"_id":"themes/next/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"d9ce7331c1236bbe0a551d56cef2405e47e65325","modified":1623915580000},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"9c8dc0b8170679cdc1ee9ee8dbcbaebf3f42897b","modified":1623915580000},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"71655ca21907e9061b6e8ac52d0d8fbf54d0062b","modified":1623915580000},{"_id":"themes/next/layout/_scripts/index.swig","hash":"cea942b450bcb0f352da78d76dc6d6f1d23d5029","modified":1622276785000},{"_id":"themes/next/layout/_macro/post.swig","hash":"090b5a9b6fca8e968178004cbd6cff205b7eba57","modified":1623915580000},{"_id":"themes/next/layout/_scripts/noscript.swig","hash":"d1f2bfde6f1da51a2b35a7ab9e7e8eb6eefd1c6b","modified":1622276785000},{"_id":"themes/next/layout/_scripts/pjax.swig","hash":"4d2c93c66e069852bb0e3ea2e268d213d07bfa3f","modified":1623915580000},{"_id":"themes/next/layout/_scripts/three.swig","hash":"a4f42f2301866bd25a784a2281069d8b66836d0b","modified":1622276785000},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"ef38c213679e7b6d2a4116f56c9e55d678446069","modified":1622276785000},{"_id":"themes/next/layout/_partials/comments.swig","hash":"db6ab5421b5f4b7cb32ac73ad0e053fdf065f83e","modified":1623915580000},{"_id":"themes/next/layout/_partials/footer.swig","hash":"4369b313cbbeae742cb35f86d23d99d4285f7359","modified":1623915580000},{"_id":"themes/next/layout/_partials/languages.swig","hash":"ba9e272f1065b8f0e8848648caa7dea3f02c6be1","modified":1623915580000},{"_id":"themes/next/layout/_partials/widgets.swig","hash":"83a40ce83dfd5cada417444fb2d6f5470aae6bb0","modified":1622276785000},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9876dbfc15713c7a47d4bcaa301f4757bd978269","modified":1623915580000},{"_id":"themes/next/layout/_third-party/baidu-push.swig","hash":"b782eb2e34c0c15440837040b5d65b093ab6ec04","modified":1623915580000},{"_id":"themes/next/scripts/events/index.js","hash":"5743cde07f3d2aa11532a168a652e52ec28514fd","modified":1623915580000},{"_id":"themes/next/layout/_third-party/index.swig","hash":"70c3c01dd181de81270c57f3d99b6d8f4c723404","modified":1622276785000},{"_id":"themes/next/scripts/filters/default-injects.js","hash":"aec50ed57b9d5d3faf2db3c88374f107203617e0","modified":1622276785000},{"_id":"themes/next/scripts/filters/front-matter.js","hash":"703bdd142a671b4b67d3d9dfb4a19d1dd7e7e8f7","modified":1622276785000},{"_id":"themes/next/scripts/filters/locals.js","hash":"b193a936ee63451f09f8886343dcfdca577c0141","modified":1623915580000},{"_id":"themes/next/scripts/filters/minify.js","hash":"19985723b9f677ff775f3b17dcebf314819a76ac","modified":1622276785000},{"_id":"themes/next/scripts/filters/post.js","hash":"44ba9b1c0bdda57590b53141306bb90adf0678db","modified":1623915580000},{"_id":"themes/next/layout/_third-party/quicklink.swig","hash":"311e5eceec9e949f1ea8d623b083cec0b8700ff2","modified":1623915580000},{"_id":"themes/next/scripts/helpers/engine.js","hash":"bdb424c3cc0d145bd0c6015bb1d2443c8a9c6cda","modified":1623915580000},{"_id":"themes/next/scripts/helpers/font.js","hash":"40cf00e9f2b7aa6e5f33d412e03ed10304b15fd7","modified":1623915580000},{"_id":"themes/next/scripts/helpers/next-config.js","hash":"5e11f30ddb5093a88a687446617a46b048fa02e5","modified":1623915580000},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"958e86b2bd24e4fdfcbf9ce73e998efe3491a71f","modified":1623915580000},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"2731e262a6b88eaee2a3ca61e6a3583a7f594702","modified":1623915580000},{"_id":"themes/next/scripts/tags/caniuse.js","hash":"94e0bbc7999b359baa42fa3731bdcf89c79ae2b3","modified":1623915580000},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"f1826ade2d135e2f60e2d95cb035383685b3370c","modified":1623915580000},{"_id":"themes/next/scripts/tags/button.js","hash":"8c6b45f36e324820c919a822674703769e6da32c","modified":1623915580000},{"_id":"themes/next/scripts/tags/label.js","hash":"fc5b267d903facb7a35001792db28b801cccb1f8","modified":1622276785000},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"d902fd313e8d35c3cc36f237607c2a0536c9edf1","modified":1623915580000},{"_id":"themes/next/scripts/tags/mermaid.js","hash":"983c6c4adea86160ecc0ba2204bc312aa338121d","modified":1622276785000},{"_id":"themes/next/scripts/tags/note.js","hash":"0a02bb4c15aec41f6d5f1271cdb5c65889e265d9","modified":1622276785000},{"_id":"themes/next/scripts/tags/pdf.js","hash":"8c613b39e7bff735473e35244b5629d02ee20618","modified":1623915580000},{"_id":"themes/next/scripts/tags/tabs.js","hash":"93d8a734a3035c1d3f04933167b500517557ba3e","modified":1623915580000},{"_id":"themes/next/scripts/tags/video.js","hash":"e5ff4c44faee604dd3ea9db6b222828c4750c227","modified":1622276785000},{"_id":"themes/next/source/css/_colors.styl","hash":"a8442520f719d3d7a19811cb3b85bcfd4a596e1f","modified":1623915580000},{"_id":"themes/next/source/css/_mixins.styl","hash":"e31a557f8879c2f4d8d5567ee1800b3e03f91f6e","modified":1623915580000},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1622276785000},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1622276785000},{"_id":"themes/next/source/css/main.styl","hash":"a3a3bbb5a973052f0186b3523911cb2539ff7b88","modified":1623915580000},{"_id":"themes/next/source/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1622276785000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1622276785000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1622276785000},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1622276785000},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1622276785000},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1622276785000},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1622276785000},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1622276785000},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1622276785000},{"_id":"themes/next/source/js/algolia-search.js","hash":"498d233eb5c7af6940baf94c1a1c36fdf1dd2636","modified":1623915580000},{"_id":"themes/next/source/js/bookmark.js","hash":"9734ebcb9b83489686f5c2da67dc9e6157e988ad","modified":1623915580000},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1622276785000},{"_id":"themes/next/source/js/local-search.js","hash":"35ccf100d8f9c0fd6bfbb7fa88c2a76c42a69110","modified":1623915580000},{"_id":"themes/next/source/js/motion.js","hash":"72df86f6dfa29cce22abeff9d814c9dddfcf13a9","modified":1623915580000},{"_id":"themes/next/source/js/next-boot.js","hash":"a1b0636423009d4a4e4cea97bcbf1842bfab582c","modified":1623915580000},{"_id":"themes/next/source/js/utils.js","hash":"730cca7f164eaf258661a61ff3f769851ff1e5da","modified":1623915580000},{"_id":"themes/next/source/lib/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1622276785000},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1622276785000},{"_id":"themes/next/layout/_scripts/pages/schedule.swig","hash":"077b5d66f6309f2e7dcf08645058ff2e03143e6c","modified":1623915580000},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"1c910fc066c06d5fbbe9f2b0c47447539e029af7","modified":1622276785000},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"7f14ef43d9e82bc1efc204c5adf0b1dbfc919a9f","modified":1622276785000},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"7f14ef43d9e82bc1efc204c5adf0b1dbfc919a9f","modified":1622276785000},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"1c910fc066c06d5fbbe9f2b0c47447539e029af7","modified":1622276785000},{"_id":"themes/next/layout/_partials/header/index.swig","hash":"7dbe93b8297b746afb89700b4d29289556e85267","modified":1623915580000},{"_id":"themes/next/layout/_partials/header/brand.swig","hash":"c70f8e71e026e878a4e9d5ab3bbbf9b0b23c240c","modified":1623915580000},{"_id":"themes/next/layout/_partials/header/menu-item.swig","hash":"9440d8a3a181698b80e1fa47f5104f4565d8cdf3","modified":1623915580000},{"_id":"themes/next/layout/_partials/header/menu.swig","hash":"d31f896680a6c2f2c3f5128b4d4dd46c87ce2130","modified":1623915580000},{"_id":"themes/next/layout/_partials/header/sub-menu.swig","hash":"ae2261bea836581918a1c2b0d1028a78718434e0","modified":1623915580000},{"_id":"themes/next/layout/_partials/head/head-unique.swig","hash":"000bad572d76ee95d9c0a78f9ccdc8d97cc7d4b4","modified":1623915580000},{"_id":"themes/next/layout/_partials/page/page-header.swig","hash":"9b7a66791d7822c52117fe167612265356512477","modified":1623915580000},{"_id":"themes/next/layout/_partials/page/breadcrumb.swig","hash":"c851717497ca64789f2176c9ecd1dedab237b752","modified":1622276785000},{"_id":"themes/next/layout/_partials/head/head.swig","hash":"810d544019e4a8651b756dd23e5592ee851eda71","modified":1623915580000},{"_id":"themes/next/layout/_partials/post/post-copyright.swig","hash":"954ad71536b6eb08bd1f30ac6e2f5493b69d1c04","modified":1623915580000},{"_id":"themes/next/layout/_partials/post/post-followme.swig","hash":"ceba16b9bd3a0c5c8811af7e7e49d0f9dcb2f41e","modified":1623915580000},{"_id":"themes/next/layout/_partials/post/post-footer.swig","hash":"8f14f3f8a1b2998d5114cc56b680fb5c419a6b07","modified":1622276785000},{"_id":"themes/next/layout/_partials/post/post-related.swig","hash":"f79c44692451db26efce704813f7a8872b7e63a0","modified":1622276785000},{"_id":"themes/next/layout/_partials/post/post-reward.swig","hash":"2b1a73556595c37951e39574df5a3f20b2edeaef","modified":1623915580000},{"_id":"themes/next/layout/_partials/search/algolia-search.swig","hash":"48430bd03b8f19c9b8cdb2642005ed67d56c6e0b","modified":1623915580000},{"_id":"themes/next/layout/_partials/search/index.swig","hash":"2be50f9bfb1c56b85b3b6910a7df27f51143632c","modified":1623915580000},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"f48a6a8eba04eb962470ce76dd731e13074d4c45","modified":1623915580000},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"4790058691b7d36cf6d2d6b4e93795a7b8d608ad","modified":1622276785000},{"_id":"themes/next/layout/_partials/sidebar/site-overview.swig","hash":"c46849e0af8f8fb78baccd40d2af14df04a074af","modified":1623915580000},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"2fa2b51d56bfac6a1ea76d651c93b9c20b01c09b","modified":1623915580000},{"_id":"themes/next/layout/_third-party/analytics/growingio.swig","hash":"5adea065641e8c55994dd2328ddae53215604928","modified":1622276785000},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"1472cabb0181f60a6a0b7fec8899a4d03dfb2040","modified":1622276785000},{"_id":"themes/next/layout/_third-party/chat/chatra.swig","hash":"f910618292c63871ca2e6c6e66c491f344fa7b1f","modified":1623915580000},{"_id":"themes/next/layout/_third-party/chat/tidio.swig","hash":"cba0e6e0fad08568a9e74ba9a5bee5341cfc04c1","modified":1622276785000},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"f39a5bf3ce9ee9adad282501235e0c588e4356ec","modified":1623915580000},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"b14908644225d78c864cd0a9b60c52407de56183","modified":1623915580000},{"_id":"themes/next/layout/_third-party/comments/disqusjs.swig","hash":"82f5b6822aa5ec958aa987b101ef860494c6cf1f","modified":1623915580000},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"f7a9eca599a682479e8ca863db59be7c9c7508c8","modified":1623915580000},{"_id":"themes/next/layout/_third-party/comments/gitalk.swig","hash":"d6ceb70648555338a80ae5724b778c8c58d7060d","modified":1623915580000},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"be0a8eccf1f6dc21154af297fc79555343031277","modified":1623915580000},{"_id":"themes/next/layout/_third-party/math/index.swig","hash":"6c5976621efd5db5f7c4c6b4f11bc79d6554885f","modified":1622276785000},{"_id":"themes/next/layout/_third-party/math/katex.swig","hash":"4791c977a730f29c846efcf6c9c15131b9400ead","modified":1622276785000},{"_id":"themes/next/layout/_third-party/math/mathjax.swig","hash":"ecf751321e799f0fb3bf94d049e535130e2547aa","modified":1623915580000},{"_id":"themes/next/layout/_third-party/search/algolia-search.swig","hash":"d35a999d67f4c302f76fdf13744ceef3c6506481","modified":1623915580000},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"767b6c714c22588bcd26ba70b0fc19b6810cbacd","modified":1622276785000},{"_id":"themes/next/layout/_third-party/search/swiftype.swig","hash":"ba0dbc06b9d244073a1c681ff7a722dcbf920b51","modified":1622276785000},{"_id":"themes/next/layout/_third-party/statistics/busuanzi-counter.swig","hash":"4b1986e43d6abce13450d2b41a736dd6a5620a10","modified":1623915580000},{"_id":"themes/next/layout/_third-party/statistics/cnzz-analytics.swig","hash":"a17ace37876822327a2f9306a472974442c9005d","modified":1622276785000},{"_id":"themes/next/layout/_third-party/statistics/index.swig","hash":"5f6a966c509680dbfa70433f9d658cee59c304d7","modified":1623915580000},{"_id":"themes/next/layout/_third-party/statistics/firestore.swig","hash":"b26ac2bfbe91dd88267f8b96aee6bb222b265b7a","modified":1623915580000},{"_id":"themes/next/scripts/events/lib/config.js","hash":"d34c6040b13649714939f59be5175e137de65ede","modified":1623915580000},{"_id":"themes/next/layout/_third-party/statistics/lean-analytics.swig","hash":"d56d5af427cdfecc33a0f62ee62c056b4e33d095","modified":1623915580000},{"_id":"themes/next/scripts/events/lib/injects-point.js","hash":"6661c1c91c7cbdefc6a5e6a034b443b8811235a1","modified":1622276785000},{"_id":"themes/next/scripts/events/lib/injects.js","hash":"f233d8d0103ae7f9b861344aa65c1a3c1de8a845","modified":1623915580000},{"_id":"themes/next/scripts/filters/comment/changyan.js","hash":"a54708fd9309b4357c423a3730eb67f395344a5e","modified":1623915580000},{"_id":"themes/next/scripts/filters/comment/common.js","hash":"2486f3e0150c753e5f3af1a3665d074704b8ee2c","modified":1623915580000},{"_id":"themes/next/scripts/filters/comment/default-config.js","hash":"7f2d93af012c1e14b8596fecbfc7febb43d9b7f5","modified":1622276785000},{"_id":"themes/next/layout/_third-party/tags/mermaid.swig","hash":"f3c43664a071ff3c0b28bd7e59b5523446829576","modified":1623915580000},{"_id":"themes/next/scripts/filters/comment/disqus.js","hash":"4c0c99c7e0f00849003dfce02a131104fb671137","modified":1623915580000},{"_id":"themes/next/scripts/filters/comment/disqusjs.js","hash":"7f8b92913d21070b489457fa5ed996d2a55f2c32","modified":1623915580000},{"_id":"themes/next/scripts/filters/comment/gitalk.js","hash":"e51dc3072c1ba0ea3008f09ecae8b46242ec6021","modified":1622276785000},{"_id":"themes/next/scripts/filters/comment/livere.js","hash":"d5fefc31fba4ab0188305b1af1feb61da49fdeb0","modified":1623915580000},{"_id":"themes/next/scripts/filters/comment/valine.js","hash":"6cbd85f9433c06bae22225ccf75ac55e04f2d106","modified":1623915580000},{"_id":"themes/next/layout/_third-party/tags/pdf.swig","hash":"d30b0e255a8092043bac46441243f943ed6fb09b","modified":1623915580000},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"f70be8e229da7e1715c11dd0e975a2e71e453ac8","modified":1623915580000},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"f4e694e5db81e57442c7e34505a416d818b3044a","modified":1623915580000},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"62df49459d552bbf73841753da8011a1f5e875c8","modified":1623915580000},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"612ec843372dae709acb17112c1145a53450cc59","modified":1623915580000},{"_id":"themes/next/source/css/_variables/base.styl","hash":"818508748b7a62e02035e87fe58e75b603ed56dc","modified":1623915580000},{"_id":"themes/next/source/js/schemes/muse.js","hash":"1eb9b88103ddcf8827b1a7cbc56471a9c5592d53","modified":1623915580000},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1622276785000},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1622276785000},{"_id":"themes/next/source/js/schemes/pisces.js","hash":"0ac5ce155bc58c972fe21c4c447f85e6f8755c62","modified":1623915580000},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"ca5e70662dcfb261c25191cc5db5084dcf661c76","modified":1623915580000},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"a47725574e1bee3bc3b63b0ff2039cc982b17eff","modified":1623915580000},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"8e7b57a72e757cf95278239641726bb2d5b869d1","modified":1623915580000},{"_id":"themes/next/source/css/_common/components/reading-progress.styl","hash":"2e3bf7baf383c9073ec5e67f157d3cb3823c0957","modified":1623915580000},{"_id":"themes/next/source/css/_common/outline/mobile.styl","hash":"681d33e3bc85bdca407d93b134c089264837378c","modified":1623915580000},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"a1690e035b505d28bdef2b4424c13fc6312ab049","modified":1623915580000},{"_id":"themes/next/source/css/_common/scaffolding/buttons.styl","hash":"a2e9e00962e43e98ec2614d6d248ef1773bb9b78","modified":1623915580000},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"0b2c4b78eead410020d7c4ded59c75592a648df8","modified":1623915580000},{"_id":"themes/next/source/css/_common/scaffolding/comments.styl","hash":"b1f0fab7344a20ed6748b04065b141ad423cf4d9","modified":1623915580000},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"b56367ea676ea8e8783ea89cd4ab150c7da7a060","modified":1622276785000},{"_id":"themes/next/source/css/_common/scaffolding/pagination.styl","hash":"8f58570a1bbc34c4989a47a1b7d42a8030f38b06","modified":1622276785000},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"523fb7b653b87ae37fc91fc8813e4ffad87b0d7e","modified":1622276785000},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"18ce72d90459c9aa66910ac64eae115f2dde3767","modified":1623915580000},{"_id":"themes/next/source/css/_common/scaffolding/toggles.styl","hash":"179e33b8ac7f4d8a8e76736a7e4f965fe9ab8b42","modified":1622276785000},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"7785bd756e0c4acede3a47fec1ed7b55988385a5","modified":1623915580000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"f6516d0f7d89dc7b6c6e143a5af54b926f585d82","modified":1623915580000},{"_id":"themes/next/source/css/_schemes/Mist/_layout.styl","hash":"bb7ace23345364eb14983e860a7172e1683a4c94","modified":1623915580000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expand.styl","hash":"6136da4bbb7e70cec99f5c7ae8c7e74f5e7c261a","modified":1623915580000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"a717969829fa6ef88225095737df3f8ee86c286b","modified":1622276785000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"7104b9cef90ca3b140d7a7afcf15540a250218fc","modified":1623915580000},{"_id":"themes/next/source/css/_schemes/Muse/_header.styl","hash":"f0131db6275ceaecae7e1a6a3798b8f89f6c850d","modified":1623915580000},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"4d1c17345d2d39ef7698f7acf82dfc0f59308c34","modified":1622276785000},{"_id":"themes/next/source/css/_schemes/Muse/_sidebar.styl","hash":"2b2e7b5cea7783c9c8bb92655e26a67c266886f0","modified":1623915580000},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"93db5dafe9294542a6b5f647643cb9deaced8e06","modified":1623915580000},{"_id":"themes/next/source/css/_schemes/Muse/_sub-menu.styl","hash":"c48ccd8d6651fe1a01faff8f01179456d39ba9b1","modified":1622276785000},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1622276785000},{"_id":"themes/next/source/css/_schemes/Pisces/_header.styl","hash":"e282df938bd029f391c466168d0e68389978f120","modified":1623915580000},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"70a4324b70501132855b5e59029acfc5d3da1ebd","modified":1623915580000},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"85da2f3006f4bef9a2199416ecfab4d288f848c4","modified":1623915580000},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"44f47c88c06d89d06f220f102649057118715828","modified":1623915580000},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"e740deadcfc4f29c5cb01e40f9df6277262ba4e3","modified":1623915580000},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1622276785000},{"_id":"themes/next/source/lib/font-awesome/css/all.min.css","hash":"0038dc97c79451578b7bd48af60ba62282b4082b","modified":1623915580000},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"260bb01acd44d88dcb7f501a238ab968f86bef9e","modified":1623915580000},{"_id":"themes/next/source/css/_common/outline/footer/footer.styl","hash":"454a4aebfabb4469b92a8cbb49f46c49ac9bf165","modified":1623915580000},{"_id":"themes/next/source/css/_common/outline/header/bookmark.styl","hash":"e2d606f1ac343e9be4f15dbbaf3464bc4df8bf81","modified":1623915580000},{"_id":"themes/next/source/css/_common/outline/header/github-banner.styl","hash":"e7a9fdb6478b8674b1cdf94de4f8052843fb71d9","modified":1623915580000},{"_id":"themes/next/source/css/_common/outline/header/headerband.styl","hash":"0caf32492692ba8e854da43697a2ec8a41612194","modified":1622276785000},{"_id":"themes/next/source/css/_common/outline/header/menu.styl","hash":"5f432a6ed9ca80a413c68b00e93d4a411abf280a","modified":1623915580000},{"_id":"themes/next/source/css/_common/outline/header/header.styl","hash":"a793cfff86ad4af818faef04c18013077873f8f0","modified":1623915580000},{"_id":"themes/next/source/css/_common/outline/header/site-meta.styl","hash":"45a239edca44acecf971d99b04f30a1aafbf6906","modified":1623915580000},{"_id":"themes/next/source/css/_common/outline/header/site-nav.styl","hash":"b2fc519828fe89a1f8f03ff7b809ad68cd46f3d7","modified":1623915580000},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"fafc96c86926b22afba8bb9418c05e6afbc05a57","modified":1622276785000},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"7504dbc5c70262b048143b2c37d2b5aa2809afa2","modified":1622276785000},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"2bd0eb1512415325653b26d62a4463e6de83c5ac","modified":1622276785000},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"e771dcb0b4673e063c0f3e2d73e7336ac05bcd57","modified":1623915580000},{"_id":"themes/next/source/css/_common/components/pages/tag-cloud.styl","hash":"d21d4ac1982c13d02f125a67c065412085a92ff2","modified":1623915580000},{"_id":"themes/next/source/css/_common/components/third-party/math.styl","hash":"b49e9fbd3c182b8fc066b8c2caf248e3eb748619","modified":1623915580000},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"e2992846b39bf3857b5104675af02ba73e72eed5","modified":1622276785000},{"_id":"themes/next/source/css/_common/components/third-party/search.styl","hash":"9f0b93d109c9aec79450c8a0cf4a4eab717d674d","modified":1623915580000},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"8a7fc03a568b95be8d3337195e38bc7ec5ba2b23","modified":1622276785000},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"9a878d0119785a2316f42aebcceaa05a120b9a7a","modified":1622276785000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"2cb1876e9e0c9ac32160888af27b1178dbcb0616","modified":1622276785000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"fa0222197b5eee47e18ac864cdc6eac75678b8fe","modified":1623915580000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"44487d9ab290dc97871fa8dd4487016deb56e123","modified":1623915580000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-dimmer.styl","hash":"9b479c2f9a9bfed77885e5093b8245cc5d768ec7","modified":1622276785000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"1f0e7fbe80956f47087c2458ea880acf7a83078b","modified":1623915580000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"a960a2dd587b15d3b3fe1b59525d6fa971c6a6ec","modified":1623915580000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"a05a4031e799bc864a4536f9ef61fe643cd421af","modified":1623915580000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"b3220db827e1adbca7880c2bb23e78fa7cbe95cb","modified":1622276785000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar.styl","hash":"a9cd93c36bae5af9223e7804963096274e8a4f03","modified":1623915580000},{"_id":"themes/next/source/css/_common/outline/sidebar/site-state.styl","hash":"2a47f8a6bb589c2fb635e6c1e4a2563c7f63c407","modified":1623915580000},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"e75693f33dbc92afc55489438267869ae2f3db54","modified":1623915580000},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f49ca072b5a800f735e8f01fc3518f885951dd8e","modified":1623915580000},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"902569a9dea90548bec21a823dd3efd94ff7c133","modified":1623915580000},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"ded41fd9d20a5e8db66aaff7cc50f105f5ef2952","modified":1623915580000},{"_id":"themes/next/source/css/_common/components/post/post-followme.styl","hash":"1e4190c10c9e0c9ce92653b0dbcec21754b0b69d","modified":1623915580000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"72d495a88f7d6515af425c12cbc67308a57d88ea","modified":1623915580000},{"_id":"themes/next/source/css/_common/components/post/post-header.styl","hash":"65cb6edb69e94e70e3291e9132408361148d41d5","modified":1623915580000},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"6a97bcfa635d637dc59005be3b931109e0d1ead5","modified":1623915580000},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"d114b2a531129e739a27ba6271cfe6857aa9a865","modified":1623915580000},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"f5c2788a78790aca1a2f37f7149d6058afb539e0","modified":1622276785000},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"5b5649b9749e3fd8b63aef22ceeece0a6e1df605","modified":1622276785000},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"99e12c9ce3d14d4837e3d3f12fc867ba9c565317","modified":1622276785000},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"a760ee83ba6216871a9f14c5e56dc9bd0d9e2103","modified":1623915580000},{"_id":"themes/next/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"f71a3e86c05ea668b008cf05a81f67d92b6d65e4","modified":1623915580000},{"_id":"themes/next/source/css/_common/scaffolding/highlight/diff.styl","hash":"d3f73688bb7423e3ab0de1efdf6db46db5e34f80","modified":1622276785000},{"_id":"themes/next/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"1d2778ca5aeeeafaa690dc2766b01b352ab76a02","modified":1623915580000},{"_id":"themes/next/source/css/_common/scaffolding/highlight/theme.styl","hash":"3b3acc5caa0b95a2598bef4eeacb21bab21bea56","modified":1622276785000},{"_id":"themes/next/source/css/_common/scaffolding/highlight/highlight.styl","hash":"35c871a809afa8306c8cde13651010e282548bc6","modified":1623915580000},{"_id":"themes/next/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"709d10f763e357e1472d6471f8be384ec9e2d983","modified":1623915580000},{"_id":"themes/next/source/css/_common/scaffolding/tags/note.styl","hash":"e4d9a77ffe98e851c1202676940097ba28253313","modified":1623915580000},{"_id":"themes/next/source/css/_common/scaffolding/tags/label.styl","hash":"d7fce4b51b5f4b7c31d93a9edb6c6ce740aa0d6b","modified":1623915580000},{"_id":"themes/next/source/css/_common/scaffolding/tags/pdf.styl","hash":"b49c64f8e9a6ca1c45c0ba98febf1974fdd03616","modified":1623915580000},{"_id":"themes/next/source/css/_common/scaffolding/tags/tabs.styl","hash":"f23670f1d8e749f3e83766d446790d8fd9620278","modified":1623915580000},{"_id":"themes/next/source/css/_common/scaffolding/tags/tags.styl","hash":"9e4c0653cfd3cc6908fa0d97581bcf80861fb1e7","modified":1622276785000},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"75a88815c47a249eadb5f0edc1675957f860cca7","modified":1623915580000},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"509988477da79c146cb93fb728405f18e923c2de","modified":1623915580000},{"_id":"source/images/bug/logBlockDown.png","hash":"ecda5b72aaf4d3d255e47c8f6b0ba0a002169fd9","modified":1727194336878},{"_id":"public/about/index.html","hash":"f11fa41e7dfc7d7d7ca93d1f79fa372ec9964015","modified":1727523693009},{"_id":"public/categories/JUC/index.html","hash":"043b1053d69abbf8de18b3ff41fc3de3c00385c5","modified":1727523693009},{"_id":"public/categories/JVM/index.html","hash":"ad69d6d797d50f55862d35e4a2c3a4b90a68c427","modified":1727523693009},{"_id":"public/categories/问题排查/index.html","hash":"527831bb6366a9f29c3458166a82ca678037c4f6","modified":1727523693009},{"_id":"public/categories/源码解析/index.html","hash":"10b8300d3c0ef41f62705e2ecf7ef262218f1022","modified":1727523693009},{"_id":"public/categories/设计模式之美/index.html","hash":"cc6857ffef5a9b026645352b524247103aca6557","modified":1727523693009},{"_id":"public/categories/设计模式之美/page/2/index.html","hash":"f736ecd2993c72255b4c1e570d0fb7fc07e793f6","modified":1727523693009},{"_id":"public/categories/设计模式之美/page/3/index.html","hash":"6efb15204dd5b3577932c0189feee143a35166b9","modified":1727523693009},{"_id":"public/categories/消息队列/index.html","hash":"2dd71d1dc60cc6c4fd90eaf549ef29fb056c37f9","modified":1727523693009},{"_id":"public/tags/JDK/index.html","hash":"51cb747d49f337279325902039b8b1eed108a671","modified":1727523693009},{"_id":"public/tags/JUC/index.html","hash":"032734b2a2c5d5de79d3a8a26e111f42f4943fc1","modified":1727523693009},{"_id":"public/tags/AQS/index.html","hash":"3809873e2d01af231d56c5150a706caf91422f74","modified":1727523693009},{"_id":"public/tags/JVM/index.html","hash":"33b2575b45fc07b8dbb2c415724ed25c2be7c5f6","modified":1727523693009},{"_id":"public/tags/问题排查/index.html","hash":"6fbb8fb991bc724de0578bb3c6ffb32c6c9089cc","modified":1727523693009},{"_id":"public/tags/设计模式之美/index.html","hash":"a51e27c9dcb3a5c90d9a0f4cea5d5d7fbf03a1d9","modified":1727523693009},{"_id":"public/tags/设计模式之美/page/2/index.html","hash":"095ce8a0d6181ef1b02ba0595235066492831656","modified":1727523693009},{"_id":"public/tags/设计模式之美/page/3/index.html","hash":"9edcf7c81f160e171a457abfeea23da30bbbed3e","modified":1727523693009},{"_id":"public/tags/消息队列/index.html","hash":"792ef8924a047224bb84cfd7ba247f6a1f69cabf","modified":1727523693009},{"_id":"public/archives/index.html","hash":"27ddebcdc49db96e56774501f14add79e7f7ede4","modified":1727523693009},{"_id":"public/archives/page/2/index.html","hash":"5d69cfdd6729a01623dccd676502bbd81a2d52cb","modified":1727523693009},{"_id":"public/archives/page/3/index.html","hash":"ac472800857827a1b27ad5f2e31c19af569d2f0e","modified":1727523693009},{"_id":"public/archives/page/4/index.html","hash":"5c7ca18333d4bbada272f3c26b1f1c4a4309bd60","modified":1727523693009},{"_id":"public/archives/2020/index.html","hash":"ba61a042a981ff0f6da6bbf3738a66cd01c0c609","modified":1727523693009},{"_id":"public/archives/2020/10/index.html","hash":"b492c28fcd511f8702b28ffdb60549a7fdd7a800","modified":1727523693009},{"_id":"public/archives/2020/11/index.html","hash":"8e5018b09eec65d6361b6f2c12dca7ee734a3f72","modified":1727523693009},{"_id":"public/archives/2021/index.html","hash":"9dc65ff03f606ca25ae5baffae81469db43bf4d4","modified":1727523693009},{"_id":"public/archives/2021/page/2/index.html","hash":"b86eeb36ca12f0bbc4386aca8c880abcbf5122ce","modified":1727523693009},{"_id":"public/archives/2021/page/3/index.html","hash":"dce5e3e72264e196376e8046a3d89435bd9bbd32","modified":1727523693009},{"_id":"public/archives/2021/page/4/index.html","hash":"63921c675959b34c054a1cac6ba2b27f8f03da6a","modified":1727523693009},{"_id":"public/archives/2021/02/index.html","hash":"e64f55b42c494d4929c6d5e96736eda64ca64749","modified":1727523693009},{"_id":"public/archives/2021/04/index.html","hash":"c7e17cbd7995968effe1a284870301e7a7698c31","modified":1727523693009},{"_id":"public/archives/2021/05/index.html","hash":"42eb38ee2def182d68168e38348457db967f3176","modified":1727523693009},{"_id":"public/archives/2021/05/page/2/index.html","hash":"6ad933a5b7301d493454d0992a4a8f71bca2c6d6","modified":1727523693009},{"_id":"public/archives/2021/06/index.html","hash":"792ca0b75d3e57205319942426d90f720d785b57","modified":1727523693009},{"_id":"public/archives/2021/06/page/2/index.html","hash":"9e614ff5bc002be798fd0fe25c17337cd8e8d578","modified":1727523693009},{"_id":"public/archives/2021/08/index.html","hash":"6b7b65c4d67406820b4513629f24765746ad84df","modified":1727523693009},{"_id":"public/archives/2021/09/index.html","hash":"5f88ec5ec4457dc5bb8f5770ff5a139984c9ac3a","modified":1727523693009},{"_id":"public/archives/2022/index.html","hash":"83fb51bce51f322d400f865dad9559b874a9df20","modified":1727523693009},{"_id":"public/archives/2022/04/index.html","hash":"bfb1f92187fd6f62f4636a2fba335a38b456e38f","modified":1727523693009},{"_id":"public/archives/2024/index.html","hash":"8b73f92a943bb2215f0963dc381554677e9788d8","modified":1727523693009},{"_id":"public/archives/2024/09/index.html","hash":"837dcd8ca73706c84f4fef24fdee21b0138839b9","modified":1727523693009},{"_id":"public/2024/09/19/消息队列选型-[转载]/index.html","hash":"f57522bc1aabc6a92ea767cc24d85d017cc7b08a","modified":1727523693009},{"_id":"public/2022/04/16/日志阻塞导致重启问题排查/index.html","hash":"53abd301d052c686e9d1a6dcbdf40a047ccb83ac","modified":1727523693009},{"_id":"public/2022/04/14/容器重启背后的思考/index.html","hash":"615ada1d09d2f5e8ae0cf0f64fb27436f3748f5a","modified":1727523693009},{"_id":"public/2021/09/02/AQS源码分析之Condition接口的实现/index.html","hash":"3dc2ef145bbd37ac61d4cd1375d3386b6929a02f","modified":1727523693009},{"_id":"public/2021/08/19/AQS源码分析之共享锁的获取与释放/index.html","hash":"007013e76db1f71eea609aaf649e22c44651ebc5","modified":1727523693009},{"_id":"public/2021/08/19/AQS源码分析之独占锁的释放/index.html","hash":"ff19f13d4b209cf6788fa41a49ddaffcf5c34a95","modified":1727523693009},{"_id":"public/2021/08/17/AQS源码分析之独占锁的获取/index.html","hash":"a89fe07d6a153edda925f540583a70bcb845ca31","modified":1727523693009},{"_id":"public/2021/08/16/死磕ConcurrentHashMap源码/index.html","hash":"b2c2987545f005b31a74678263f97b0dbe28d216","modified":1727523693009},{"_id":"public/2021/08/13/死磕ThreadLocal源码/index.html","hash":"ea48b09763fcc47c5e1ef04e40d01870a72bb52e","modified":1727523693009},{"_id":"public/2021/08/12/死磕HashMap源码(二)/index.html","hash":"73c1f073ba4a9a86ad79c2c477682804df9fc4c5","modified":1727523693009},{"_id":"public/2021/08/12/死磕HashMap源码(一)/index.html","hash":"d22d4611a96cde5edd9c2ed2d60cf00c29acf2c2","modified":1727523693009},{"_id":"public/2021/08/11/死磕LinkedList源码/index.html","hash":"856bda71d7ff569c49b9f5d5ea2c9ea5d10dd38c","modified":1727523693009},{"_id":"public/2021/08/11/死磕ArrayList源码/index.html","hash":"4bdd331c67c9f8a913ca83d4f7875fb9e5621f03","modified":1727523693009},{"_id":"public/2021/06/29/设计模式之中介模式/index.html","hash":"f6d1e819670068c0b58b34f9f0b5b4e619f3a205","modified":1727523693009},{"_id":"public/2021/06/28/设计模式之解释器模式/index.html","hash":"de4a7bc67ea2add6d84f0cc59024ba8a4d84649a","modified":1727523693009},{"_id":"public/2021/06/25/设计模式之命令模式/index.html","hash":"165ba3cf4de843f899f23ad0ae0aa0ed039eabee","modified":1727523693009},{"_id":"public/2021/06/23/设计模式之备忘录模式/index.html","hash":"4f08e5ffba62dc3d6e1e8b64c2122d43a6e6e72b","modified":1727523693009},{"_id":"public/2021/06/09/设计模式之访问者模式/index.html","hash":"b52444bd701f2a4331298c8152f1b6a809852fb2","modified":1727523693009},{"_id":"public/2021/06/09/设计模式之迭代器模式/index.html","hash":"2c481d2dfdbecb4169f6d6dc0ecef1e5c3c04192","modified":1727523693009},{"_id":"public/2021/06/07/设计模式之状态模式/index.html","hash":"3b188e7f51cc77e032d5bf4495f8dbe46c0e80ca","modified":1727523693009},{"_id":"public/2021/06/03/设计模式之模版模式/index.html","hash":"6ac5a68da656eb8ac8a30760450b1c4546c4f66a","modified":1727523693009},{"_id":"public/2021/06/03/设计模式之策略模式/index.html","hash":"d8480f992b22596ba391683e5e74067ee3dbcd2e","modified":1727523693009},{"_id":"public/2021/06/02/设计模式之观察者模式/index.html","hash":"01d519e10750cda0b5e1046413999d1378acc301","modified":1727523693009},{"_id":"public/2021/06/01/设计模式之享元模式/index.html","hash":"ffd8232a2ab2b769b8f7973f901410b9b8afa771","modified":1727523693009},{"_id":"public/2021/05/31/设计模式之组合模式/index.html","hash":"8cbb5bf1fb07848854ec4b6f2d7e56ec9310f39d","modified":1727523693009},{"_id":"public/2021/05/31/设计模式之适配器模式/index.html","hash":"e38825eefa3a5584500d71df97a242e0f2c2bf5c","modified":1727523693009},{"_id":"public/2021/05/31/设计模式之门面模式/index.html","hash":"89c002b082c759ef9b305c91a0efc3d321a348a2","modified":1727523693009},{"_id":"public/2021/05/29/JVM怎么判断对象已经死了/index.html","hash":"eaf155ea53d95f8392fd9a9a9664116bf155e2af","modified":1727523693009},{"_id":"public/2021/05/29/设计原则与思想-设计原则/index.html","hash":"bbe2914eed3b065e51146686abab2dbf75b402c6","modified":1727523693009},{"_id":"public/2021/05/25/设计模式之装饰器模式/index.html","hash":"e091d17dd0b0644d90677f4fb0b7f09c15d89141","modified":1727523693009},{"_id":"public/2021/05/19/设计模式之桥接模式/index.html","hash":"2cb251765d63fde8873b5208c2fa642b6edbb90a","modified":1727523693009},{"_id":"public/2021/05/13/设计模式之代理模式/index.html","hash":"5d7929de4c1d24f8db2304f3059239ea09f4d06e","modified":1727523693009},{"_id":"public/2021/05/11/设计模式之原型模式/index.html","hash":"7ec2c499a7ae48f74c828edd555cf4af1870f6cb","modified":1727523693009},{"_id":"public/2021/05/07/设计模式之建造者模式/index.html","hash":"75340251b24ba1d84044d1b3a073bf773ebbb596","modified":1727523693009},{"_id":"public/2021/05/06/设计模式之工厂模式/index.html","hash":"cf786f83d2930a1f74d6a8edd0b738783c3e5397","modified":1727523693009},{"_id":"public/2021/04/16/设计模式之单例模式/index.html","hash":"d5c2838ad1d65231e77d163e162c8a68d106b538","modified":1727523693009},{"_id":"public/2021/02/25/设计原则与思想-规范与重构/index.html","hash":"89490fe429c13d76ebb94c15c1c22fc50866ccb5","modified":1727523693009},{"_id":"public/2020/11/30/设计原则/index.html","hash":"7acfa17c4c76b5d742c02cb9101dec4da6220d2b","modified":1727523693009},{"_id":"public/2020/10/22/设计原则与思想-面向对象/index.html","hash":"6f23a9ec58d484b162ac6a08b1b497f032da98bf","modified":1727523693009},{"_id":"public/index.html","hash":"d7bc9b7d18efc6efe982305c50950b93c1221626","modified":1727523693009},{"_id":"public/page/2/index.html","hash":"bf2a9a86aea5fd7a7c528d2e343e1851bf96f686","modified":1727523693009},{"_id":"public/page/3/index.html","hash":"ae75236709840d471396cb4451afcf215e574231","modified":1727523693009},{"_id":"public/page/4/index.html","hash":"0c3cee13f6b5a3186ecfc4797cd33ff617d382d8","modified":1727523693009},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1727523693009},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1727523693009},{"_id":"public/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1727523693009},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1727523693009},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1727523693009},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1727523693009},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1727523693009},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1727523693009},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1727523693009},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1727523693009},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1727523693009},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1727523693009},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1727523693009},{"_id":"public/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"260bb01acd44d88dcb7f501a238ab968f86bef9e","modified":1727523693009},{"_id":"public/images/bug/dockerBuild.png","hash":"867b9cf393ebe7058ba9053fc145ad6a7802ec4f","modified":1727523693009},{"_id":"public/images/bug/jibBuild.png","hash":"f0834a1d446487f22d886d3f860618fe9ed8d1ef","modified":1727523693009},{"_id":"public/images/hashmap/delcase1.png","hash":"043e687f6b685a127547f05fcf095278f2022562","modified":1727523693009},{"_id":"public/images/hashmap/delcase2.png","hash":"2254dd196d6335e914b6fb56bebd7c62dc2acad7","modified":1727523693009},{"_id":"public/images/hashmap/delcase3.png","hash":"998fc6bcb03cd51ea035befab676925dbe666d07","modified":1727523693009},{"_id":"public/images/hashmap/delcase4.png","hash":"3d6d84fd0031f63b652a2e3a230b411eaf542d6d","modified":1727523693009},{"_id":"public/images/hashmap/hashcode.png","hash":"03ec5d623459e0c81bae169252556d909c985fee","modified":1727523693009},{"_id":"public/images/hashmap/insertcase2.png","hash":"d4d8793fedbc5d9aa0a397e3aa2564afde74642d","modified":1727523693009},{"_id":"public/images/hashmap/insertcase1.png","hash":"d3fd176d4f1ed3acfad512c9c5fe8f894a347dfb","modified":1727523693009},{"_id":"public/images/hashmap/insertcase3.png","hash":"843e247d2c7a792912ad3d71a016c176aeb56aef","modified":1727523693009},{"_id":"public/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"509988477da79c146cb93fb728405f18e923c2de","modified":1727523693009},{"_id":"public/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"75a88815c47a249eadb5f0edc1675957f860cca7","modified":1727523693009},{"_id":"public/images/hashmap/bst.png","hash":"6e45729a5480ff65c99f6c508b0f8ab0c95fee5e","modified":1727523693009},{"_id":"public/images/aqs/tailfork.png","hash":"687a4b3d0d9a435cbd52937437e5f75e1a7b4b2c","modified":1727523693009},{"_id":"public/images/aqs/syncqueue.png","hash":"02dd0ba7e636e2593c3f42774ba168a28b337f89","modified":1727523693009},{"_id":"public/images/hashmap/bstdel.png","hash":"c5e840857a21579954521a25972d583bcee06a1a","modified":1727523693009},{"_id":"public/images/mq/mq1.png","hash":"22902299a637451e4ef9568dd3b0fc18c4df3136","modified":1727523693009},{"_id":"public/images/hashmap/rotateRBTree.png","hash":"c4dbdb4ca9513fab14b2504d0ad3729d6224bbbc","modified":1727523693009},{"_id":"public/images/mq/mq5.png","hash":"4f026f8f27c71c8a53d6ff225fd99965e151300a","modified":1727523693009},{"_id":"public/images/mq/mq7.png","hash":"cb8406c880b99cccb3a5978a6063042463f129d7","modified":1727523693009},{"_id":"public/images/mq/mq6.png","hash":"dd5afc32189e362a8565082c5178f54b0d0ea95d","modified":1727523693009},{"_id":"public/js/bookmark.js","hash":"9734ebcb9b83489686f5c2da67dc9e6157e988ad","modified":1727523693009},{"_id":"public/js/algolia-search.js","hash":"498d233eb5c7af6940baf94c1a1c36fdf1dd2636","modified":1727523693009},{"_id":"public/js/local-search.js","hash":"35ccf100d8f9c0fd6bfbb7fa88c2a76c42a69110","modified":1727523693009},{"_id":"public/js/motion.js","hash":"72df86f6dfa29cce22abeff9d814c9dddfcf13a9","modified":1727523693009},{"_id":"public/js/next-boot.js","hash":"a1b0636423009d4a4e4cea97bcbf1842bfab582c","modified":1727523693009},{"_id":"public/js/utils.js","hash":"730cca7f164eaf258661a61ff3f769851ff1e5da","modified":1727523693009},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1727523693009},{"_id":"public/js/schemes/muse.js","hash":"1eb9b88103ddcf8827b1a7cbc56471a9c5592d53","modified":1727523693009},{"_id":"public/js/schemes/pisces.js","hash":"0ac5ce155bc58c972fe21c4c447f85e6f8755c62","modified":1727523693009},{"_id":"public/css/main.css","hash":"ce5dedffe02b8bb15a23c40517df34c3e3c97a8e","modified":1727523693009},{"_id":"public/images/mq/mq10.png","hash":"a04bcc11a5563656ae2a4b8784de75b68e3a01c3","modified":1727523693009},{"_id":"public/images/mq/mq3.png","hash":"38878d18ebfed3566c455077070ca85a39da32e3","modified":1727523693009},{"_id":"public/lib/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1727523693009},{"_id":"public/images/mq/mq4.png","hash":"3bec0c6d53990cae691a6ab812bcc4c9fa696430","modified":1727523693009},{"_id":"public/images/mq/mq9.png","hash":"fced6cdea590436e10d67f33f2e7eabfd4c8b668","modified":1727523693009},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1727523693009},{"_id":"public/lib/font-awesome/css/all.min.css","hash":"0038dc97c79451578b7bd48af60ba62282b4082b","modified":1727523693009},{"_id":"public/images/mq/mq2.png","hash":"5a33e4b870cfda5bdb31868c4e313ec6e48ecbc7","modified":1727523693009},{"_id":"public/images/mq/mq8.png","hash":"c5294d903c20fa0c51ebdfdbb21bc448d78531fd","modified":1727523693009},{"_id":"public/images/bug/logBlockDown.png","hash":"ecda5b72aaf4d3d255e47c8f6b0ba0a002169fd9","modified":1727523693009}],"Category":[{"name":"JUC","_id":"cm1m304x1000331b4e1dp1t5a"},{"name":"JVM","_id":"cm1m304x9000d31b43kcj2unx"},{"name":"问题排查","_id":"cm1m304xb000l31b4ayyr1opi"},{"name":"源码解析","_id":"cm1m304xe000s31b42ky333es"},{"name":"设计模式之美","_id":"cm1m304xp001p31b4h39l71uc"},{"name":"消息队列","_id":"cm1m304xu002531b49db63tcz"}],"Data":[],"Page":[{"_content":"## 言风\n17年毕业 工作7年  Java\n邮箱 489305497@qq.com\n","source":"about/index.md","raw":"## 言风\n17年毕业 工作7年  Java\n邮箱 489305497@qq.com\n","date":"2024-09-24T16:12:16.870Z","updated":"2024-09-24T16:12:16.870Z","path":"about/index.html","title":"","comments":1,"layout":"page","_id":"cm1m304wr000031b4g4j72u5r","content":"<h2 id=\"言风\"><a href=\"#言风\" class=\"headerlink\" title=\"言风\"></a>言风</h2><p>17年毕业 工作7年  Java<br>邮箱 <a href=\"mailto:&#x34;&#x38;&#57;&#x33;&#x30;&#x35;&#52;&#x39;&#x37;&#x40;&#113;&#x71;&#46;&#99;&#x6f;&#109;\">&#x34;&#x38;&#57;&#x33;&#x30;&#x35;&#52;&#x39;&#x37;&#x40;&#113;&#x71;&#46;&#99;&#x6f;&#109;</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"言风\"><a href=\"#言风\" class=\"headerlink\" title=\"言风\"></a>言风</h2><p>17年毕业 工作7年  Java<br>邮箱 <a href=\"mailto:&#x34;&#x38;&#57;&#x33;&#x30;&#x35;&#52;&#x39;&#x37;&#x40;&#113;&#x71;&#46;&#99;&#x6f;&#109;\">&#x34;&#x38;&#57;&#x33;&#x30;&#x35;&#52;&#x39;&#x37;&#x40;&#113;&#x71;&#46;&#99;&#x6f;&#109;</a></p>\n"}],"Post":[{"layout":"post","title":"AQS源码分析之共享锁的获取与释放","description":"AQS源码分析之共享锁的获取与释放","date":"2021-08-19T14:37:10.000Z","_content":"\n\n\n#### 共享锁与独占锁的区别\n\n共享锁和独占锁的最大区别在于，独占锁是独占的，排他的，因此独占锁中有一个`exclusiveOwnerThread`属性，用来记录当前持有锁的线程，当独占锁已经被某个线程持有时，其他线程只能等待它被释放时，才能去竞争锁，并且同一时刻只能有一个线程竞争锁成功。\n\n但是对于共享锁而言，它是可以被多个线程同时持有。如果一个线程成功获取了共享锁，那么其他等待在这个共享锁上的线程就也可以尝试去获取锁，并且极有可能获取成功。\n\n| 独占锁                                     | 共享锁                                           |\n| ------------------------------------------ | ------------------------------------------------ |\n| tryAcquire(int arg)                        | tryAcquireShared(int arg)                        |\n| tryAcquireNanos(int arg,long nanosTimeout) | tryAcquireSharedNanos(int arg,long nanosTimeout) |\n| acquire(int arg)                           | acquireShared(int arg)                           |\n| acquireQueued(final Node node,int arg)     | doAcquireShared(int arg)                         |\n| acquireinterruptibly(int arg)              | acquireSharedInterruptibly(int arg)              |\n| doAcquireInterruptibly(int arg)            | doAcquireSharedInterruptibly(int arg)            |\n| doAcquireNanos(int arg,long nanosTimeout)  | doAcquireSharedNanos(int arg,long nanosTimeout)  |\n| release(int arg)                           | releaseShared(int arg)                           |\n| tryRelease(int arg)                        | tryReleaseShared(int arg)                        |\n| -                                          | doReleaseShared()                                |\n\n除了最后一个共享锁的doReleaseShared()方法独占锁没有对应外，其他方法，共享锁和独占锁都是一一对应的。\n\n在独占锁中，我们只有在获取独占锁的节点释放锁时，才会唤醒后继节点——这是合理的，因为独占锁只能被一个线程持有，如果它还没被释放，就没必要去唤醒它的后继节点。\n\n但是在共享模式下，当一个节点获取到了共享锁，我们在获取成功后就可以唤醒后继节点，而不需要等到释放锁的时候再去唤醒。这是因为共享锁可以被多个线程同时持有，一个锁获取到了，则后继的节点都可以直接来获取。因此，在共享锁模式下，在获取锁和释放锁结束时，都会唤醒后继节点。所以doReleaseShared()方法与unparkSuccessor(h)方法无法直接对应。\n\n#### 共享锁的获取\n\n```java\npublic final void acquireShared(int arg) {\n    if (tryAcquireShared(arg) < 0)\n        doAcquireShared(arg);\n}\n```\n\n独占锁的获取\n\n```java\npublic final void acquire(int arg) {\n    if (!tryAcquire(arg) &&\n        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n        selfInterrupt();\n}\n```\n\n可以看到共享锁tryAcquireShared()返回的是一个int类型而独占锁tryAcquire()返回的是boolean类型的。\n\ntryAcquireShared返回值：\n\n- 如果该值小于0，表示当前线程获取共享锁失败\n- 如果该值大于0，表示当前线程获取共享锁成功，并且接下来其他线程获取共享锁的行为很可能成功\n- 如果该值等于0，表示当前线程获取共享锁成功，但是接下来其他线程尝试获取共享锁的行为会失败\n\n因此只要返回值大于0，就表示获取共享锁成功。\n\ntryAcquireShared由子类实现，先不看。\n\n看下doAcquireShared方法，对应独占锁的acquireQueued。\n\n```java\nprivate void doAcquireShared(int arg) {\n    final Node node = addWaiter(Node.SHARED);\n    //独占锁这里是\n    //addWaiter(Node.EXCLUSIVE)\n    boolean failed = true;\n    try {\n        boolean interrupted = false;\n        for (;;) {\n            final Node p = node.predecessor();\n            if (p == head) {\n                int r = tryAcquireShared(arg);\n                if (r >= 0) {\n                    setHeadAndPropagate(node, r);\n                    //独占锁这里是\n                    //setHead(node)\n                    p.next = null; // help GC\n                    if (interrupted)\n                        selfInterrupt();\n                    failed = false;\n                    return;\n                }\n            }\n            if (shouldParkAfterFailedAcquire(p, node) &&\n                parkAndCheckInterrupt())\n                interrupted = true;\n        }\n    } finally {\n        if (failed)\n            cancelAcquire(node);\n    }\n}\n```\n\n我在共享锁和独占锁不同的地方加了注释，可以看到，第一点不同是独占锁的acquireQueued调用的是addWaiter(Node.EXCLUSIVE)，而共享锁调用的是addWaiter(Node.SHARED)，表明该节点处于共享模式，两种模式的定义为：\n\n```java\nstatic final Node SHARED = new Node();\nstatic final Node EXCLUSIVE = null;\n```\n\n这个模式被赋值给了节点的nextWaiter属性：\n\n```java\nNode(Thread thread, Node mode) {     // Used by addWaiter\n    this.nextWaiter = mode;\n    this.thread = thread;\n}\n```\n\n我们知道，在条件队列中，nextWaiter是指向条件队列中的下一个节点的，它将条件队列中的节点穿起来，构成了单链表。但是在sync queue队列中，我们只用prev，next属性来串联节点，这样就形成了双向链表，nextWaiter属性在这里只起到一个标记作用，不会串联节点。Node SHARED = new Node() 这个节点并不属于sync queue，不代表任何线程，只是作为判断节点是否处于共享模式的依据（Node中isShared方法）：\n\n```java\nfinal boolean isShared() {\n     return nextWaiter == SHARED;\n }\n```\n\n第二点不同在于获取锁成功后的行为，对于独占锁而言，是直接调用了setHead(node)方法，而共享锁调用的是setHeadAndPropagate(node,r)：\n\n```java\nprivate void setHeadAndPropagate(Node node, int propagate) {\n    Node h = head; // Record old head for check below\n    setHead(node);\n\n    if (propagate > 0 || h == null || h.waitStatus < 0 ||\n        (h = head) == null || h.waitStatus < 0) {\n        Node s = node.next;\n        if (s == null || s.isShared())\n            doReleaseShared();\n    }\n}\n```\n\n在这个方法内部，不进调用了setHead(node)方法，还在一定条件下调用了doReleaseShared()来唤醒后继的节点。这是因为在共享锁模式下，锁可以被多个线程所共同持有，既然当前线程已经拿到了共享锁了，那么就可以直接通知后继节点来拿锁，而不必等到锁被释放的时候再通知。这个doReleaseShared()方法在分析释放锁的时候再看。\n\n#### 共享锁的释放\n\n共享锁释放的方法是releaseShared(int arg) ：\n\n```java\npublic final boolean releaseShared(int arg) {\n    if (tryReleaseShared(arg)) {\n        doReleaseShared();\n        return true;\n    }\n    return false;\n}\n```\n\n独占锁的释放的方法release(int arg)：\n\n```java\npublic final boolean release(int arg) {\n    if (tryRelease(arg)) {\n        Node h = head;\n        if (h != null && h.waitStatus != 0)\n            unparkSuccessor(h);\n        return true;\n    }\n    return false;\n}\n```\n\n在独占锁模式下，由于头节点就是独占锁的节点，在它释放独占锁后，如果发现自己的waitStatus不为0，则它将唤醒它的后继节点。\n\n在共享模式下，头节点就是持有共享锁的节点，在它释放共享锁后，它也应该唤醒它的后继节点，但是值得注意的是，我们在之前的setHeadAndPropagate方法中可能已经调用过该方法了，也就是说它可能被同一个头节点调用两次，也有可能在我们从releaseShared方法中调用它时，当前的头节点已经易主了。\n\n看下doReleaseShared这个方法：\n\n```java\nprivate void doReleaseShared() {\n    for (;;) {\n        Node h = head;\n        if (h != null && h != tail) {\n            int ws = h.waitStatus;\n            if (ws == Node.SIGNAL) {\n                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))\n                    continue;            // loop to recheck cases\n                unparkSuccessor(h);\n            }\n            else if (ws == 0 &&\n                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))\n                continue;                // loop on failed CAS\n        }\n        if (h == head)                   // loop if head changed\n            break;\n    }\n}\n```\n\n这个方法比较难理解。我们先从哪里调这个方法，谁调用这个方法，调用这个方法的目的是什么这些方面去分析。\n\n**1.该方法有几处调用？**\n\n这个方法一共有两处调用，一处是acquireShared末尾，当线程成功获取到共享锁后，在一定条件下调用该方法，一处是在releaseShared方法中，当线程释放共享锁的时候调用。\n\n**2.调用该方法的线程是谁？**\n\n在独占锁中，只有获的了锁的线程才能调用release释放锁，因此调用unparkSuccessor(h)唤醒后继节点的必然是持有锁的线程，该线程可看做是当前的头节点（虽然setHead方法中已经将头节点的thread属性设为null了，但是这个头节点曾经代表的就是这个线程）\n\n在共享锁中，持有共享锁的线程可以是多个，这些线程都可以调用releaseShared方法释放锁。而这些线程想要获得共享锁，则他们必然曾经成为过头节点，或者就是现在的头节点。因此，如果在releaseShared方法中调用的doReleaseShared，可能此时调用方法的线程已经不是头节点所代表的线程了，头节点可能已经被易主好几次了。\n\n**3.调用该方法的目的是什么？**\n\n这个方法的作用是在当前共享锁是可获取状态时，唤醒head节点的下一个节点。这一点看起来和独占锁似乎一样，但是它们有一个重要的差别是，在共享锁中，当头节点发生变化时，会回到循环中再立即唤醒head节点的下一个节点的。也就是说，在当前节点完成唤醒后继节点的任务之后将要退出时，如果发现被唤醒节点的后继节点已经成为新的头节点，则会立即出发唤醒head节点的下一个节点的操作，直到在这个循环中头节点没有发生变化。\n\n**4.退出该方法的条件是什么？**\n\n该方法是一个自旋操作，只有满足h == head条件后的break可以退出这个方法。也就是在这次循环中，头节点没有发生变化。\n\n假设队列中依次排列有\n\n> dummy node ->A -> B -> C -> D\n\n现在假设A拿到了共享锁，则它将成为新的dummy node\n\n> dummy node(A) -> B -> C-> D\n\n此时A线程会调用doReleaseShared，我们写作doReleaseShared[A]，在该方法中将继续唤醒后继的节点B，B很快获得了共享锁，成为新的头节点\n\n> dummy node(B) -> C -> D\n\n此时B也会调用doReleaseShared，我们写作doReleaseShared[B]，该方法将唤醒后继的节点C，但是在doReleaseShared[B]调用的时候，doReleaseShared[A]还没运行结束，当它运行到if(h == head)时，发现头节点已经变了，所以它将继续回到for循环中，doReleaseShared[B]运行到判断的时候，也进入到for循环中。\n\n这时这里就形成了一个“调用风暴”，大量线程在同时执行doReleaseShared，这将加快后继节点的唤醒速度，提升执行效率。同时内部的CAS又保证了多个线程唤醒同一个节点时，只有一个线程可以成功。\n\n如果doReleaseShared[A]执行结束时，节点B还没有成为新的头节点，那么doReleaseShared[A]就会结束退出，这样也不会影响A唤醒了B线程的结果，最终等待共享锁的线程都将执行。\n\n这里的“调用风暴”其实是一个优化操作，因为我们在执行到该方法末尾的时候，unparkSuccessor基本上已经被调用过了，然后因为是共享锁，所以被唤醒的后继节点也极有可能已经获取到了共享锁，成为新的head节点，当它成为head节点后，它可能还是要在setHeadAndPropagate方法中调用doReleaseShared唤醒它的后继节点。\n\n```java\nif (h != null && h != tail) {\n            int ws = h.waitStatus;\n            if (ws == Node.SIGNAL) {\n                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))\n                    continue;            // loop to recheck cases\n                unparkSuccessor(h); \n            }\n            else if (ws == 0 &&\n                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))\n                continue;                // loop on failed CAS\n}\n```\n\n第一个if比较好理解，如果当前头节点ws值为SIGNAL，则说明后继节点需要被唤醒，这里使用CAS先改ws状态改为0，并且让成功的那个线程执行unparkSuccessor，这样也保证了unparkSuccessor只会被执行一次。\n\n这个第二个if。是**当前队列最后一个节点变成了头节点**，为什么是这种情况呢\u0010？因为每次新加入一个节点，都会把自己的前驱节点的waitStatus改为SIGNAL。\n\n这个if描述了一个极其严苛且短暂的状态：\n\n1.首先，队列里有至少两个节点 可以看最外层的判断条件 if(h != null && h != tail)\n\n2.要执行到else if语句，说明头节点是刚刚成为头节点的，它的waitStatus还是0，尾节点是在这之后加进来的，它需要执行shouldParkAfterFailedAcquire，将它的前驱节点（头节点）的waitStatus改为SIGNAL，但是目前这个修改操作还没有来得及执行。这种情况使得可以进入第二个if的前半段 ws == 0\n\n3.紧接着要满足!compareAndSetWaitStatus(h, 0, Node.PROPAGATE)这一条件，说明此时头节点的waitStatus已经不是0了，说明之前那个没有来得及执行的在shouldParkAfterFailedAcquire将前驱节点的waitStatus值修改为SIGNAL的操作现在执行完了\n\n所以第二个if的&&连接了两个不一致的状态，分别对应了shouldParkAfterFailedAcquire的`compareAndSetWaitStatus(pred, ws, Node.SIGNAL)`执行成功前和执行成功后，因为doReleaseShared和shouldParkAfterFailedAcquire是可以并发执行的，所以这一条件是有可能满足的，只是满足条件非常严苛，可能只是一瞬间的事。\n\n#### 总结\n\n- 共享锁的调用框架和独占锁很相似，它们最大的不同在于获取锁的逻辑——共享锁可以被多个线程同时持有，而独占锁同一时刻只能被一个线程持有\n- 由于共享锁同一时刻可以被多个线程持有，因此当头节点获取到共享锁时，可以立即唤醒后继节点来竞争锁，而不必等到释放锁的时候。因此共享锁触发唤醒后继节点的行为可能有两处，一处在当前节点成功获得共享锁后，一处在当前节点释放共享锁后。","source":"_posts/AQS源码分析之共享锁的获取与释放.md","raw":"---\nlayout:    post\ntitle:     AQS源码分析之共享锁的获取与释放\ncategory:  JUC\ndescription: AQS源码分析之共享锁的获取与释放\ntags: \n    - JDK\n    - JUC\n    - AQS\ndate: 2021/08/19 22:37:10\n\n---\n\n\n\n#### 共享锁与独占锁的区别\n\n共享锁和独占锁的最大区别在于，独占锁是独占的，排他的，因此独占锁中有一个`exclusiveOwnerThread`属性，用来记录当前持有锁的线程，当独占锁已经被某个线程持有时，其他线程只能等待它被释放时，才能去竞争锁，并且同一时刻只能有一个线程竞争锁成功。\n\n但是对于共享锁而言，它是可以被多个线程同时持有。如果一个线程成功获取了共享锁，那么其他等待在这个共享锁上的线程就也可以尝试去获取锁，并且极有可能获取成功。\n\n| 独占锁                                     | 共享锁                                           |\n| ------------------------------------------ | ------------------------------------------------ |\n| tryAcquire(int arg)                        | tryAcquireShared(int arg)                        |\n| tryAcquireNanos(int arg,long nanosTimeout) | tryAcquireSharedNanos(int arg,long nanosTimeout) |\n| acquire(int arg)                           | acquireShared(int arg)                           |\n| acquireQueued(final Node node,int arg)     | doAcquireShared(int arg)                         |\n| acquireinterruptibly(int arg)              | acquireSharedInterruptibly(int arg)              |\n| doAcquireInterruptibly(int arg)            | doAcquireSharedInterruptibly(int arg)            |\n| doAcquireNanos(int arg,long nanosTimeout)  | doAcquireSharedNanos(int arg,long nanosTimeout)  |\n| release(int arg)                           | releaseShared(int arg)                           |\n| tryRelease(int arg)                        | tryReleaseShared(int arg)                        |\n| -                                          | doReleaseShared()                                |\n\n除了最后一个共享锁的doReleaseShared()方法独占锁没有对应外，其他方法，共享锁和独占锁都是一一对应的。\n\n在独占锁中，我们只有在获取独占锁的节点释放锁时，才会唤醒后继节点——这是合理的，因为独占锁只能被一个线程持有，如果它还没被释放，就没必要去唤醒它的后继节点。\n\n但是在共享模式下，当一个节点获取到了共享锁，我们在获取成功后就可以唤醒后继节点，而不需要等到释放锁的时候再去唤醒。这是因为共享锁可以被多个线程同时持有，一个锁获取到了，则后继的节点都可以直接来获取。因此，在共享锁模式下，在获取锁和释放锁结束时，都会唤醒后继节点。所以doReleaseShared()方法与unparkSuccessor(h)方法无法直接对应。\n\n#### 共享锁的获取\n\n```java\npublic final void acquireShared(int arg) {\n    if (tryAcquireShared(arg) < 0)\n        doAcquireShared(arg);\n}\n```\n\n独占锁的获取\n\n```java\npublic final void acquire(int arg) {\n    if (!tryAcquire(arg) &&\n        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n        selfInterrupt();\n}\n```\n\n可以看到共享锁tryAcquireShared()返回的是一个int类型而独占锁tryAcquire()返回的是boolean类型的。\n\ntryAcquireShared返回值：\n\n- 如果该值小于0，表示当前线程获取共享锁失败\n- 如果该值大于0，表示当前线程获取共享锁成功，并且接下来其他线程获取共享锁的行为很可能成功\n- 如果该值等于0，表示当前线程获取共享锁成功，但是接下来其他线程尝试获取共享锁的行为会失败\n\n因此只要返回值大于0，就表示获取共享锁成功。\n\ntryAcquireShared由子类实现，先不看。\n\n看下doAcquireShared方法，对应独占锁的acquireQueued。\n\n```java\nprivate void doAcquireShared(int arg) {\n    final Node node = addWaiter(Node.SHARED);\n    //独占锁这里是\n    //addWaiter(Node.EXCLUSIVE)\n    boolean failed = true;\n    try {\n        boolean interrupted = false;\n        for (;;) {\n            final Node p = node.predecessor();\n            if (p == head) {\n                int r = tryAcquireShared(arg);\n                if (r >= 0) {\n                    setHeadAndPropagate(node, r);\n                    //独占锁这里是\n                    //setHead(node)\n                    p.next = null; // help GC\n                    if (interrupted)\n                        selfInterrupt();\n                    failed = false;\n                    return;\n                }\n            }\n            if (shouldParkAfterFailedAcquire(p, node) &&\n                parkAndCheckInterrupt())\n                interrupted = true;\n        }\n    } finally {\n        if (failed)\n            cancelAcquire(node);\n    }\n}\n```\n\n我在共享锁和独占锁不同的地方加了注释，可以看到，第一点不同是独占锁的acquireQueued调用的是addWaiter(Node.EXCLUSIVE)，而共享锁调用的是addWaiter(Node.SHARED)，表明该节点处于共享模式，两种模式的定义为：\n\n```java\nstatic final Node SHARED = new Node();\nstatic final Node EXCLUSIVE = null;\n```\n\n这个模式被赋值给了节点的nextWaiter属性：\n\n```java\nNode(Thread thread, Node mode) {     // Used by addWaiter\n    this.nextWaiter = mode;\n    this.thread = thread;\n}\n```\n\n我们知道，在条件队列中，nextWaiter是指向条件队列中的下一个节点的，它将条件队列中的节点穿起来，构成了单链表。但是在sync queue队列中，我们只用prev，next属性来串联节点，这样就形成了双向链表，nextWaiter属性在这里只起到一个标记作用，不会串联节点。Node SHARED = new Node() 这个节点并不属于sync queue，不代表任何线程，只是作为判断节点是否处于共享模式的依据（Node中isShared方法）：\n\n```java\nfinal boolean isShared() {\n     return nextWaiter == SHARED;\n }\n```\n\n第二点不同在于获取锁成功后的行为，对于独占锁而言，是直接调用了setHead(node)方法，而共享锁调用的是setHeadAndPropagate(node,r)：\n\n```java\nprivate void setHeadAndPropagate(Node node, int propagate) {\n    Node h = head; // Record old head for check below\n    setHead(node);\n\n    if (propagate > 0 || h == null || h.waitStatus < 0 ||\n        (h = head) == null || h.waitStatus < 0) {\n        Node s = node.next;\n        if (s == null || s.isShared())\n            doReleaseShared();\n    }\n}\n```\n\n在这个方法内部，不进调用了setHead(node)方法，还在一定条件下调用了doReleaseShared()来唤醒后继的节点。这是因为在共享锁模式下，锁可以被多个线程所共同持有，既然当前线程已经拿到了共享锁了，那么就可以直接通知后继节点来拿锁，而不必等到锁被释放的时候再通知。这个doReleaseShared()方法在分析释放锁的时候再看。\n\n#### 共享锁的释放\n\n共享锁释放的方法是releaseShared(int arg) ：\n\n```java\npublic final boolean releaseShared(int arg) {\n    if (tryReleaseShared(arg)) {\n        doReleaseShared();\n        return true;\n    }\n    return false;\n}\n```\n\n独占锁的释放的方法release(int arg)：\n\n```java\npublic final boolean release(int arg) {\n    if (tryRelease(arg)) {\n        Node h = head;\n        if (h != null && h.waitStatus != 0)\n            unparkSuccessor(h);\n        return true;\n    }\n    return false;\n}\n```\n\n在独占锁模式下，由于头节点就是独占锁的节点，在它释放独占锁后，如果发现自己的waitStatus不为0，则它将唤醒它的后继节点。\n\n在共享模式下，头节点就是持有共享锁的节点，在它释放共享锁后，它也应该唤醒它的后继节点，但是值得注意的是，我们在之前的setHeadAndPropagate方法中可能已经调用过该方法了，也就是说它可能被同一个头节点调用两次，也有可能在我们从releaseShared方法中调用它时，当前的头节点已经易主了。\n\n看下doReleaseShared这个方法：\n\n```java\nprivate void doReleaseShared() {\n    for (;;) {\n        Node h = head;\n        if (h != null && h != tail) {\n            int ws = h.waitStatus;\n            if (ws == Node.SIGNAL) {\n                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))\n                    continue;            // loop to recheck cases\n                unparkSuccessor(h);\n            }\n            else if (ws == 0 &&\n                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))\n                continue;                // loop on failed CAS\n        }\n        if (h == head)                   // loop if head changed\n            break;\n    }\n}\n```\n\n这个方法比较难理解。我们先从哪里调这个方法，谁调用这个方法，调用这个方法的目的是什么这些方面去分析。\n\n**1.该方法有几处调用？**\n\n这个方法一共有两处调用，一处是acquireShared末尾，当线程成功获取到共享锁后，在一定条件下调用该方法，一处是在releaseShared方法中，当线程释放共享锁的时候调用。\n\n**2.调用该方法的线程是谁？**\n\n在独占锁中，只有获的了锁的线程才能调用release释放锁，因此调用unparkSuccessor(h)唤醒后继节点的必然是持有锁的线程，该线程可看做是当前的头节点（虽然setHead方法中已经将头节点的thread属性设为null了，但是这个头节点曾经代表的就是这个线程）\n\n在共享锁中，持有共享锁的线程可以是多个，这些线程都可以调用releaseShared方法释放锁。而这些线程想要获得共享锁，则他们必然曾经成为过头节点，或者就是现在的头节点。因此，如果在releaseShared方法中调用的doReleaseShared，可能此时调用方法的线程已经不是头节点所代表的线程了，头节点可能已经被易主好几次了。\n\n**3.调用该方法的目的是什么？**\n\n这个方法的作用是在当前共享锁是可获取状态时，唤醒head节点的下一个节点。这一点看起来和独占锁似乎一样，但是它们有一个重要的差别是，在共享锁中，当头节点发生变化时，会回到循环中再立即唤醒head节点的下一个节点的。也就是说，在当前节点完成唤醒后继节点的任务之后将要退出时，如果发现被唤醒节点的后继节点已经成为新的头节点，则会立即出发唤醒head节点的下一个节点的操作，直到在这个循环中头节点没有发生变化。\n\n**4.退出该方法的条件是什么？**\n\n该方法是一个自旋操作，只有满足h == head条件后的break可以退出这个方法。也就是在这次循环中，头节点没有发生变化。\n\n假设队列中依次排列有\n\n> dummy node ->A -> B -> C -> D\n\n现在假设A拿到了共享锁，则它将成为新的dummy node\n\n> dummy node(A) -> B -> C-> D\n\n此时A线程会调用doReleaseShared，我们写作doReleaseShared[A]，在该方法中将继续唤醒后继的节点B，B很快获得了共享锁，成为新的头节点\n\n> dummy node(B) -> C -> D\n\n此时B也会调用doReleaseShared，我们写作doReleaseShared[B]，该方法将唤醒后继的节点C，但是在doReleaseShared[B]调用的时候，doReleaseShared[A]还没运行结束，当它运行到if(h == head)时，发现头节点已经变了，所以它将继续回到for循环中，doReleaseShared[B]运行到判断的时候，也进入到for循环中。\n\n这时这里就形成了一个“调用风暴”，大量线程在同时执行doReleaseShared，这将加快后继节点的唤醒速度，提升执行效率。同时内部的CAS又保证了多个线程唤醒同一个节点时，只有一个线程可以成功。\n\n如果doReleaseShared[A]执行结束时，节点B还没有成为新的头节点，那么doReleaseShared[A]就会结束退出，这样也不会影响A唤醒了B线程的结果，最终等待共享锁的线程都将执行。\n\n这里的“调用风暴”其实是一个优化操作，因为我们在执行到该方法末尾的时候，unparkSuccessor基本上已经被调用过了，然后因为是共享锁，所以被唤醒的后继节点也极有可能已经获取到了共享锁，成为新的head节点，当它成为head节点后，它可能还是要在setHeadAndPropagate方法中调用doReleaseShared唤醒它的后继节点。\n\n```java\nif (h != null && h != tail) {\n            int ws = h.waitStatus;\n            if (ws == Node.SIGNAL) {\n                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))\n                    continue;            // loop to recheck cases\n                unparkSuccessor(h); \n            }\n            else if (ws == 0 &&\n                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))\n                continue;                // loop on failed CAS\n}\n```\n\n第一个if比较好理解，如果当前头节点ws值为SIGNAL，则说明后继节点需要被唤醒，这里使用CAS先改ws状态改为0，并且让成功的那个线程执行unparkSuccessor，这样也保证了unparkSuccessor只会被执行一次。\n\n这个第二个if。是**当前队列最后一个节点变成了头节点**，为什么是这种情况呢\u0010？因为每次新加入一个节点，都会把自己的前驱节点的waitStatus改为SIGNAL。\n\n这个if描述了一个极其严苛且短暂的状态：\n\n1.首先，队列里有至少两个节点 可以看最外层的判断条件 if(h != null && h != tail)\n\n2.要执行到else if语句，说明头节点是刚刚成为头节点的，它的waitStatus还是0，尾节点是在这之后加进来的，它需要执行shouldParkAfterFailedAcquire，将它的前驱节点（头节点）的waitStatus改为SIGNAL，但是目前这个修改操作还没有来得及执行。这种情况使得可以进入第二个if的前半段 ws == 0\n\n3.紧接着要满足!compareAndSetWaitStatus(h, 0, Node.PROPAGATE)这一条件，说明此时头节点的waitStatus已经不是0了，说明之前那个没有来得及执行的在shouldParkAfterFailedAcquire将前驱节点的waitStatus值修改为SIGNAL的操作现在执行完了\n\n所以第二个if的&&连接了两个不一致的状态，分别对应了shouldParkAfterFailedAcquire的`compareAndSetWaitStatus(pred, ws, Node.SIGNAL)`执行成功前和执行成功后，因为doReleaseShared和shouldParkAfterFailedAcquire是可以并发执行的，所以这一条件是有可能满足的，只是满足条件非常严苛，可能只是一瞬间的事。\n\n#### 总结\n\n- 共享锁的调用框架和独占锁很相似，它们最大的不同在于获取锁的逻辑——共享锁可以被多个线程同时持有，而独占锁同一时刻只能被一个线程持有\n- 由于共享锁同一时刻可以被多个线程持有，因此当头节点获取到共享锁时，可以立即唤醒后继节点来竞争锁，而不必等到释放锁的时候。因此共享锁触发唤醒后继节点的行为可能有两处，一处在当前节点成功获得共享锁后，一处在当前节点释放共享锁后。","slug":"AQS源码分析之共享锁的获取与释放","published":1,"updated":"2021-08-19T14:37:10.000Z","comments":1,"photos":[],"link":"","_id":"cm1m304ww000131b40rkgczjb","content":"<h4 id=\"共享锁与独占锁的区别\"><a href=\"#共享锁与独占锁的区别\" class=\"headerlink\" title=\"共享锁与独占锁的区别\"></a>共享锁与独占锁的区别</h4><p>共享锁和独占锁的最大区别在于，独占锁是独占的，排他的，因此独占锁中有一个<code>exclusiveOwnerThread</code>属性，用来记录当前持有锁的线程，当独占锁已经被某个线程持有时，其他线程只能等待它被释放时，才能去竞争锁，并且同一时刻只能有一个线程竞争锁成功。</p>\n<p>但是对于共享锁而言，它是可以被多个线程同时持有。如果一个线程成功获取了共享锁，那么其他等待在这个共享锁上的线程就也可以尝试去获取锁，并且极有可能获取成功。</p>\n<table>\n<thead>\n<tr>\n<th>独占锁</th>\n<th>共享锁</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>tryAcquire(int arg)</td>\n<td>tryAcquireShared(int arg)</td>\n</tr>\n<tr>\n<td>tryAcquireNanos(int arg,long nanosTimeout)</td>\n<td>tryAcquireSharedNanos(int arg,long nanosTimeout)</td>\n</tr>\n<tr>\n<td>acquire(int arg)</td>\n<td>acquireShared(int arg)</td>\n</tr>\n<tr>\n<td>acquireQueued(final Node node,int arg)</td>\n<td>doAcquireShared(int arg)</td>\n</tr>\n<tr>\n<td>acquireinterruptibly(int arg)</td>\n<td>acquireSharedInterruptibly(int arg)</td>\n</tr>\n<tr>\n<td>doAcquireInterruptibly(int arg)</td>\n<td>doAcquireSharedInterruptibly(int arg)</td>\n</tr>\n<tr>\n<td>doAcquireNanos(int arg,long nanosTimeout)</td>\n<td>doAcquireSharedNanos(int arg,long nanosTimeout)</td>\n</tr>\n<tr>\n<td>release(int arg)</td>\n<td>releaseShared(int arg)</td>\n</tr>\n<tr>\n<td>tryRelease(int arg)</td>\n<td>tryReleaseShared(int arg)</td>\n</tr>\n<tr>\n<td>-</td>\n<td>doReleaseShared()</td>\n</tr>\n</tbody></table>\n<p>除了最后一个共享锁的doReleaseShared()方法独占锁没有对应外，其他方法，共享锁和独占锁都是一一对应的。</p>\n<p>在独占锁中，我们只有在获取独占锁的节点释放锁时，才会唤醒后继节点——这是合理的，因为独占锁只能被一个线程持有，如果它还没被释放，就没必要去唤醒它的后继节点。</p>\n<p>但是在共享模式下，当一个节点获取到了共享锁，我们在获取成功后就可以唤醒后继节点，而不需要等到释放锁的时候再去唤醒。这是因为共享锁可以被多个线程同时持有，一个锁获取到了，则后继的节点都可以直接来获取。因此，在共享锁模式下，在获取锁和释放锁结束时，都会唤醒后继节点。所以doReleaseShared()方法与unparkSuccessor(h)方法无法直接对应。</p>\n<h4 id=\"共享锁的获取\"><a href=\"#共享锁的获取\" class=\"headerlink\" title=\"共享锁的获取\"></a>共享锁的获取</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">acquireShared</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tryAcquireShared(arg) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        doAcquireShared(arg);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>独占锁的获取</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">acquire</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class=\"line\">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class=\"line\">        selfInterrupt();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到共享锁tryAcquireShared()返回的是一个int类型而独占锁tryAcquire()返回的是boolean类型的。</p>\n<p>tryAcquireShared返回值：</p>\n<ul>\n<li>如果该值小于0，表示当前线程获取共享锁失败</li>\n<li>如果该值大于0，表示当前线程获取共享锁成功，并且接下来其他线程获取共享锁的行为很可能成功</li>\n<li>如果该值等于0，表示当前线程获取共享锁成功，但是接下来其他线程尝试获取共享锁的行为会失败</li>\n</ul>\n<p>因此只要返回值大于0，就表示获取共享锁成功。</p>\n<p>tryAcquireShared由子类实现，先不看。</p>\n<p>看下doAcquireShared方法，对应独占锁的acquireQueued。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">doAcquireShared</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class=\"line\">    <span class=\"comment\">//独占锁这里是</span></span><br><span class=\"line\">    <span class=\"comment\">//addWaiter(Node.EXCLUSIVE)</span></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> failed = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> interrupted = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> Node p = node.predecessor();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p == head) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> r = tryAcquireShared(arg);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (r &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    setHeadAndPropagate(node, r);</span><br><span class=\"line\">                    <span class=\"comment\">//独占锁这里是</span></span><br><span class=\"line\">                    <span class=\"comment\">//setHead(node)</span></span><br><span class=\"line\">                    p.next = <span class=\"keyword\">null</span>; <span class=\"comment\">// help GC</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (interrupted)</span><br><span class=\"line\">                        selfInterrupt();</span><br><span class=\"line\">                    failed = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class=\"line\">                parkAndCheckInterrupt())</span><br><span class=\"line\">                interrupted = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (failed)</span><br><span class=\"line\">            cancelAcquire(node);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我在共享锁和独占锁不同的地方加了注释，可以看到，第一点不同是独占锁的acquireQueued调用的是addWaiter(Node.EXCLUSIVE)，而共享锁调用的是addWaiter(Node.SHARED)，表明该节点处于共享模式，两种模式的定义为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Node SHARED = <span class=\"keyword\">new</span> Node();</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Node EXCLUSIVE = <span class=\"keyword\">null</span>;</span><br></pre></td></tr></table></figure>\n\n<p>这个模式被赋值给了节点的nextWaiter属性：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Node(Thread thread, Node mode) &#123;     <span class=\"comment\">// Used by addWaiter</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.nextWaiter = mode;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.thread = thread;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们知道，在条件队列中，nextWaiter是指向条件队列中的下一个节点的，它将条件队列中的节点穿起来，构成了单链表。但是在sync queue队列中，我们只用prev，next属性来串联节点，这样就形成了双向链表，nextWaiter属性在这里只起到一个标记作用，不会串联节点。Node SHARED = new Node() 这个节点并不属于sync queue，不代表任何线程，只是作为判断节点是否处于共享模式的依据（Node中isShared方法）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isShared</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> nextWaiter == SHARED;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>第二点不同在于获取锁成功后的行为，对于独占锁而言，是直接调用了setHead(node)方法，而共享锁调用的是setHeadAndPropagate(node,r)：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">setHeadAndPropagate</span><span class=\"params\">(Node node, <span class=\"keyword\">int</span> propagate)</span> </span>&#123;</span><br><span class=\"line\">    Node h = head; <span class=\"comment\">// Record old head for check below</span></span><br><span class=\"line\">    setHead(node);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (propagate &gt; <span class=\"number\">0</span> || h == <span class=\"keyword\">null</span> || h.waitStatus &lt; <span class=\"number\">0</span> ||</span><br><span class=\"line\">        (h = head) == <span class=\"keyword\">null</span> || h.waitStatus &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        Node s = node.next;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s == <span class=\"keyword\">null</span> || s.isShared())</span><br><span class=\"line\">            doReleaseShared();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在这个方法内部，不进调用了setHead(node)方法，还在一定条件下调用了doReleaseShared()来唤醒后继的节点。这是因为在共享锁模式下，锁可以被多个线程所共同持有，既然当前线程已经拿到了共享锁了，那么就可以直接通知后继节点来拿锁，而不必等到锁被释放的时候再通知。这个doReleaseShared()方法在分析释放锁的时候再看。</p>\n<h4 id=\"共享锁的释放\"><a href=\"#共享锁的释放\" class=\"headerlink\" title=\"共享锁的释放\"></a>共享锁的释放</h4><p>共享锁释放的方法是releaseShared(int arg) ：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">releaseShared</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class=\"line\">        doReleaseShared();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>独占锁的释放的方法release(int arg)：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">release</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tryRelease(arg)) &#123;</span><br><span class=\"line\">        Node h = head;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (h != <span class=\"keyword\">null</span> &amp;&amp; h.waitStatus != <span class=\"number\">0</span>)</span><br><span class=\"line\">            unparkSuccessor(h);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在独占锁模式下，由于头节点就是独占锁的节点，在它释放独占锁后，如果发现自己的waitStatus不为0，则它将唤醒它的后继节点。</p>\n<p>在共享模式下，头节点就是持有共享锁的节点，在它释放共享锁后，它也应该唤醒它的后继节点，但是值得注意的是，我们在之前的setHeadAndPropagate方法中可能已经调用过该方法了，也就是说它可能被同一个头节点调用两次，也有可能在我们从releaseShared方法中调用它时，当前的头节点已经易主了。</p>\n<p>看下doReleaseShared这个方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">doReleaseShared</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        Node h = head;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (h != <span class=\"keyword\">null</span> &amp;&amp; h != tail) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> ws = h.waitStatus;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class=\"number\">0</span>))</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;            <span class=\"comment\">// loop to recheck cases</span></span><br><span class=\"line\">                unparkSuccessor(h);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ws == <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">                     !compareAndSetWaitStatus(h, <span class=\"number\">0</span>, Node.PROPAGATE))</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;                <span class=\"comment\">// loop on failed CAS</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (h == head)                   <span class=\"comment\">// loop if head changed</span></span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个方法比较难理解。我们先从哪里调这个方法，谁调用这个方法，调用这个方法的目的是什么这些方面去分析。</p>\n<p><strong>1.该方法有几处调用？</strong></p>\n<p>这个方法一共有两处调用，一处是acquireShared末尾，当线程成功获取到共享锁后，在一定条件下调用该方法，一处是在releaseShared方法中，当线程释放共享锁的时候调用。</p>\n<p><strong>2.调用该方法的线程是谁？</strong></p>\n<p>在独占锁中，只有获的了锁的线程才能调用release释放锁，因此调用unparkSuccessor(h)唤醒后继节点的必然是持有锁的线程，该线程可看做是当前的头节点（虽然setHead方法中已经将头节点的thread属性设为null了，但是这个头节点曾经代表的就是这个线程）</p>\n<p>在共享锁中，持有共享锁的线程可以是多个，这些线程都可以调用releaseShared方法释放锁。而这些线程想要获得共享锁，则他们必然曾经成为过头节点，或者就是现在的头节点。因此，如果在releaseShared方法中调用的doReleaseShared，可能此时调用方法的线程已经不是头节点所代表的线程了，头节点可能已经被易主好几次了。</p>\n<p><strong>3.调用该方法的目的是什么？</strong></p>\n<p>这个方法的作用是在当前共享锁是可获取状态时，唤醒head节点的下一个节点。这一点看起来和独占锁似乎一样，但是它们有一个重要的差别是，在共享锁中，当头节点发生变化时，会回到循环中再立即唤醒head节点的下一个节点的。也就是说，在当前节点完成唤醒后继节点的任务之后将要退出时，如果发现被唤醒节点的后继节点已经成为新的头节点，则会立即出发唤醒head节点的下一个节点的操作，直到在这个循环中头节点没有发生变化。</p>\n<p><strong>4.退出该方法的条件是什么？</strong></p>\n<p>该方法是一个自旋操作，只有满足h == head条件后的break可以退出这个方法。也就是在这次循环中，头节点没有发生变化。</p>\n<p>假设队列中依次排列有</p>\n<blockquote>\n<p>dummy node -&gt;A -&gt; B -&gt; C -&gt; D</p>\n</blockquote>\n<p>现在假设A拿到了共享锁，则它将成为新的dummy node</p>\n<blockquote>\n<p>dummy node(A) -&gt; B -&gt; C-&gt; D</p>\n</blockquote>\n<p>此时A线程会调用doReleaseShared，我们写作doReleaseShared[A]，在该方法中将继续唤醒后继的节点B，B很快获得了共享锁，成为新的头节点</p>\n<blockquote>\n<p>dummy node(B) -&gt; C -&gt; D</p>\n</blockquote>\n<p>此时B也会调用doReleaseShared，我们写作doReleaseShared[B]，该方法将唤醒后继的节点C，但是在doReleaseShared[B]调用的时候，doReleaseShared[A]还没运行结束，当它运行到if(h == head)时，发现头节点已经变了，所以它将继续回到for循环中，doReleaseShared[B]运行到判断的时候，也进入到for循环中。</p>\n<p>这时这里就形成了一个“调用风暴”，大量线程在同时执行doReleaseShared，这将加快后继节点的唤醒速度，提升执行效率。同时内部的CAS又保证了多个线程唤醒同一个节点时，只有一个线程可以成功。</p>\n<p>如果doReleaseShared[A]执行结束时，节点B还没有成为新的头节点，那么doReleaseShared[A]就会结束退出，这样也不会影响A唤醒了B线程的结果，最终等待共享锁的线程都将执行。</p>\n<p>这里的“调用风暴”其实是一个优化操作，因为我们在执行到该方法末尾的时候，unparkSuccessor基本上已经被调用过了，然后因为是共享锁，所以被唤醒的后继节点也极有可能已经获取到了共享锁，成为新的head节点，当它成为head节点后，它可能还是要在setHeadAndPropagate方法中调用doReleaseShared唤醒它的后继节点。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (h != <span class=\"keyword\">null</span> &amp;&amp; h != tail) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> ws = h.waitStatus;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class=\"number\">0</span>))</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;            <span class=\"comment\">// loop to recheck cases</span></span><br><span class=\"line\">                unparkSuccessor(h); </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ws == <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">                     !compareAndSetWaitStatus(h, <span class=\"number\">0</span>, Node.PROPAGATE))</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;                <span class=\"comment\">// loop on failed CAS</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>第一个if比较好理解，如果当前头节点ws值为SIGNAL，则说明后继节点需要被唤醒，这里使用CAS先改ws状态改为0，并且让成功的那个线程执行unparkSuccessor，这样也保证了unparkSuccessor只会被执行一次。</p>\n<p>这个第二个if。是<strong>当前队列最后一个节点变成了头节点</strong>，为什么是这种情况呢\u0010？因为每次新加入一个节点，都会把自己的前驱节点的waitStatus改为SIGNAL。</p>\n<p>这个if描述了一个极其严苛且短暂的状态：</p>\n<p>1.首先，队列里有至少两个节点 可以看最外层的判断条件 if(h != null &amp;&amp; h != tail)</p>\n<p>2.要执行到else if语句，说明头节点是刚刚成为头节点的，它的waitStatus还是0，尾节点是在这之后加进来的，它需要执行shouldParkAfterFailedAcquire，将它的前驱节点（头节点）的waitStatus改为SIGNAL，但是目前这个修改操作还没有来得及执行。这种情况使得可以进入第二个if的前半段 ws == 0</p>\n<p>3.紧接着要满足!compareAndSetWaitStatus(h, 0, Node.PROPAGATE)这一条件，说明此时头节点的waitStatus已经不是0了，说明之前那个没有来得及执行的在shouldParkAfterFailedAcquire将前驱节点的waitStatus值修改为SIGNAL的操作现在执行完了</p>\n<p>所以第二个if的&amp;&amp;连接了两个不一致的状态，分别对应了shouldParkAfterFailedAcquire的<code>compareAndSetWaitStatus(pred, ws, Node.SIGNAL)</code>执行成功前和执行成功后，因为doReleaseShared和shouldParkAfterFailedAcquire是可以并发执行的，所以这一条件是有可能满足的，只是满足条件非常严苛，可能只是一瞬间的事。</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><ul>\n<li>共享锁的调用框架和独占锁很相似，它们最大的不同在于获取锁的逻辑——共享锁可以被多个线程同时持有，而独占锁同一时刻只能被一个线程持有</li>\n<li>由于共享锁同一时刻可以被多个线程持有，因此当头节点获取到共享锁时，可以立即唤醒后继节点来竞争锁，而不必等到释放锁的时候。因此共享锁触发唤醒后继节点的行为可能有两处，一处在当前节点成功获得共享锁后，一处在当前节点释放共享锁后。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"共享锁与独占锁的区别\"><a href=\"#共享锁与独占锁的区别\" class=\"headerlink\" title=\"共享锁与独占锁的区别\"></a>共享锁与独占锁的区别</h4><p>共享锁和独占锁的最大区别在于，独占锁是独占的，排他的，因此独占锁中有一个<code>exclusiveOwnerThread</code>属性，用来记录当前持有锁的线程，当独占锁已经被某个线程持有时，其他线程只能等待它被释放时，才能去竞争锁，并且同一时刻只能有一个线程竞争锁成功。</p>\n<p>但是对于共享锁而言，它是可以被多个线程同时持有。如果一个线程成功获取了共享锁，那么其他等待在这个共享锁上的线程就也可以尝试去获取锁，并且极有可能获取成功。</p>\n<table>\n<thead>\n<tr>\n<th>独占锁</th>\n<th>共享锁</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>tryAcquire(int arg)</td>\n<td>tryAcquireShared(int arg)</td>\n</tr>\n<tr>\n<td>tryAcquireNanos(int arg,long nanosTimeout)</td>\n<td>tryAcquireSharedNanos(int arg,long nanosTimeout)</td>\n</tr>\n<tr>\n<td>acquire(int arg)</td>\n<td>acquireShared(int arg)</td>\n</tr>\n<tr>\n<td>acquireQueued(final Node node,int arg)</td>\n<td>doAcquireShared(int arg)</td>\n</tr>\n<tr>\n<td>acquireinterruptibly(int arg)</td>\n<td>acquireSharedInterruptibly(int arg)</td>\n</tr>\n<tr>\n<td>doAcquireInterruptibly(int arg)</td>\n<td>doAcquireSharedInterruptibly(int arg)</td>\n</tr>\n<tr>\n<td>doAcquireNanos(int arg,long nanosTimeout)</td>\n<td>doAcquireSharedNanos(int arg,long nanosTimeout)</td>\n</tr>\n<tr>\n<td>release(int arg)</td>\n<td>releaseShared(int arg)</td>\n</tr>\n<tr>\n<td>tryRelease(int arg)</td>\n<td>tryReleaseShared(int arg)</td>\n</tr>\n<tr>\n<td>-</td>\n<td>doReleaseShared()</td>\n</tr>\n</tbody></table>\n<p>除了最后一个共享锁的doReleaseShared()方法独占锁没有对应外，其他方法，共享锁和独占锁都是一一对应的。</p>\n<p>在独占锁中，我们只有在获取独占锁的节点释放锁时，才会唤醒后继节点——这是合理的，因为独占锁只能被一个线程持有，如果它还没被释放，就没必要去唤醒它的后继节点。</p>\n<p>但是在共享模式下，当一个节点获取到了共享锁，我们在获取成功后就可以唤醒后继节点，而不需要等到释放锁的时候再去唤醒。这是因为共享锁可以被多个线程同时持有，一个锁获取到了，则后继的节点都可以直接来获取。因此，在共享锁模式下，在获取锁和释放锁结束时，都会唤醒后继节点。所以doReleaseShared()方法与unparkSuccessor(h)方法无法直接对应。</p>\n<h4 id=\"共享锁的获取\"><a href=\"#共享锁的获取\" class=\"headerlink\" title=\"共享锁的获取\"></a>共享锁的获取</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">acquireShared</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tryAcquireShared(arg) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        doAcquireShared(arg);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>独占锁的获取</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">acquire</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class=\"line\">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class=\"line\">        selfInterrupt();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到共享锁tryAcquireShared()返回的是一个int类型而独占锁tryAcquire()返回的是boolean类型的。</p>\n<p>tryAcquireShared返回值：</p>\n<ul>\n<li>如果该值小于0，表示当前线程获取共享锁失败</li>\n<li>如果该值大于0，表示当前线程获取共享锁成功，并且接下来其他线程获取共享锁的行为很可能成功</li>\n<li>如果该值等于0，表示当前线程获取共享锁成功，但是接下来其他线程尝试获取共享锁的行为会失败</li>\n</ul>\n<p>因此只要返回值大于0，就表示获取共享锁成功。</p>\n<p>tryAcquireShared由子类实现，先不看。</p>\n<p>看下doAcquireShared方法，对应独占锁的acquireQueued。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">doAcquireShared</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class=\"line\">    <span class=\"comment\">//独占锁这里是</span></span><br><span class=\"line\">    <span class=\"comment\">//addWaiter(Node.EXCLUSIVE)</span></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> failed = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> interrupted = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> Node p = node.predecessor();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p == head) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> r = tryAcquireShared(arg);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (r &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    setHeadAndPropagate(node, r);</span><br><span class=\"line\">                    <span class=\"comment\">//独占锁这里是</span></span><br><span class=\"line\">                    <span class=\"comment\">//setHead(node)</span></span><br><span class=\"line\">                    p.next = <span class=\"keyword\">null</span>; <span class=\"comment\">// help GC</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (interrupted)</span><br><span class=\"line\">                        selfInterrupt();</span><br><span class=\"line\">                    failed = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class=\"line\">                parkAndCheckInterrupt())</span><br><span class=\"line\">                interrupted = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (failed)</span><br><span class=\"line\">            cancelAcquire(node);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我在共享锁和独占锁不同的地方加了注释，可以看到，第一点不同是独占锁的acquireQueued调用的是addWaiter(Node.EXCLUSIVE)，而共享锁调用的是addWaiter(Node.SHARED)，表明该节点处于共享模式，两种模式的定义为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Node SHARED = <span class=\"keyword\">new</span> Node();</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Node EXCLUSIVE = <span class=\"keyword\">null</span>;</span><br></pre></td></tr></table></figure>\n\n<p>这个模式被赋值给了节点的nextWaiter属性：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Node(Thread thread, Node mode) &#123;     <span class=\"comment\">// Used by addWaiter</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.nextWaiter = mode;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.thread = thread;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们知道，在条件队列中，nextWaiter是指向条件队列中的下一个节点的，它将条件队列中的节点穿起来，构成了单链表。但是在sync queue队列中，我们只用prev，next属性来串联节点，这样就形成了双向链表，nextWaiter属性在这里只起到一个标记作用，不会串联节点。Node SHARED = new Node() 这个节点并不属于sync queue，不代表任何线程，只是作为判断节点是否处于共享模式的依据（Node中isShared方法）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isShared</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> nextWaiter == SHARED;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>第二点不同在于获取锁成功后的行为，对于独占锁而言，是直接调用了setHead(node)方法，而共享锁调用的是setHeadAndPropagate(node,r)：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">setHeadAndPropagate</span><span class=\"params\">(Node node, <span class=\"keyword\">int</span> propagate)</span> </span>&#123;</span><br><span class=\"line\">    Node h = head; <span class=\"comment\">// Record old head for check below</span></span><br><span class=\"line\">    setHead(node);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (propagate &gt; <span class=\"number\">0</span> || h == <span class=\"keyword\">null</span> || h.waitStatus &lt; <span class=\"number\">0</span> ||</span><br><span class=\"line\">        (h = head) == <span class=\"keyword\">null</span> || h.waitStatus &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        Node s = node.next;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s == <span class=\"keyword\">null</span> || s.isShared())</span><br><span class=\"line\">            doReleaseShared();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在这个方法内部，不进调用了setHead(node)方法，还在一定条件下调用了doReleaseShared()来唤醒后继的节点。这是因为在共享锁模式下，锁可以被多个线程所共同持有，既然当前线程已经拿到了共享锁了，那么就可以直接通知后继节点来拿锁，而不必等到锁被释放的时候再通知。这个doReleaseShared()方法在分析释放锁的时候再看。</p>\n<h4 id=\"共享锁的释放\"><a href=\"#共享锁的释放\" class=\"headerlink\" title=\"共享锁的释放\"></a>共享锁的释放</h4><p>共享锁释放的方法是releaseShared(int arg) ：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">releaseShared</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class=\"line\">        doReleaseShared();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>独占锁的释放的方法release(int arg)：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">release</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tryRelease(arg)) &#123;</span><br><span class=\"line\">        Node h = head;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (h != <span class=\"keyword\">null</span> &amp;&amp; h.waitStatus != <span class=\"number\">0</span>)</span><br><span class=\"line\">            unparkSuccessor(h);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在独占锁模式下，由于头节点就是独占锁的节点，在它释放独占锁后，如果发现自己的waitStatus不为0，则它将唤醒它的后继节点。</p>\n<p>在共享模式下，头节点就是持有共享锁的节点，在它释放共享锁后，它也应该唤醒它的后继节点，但是值得注意的是，我们在之前的setHeadAndPropagate方法中可能已经调用过该方法了，也就是说它可能被同一个头节点调用两次，也有可能在我们从releaseShared方法中调用它时，当前的头节点已经易主了。</p>\n<p>看下doReleaseShared这个方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">doReleaseShared</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        Node h = head;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (h != <span class=\"keyword\">null</span> &amp;&amp; h != tail) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> ws = h.waitStatus;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class=\"number\">0</span>))</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;            <span class=\"comment\">// loop to recheck cases</span></span><br><span class=\"line\">                unparkSuccessor(h);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ws == <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">                     !compareAndSetWaitStatus(h, <span class=\"number\">0</span>, Node.PROPAGATE))</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;                <span class=\"comment\">// loop on failed CAS</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (h == head)                   <span class=\"comment\">// loop if head changed</span></span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个方法比较难理解。我们先从哪里调这个方法，谁调用这个方法，调用这个方法的目的是什么这些方面去分析。</p>\n<p><strong>1.该方法有几处调用？</strong></p>\n<p>这个方法一共有两处调用，一处是acquireShared末尾，当线程成功获取到共享锁后，在一定条件下调用该方法，一处是在releaseShared方法中，当线程释放共享锁的时候调用。</p>\n<p><strong>2.调用该方法的线程是谁？</strong></p>\n<p>在独占锁中，只有获的了锁的线程才能调用release释放锁，因此调用unparkSuccessor(h)唤醒后继节点的必然是持有锁的线程，该线程可看做是当前的头节点（虽然setHead方法中已经将头节点的thread属性设为null了，但是这个头节点曾经代表的就是这个线程）</p>\n<p>在共享锁中，持有共享锁的线程可以是多个，这些线程都可以调用releaseShared方法释放锁。而这些线程想要获得共享锁，则他们必然曾经成为过头节点，或者就是现在的头节点。因此，如果在releaseShared方法中调用的doReleaseShared，可能此时调用方法的线程已经不是头节点所代表的线程了，头节点可能已经被易主好几次了。</p>\n<p><strong>3.调用该方法的目的是什么？</strong></p>\n<p>这个方法的作用是在当前共享锁是可获取状态时，唤醒head节点的下一个节点。这一点看起来和独占锁似乎一样，但是它们有一个重要的差别是，在共享锁中，当头节点发生变化时，会回到循环中再立即唤醒head节点的下一个节点的。也就是说，在当前节点完成唤醒后继节点的任务之后将要退出时，如果发现被唤醒节点的后继节点已经成为新的头节点，则会立即出发唤醒head节点的下一个节点的操作，直到在这个循环中头节点没有发生变化。</p>\n<p><strong>4.退出该方法的条件是什么？</strong></p>\n<p>该方法是一个自旋操作，只有满足h == head条件后的break可以退出这个方法。也就是在这次循环中，头节点没有发生变化。</p>\n<p>假设队列中依次排列有</p>\n<blockquote>\n<p>dummy node -&gt;A -&gt; B -&gt; C -&gt; D</p>\n</blockquote>\n<p>现在假设A拿到了共享锁，则它将成为新的dummy node</p>\n<blockquote>\n<p>dummy node(A) -&gt; B -&gt; C-&gt; D</p>\n</blockquote>\n<p>此时A线程会调用doReleaseShared，我们写作doReleaseShared[A]，在该方法中将继续唤醒后继的节点B，B很快获得了共享锁，成为新的头节点</p>\n<blockquote>\n<p>dummy node(B) -&gt; C -&gt; D</p>\n</blockquote>\n<p>此时B也会调用doReleaseShared，我们写作doReleaseShared[B]，该方法将唤醒后继的节点C，但是在doReleaseShared[B]调用的时候，doReleaseShared[A]还没运行结束，当它运行到if(h == head)时，发现头节点已经变了，所以它将继续回到for循环中，doReleaseShared[B]运行到判断的时候，也进入到for循环中。</p>\n<p>这时这里就形成了一个“调用风暴”，大量线程在同时执行doReleaseShared，这将加快后继节点的唤醒速度，提升执行效率。同时内部的CAS又保证了多个线程唤醒同一个节点时，只有一个线程可以成功。</p>\n<p>如果doReleaseShared[A]执行结束时，节点B还没有成为新的头节点，那么doReleaseShared[A]就会结束退出，这样也不会影响A唤醒了B线程的结果，最终等待共享锁的线程都将执行。</p>\n<p>这里的“调用风暴”其实是一个优化操作，因为我们在执行到该方法末尾的时候，unparkSuccessor基本上已经被调用过了，然后因为是共享锁，所以被唤醒的后继节点也极有可能已经获取到了共享锁，成为新的head节点，当它成为head节点后，它可能还是要在setHeadAndPropagate方法中调用doReleaseShared唤醒它的后继节点。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (h != <span class=\"keyword\">null</span> &amp;&amp; h != tail) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> ws = h.waitStatus;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class=\"number\">0</span>))</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;            <span class=\"comment\">// loop to recheck cases</span></span><br><span class=\"line\">                unparkSuccessor(h); </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ws == <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">                     !compareAndSetWaitStatus(h, <span class=\"number\">0</span>, Node.PROPAGATE))</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;                <span class=\"comment\">// loop on failed CAS</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>第一个if比较好理解，如果当前头节点ws值为SIGNAL，则说明后继节点需要被唤醒，这里使用CAS先改ws状态改为0，并且让成功的那个线程执行unparkSuccessor，这样也保证了unparkSuccessor只会被执行一次。</p>\n<p>这个第二个if。是<strong>当前队列最后一个节点变成了头节点</strong>，为什么是这种情况呢\u0010？因为每次新加入一个节点，都会把自己的前驱节点的waitStatus改为SIGNAL。</p>\n<p>这个if描述了一个极其严苛且短暂的状态：</p>\n<p>1.首先，队列里有至少两个节点 可以看最外层的判断条件 if(h != null &amp;&amp; h != tail)</p>\n<p>2.要执行到else if语句，说明头节点是刚刚成为头节点的，它的waitStatus还是0，尾节点是在这之后加进来的，它需要执行shouldParkAfterFailedAcquire，将它的前驱节点（头节点）的waitStatus改为SIGNAL，但是目前这个修改操作还没有来得及执行。这种情况使得可以进入第二个if的前半段 ws == 0</p>\n<p>3.紧接着要满足!compareAndSetWaitStatus(h, 0, Node.PROPAGATE)这一条件，说明此时头节点的waitStatus已经不是0了，说明之前那个没有来得及执行的在shouldParkAfterFailedAcquire将前驱节点的waitStatus值修改为SIGNAL的操作现在执行完了</p>\n<p>所以第二个if的&amp;&amp;连接了两个不一致的状态，分别对应了shouldParkAfterFailedAcquire的<code>compareAndSetWaitStatus(pred, ws, Node.SIGNAL)</code>执行成功前和执行成功后，因为doReleaseShared和shouldParkAfterFailedAcquire是可以并发执行的，所以这一条件是有可能满足的，只是满足条件非常严苛，可能只是一瞬间的事。</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><ul>\n<li>共享锁的调用框架和独占锁很相似，它们最大的不同在于获取锁的逻辑——共享锁可以被多个线程同时持有，而独占锁同一时刻只能被一个线程持有</li>\n<li>由于共享锁同一时刻可以被多个线程持有，因此当头节点获取到共享锁时，可以立即唤醒后继节点来竞争锁，而不必等到释放锁的时候。因此共享锁触发唤醒后继节点的行为可能有两处，一处在当前节点成功获得共享锁后，一处在当前节点释放共享锁后。</li>\n</ul>\n"},{"layout":"post","title":"AQS源码分析之独占锁的释放","description":"AQS源码分析之独占锁的释放","date":"2021-08-18T16:28:10.000Z","_content":"\n上一篇讲了ReentrantLock的NonfairSync的获取锁的操作，这篇主要来看一下释放锁的操作。这里要提一下，Java的内置锁在退出临界区之后会自动释放，但是ReentrantLock这样的显式锁是需要手动释放的，所以在加锁的时候一定要记得在finally语句块中释放锁！！！\n\n#### 释放锁\n\n由于公平锁和非公平锁的释放是一样的，所以unlock的逻辑并没有放在FairSync或NonfairSync中，而是直接定义在ReentrantLock类中：\n\n```java\npublic void unlock() {\n    sync.release(1);\n}\n```\n\nrelease方法定义在AQS类中，描述了释放锁的流程\n\n```java\npublic final boolean release(int arg) {\n    if (tryRelease(arg)) {\n        Node h = head;\n        if (h != null && h.waitStatus != 0)\n            unparkSuccessor(h);\n        return true;\n    }\n    return false;\n}\n```\n\n相比于获取锁，释放锁的过程简单很多，只涉及两个函数调用。\n\n- tryRelease(arg)\n\n    该方法由继承AQS的子类实现，为释放锁的具体逻辑\n\n- unparkSuccessor(h)\n\n    唤醒后继线程\n\n这里要注意一下，只要tryRelease返回true，那么后续操作不会影响最终release返回true的结果。\n\nif (h != null && h.waitStatus != 0) 这个条件h!=null 就是头节点不为空很好理解，那么头节点的waitStatus !=0是什么意思。在获取锁的时候，如果没有获取成功然后当前线程入队成功后，会调用shouldParkAfterFailedAcquire函数，这个函数会将前驱节点的waitStatus设为Node.SIGNAL，但是这个值也不是0呀。我们在新建一个节点的时候，在addWaiter函数中，当我们将一个新的节点添加进队列或者初始化空队列的时候，都会新建节点，而新建节点的waitStauts在没有赋值的情况下都会初始化为0。\n\n所以当一个head节点的waitStatus为0说明这个head节点后面没有在挂起等待中的后继节点了（如果有的话，就会被后面的节点修改waitStatus为Node.SIGNAL了），自然也不执行UnparkSuccessor了。\n\n##### tryRelease\n\ntryRelease是由ReentrantLock的静态类Sync实现。这里要记住，能执行释放锁的线程，一定是已经拿到锁的线程。因为是已经拿到锁的线程去释放锁，所以不会有任何竞争，也没有任何CAS操作。\n\n```java\nprotected final boolean tryRelease(int releases) {\n    //先将持有锁的线程数减1 unlock时传入的参数为1\n    //这里的操作主要是针对可重入锁的情况 c可能是大于1的\n    int c = getState() - releases;\n    //释放锁的线程和持有锁的线程必须一致\n    if (Thread.currentThread() != getExclusiveOwnerThread())\n        throw new IllegalMonitorStateException();\n    boolean free = false;\n    //没有线程持有锁了 所以锁可以直接释放了 否则只是减少持有锁的线程数\n    if (c == 0) {\n        free = true;\n        setExclusiveOwnerThread(null);\n    }\n    setState(c);\n    return free;\n}\n```\n\n##### unparkSuccessor\n\n锁成功释放之后，就需要唤醒后续节点了。这个方法定义在AQS中。\n\n```java\nprivate void unparkSuccessor(Node node) {\n\n    int ws = node.waitStatus;\n    //如果head节点的ws小于0直接赋值成0\n    if (ws < 0)\n        compareAndSetWaitStatus(node, ws, 0);\n\n    //通常情况下，要唤醒的节点是自己的后继节点\n    //如果后继节点存在并且在等待锁，那么直接唤醒它\n    //但是有可能存在后继节点取消等待锁 的情况\n    //这个时候从尾节点开始向前找，直到找到最靠前的ws<=0的节点 然后唤醒它\n    Node s = node.next;\n    if (s == null || s.waitStatus > 0) {\n        s = null;\n        for (Node t = tail; t != null && t != node; t = t.prev)\n            if (t.waitStatus <= 0)\n                s = t;\n    }\n    if (s != null)\n        LockSupport.unpark(s.thread);\n}\n```\n\n当前节点的前驱节点的waitStatus这个属性是用来决定是否要挂起当前线程的，并且如果一个线程被挂起，它的前驱节点的waitStatus必然是Node.SIGNAL。Node.CANCELLED值为1，所以只要不是取消，就会被唤醒。\n\n这里其实有一个问题，为什么要从尾节点开始遍历，而不是从头节点开始遍历呢，如果从头节点开始遍历，似乎遍历走过的路径更短。\n\n这里从后往前遍历是有个条件的：\n\n```java\nif (s == null || s.waitStatus > 0)\n```\n\n也就是后继节点不存在，或者后继节点取消了排队，这一条件大多数情况下是不满足的。因为虽然后继节点取消排队很正常，但是节点在挂起前，都会给自己找一个waitStatus状态为SIGNAL的前驱节点，而跳过那些已经取消掉的节点。\n\n所以从后往前找的目的是为了照顾刚加入队列的节点，这就涉及到上一篇介绍的“尾分叉”了：\n\n```java\nprivate Node addWaiter(Node mode) {\n    Node node = new Node(Thread.currentThread(), mode); //将当前线程包装成Node\n    Node pred = tail;\n    // 如果队列不为空, 则用CAS方式将当前节点设为尾节点\n    if (pred != null) {\n        node.prev = pred; //step 1, 设置前驱节点\n        if (compareAndSetTail(pred, node)) { // step2, 将当前节点设置成新的尾节点\n            pred.next = node; // step 3, 将前驱节点的next属性指向自己\n            return node;\n        }\n    }\n    enq(node); \n    return node;\n}\n```\n\n仔细看上面的代码，可以发现节点入队不是一个原子操作，虽然用了compareAndSetTail操作保证了当前节点被设置成尾节点，但是只能保证，第一步和第二步是执行完成的，有可能在第三步还没被执行到的时候，unparkSuccessor方法就开始执行了，此时pred.next还没有被设置成node，所以从前往后遍历是遍历不到的，但是因为尾节点已经设置完成，node.prev = pred操作也被执行过了，所以可以根据尾节点去往前遍历。\n\n总结一下就是，我们处于多线程条件下，如果一个节点的next属性为null，并不能保证它就是尾节点（可能因为新加的尾节点还没执行pred.next = node）,但是一个节点能入队，那么它的prev属性一定是有值的，所以反向查找一定是最精确的。\n\n在调用LockSupport.unpark(s.thread)之后，会发生什么呢？\n\n当然是回到最初的起点啦，从哪里被挂起来就从哪里唤醒（继续执行）：\n\n```java\nprivate final boolean parkAndCheckInterrupt() {\n    LockSupport.park(this); //在这里被挂起了, 唤醒之后就能继续往下执行了\n    return Thread.interrupted();\n}\n```\n\n线程被唤醒后，它将调用Thread.interrupted()并返回，Thread.interrupted()这个方法将返回当前线程的的中断状态，并清除它。然后再回到parkAndCheckInterrupt被调用的地方\n\n```java\nfinal boolean acquireQueued(final Node node, int arg) {\n    boolean failed = true;\n    try {\n        boolean interrupted = false;\n        for (;;) {\n            final Node p = node.predecessor();\n            if (p == head && tryAcquire(arg)) {\n                setHead(node);\n                p.next = null; // help GC\n                failed = false;\n                return interrupted;\n            }\n            \n            // 在这里！！！在这里！！！\n            // 在这里！！！在这里！！！\n            if (shouldParkAfterFailedAcquire(p, node) && parkAndCheckInterrupt())\n                interrupted = true;\n        }\n    } finally {\n        if (failed)\n            cancelAcquire(node);\n    }\n}\n```\n\n可以看到如果Thread.interrupted()返回true，那么parkAndCheckInterrupt()也会返回true，interrupted将被修改成true，反之为false。\n\n再接下来回到for(;;)循环中，进行新一轮的抢锁。\n\n假设这次抢到了，将从return interrupted返回，返回到acquireQueued的调用处，就是：\n\n```java\npublic final void acquire(int arg) {\n    if (!tryAcquire(arg) && acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n        selfInterrupt();\n}\n```\n\n如果acquireQueued返回true，将执行selfInterrupt()\n\n```java\nstatic void selfInterrupt() {\n    Thread.currentThread().interrupt();\n}\n```\n\n这段代码的作用就是中断当前线程。绕了这么一大圈，最后还是中断了当前线程，干啥呢这是？\n\n这一切的原因在于，我们不知道线程唤醒的原因。\n\n当我们从LockSupport.park(this)处被唤醒，我们并不知道是什么原因被唤醒，可能是别的线程释放锁，调用的LockSupport.unpark(s.thread)，也有可能是因为当前线程在等待中被中断了，因此我们通过Thread.interrupted()检查了当前线程的中断标志，并把它记录下来，在最后返回acquire()方法后，**如果发现当前线程曾经被中断过，那就把当前线程再中断一次**。\n\n为什么这样做呢？\n\n从上面的代码我们知道，即使线程在等待资源的过程中被中断唤醒，它还是会坚持不懈的抢锁，知道它抢到锁为止。也就是说，**它是不响应中断的**，仅仅是记录自己被人中断过。\n\n最后，当它抢到锁返回了，发现自己曾经被中断过，它就再中断自己一次，将这个中断补上。\n\n注意，中断对线程来说只是一个建议，一个线程被中断只是其中断状态被设为true，线程可以选择忽略这个中断，中断一个线程并不会影响线程的执行。\n\n这里补充一点，在return interrupted处返回时并不是直接返回的，因为还有一个finally代码块：\n\n```java\nfinally {\n    if (failed)\n        cancelAcquire(node);\n}\n```\n\n这个执行的情况，其实我没太懂，这里failed为true的时候，只能子类实现tryAcquire抛出异常了，然后进行相关的善后工作。","source":"_posts/AQS源码分析之独占锁的释放.md","raw":"---\nlayout:    post\ntitle:     AQS源码分析之独占锁的释放\ncategory:  JUC\ndescription: AQS源码分析之独占锁的释放\ntags:\n- JDK\n- JUC\ndate: 2021/08/19 00:28:10\n\n---\n\n上一篇讲了ReentrantLock的NonfairSync的获取锁的操作，这篇主要来看一下释放锁的操作。这里要提一下，Java的内置锁在退出临界区之后会自动释放，但是ReentrantLock这样的显式锁是需要手动释放的，所以在加锁的时候一定要记得在finally语句块中释放锁！！！\n\n#### 释放锁\n\n由于公平锁和非公平锁的释放是一样的，所以unlock的逻辑并没有放在FairSync或NonfairSync中，而是直接定义在ReentrantLock类中：\n\n```java\npublic void unlock() {\n    sync.release(1);\n}\n```\n\nrelease方法定义在AQS类中，描述了释放锁的流程\n\n```java\npublic final boolean release(int arg) {\n    if (tryRelease(arg)) {\n        Node h = head;\n        if (h != null && h.waitStatus != 0)\n            unparkSuccessor(h);\n        return true;\n    }\n    return false;\n}\n```\n\n相比于获取锁，释放锁的过程简单很多，只涉及两个函数调用。\n\n- tryRelease(arg)\n\n    该方法由继承AQS的子类实现，为释放锁的具体逻辑\n\n- unparkSuccessor(h)\n\n    唤醒后继线程\n\n这里要注意一下，只要tryRelease返回true，那么后续操作不会影响最终release返回true的结果。\n\nif (h != null && h.waitStatus != 0) 这个条件h!=null 就是头节点不为空很好理解，那么头节点的waitStatus !=0是什么意思。在获取锁的时候，如果没有获取成功然后当前线程入队成功后，会调用shouldParkAfterFailedAcquire函数，这个函数会将前驱节点的waitStatus设为Node.SIGNAL，但是这个值也不是0呀。我们在新建一个节点的时候，在addWaiter函数中，当我们将一个新的节点添加进队列或者初始化空队列的时候，都会新建节点，而新建节点的waitStauts在没有赋值的情况下都会初始化为0。\n\n所以当一个head节点的waitStatus为0说明这个head节点后面没有在挂起等待中的后继节点了（如果有的话，就会被后面的节点修改waitStatus为Node.SIGNAL了），自然也不执行UnparkSuccessor了。\n\n##### tryRelease\n\ntryRelease是由ReentrantLock的静态类Sync实现。这里要记住，能执行释放锁的线程，一定是已经拿到锁的线程。因为是已经拿到锁的线程去释放锁，所以不会有任何竞争，也没有任何CAS操作。\n\n```java\nprotected final boolean tryRelease(int releases) {\n    //先将持有锁的线程数减1 unlock时传入的参数为1\n    //这里的操作主要是针对可重入锁的情况 c可能是大于1的\n    int c = getState() - releases;\n    //释放锁的线程和持有锁的线程必须一致\n    if (Thread.currentThread() != getExclusiveOwnerThread())\n        throw new IllegalMonitorStateException();\n    boolean free = false;\n    //没有线程持有锁了 所以锁可以直接释放了 否则只是减少持有锁的线程数\n    if (c == 0) {\n        free = true;\n        setExclusiveOwnerThread(null);\n    }\n    setState(c);\n    return free;\n}\n```\n\n##### unparkSuccessor\n\n锁成功释放之后，就需要唤醒后续节点了。这个方法定义在AQS中。\n\n```java\nprivate void unparkSuccessor(Node node) {\n\n    int ws = node.waitStatus;\n    //如果head节点的ws小于0直接赋值成0\n    if (ws < 0)\n        compareAndSetWaitStatus(node, ws, 0);\n\n    //通常情况下，要唤醒的节点是自己的后继节点\n    //如果后继节点存在并且在等待锁，那么直接唤醒它\n    //但是有可能存在后继节点取消等待锁 的情况\n    //这个时候从尾节点开始向前找，直到找到最靠前的ws<=0的节点 然后唤醒它\n    Node s = node.next;\n    if (s == null || s.waitStatus > 0) {\n        s = null;\n        for (Node t = tail; t != null && t != node; t = t.prev)\n            if (t.waitStatus <= 0)\n                s = t;\n    }\n    if (s != null)\n        LockSupport.unpark(s.thread);\n}\n```\n\n当前节点的前驱节点的waitStatus这个属性是用来决定是否要挂起当前线程的，并且如果一个线程被挂起，它的前驱节点的waitStatus必然是Node.SIGNAL。Node.CANCELLED值为1，所以只要不是取消，就会被唤醒。\n\n这里其实有一个问题，为什么要从尾节点开始遍历，而不是从头节点开始遍历呢，如果从头节点开始遍历，似乎遍历走过的路径更短。\n\n这里从后往前遍历是有个条件的：\n\n```java\nif (s == null || s.waitStatus > 0)\n```\n\n也就是后继节点不存在，或者后继节点取消了排队，这一条件大多数情况下是不满足的。因为虽然后继节点取消排队很正常，但是节点在挂起前，都会给自己找一个waitStatus状态为SIGNAL的前驱节点，而跳过那些已经取消掉的节点。\n\n所以从后往前找的目的是为了照顾刚加入队列的节点，这就涉及到上一篇介绍的“尾分叉”了：\n\n```java\nprivate Node addWaiter(Node mode) {\n    Node node = new Node(Thread.currentThread(), mode); //将当前线程包装成Node\n    Node pred = tail;\n    // 如果队列不为空, 则用CAS方式将当前节点设为尾节点\n    if (pred != null) {\n        node.prev = pred; //step 1, 设置前驱节点\n        if (compareAndSetTail(pred, node)) { // step2, 将当前节点设置成新的尾节点\n            pred.next = node; // step 3, 将前驱节点的next属性指向自己\n            return node;\n        }\n    }\n    enq(node); \n    return node;\n}\n```\n\n仔细看上面的代码，可以发现节点入队不是一个原子操作，虽然用了compareAndSetTail操作保证了当前节点被设置成尾节点，但是只能保证，第一步和第二步是执行完成的，有可能在第三步还没被执行到的时候，unparkSuccessor方法就开始执行了，此时pred.next还没有被设置成node，所以从前往后遍历是遍历不到的，但是因为尾节点已经设置完成，node.prev = pred操作也被执行过了，所以可以根据尾节点去往前遍历。\n\n总结一下就是，我们处于多线程条件下，如果一个节点的next属性为null，并不能保证它就是尾节点（可能因为新加的尾节点还没执行pred.next = node）,但是一个节点能入队，那么它的prev属性一定是有值的，所以反向查找一定是最精确的。\n\n在调用LockSupport.unpark(s.thread)之后，会发生什么呢？\n\n当然是回到最初的起点啦，从哪里被挂起来就从哪里唤醒（继续执行）：\n\n```java\nprivate final boolean parkAndCheckInterrupt() {\n    LockSupport.park(this); //在这里被挂起了, 唤醒之后就能继续往下执行了\n    return Thread.interrupted();\n}\n```\n\n线程被唤醒后，它将调用Thread.interrupted()并返回，Thread.interrupted()这个方法将返回当前线程的的中断状态，并清除它。然后再回到parkAndCheckInterrupt被调用的地方\n\n```java\nfinal boolean acquireQueued(final Node node, int arg) {\n    boolean failed = true;\n    try {\n        boolean interrupted = false;\n        for (;;) {\n            final Node p = node.predecessor();\n            if (p == head && tryAcquire(arg)) {\n                setHead(node);\n                p.next = null; // help GC\n                failed = false;\n                return interrupted;\n            }\n            \n            // 在这里！！！在这里！！！\n            // 在这里！！！在这里！！！\n            if (shouldParkAfterFailedAcquire(p, node) && parkAndCheckInterrupt())\n                interrupted = true;\n        }\n    } finally {\n        if (failed)\n            cancelAcquire(node);\n    }\n}\n```\n\n可以看到如果Thread.interrupted()返回true，那么parkAndCheckInterrupt()也会返回true，interrupted将被修改成true，反之为false。\n\n再接下来回到for(;;)循环中，进行新一轮的抢锁。\n\n假设这次抢到了，将从return interrupted返回，返回到acquireQueued的调用处，就是：\n\n```java\npublic final void acquire(int arg) {\n    if (!tryAcquire(arg) && acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n        selfInterrupt();\n}\n```\n\n如果acquireQueued返回true，将执行selfInterrupt()\n\n```java\nstatic void selfInterrupt() {\n    Thread.currentThread().interrupt();\n}\n```\n\n这段代码的作用就是中断当前线程。绕了这么一大圈，最后还是中断了当前线程，干啥呢这是？\n\n这一切的原因在于，我们不知道线程唤醒的原因。\n\n当我们从LockSupport.park(this)处被唤醒，我们并不知道是什么原因被唤醒，可能是别的线程释放锁，调用的LockSupport.unpark(s.thread)，也有可能是因为当前线程在等待中被中断了，因此我们通过Thread.interrupted()检查了当前线程的中断标志，并把它记录下来，在最后返回acquire()方法后，**如果发现当前线程曾经被中断过，那就把当前线程再中断一次**。\n\n为什么这样做呢？\n\n从上面的代码我们知道，即使线程在等待资源的过程中被中断唤醒，它还是会坚持不懈的抢锁，知道它抢到锁为止。也就是说，**它是不响应中断的**，仅仅是记录自己被人中断过。\n\n最后，当它抢到锁返回了，发现自己曾经被中断过，它就再中断自己一次，将这个中断补上。\n\n注意，中断对线程来说只是一个建议，一个线程被中断只是其中断状态被设为true，线程可以选择忽略这个中断，中断一个线程并不会影响线程的执行。\n\n这里补充一点，在return interrupted处返回时并不是直接返回的，因为还有一个finally代码块：\n\n```java\nfinally {\n    if (failed)\n        cancelAcquire(node);\n}\n```\n\n这个执行的情况，其实我没太懂，这里failed为true的时候，只能子类实现tryAcquire抛出异常了，然后进行相关的善后工作。","slug":"AQS源码分析之独占锁的释放","published":1,"updated":"2021-08-18T16:28:10.000Z","comments":1,"photos":[],"link":"","_id":"cm1m304wz000231b4daaw7tqi","content":"<p>上一篇讲了ReentrantLock的NonfairSync的获取锁的操作，这篇主要来看一下释放锁的操作。这里要提一下，Java的内置锁在退出临界区之后会自动释放，但是ReentrantLock这样的显式锁是需要手动释放的，所以在加锁的时候一定要记得在finally语句块中释放锁！！！</p>\n<h4 id=\"释放锁\"><a href=\"#释放锁\" class=\"headerlink\" title=\"释放锁\"></a>释放锁</h4><p>由于公平锁和非公平锁的释放是一样的，所以unlock的逻辑并没有放在FairSync或NonfairSync中，而是直接定义在ReentrantLock类中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">unlock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    sync.release(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>release方法定义在AQS类中，描述了释放锁的流程</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">release</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tryRelease(arg)) &#123;</span><br><span class=\"line\">        Node h = head;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (h != <span class=\"keyword\">null</span> &amp;&amp; h.waitStatus != <span class=\"number\">0</span>)</span><br><span class=\"line\">            unparkSuccessor(h);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>相比于获取锁，释放锁的过程简单很多，只涉及两个函数调用。</p>\n<ul>\n<li><p>tryRelease(arg)</p>\n<p>  该方法由继承AQS的子类实现，为释放锁的具体逻辑</p>\n</li>\n<li><p>unparkSuccessor(h)</p>\n<p>  唤醒后继线程</p>\n</li>\n</ul>\n<p>这里要注意一下，只要tryRelease返回true，那么后续操作不会影响最终release返回true的结果。</p>\n<p>if (h != null &amp;&amp; h.waitStatus != 0) 这个条件h!=null 就是头节点不为空很好理解，那么头节点的waitStatus !=0是什么意思。在获取锁的时候，如果没有获取成功然后当前线程入队成功后，会调用shouldParkAfterFailedAcquire函数，这个函数会将前驱节点的waitStatus设为Node.SIGNAL，但是这个值也不是0呀。我们在新建一个节点的时候，在addWaiter函数中，当我们将一个新的节点添加进队列或者初始化空队列的时候，都会新建节点，而新建节点的waitStauts在没有赋值的情况下都会初始化为0。</p>\n<p>所以当一个head节点的waitStatus为0说明这个head节点后面没有在挂起等待中的后继节点了（如果有的话，就会被后面的节点修改waitStatus为Node.SIGNAL了），自然也不执行UnparkSuccessor了。</p>\n<h5 id=\"tryRelease\"><a href=\"#tryRelease\" class=\"headerlink\" title=\"tryRelease\"></a>tryRelease</h5><p>tryRelease是由ReentrantLock的静态类Sync实现。这里要记住，能执行释放锁的线程，一定是已经拿到锁的线程。因为是已经拿到锁的线程去释放锁，所以不会有任何竞争，也没有任何CAS操作。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryRelease</span><span class=\"params\">(<span class=\"keyword\">int</span> releases)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//先将持有锁的线程数减1 unlock时传入的参数为1</span></span><br><span class=\"line\">    <span class=\"comment\">//这里的操作主要是针对可重入锁的情况 c可能是大于1的</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> c = getState() - releases;</span><br><span class=\"line\">    <span class=\"comment\">//释放锁的线程和持有锁的线程必须一致</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalMonitorStateException();</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> free = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"comment\">//没有线程持有锁了 所以锁可以直接释放了 否则只是减少持有锁的线程数</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        free = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        setExclusiveOwnerThread(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    setState(c);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> free;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"unparkSuccessor\"><a href=\"#unparkSuccessor\" class=\"headerlink\" title=\"unparkSuccessor\"></a>unparkSuccessor</h5><p>锁成功释放之后，就需要唤醒后续节点了。这个方法定义在AQS中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">unparkSuccessor</span><span class=\"params\">(Node node)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> ws = node.waitStatus;</span><br><span class=\"line\">    <span class=\"comment\">//如果head节点的ws小于0直接赋值成0</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ws &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        compareAndSetWaitStatus(node, ws, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//通常情况下，要唤醒的节点是自己的后继节点</span></span><br><span class=\"line\">    <span class=\"comment\">//如果后继节点存在并且在等待锁，那么直接唤醒它</span></span><br><span class=\"line\">    <span class=\"comment\">//但是有可能存在后继节点取消等待锁 的情况</span></span><br><span class=\"line\">    <span class=\"comment\">//这个时候从尾节点开始向前找，直到找到最靠前的ws&lt;=0的节点 然后唤醒它</span></span><br><span class=\"line\">    Node s = node.next;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s == <span class=\"keyword\">null</span> || s.waitStatus &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        s = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Node t = tail; t != <span class=\"keyword\">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (t.waitStatus &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">                s = t;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        LockSupport.unpark(s.thread);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当前节点的前驱节点的waitStatus这个属性是用来决定是否要挂起当前线程的，并且如果一个线程被挂起，它的前驱节点的waitStatus必然是Node.SIGNAL。Node.CANCELLED值为1，所以只要不是取消，就会被唤醒。</p>\n<p>这里其实有一个问题，为什么要从尾节点开始遍历，而不是从头节点开始遍历呢，如果从头节点开始遍历，似乎遍历走过的路径更短。</p>\n<p>这里从后往前遍历是有个条件的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (s == <span class=\"keyword\">null</span> || s.waitStatus &gt; <span class=\"number\">0</span>)</span><br></pre></td></tr></table></figure>\n\n<p>也就是后继节点不存在，或者后继节点取消了排队，这一条件大多数情况下是不满足的。因为虽然后继节点取消排队很正常，但是节点在挂起前，都会给自己找一个waitStatus状态为SIGNAL的前驱节点，而跳过那些已经取消掉的节点。</p>\n<p>所以从后往前找的目的是为了照顾刚加入队列的节点，这就涉及到上一篇介绍的“尾分叉”了：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Node <span class=\"title\">addWaiter</span><span class=\"params\">(Node mode)</span> </span>&#123;</span><br><span class=\"line\">    Node node = <span class=\"keyword\">new</span> Node(Thread.currentThread(), mode); <span class=\"comment\">//将当前线程包装成Node</span></span><br><span class=\"line\">    Node pred = tail;</span><br><span class=\"line\">    <span class=\"comment\">// 如果队列不为空, 则用CAS方式将当前节点设为尾节点</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pred != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        node.prev = pred; <span class=\"comment\">//step 1, 设置前驱节点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (compareAndSetTail(pred, node)) &#123; <span class=\"comment\">// step2, 将当前节点设置成新的尾节点</span></span><br><span class=\"line\">            pred.next = node; <span class=\"comment\">// step 3, 将前驱节点的next属性指向自己</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    enq(node); </span><br><span class=\"line\">    <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>仔细看上面的代码，可以发现节点入队不是一个原子操作，虽然用了compareAndSetTail操作保证了当前节点被设置成尾节点，但是只能保证，第一步和第二步是执行完成的，有可能在第三步还没被执行到的时候，unparkSuccessor方法就开始执行了，此时pred.next还没有被设置成node，所以从前往后遍历是遍历不到的，但是因为尾节点已经设置完成，node.prev = pred操作也被执行过了，所以可以根据尾节点去往前遍历。</p>\n<p>总结一下就是，我们处于多线程条件下，如果一个节点的next属性为null，并不能保证它就是尾节点（可能因为新加的尾节点还没执行pred.next = node）,但是一个节点能入队，那么它的prev属性一定是有值的，所以反向查找一定是最精确的。</p>\n<p>在调用LockSupport.unpark(s.thread)之后，会发生什么呢？</p>\n<p>当然是回到最初的起点啦，从哪里被挂起来就从哪里唤醒（继续执行）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">parkAndCheckInterrupt</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    LockSupport.park(<span class=\"keyword\">this</span>); <span class=\"comment\">//在这里被挂起了, 唤醒之后就能继续往下执行了</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> Thread.interrupted();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>线程被唤醒后，它将调用Thread.interrupted()并返回，Thread.interrupted()这个方法将返回当前线程的的中断状态，并清除它。然后再回到parkAndCheckInterrupt被调用的地方</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">acquireQueued</span><span class=\"params\">(<span class=\"keyword\">final</span> Node node, <span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> failed = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> interrupted = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> Node p = node.predecessor();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class=\"line\">                setHead(node);</span><br><span class=\"line\">                p.next = <span class=\"keyword\">null</span>; <span class=\"comment\">// help GC</span></span><br><span class=\"line\">                failed = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> interrupted;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 在这里！！！在这里！！！</span></span><br><span class=\"line\">            <span class=\"comment\">// 在这里！！！在这里！！！</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())</span><br><span class=\"line\">                interrupted = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (failed)</span><br><span class=\"line\">            cancelAcquire(node);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到如果Thread.interrupted()返回true，那么parkAndCheckInterrupt()也会返回true，interrupted将被修改成true，反之为false。</p>\n<p>再接下来回到for(;;)循环中，进行新一轮的抢锁。</p>\n<p>假设这次抢到了，将从return interrupted返回，返回到acquireQueued的调用处，就是：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">acquire</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class=\"line\">        selfInterrupt();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果acquireQueued返回true，将执行selfInterrupt()</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">selfInterrupt</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Thread.currentThread().interrupt();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这段代码的作用就是中断当前线程。绕了这么一大圈，最后还是中断了当前线程，干啥呢这是？</p>\n<p>这一切的原因在于，我们不知道线程唤醒的原因。</p>\n<p>当我们从LockSupport.park(this)处被唤醒，我们并不知道是什么原因被唤醒，可能是别的线程释放锁，调用的LockSupport.unpark(s.thread)，也有可能是因为当前线程在等待中被中断了，因此我们通过Thread.interrupted()检查了当前线程的中断标志，并把它记录下来，在最后返回acquire()方法后，<strong>如果发现当前线程曾经被中断过，那就把当前线程再中断一次</strong>。</p>\n<p>为什么这样做呢？</p>\n<p>从上面的代码我们知道，即使线程在等待资源的过程中被中断唤醒，它还是会坚持不懈的抢锁，知道它抢到锁为止。也就是说，<strong>它是不响应中断的</strong>，仅仅是记录自己被人中断过。</p>\n<p>最后，当它抢到锁返回了，发现自己曾经被中断过，它就再中断自己一次，将这个中断补上。</p>\n<p>注意，中断对线程来说只是一个建议，一个线程被中断只是其中断状态被设为true，线程可以选择忽略这个中断，中断一个线程并不会影响线程的执行。</p>\n<p>这里补充一点，在return interrupted处返回时并不是直接返回的，因为还有一个finally代码块：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (failed)</span><br><span class=\"line\">        cancelAcquire(node);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个执行的情况，其实我没太懂，这里failed为true的时候，只能子类实现tryAcquire抛出异常了，然后进行相关的善后工作。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>上一篇讲了ReentrantLock的NonfairSync的获取锁的操作，这篇主要来看一下释放锁的操作。这里要提一下，Java的内置锁在退出临界区之后会自动释放，但是ReentrantLock这样的显式锁是需要手动释放的，所以在加锁的时候一定要记得在finally语句块中释放锁！！！</p>\n<h4 id=\"释放锁\"><a href=\"#释放锁\" class=\"headerlink\" title=\"释放锁\"></a>释放锁</h4><p>由于公平锁和非公平锁的释放是一样的，所以unlock的逻辑并没有放在FairSync或NonfairSync中，而是直接定义在ReentrantLock类中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">unlock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    sync.release(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>release方法定义在AQS类中，描述了释放锁的流程</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">release</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tryRelease(arg)) &#123;</span><br><span class=\"line\">        Node h = head;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (h != <span class=\"keyword\">null</span> &amp;&amp; h.waitStatus != <span class=\"number\">0</span>)</span><br><span class=\"line\">            unparkSuccessor(h);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>相比于获取锁，释放锁的过程简单很多，只涉及两个函数调用。</p>\n<ul>\n<li><p>tryRelease(arg)</p>\n<p>  该方法由继承AQS的子类实现，为释放锁的具体逻辑</p>\n</li>\n<li><p>unparkSuccessor(h)</p>\n<p>  唤醒后继线程</p>\n</li>\n</ul>\n<p>这里要注意一下，只要tryRelease返回true，那么后续操作不会影响最终release返回true的结果。</p>\n<p>if (h != null &amp;&amp; h.waitStatus != 0) 这个条件h!=null 就是头节点不为空很好理解，那么头节点的waitStatus !=0是什么意思。在获取锁的时候，如果没有获取成功然后当前线程入队成功后，会调用shouldParkAfterFailedAcquire函数，这个函数会将前驱节点的waitStatus设为Node.SIGNAL，但是这个值也不是0呀。我们在新建一个节点的时候，在addWaiter函数中，当我们将一个新的节点添加进队列或者初始化空队列的时候，都会新建节点，而新建节点的waitStauts在没有赋值的情况下都会初始化为0。</p>\n<p>所以当一个head节点的waitStatus为0说明这个head节点后面没有在挂起等待中的后继节点了（如果有的话，就会被后面的节点修改waitStatus为Node.SIGNAL了），自然也不执行UnparkSuccessor了。</p>\n<h5 id=\"tryRelease\"><a href=\"#tryRelease\" class=\"headerlink\" title=\"tryRelease\"></a>tryRelease</h5><p>tryRelease是由ReentrantLock的静态类Sync实现。这里要记住，能执行释放锁的线程，一定是已经拿到锁的线程。因为是已经拿到锁的线程去释放锁，所以不会有任何竞争，也没有任何CAS操作。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryRelease</span><span class=\"params\">(<span class=\"keyword\">int</span> releases)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//先将持有锁的线程数减1 unlock时传入的参数为1</span></span><br><span class=\"line\">    <span class=\"comment\">//这里的操作主要是针对可重入锁的情况 c可能是大于1的</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> c = getState() - releases;</span><br><span class=\"line\">    <span class=\"comment\">//释放锁的线程和持有锁的线程必须一致</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalMonitorStateException();</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> free = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"comment\">//没有线程持有锁了 所以锁可以直接释放了 否则只是减少持有锁的线程数</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        free = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        setExclusiveOwnerThread(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    setState(c);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> free;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"unparkSuccessor\"><a href=\"#unparkSuccessor\" class=\"headerlink\" title=\"unparkSuccessor\"></a>unparkSuccessor</h5><p>锁成功释放之后，就需要唤醒后续节点了。这个方法定义在AQS中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">unparkSuccessor</span><span class=\"params\">(Node node)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> ws = node.waitStatus;</span><br><span class=\"line\">    <span class=\"comment\">//如果head节点的ws小于0直接赋值成0</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ws &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        compareAndSetWaitStatus(node, ws, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//通常情况下，要唤醒的节点是自己的后继节点</span></span><br><span class=\"line\">    <span class=\"comment\">//如果后继节点存在并且在等待锁，那么直接唤醒它</span></span><br><span class=\"line\">    <span class=\"comment\">//但是有可能存在后继节点取消等待锁 的情况</span></span><br><span class=\"line\">    <span class=\"comment\">//这个时候从尾节点开始向前找，直到找到最靠前的ws&lt;=0的节点 然后唤醒它</span></span><br><span class=\"line\">    Node s = node.next;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s == <span class=\"keyword\">null</span> || s.waitStatus &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        s = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Node t = tail; t != <span class=\"keyword\">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (t.waitStatus &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">                s = t;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        LockSupport.unpark(s.thread);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当前节点的前驱节点的waitStatus这个属性是用来决定是否要挂起当前线程的，并且如果一个线程被挂起，它的前驱节点的waitStatus必然是Node.SIGNAL。Node.CANCELLED值为1，所以只要不是取消，就会被唤醒。</p>\n<p>这里其实有一个问题，为什么要从尾节点开始遍历，而不是从头节点开始遍历呢，如果从头节点开始遍历，似乎遍历走过的路径更短。</p>\n<p>这里从后往前遍历是有个条件的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (s == <span class=\"keyword\">null</span> || s.waitStatus &gt; <span class=\"number\">0</span>)</span><br></pre></td></tr></table></figure>\n\n<p>也就是后继节点不存在，或者后继节点取消了排队，这一条件大多数情况下是不满足的。因为虽然后继节点取消排队很正常，但是节点在挂起前，都会给自己找一个waitStatus状态为SIGNAL的前驱节点，而跳过那些已经取消掉的节点。</p>\n<p>所以从后往前找的目的是为了照顾刚加入队列的节点，这就涉及到上一篇介绍的“尾分叉”了：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Node <span class=\"title\">addWaiter</span><span class=\"params\">(Node mode)</span> </span>&#123;</span><br><span class=\"line\">    Node node = <span class=\"keyword\">new</span> Node(Thread.currentThread(), mode); <span class=\"comment\">//将当前线程包装成Node</span></span><br><span class=\"line\">    Node pred = tail;</span><br><span class=\"line\">    <span class=\"comment\">// 如果队列不为空, 则用CAS方式将当前节点设为尾节点</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pred != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        node.prev = pred; <span class=\"comment\">//step 1, 设置前驱节点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (compareAndSetTail(pred, node)) &#123; <span class=\"comment\">// step2, 将当前节点设置成新的尾节点</span></span><br><span class=\"line\">            pred.next = node; <span class=\"comment\">// step 3, 将前驱节点的next属性指向自己</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    enq(node); </span><br><span class=\"line\">    <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>仔细看上面的代码，可以发现节点入队不是一个原子操作，虽然用了compareAndSetTail操作保证了当前节点被设置成尾节点，但是只能保证，第一步和第二步是执行完成的，有可能在第三步还没被执行到的时候，unparkSuccessor方法就开始执行了，此时pred.next还没有被设置成node，所以从前往后遍历是遍历不到的，但是因为尾节点已经设置完成，node.prev = pred操作也被执行过了，所以可以根据尾节点去往前遍历。</p>\n<p>总结一下就是，我们处于多线程条件下，如果一个节点的next属性为null，并不能保证它就是尾节点（可能因为新加的尾节点还没执行pred.next = node）,但是一个节点能入队，那么它的prev属性一定是有值的，所以反向查找一定是最精确的。</p>\n<p>在调用LockSupport.unpark(s.thread)之后，会发生什么呢？</p>\n<p>当然是回到最初的起点啦，从哪里被挂起来就从哪里唤醒（继续执行）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">parkAndCheckInterrupt</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    LockSupport.park(<span class=\"keyword\">this</span>); <span class=\"comment\">//在这里被挂起了, 唤醒之后就能继续往下执行了</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> Thread.interrupted();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>线程被唤醒后，它将调用Thread.interrupted()并返回，Thread.interrupted()这个方法将返回当前线程的的中断状态，并清除它。然后再回到parkAndCheckInterrupt被调用的地方</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">acquireQueued</span><span class=\"params\">(<span class=\"keyword\">final</span> Node node, <span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> failed = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> interrupted = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> Node p = node.predecessor();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class=\"line\">                setHead(node);</span><br><span class=\"line\">                p.next = <span class=\"keyword\">null</span>; <span class=\"comment\">// help GC</span></span><br><span class=\"line\">                failed = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> interrupted;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 在这里！！！在这里！！！</span></span><br><span class=\"line\">            <span class=\"comment\">// 在这里！！！在这里！！！</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())</span><br><span class=\"line\">                interrupted = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (failed)</span><br><span class=\"line\">            cancelAcquire(node);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到如果Thread.interrupted()返回true，那么parkAndCheckInterrupt()也会返回true，interrupted将被修改成true，反之为false。</p>\n<p>再接下来回到for(;;)循环中，进行新一轮的抢锁。</p>\n<p>假设这次抢到了，将从return interrupted返回，返回到acquireQueued的调用处，就是：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">acquire</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class=\"line\">        selfInterrupt();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果acquireQueued返回true，将执行selfInterrupt()</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">selfInterrupt</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Thread.currentThread().interrupt();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这段代码的作用就是中断当前线程。绕了这么一大圈，最后还是中断了当前线程，干啥呢这是？</p>\n<p>这一切的原因在于，我们不知道线程唤醒的原因。</p>\n<p>当我们从LockSupport.park(this)处被唤醒，我们并不知道是什么原因被唤醒，可能是别的线程释放锁，调用的LockSupport.unpark(s.thread)，也有可能是因为当前线程在等待中被中断了，因此我们通过Thread.interrupted()检查了当前线程的中断标志，并把它记录下来，在最后返回acquire()方法后，<strong>如果发现当前线程曾经被中断过，那就把当前线程再中断一次</strong>。</p>\n<p>为什么这样做呢？</p>\n<p>从上面的代码我们知道，即使线程在等待资源的过程中被中断唤醒，它还是会坚持不懈的抢锁，知道它抢到锁为止。也就是说，<strong>它是不响应中断的</strong>，仅仅是记录自己被人中断过。</p>\n<p>最后，当它抢到锁返回了，发现自己曾经被中断过，它就再中断自己一次，将这个中断补上。</p>\n<p>注意，中断对线程来说只是一个建议，一个线程被中断只是其中断状态被设为true，线程可以选择忽略这个中断，中断一个线程并不会影响线程的执行。</p>\n<p>这里补充一点，在return interrupted处返回时并不是直接返回的，因为还有一个finally代码块：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (failed)</span><br><span class=\"line\">        cancelAcquire(node);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个执行的情况，其实我没太懂，这里failed为true的时候，只能子类实现tryAcquire抛出异常了，然后进行相关的善后工作。</p>\n"},{"layout":"post","title":"JVM怎么判断对象已经死了","description":"在JVM中是如何判断对象已经死亡的呢","date":"2021-05-29T05:26:10.000Z","_content":"\n> 本文转载自 https://mp.weixin.qq.com/s/bPexDXkSJ0T4vQnmWMsoZQ \n\nGC的历史比Java还要久远，我们在思考GC时候需要思考三个问题：\n\n**哪些内存需要回收？**\n\n**什么时候回收？**\n\n**如何回收？**\n\n在Java中程序计数器、虚拟机栈、本地方法栈这三个区域随线程而生，随线程而灭：栈中的栈帧随着方法的调用和退出而有条不紊的进行着入栈和出栈的过程。\n\n每个栈帧分配多少内存在类结构确定下来时就已知的，方法结束或者线程结束内存自然跟着回收了。\n\n而Java堆和方法区不一样，一个接口中的多个实现类的内存可能不一样，每个方法的多个分支需要的内存也可能不一样，我们只有在程序运行时候才知道会创建哪些对象，这部分内存的分配和回收都是动态的。\n\n### 一、判断对象已死的算法\n\n1）引用计数算法\n\n给对象添加一个引用计数器，每当一个地方引用它时候，计数器就加1，当引用失效，计数器就减1；任何时刻计数器为0的对象就是不可能再被使用了。\n\n这种方法实现简单，效率高，但是它很难解决对象的循环引用问题：\n\n```java\npublic class Test {\n\n    private static final int _1MB = 1024 *1024;\n\n    private Object instance = null;\n\n    public static void testGC(){\n        Test objectA = new Test();\n        Test objectB = new Test();\n\n        objectA.instance = objectB;\n        objectB.instance = objectA;\n\n        objectA = null;\n        objectB = null;\n\n        // 假如这里发生GC，objectA和objectB会不会被回收\n\n    }\n}\n```\n\n2）可达性分析算法\n\n这个算法的基本思路是通过一系列称为`GC Roots`（一组必须活跃的引用）作为起始点，从这些节点开始向下搜索，搜索走过的路径称为引用链，当一个对象到`GC Roots`没有任何引用链时候，那么证明此对象是不可用的。\n\n在Java语言中，能作为`GC Roots`的对象包括以下几种\n\n1）虚拟机栈（栈帧中的本地变量表）中引用的对象\n\n2）方法区中类静态属性引用的对象\n\n3）方法区中常量引用的对象\n\n4）本地方法栈JNI（即一般说的Native方法）引用的对象\n\n### 二、引用\n\n无论是通过引用计数器算法判断对象的引用数量，还是通过可达性分析算法判断对象引用链是否可达，判断对象是否可活都离不开引用，Java中将引用分为四种：\n\n**1）强引用（Strong Reference）**\n\n是指程序代码中普遍存在的，类似“Object obj = new Object()”这类的引用，只有强引用还存在对象就不会被回收。\n\n**2）软引用（Soft Reference）**\n\n软引用是用来描述一些还有用但是非必须的对象。对于软引用关联的对象，在系统将于发生内存溢出异常之前，将会把这些对象列进回收范围中进行二次回收。\n\n**3）弱引用（Weak Reference）**\n\n也是用来描述非必须对象的，强度比软引用还弱一些，被软引用关联的对象只能存活到下一次内存回收之前。\n\n**4）虚引用（Phantom Referenece）**\n\n也成为幽灵引用和幻影引用，为一个对象设置虚引用关联的唯一目的就是能在这个对象被回收时收到一个系统通知。\n\n### 三、生存还是死亡\n\n即使在可达性分析算法中不可达的对象，也并非一定是“非死不可”的，这时候他们暂时处于“缓刑”阶段，真正宣告一个对象死亡至少要经历两个阶段：\n\n1）如果对象在可达性分析算法中不可达，那么它会被第一次标记并进行一次筛选，筛选的条件是是否需要执行finalize()方法（当对象没有覆盖finalize()或者finalize()方法已经执行过了（对象的此方法只会执行一次）），虚拟机将这两种情况都会视为没有必要执行）。\n\n2）如果这个对象有必要执行finalize()方法会将其放入F-Queue队列中，稍后GC将对F-Queue队列进行第二次标记，如果在重写finalize()方法中将对象自己赋值给某个类变量或者对象的成员变量，那么第二次标记时候就会将它移出“即将回收”的集合。\n\nfinalize()能做的工作，使用 try-finally 或者其他方式都能做到更好，更及时，所以不建议使用此方法。\n\n### 四、方法区回收\n\n永久代中回收的内容主要是两部分：废弃的常量和无用的类。判断无用的类（类卸载）必须满足三个条件：\n\n1）该类所有的实例都已经被回收\n\n2）加载该类的ClassLoader被回收\n\n3）该类对应的java.lang.Class对象没有在任何地方引用，无法在任何地方通过反射访问该类的方法","source":"_posts/JVM怎么判断对象已经死了.md","raw":"---\nlayout:    post\ntitle:     JVM怎么判断对象已经死了\ncategory:  JVM\ndescription: 在JVM中是如何判断对象已经死亡的呢\ntags: JVM\ndate: 2021/05/29 13:26:10\n---\n\n> 本文转载自 https://mp.weixin.qq.com/s/bPexDXkSJ0T4vQnmWMsoZQ \n\nGC的历史比Java还要久远，我们在思考GC时候需要思考三个问题：\n\n**哪些内存需要回收？**\n\n**什么时候回收？**\n\n**如何回收？**\n\n在Java中程序计数器、虚拟机栈、本地方法栈这三个区域随线程而生，随线程而灭：栈中的栈帧随着方法的调用和退出而有条不紊的进行着入栈和出栈的过程。\n\n每个栈帧分配多少内存在类结构确定下来时就已知的，方法结束或者线程结束内存自然跟着回收了。\n\n而Java堆和方法区不一样，一个接口中的多个实现类的内存可能不一样，每个方法的多个分支需要的内存也可能不一样，我们只有在程序运行时候才知道会创建哪些对象，这部分内存的分配和回收都是动态的。\n\n### 一、判断对象已死的算法\n\n1）引用计数算法\n\n给对象添加一个引用计数器，每当一个地方引用它时候，计数器就加1，当引用失效，计数器就减1；任何时刻计数器为0的对象就是不可能再被使用了。\n\n这种方法实现简单，效率高，但是它很难解决对象的循环引用问题：\n\n```java\npublic class Test {\n\n    private static final int _1MB = 1024 *1024;\n\n    private Object instance = null;\n\n    public static void testGC(){\n        Test objectA = new Test();\n        Test objectB = new Test();\n\n        objectA.instance = objectB;\n        objectB.instance = objectA;\n\n        objectA = null;\n        objectB = null;\n\n        // 假如这里发生GC，objectA和objectB会不会被回收\n\n    }\n}\n```\n\n2）可达性分析算法\n\n这个算法的基本思路是通过一系列称为`GC Roots`（一组必须活跃的引用）作为起始点，从这些节点开始向下搜索，搜索走过的路径称为引用链，当一个对象到`GC Roots`没有任何引用链时候，那么证明此对象是不可用的。\n\n在Java语言中，能作为`GC Roots`的对象包括以下几种\n\n1）虚拟机栈（栈帧中的本地变量表）中引用的对象\n\n2）方法区中类静态属性引用的对象\n\n3）方法区中常量引用的对象\n\n4）本地方法栈JNI（即一般说的Native方法）引用的对象\n\n### 二、引用\n\n无论是通过引用计数器算法判断对象的引用数量，还是通过可达性分析算法判断对象引用链是否可达，判断对象是否可活都离不开引用，Java中将引用分为四种：\n\n**1）强引用（Strong Reference）**\n\n是指程序代码中普遍存在的，类似“Object obj = new Object()”这类的引用，只有强引用还存在对象就不会被回收。\n\n**2）软引用（Soft Reference）**\n\n软引用是用来描述一些还有用但是非必须的对象。对于软引用关联的对象，在系统将于发生内存溢出异常之前，将会把这些对象列进回收范围中进行二次回收。\n\n**3）弱引用（Weak Reference）**\n\n也是用来描述非必须对象的，强度比软引用还弱一些，被软引用关联的对象只能存活到下一次内存回收之前。\n\n**4）虚引用（Phantom Referenece）**\n\n也成为幽灵引用和幻影引用，为一个对象设置虚引用关联的唯一目的就是能在这个对象被回收时收到一个系统通知。\n\n### 三、生存还是死亡\n\n即使在可达性分析算法中不可达的对象，也并非一定是“非死不可”的，这时候他们暂时处于“缓刑”阶段，真正宣告一个对象死亡至少要经历两个阶段：\n\n1）如果对象在可达性分析算法中不可达，那么它会被第一次标记并进行一次筛选，筛选的条件是是否需要执行finalize()方法（当对象没有覆盖finalize()或者finalize()方法已经执行过了（对象的此方法只会执行一次）），虚拟机将这两种情况都会视为没有必要执行）。\n\n2）如果这个对象有必要执行finalize()方法会将其放入F-Queue队列中，稍后GC将对F-Queue队列进行第二次标记，如果在重写finalize()方法中将对象自己赋值给某个类变量或者对象的成员变量，那么第二次标记时候就会将它移出“即将回收”的集合。\n\nfinalize()能做的工作，使用 try-finally 或者其他方式都能做到更好，更及时，所以不建议使用此方法。\n\n### 四、方法区回收\n\n永久代中回收的内容主要是两部分：废弃的常量和无用的类。判断无用的类（类卸载）必须满足三个条件：\n\n1）该类所有的实例都已经被回收\n\n2）加载该类的ClassLoader被回收\n\n3）该类对应的java.lang.Class对象没有在任何地方引用，无法在任何地方通过反射访问该类的方法","slug":"JVM怎么判断对象已经死了","published":1,"updated":"2021-05-29T05:26:10.000Z","comments":1,"photos":[],"link":"","_id":"cm1m304x2000531b4crlshtzu","content":"<blockquote>\n<p>本文转载自 <a href=\"https://mp.weixin.qq.com/s/bPexDXkSJ0T4vQnmWMsoZQ\">https://mp.weixin.qq.com/s/bPexDXkSJ0T4vQnmWMsoZQ</a> </p>\n</blockquote>\n<p>GC的历史比Java还要久远，我们在思考GC时候需要思考三个问题：</p>\n<p><strong>哪些内存需要回收？</strong></p>\n<p><strong>什么时候回收？</strong></p>\n<p><strong>如何回收？</strong></p>\n<p>在Java中程序计数器、虚拟机栈、本地方法栈这三个区域随线程而生，随线程而灭：栈中的栈帧随着方法的调用和退出而有条不紊的进行着入栈和出栈的过程。</p>\n<p>每个栈帧分配多少内存在类结构确定下来时就已知的，方法结束或者线程结束内存自然跟着回收了。</p>\n<p>而Java堆和方法区不一样，一个接口中的多个实现类的内存可能不一样，每个方法的多个分支需要的内存也可能不一样，我们只有在程序运行时候才知道会创建哪些对象，这部分内存的分配和回收都是动态的。</p>\n<h3 id=\"一、判断对象已死的算法\"><a href=\"#一、判断对象已死的算法\" class=\"headerlink\" title=\"一、判断对象已死的算法\"></a>一、判断对象已死的算法</h3><p>1）引用计数算法</p>\n<p>给对象添加一个引用计数器，每当一个地方引用它时候，计数器就加1，当引用失效，计数器就减1；任何时刻计数器为0的对象就是不可能再被使用了。</p>\n<p>这种方法实现简单，效率高，但是它很难解决对象的循环引用问题：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> _1MB = <span class=\"number\">1024</span> *<span class=\"number\">1024</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object instance = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">testGC</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        Test objectA = <span class=\"keyword\">new</span> Test();</span><br><span class=\"line\">        Test objectB = <span class=\"keyword\">new</span> Test();</span><br><span class=\"line\"></span><br><span class=\"line\">        objectA.instance = objectB;</span><br><span class=\"line\">        objectB.instance = objectA;</span><br><span class=\"line\"></span><br><span class=\"line\">        objectA = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        objectB = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 假如这里发生GC，objectA和objectB会不会被回收</span></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>2）可达性分析算法</p>\n<p>这个算法的基本思路是通过一系列称为<code>GC Roots</code>（一组必须活跃的引用）作为起始点，从这些节点开始向下搜索，搜索走过的路径称为引用链，当一个对象到<code>GC Roots</code>没有任何引用链时候，那么证明此对象是不可用的。</p>\n<p>在Java语言中，能作为<code>GC Roots</code>的对象包括以下几种</p>\n<p>1）虚拟机栈（栈帧中的本地变量表）中引用的对象</p>\n<p>2）方法区中类静态属性引用的对象</p>\n<p>3）方法区中常量引用的对象</p>\n<p>4）本地方法栈JNI（即一般说的Native方法）引用的对象</p>\n<h3 id=\"二、引用\"><a href=\"#二、引用\" class=\"headerlink\" title=\"二、引用\"></a>二、引用</h3><p>无论是通过引用计数器算法判断对象的引用数量，还是通过可达性分析算法判断对象引用链是否可达，判断对象是否可活都离不开引用，Java中将引用分为四种：</p>\n<p><strong>1）强引用（Strong Reference）</strong></p>\n<p>是指程序代码中普遍存在的，类似“Object obj = new Object()”这类的引用，只有强引用还存在对象就不会被回收。</p>\n<p><strong>2）软引用（Soft Reference）</strong></p>\n<p>软引用是用来描述一些还有用但是非必须的对象。对于软引用关联的对象，在系统将于发生内存溢出异常之前，将会把这些对象列进回收范围中进行二次回收。</p>\n<p><strong>3）弱引用（Weak Reference）</strong></p>\n<p>也是用来描述非必须对象的，强度比软引用还弱一些，被软引用关联的对象只能存活到下一次内存回收之前。</p>\n<p><strong>4）虚引用（Phantom Referenece）</strong></p>\n<p>也成为幽灵引用和幻影引用，为一个对象设置虚引用关联的唯一目的就是能在这个对象被回收时收到一个系统通知。</p>\n<h3 id=\"三、生存还是死亡\"><a href=\"#三、生存还是死亡\" class=\"headerlink\" title=\"三、生存还是死亡\"></a>三、生存还是死亡</h3><p>即使在可达性分析算法中不可达的对象，也并非一定是“非死不可”的，这时候他们暂时处于“缓刑”阶段，真正宣告一个对象死亡至少要经历两个阶段：</p>\n<p>1）如果对象在可达性分析算法中不可达，那么它会被第一次标记并进行一次筛选，筛选的条件是是否需要执行finalize()方法（当对象没有覆盖finalize()或者finalize()方法已经执行过了（对象的此方法只会执行一次）），虚拟机将这两种情况都会视为没有必要执行）。</p>\n<p>2）如果这个对象有必要执行finalize()方法会将其放入F-Queue队列中，稍后GC将对F-Queue队列进行第二次标记，如果在重写finalize()方法中将对象自己赋值给某个类变量或者对象的成员变量，那么第二次标记时候就会将它移出“即将回收”的集合。</p>\n<p>finalize()能做的工作，使用 try-finally 或者其他方式都能做到更好，更及时，所以不建议使用此方法。</p>\n<h3 id=\"四、方法区回收\"><a href=\"#四、方法区回收\" class=\"headerlink\" title=\"四、方法区回收\"></a>四、方法区回收</h3><p>永久代中回收的内容主要是两部分：废弃的常量和无用的类。判断无用的类（类卸载）必须满足三个条件：</p>\n<p>1）该类所有的实例都已经被回收</p>\n<p>2）加载该类的ClassLoader被回收</p>\n<p>3）该类对应的java.lang.Class对象没有在任何地方引用，无法在任何地方通过反射访问该类的方法</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>本文转载自 <a href=\"https://mp.weixin.qq.com/s/bPexDXkSJ0T4vQnmWMsoZQ\">https://mp.weixin.qq.com/s/bPexDXkSJ0T4vQnmWMsoZQ</a> </p>\n</blockquote>\n<p>GC的历史比Java还要久远，我们在思考GC时候需要思考三个问题：</p>\n<p><strong>哪些内存需要回收？</strong></p>\n<p><strong>什么时候回收？</strong></p>\n<p><strong>如何回收？</strong></p>\n<p>在Java中程序计数器、虚拟机栈、本地方法栈这三个区域随线程而生，随线程而灭：栈中的栈帧随着方法的调用和退出而有条不紊的进行着入栈和出栈的过程。</p>\n<p>每个栈帧分配多少内存在类结构确定下来时就已知的，方法结束或者线程结束内存自然跟着回收了。</p>\n<p>而Java堆和方法区不一样，一个接口中的多个实现类的内存可能不一样，每个方法的多个分支需要的内存也可能不一样，我们只有在程序运行时候才知道会创建哪些对象，这部分内存的分配和回收都是动态的。</p>\n<h3 id=\"一、判断对象已死的算法\"><a href=\"#一、判断对象已死的算法\" class=\"headerlink\" title=\"一、判断对象已死的算法\"></a>一、判断对象已死的算法</h3><p>1）引用计数算法</p>\n<p>给对象添加一个引用计数器，每当一个地方引用它时候，计数器就加1，当引用失效，计数器就减1；任何时刻计数器为0的对象就是不可能再被使用了。</p>\n<p>这种方法实现简单，效率高，但是它很难解决对象的循环引用问题：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> _1MB = <span class=\"number\">1024</span> *<span class=\"number\">1024</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object instance = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">testGC</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        Test objectA = <span class=\"keyword\">new</span> Test();</span><br><span class=\"line\">        Test objectB = <span class=\"keyword\">new</span> Test();</span><br><span class=\"line\"></span><br><span class=\"line\">        objectA.instance = objectB;</span><br><span class=\"line\">        objectB.instance = objectA;</span><br><span class=\"line\"></span><br><span class=\"line\">        objectA = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        objectB = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 假如这里发生GC，objectA和objectB会不会被回收</span></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>2）可达性分析算法</p>\n<p>这个算法的基本思路是通过一系列称为<code>GC Roots</code>（一组必须活跃的引用）作为起始点，从这些节点开始向下搜索，搜索走过的路径称为引用链，当一个对象到<code>GC Roots</code>没有任何引用链时候，那么证明此对象是不可用的。</p>\n<p>在Java语言中，能作为<code>GC Roots</code>的对象包括以下几种</p>\n<p>1）虚拟机栈（栈帧中的本地变量表）中引用的对象</p>\n<p>2）方法区中类静态属性引用的对象</p>\n<p>3）方法区中常量引用的对象</p>\n<p>4）本地方法栈JNI（即一般说的Native方法）引用的对象</p>\n<h3 id=\"二、引用\"><a href=\"#二、引用\" class=\"headerlink\" title=\"二、引用\"></a>二、引用</h3><p>无论是通过引用计数器算法判断对象的引用数量，还是通过可达性分析算法判断对象引用链是否可达，判断对象是否可活都离不开引用，Java中将引用分为四种：</p>\n<p><strong>1）强引用（Strong Reference）</strong></p>\n<p>是指程序代码中普遍存在的，类似“Object obj = new Object()”这类的引用，只有强引用还存在对象就不会被回收。</p>\n<p><strong>2）软引用（Soft Reference）</strong></p>\n<p>软引用是用来描述一些还有用但是非必须的对象。对于软引用关联的对象，在系统将于发生内存溢出异常之前，将会把这些对象列进回收范围中进行二次回收。</p>\n<p><strong>3）弱引用（Weak Reference）</strong></p>\n<p>也是用来描述非必须对象的，强度比软引用还弱一些，被软引用关联的对象只能存活到下一次内存回收之前。</p>\n<p><strong>4）虚引用（Phantom Referenece）</strong></p>\n<p>也成为幽灵引用和幻影引用，为一个对象设置虚引用关联的唯一目的就是能在这个对象被回收时收到一个系统通知。</p>\n<h3 id=\"三、生存还是死亡\"><a href=\"#三、生存还是死亡\" class=\"headerlink\" title=\"三、生存还是死亡\"></a>三、生存还是死亡</h3><p>即使在可达性分析算法中不可达的对象，也并非一定是“非死不可”的，这时候他们暂时处于“缓刑”阶段，真正宣告一个对象死亡至少要经历两个阶段：</p>\n<p>1）如果对象在可达性分析算法中不可达，那么它会被第一次标记并进行一次筛选，筛选的条件是是否需要执行finalize()方法（当对象没有覆盖finalize()或者finalize()方法已经执行过了（对象的此方法只会执行一次）），虚拟机将这两种情况都会视为没有必要执行）。</p>\n<p>2）如果这个对象有必要执行finalize()方法会将其放入F-Queue队列中，稍后GC将对F-Queue队列进行第二次标记，如果在重写finalize()方法中将对象自己赋值给某个类变量或者对象的成员变量，那么第二次标记时候就会将它移出“即将回收”的集合。</p>\n<p>finalize()能做的工作，使用 try-finally 或者其他方式都能做到更好，更及时，所以不建议使用此方法。</p>\n<h3 id=\"四、方法区回收\"><a href=\"#四、方法区回收\" class=\"headerlink\" title=\"四、方法区回收\"></a>四、方法区回收</h3><p>永久代中回收的内容主要是两部分：废弃的常量和无用的类。判断无用的类（类卸载）必须满足三个条件：</p>\n<p>1）该类所有的实例都已经被回收</p>\n<p>2）加载该类的ClassLoader被回收</p>\n<p>3）该类对应的java.lang.Class对象没有在任何地方引用，无法在任何地方通过反射访问该类的方法</p>\n"},{"layout":"post","title":"日志阻塞导致重启问题排查","description":"日志阻塞导致重启问题排查","date":"2022-04-16T12:27:10.000Z","_content":"### 背景\n2022年2月3日发生告警，一台应用容器重启\n\n### 原因排查\n![](https://vqianxiao.github.io/blog/images/bug/logBlockDown.png)\n\n通过排查jstatck文件，发现有大量线程在执行 at ch.qos.logback.core.OutputStreamAppender.writeBytes(OutputStreamAppender.java:197)\n\n因为中台封装过日志打印，会将日志打印全部修改为异步打印。正常逻辑来说应该不会有同步打印日志的情况。\n基本逻辑就是在容器启动的时候，拿到所有appender，如果是FileAppender类型的，就会将这个类型的Appender封装成AsyncAppender类型的实例。\ndebug的时候发现每条日志打印都会调用每个Appender的doAppend方法，有两个Appender，一个是ConsoleAppender，一个是AsyncAppender\n\n具体代码如下 ch.qos.logback.core.spi.AppenderAttachableImpl#appendLoopOnAppenders\n\n```java\n    public int appendLoopOnAppenders(E e) {\n        int size = 0;\n        final Appender<E>[] appenderArray = appenderList.asTypedArray();\n        final int len = appenderArray.length;\n        for (int i = 0; i < len; i++) {\n            appenderArray[i].doAppend(e);\n            size++;\n        }\n    return size;\n    }\n```\n\n既然文件输出的Appender已经被封装成异步的Appender了，那问题就应该在ConsoleAppender上了。在服务器中应该是禁用控制台输出的。\n看了下中台代码，发现他们会根据当前是否是jar包运行的来区分是不是需要禁用ConsoleAppender。\n但是我们部署的时候使用了jib的部署方式，所以之前的jar包运行判断就失效了，导致控制台输出没有被禁用掉。\n\n```java\n        for (ConsoleAppender consoleAppender : consoleAppenders) {\n            consoleAppender.addFilter(new ThreadNameFilter());//设置线程名字\n            if (SpringBootUtils.isJarInJarMode()) {\n                consoleAppender.addFilter(new DenyFilter());//禁用输出\n            }\n        }\n```\n后来和中台沟通，发现中台已经修复了这个问题。通过使用环境变量，判断是不是运行在docker容器中，来解决Console日志输出导致阻塞的问题。\n\n### jib\nJib 在不使用 Dockerfile 或不安装 Docker 的情况下构建容器。可以在用于 Maven 或 Gradle 的 Jib 插件中使用 Jib，也可以使用 Jib Java 库。\n\nJib 处理将应用打包到容器映像中的所有步骤。无需了解创建 Dockerfile 的最佳做法或安装 Docker。\n\nDocker 构建流程：\n![](https://vqianxiao.github.io/blog/images/bug/dockerBuild.png)\n\nJib 构建流程：\n![](https://vqianxiao.github.io/blog/images/bug/jibBuild.png)\n\n\nJib 将应用整理成不同的层、依赖项、资源和类；并且利用 Docker 映像层缓存仅通过重建更改来保持构建速度。Jib 的层组织和小型基础映像可使整体映像尺寸变小，从而提升性能和可携性。\n\n\n\n\n\n\n","source":"_posts/日志阻塞导致重启问题排查.md","raw":"---\nlayout:    post\ntitle:     日志阻塞导致重启问题排查\ncategory:  问题排查\ndescription: 日志阻塞导致重启问题排查\ntags: 问题排查\ndate: 2022/04/16 20:27:10\n\n---\n### 背景\n2022年2月3日发生告警，一台应用容器重启\n\n### 原因排查\n![](https://vqianxiao.github.io/blog/images/bug/logBlockDown.png)\n\n通过排查jstatck文件，发现有大量线程在执行 at ch.qos.logback.core.OutputStreamAppender.writeBytes(OutputStreamAppender.java:197)\n\n因为中台封装过日志打印，会将日志打印全部修改为异步打印。正常逻辑来说应该不会有同步打印日志的情况。\n基本逻辑就是在容器启动的时候，拿到所有appender，如果是FileAppender类型的，就会将这个类型的Appender封装成AsyncAppender类型的实例。\ndebug的时候发现每条日志打印都会调用每个Appender的doAppend方法，有两个Appender，一个是ConsoleAppender，一个是AsyncAppender\n\n具体代码如下 ch.qos.logback.core.spi.AppenderAttachableImpl#appendLoopOnAppenders\n\n```java\n    public int appendLoopOnAppenders(E e) {\n        int size = 0;\n        final Appender<E>[] appenderArray = appenderList.asTypedArray();\n        final int len = appenderArray.length;\n        for (int i = 0; i < len; i++) {\n            appenderArray[i].doAppend(e);\n            size++;\n        }\n    return size;\n    }\n```\n\n既然文件输出的Appender已经被封装成异步的Appender了，那问题就应该在ConsoleAppender上了。在服务器中应该是禁用控制台输出的。\n看了下中台代码，发现他们会根据当前是否是jar包运行的来区分是不是需要禁用ConsoleAppender。\n但是我们部署的时候使用了jib的部署方式，所以之前的jar包运行判断就失效了，导致控制台输出没有被禁用掉。\n\n```java\n        for (ConsoleAppender consoleAppender : consoleAppenders) {\n            consoleAppender.addFilter(new ThreadNameFilter());//设置线程名字\n            if (SpringBootUtils.isJarInJarMode()) {\n                consoleAppender.addFilter(new DenyFilter());//禁用输出\n            }\n        }\n```\n后来和中台沟通，发现中台已经修复了这个问题。通过使用环境变量，判断是不是运行在docker容器中，来解决Console日志输出导致阻塞的问题。\n\n### jib\nJib 在不使用 Dockerfile 或不安装 Docker 的情况下构建容器。可以在用于 Maven 或 Gradle 的 Jib 插件中使用 Jib，也可以使用 Jib Java 库。\n\nJib 处理将应用打包到容器映像中的所有步骤。无需了解创建 Dockerfile 的最佳做法或安装 Docker。\n\nDocker 构建流程：\n![](https://vqianxiao.github.io/blog/images/bug/dockerBuild.png)\n\nJib 构建流程：\n![](https://vqianxiao.github.io/blog/images/bug/jibBuild.png)\n\n\nJib 将应用整理成不同的层、依赖项、资源和类；并且利用 Docker 映像层缓存仅通过重建更改来保持构建速度。Jib 的层组织和小型基础映像可使整体映像尺寸变小，从而提升性能和可携性。\n\n\n\n\n\n\n","slug":"日志阻塞导致重启问题排查","published":1,"updated":"2022-04-16T12:27:10.000Z","comments":1,"photos":[],"link":"","_id":"cm1m304x3000631b47d4ga9t5","content":"<h3 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h3><p>2022年2月3日发生告警，一台应用容器重启</p>\n<h3 id=\"原因排查\"><a href=\"#原因排查\" class=\"headerlink\" title=\"原因排查\"></a>原因排查</h3><p><img src=\"https://vqianxiao.github.io/blog/images/bug/logBlockDown.png\"></p>\n<p>通过排查jstatck文件，发现有大量线程在执行 at ch.qos.logback.core.OutputStreamAppender.writeBytes(OutputStreamAppender.java:197)</p>\n<p>因为中台封装过日志打印，会将日志打印全部修改为异步打印。正常逻辑来说应该不会有同步打印日志的情况。<br>基本逻辑就是在容器启动的时候，拿到所有appender，如果是FileAppender类型的，就会将这个类型的Appender封装成AsyncAppender类型的实例。<br>debug的时候发现每条日志打印都会调用每个Appender的doAppend方法，有两个Appender，一个是ConsoleAppender，一个是AsyncAppender</p>\n<p>具体代码如下 ch.qos.logback.core.spi.AppenderAttachableImpl#appendLoopOnAppenders</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">appendLoopOnAppenders</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> size = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Appender&lt;E&gt;[] appenderArray = appenderList.asTypedArray();</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> len = appenderArray.length;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">        appenderArray[i].doAppend(e);</span><br><span class=\"line\">        size++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> size;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>既然文件输出的Appender已经被封装成异步的Appender了，那问题就应该在ConsoleAppender上了。在服务器中应该是禁用控制台输出的。<br>看了下中台代码，发现他们会根据当前是否是jar包运行的来区分是不是需要禁用ConsoleAppender。<br>但是我们部署的时候使用了jib的部署方式，所以之前的jar包运行判断就失效了，导致控制台输出没有被禁用掉。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (ConsoleAppender consoleAppender : consoleAppenders) &#123;</span><br><span class=\"line\">    consoleAppender.addFilter(<span class=\"keyword\">new</span> ThreadNameFilter());<span class=\"comment\">//设置线程名字</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (SpringBootUtils.isJarInJarMode()) &#123;</span><br><span class=\"line\">        consoleAppender.addFilter(<span class=\"keyword\">new</span> DenyFilter());<span class=\"comment\">//禁用输出</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>后来和中台沟通，发现中台已经修复了这个问题。通过使用环境变量，判断是不是运行在docker容器中，来解决Console日志输出导致阻塞的问题。</p>\n<h3 id=\"jib\"><a href=\"#jib\" class=\"headerlink\" title=\"jib\"></a>jib</h3><p>Jib 在不使用 Dockerfile 或不安装 Docker 的情况下构建容器。可以在用于 Maven 或 Gradle 的 Jib 插件中使用 Jib，也可以使用 Jib Java 库。</p>\n<p>Jib 处理将应用打包到容器映像中的所有步骤。无需了解创建 Dockerfile 的最佳做法或安装 Docker。</p>\n<p>Docker 构建流程：<br><img src=\"https://vqianxiao.github.io/blog/images/bug/dockerBuild.png\"></p>\n<p>Jib 构建流程：<br><img src=\"https://vqianxiao.github.io/blog/images/bug/jibBuild.png\"></p>\n<p>Jib 将应用整理成不同的层、依赖项、资源和类；并且利用 Docker 映像层缓存仅通过重建更改来保持构建速度。Jib 的层组织和小型基础映像可使整体映像尺寸变小，从而提升性能和可携性。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h3><p>2022年2月3日发生告警，一台应用容器重启</p>\n<h3 id=\"原因排查\"><a href=\"#原因排查\" class=\"headerlink\" title=\"原因排查\"></a>原因排查</h3><p><img src=\"https://vqianxiao.github.io/blog/images/bug/logBlockDown.png\"></p>\n<p>通过排查jstatck文件，发现有大量线程在执行 at ch.qos.logback.core.OutputStreamAppender.writeBytes(OutputStreamAppender.java:197)</p>\n<p>因为中台封装过日志打印，会将日志打印全部修改为异步打印。正常逻辑来说应该不会有同步打印日志的情况。<br>基本逻辑就是在容器启动的时候，拿到所有appender，如果是FileAppender类型的，就会将这个类型的Appender封装成AsyncAppender类型的实例。<br>debug的时候发现每条日志打印都会调用每个Appender的doAppend方法，有两个Appender，一个是ConsoleAppender，一个是AsyncAppender</p>\n<p>具体代码如下 ch.qos.logback.core.spi.AppenderAttachableImpl#appendLoopOnAppenders</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">appendLoopOnAppenders</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> size = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Appender&lt;E&gt;[] appenderArray = appenderList.asTypedArray();</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> len = appenderArray.length;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">        appenderArray[i].doAppend(e);</span><br><span class=\"line\">        size++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> size;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>既然文件输出的Appender已经被封装成异步的Appender了，那问题就应该在ConsoleAppender上了。在服务器中应该是禁用控制台输出的。<br>看了下中台代码，发现他们会根据当前是否是jar包运行的来区分是不是需要禁用ConsoleAppender。<br>但是我们部署的时候使用了jib的部署方式，所以之前的jar包运行判断就失效了，导致控制台输出没有被禁用掉。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (ConsoleAppender consoleAppender : consoleAppenders) &#123;</span><br><span class=\"line\">    consoleAppender.addFilter(<span class=\"keyword\">new</span> ThreadNameFilter());<span class=\"comment\">//设置线程名字</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (SpringBootUtils.isJarInJarMode()) &#123;</span><br><span class=\"line\">        consoleAppender.addFilter(<span class=\"keyword\">new</span> DenyFilter());<span class=\"comment\">//禁用输出</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>后来和中台沟通，发现中台已经修复了这个问题。通过使用环境变量，判断是不是运行在docker容器中，来解决Console日志输出导致阻塞的问题。</p>\n<h3 id=\"jib\"><a href=\"#jib\" class=\"headerlink\" title=\"jib\"></a>jib</h3><p>Jib 在不使用 Dockerfile 或不安装 Docker 的情况下构建容器。可以在用于 Maven 或 Gradle 的 Jib 插件中使用 Jib，也可以使用 Jib Java 库。</p>\n<p>Jib 处理将应用打包到容器映像中的所有步骤。无需了解创建 Dockerfile 的最佳做法或安装 Docker。</p>\n<p>Docker 构建流程：<br><img src=\"https://vqianxiao.github.io/blog/images/bug/dockerBuild.png\"></p>\n<p>Jib 构建流程：<br><img src=\"https://vqianxiao.github.io/blog/images/bug/jibBuild.png\"></p>\n<p>Jib 将应用整理成不同的层、依赖项、资源和类；并且利用 Docker 映像层缓存仅通过重建更改来保持构建速度。Jib 的层组织和小型基础映像可使整体映像尺寸变小，从而提升性能和可携性。</p>\n"},{"layout":"post","title":"死磕ArrayList源码","description":"死磕ArrayList源码","date":"2021-08-11T09:11:10.000Z","_content":"\nArrayList是List接口的可变数组的实现。实现了所有可选列表的操作。继承自AbstractList，实现了List接口、RandomAccess接口、Cloneable接口、Serializable接口。\n实现的这些接口中，RandomAccess接口和Cloneable接口还有Serializable接口都是表示ArrayList拥有随机访问、克隆、序列化的能力。\n\nAbstractList抽象类主要是提供支持随机访问实现的模版。\n\nIterable是一个遍历接口，提供了获取迭代器的方法，集合可以根据自己的需要实现自己的迭代器\n\n每一个ArrayList都有一个容量，该容量就是存储元素的数组大小。它总是大于等于列表的大小的，随着向ArrayList中不断添加元素，其容量也会自动增长，自动增长会带来数组的拷贝。因此如果提前知道数据量大小，在构造函数提前把容量设置好，可以减少因为扩容带来的数据拷贝的不必要的性能损耗。\n\nArrayList的属性\n\n```java\n//默认容量大小\nprivate static final int DEFAULT_CAPACITY = 10;\n\n//空集合的空实例\nprivate static final Object[] EMPTY_ELEMENTDATA = {};\n\n//默认大小的空实例 和EMPTY_ELEMENTDATA 不同是为了知道添加第一个元素的时候需要膨胀多少\nprivate static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};\n\n//就是集合中的数组元素\ntransient Object[] elementData; // non-private to simplify nested class access\n\n//集合中元素的个数\nprivate int size;\n```\n\n相关注释写在代码上了。然后来看add()方法。\n\n```java\npublic boolean add(E e) {\n  ensureCapacityInternal(size + 1);  // Increments modCount!!\n  elementData[size++] = e;\n  return true;\n}\n```\n\n这里面后面2行基本上不用讲了，主要是ensureCapacityInternal()这个方法干了点啥呢？\n\n```java\nprivate void ensureCapacityInternal(int minCapacity) {\n  ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));\n}\n\n//计算容量\nprivate static int calculateCapacity(Object[] elementData, int minCapacity) {\n  //这里如果是无参构造器创建的数组 那么在第一次插入数据的时候 就可以把数据扩容到默认大小\n  if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\n    return Math.max(DEFAULT_CAPACITY, minCapacity);\n  }\n  //否则就是数组的长度+1\n  return minCapacity;\n}\n\n//检查容量是否足够 不够的话进行扩容\nprivate void ensureExplicitCapacity(int minCapacity) {\n  //这个modCount要注意下\n  modCount++;\n\t\t\t\t\n  //当前数据量大于数组的容量了 进行扩容\n  // overflow-conscious code\n  if (minCapacity - elementData.length > 0)\n    grow(minCapacity);\n}\n\n//扩容\nprivate void grow(int minCapacity) {\n  // overflow-conscious code\n  int oldCapacity = elementData.length;\n  //新容量 = 旧容量 + （旧的容量/2）新的容量就是旧的容量的1.5倍\n  int newCapacity = oldCapacity + (oldCapacity >> 1);\n  //新容量小于需要的容量 需要的容量覆盖新容量\n  if (newCapacity - minCapacity < 0)\n    newCapacity = minCapacity;\n  //新的容量比最大容量大 使用最大容量\n  if (newCapacity - MAX_ARRAY_SIZE > 0)\n    newCapacity = hugeCapacity(minCapacity);\n  //进行数组拷贝 把旧的数据拷贝到新的数组上\n  // minCapacity is usually close to size, so this is a win:\n  elementData = Arrays.copyOf(elementData, newCapacity);\n}\n```\n\n这里有个modCount这里要讲下，modCount就是修改次数，在AbstractList中有这么一段判断\n\n```java\nfinal void checkForComodification() {\n  if (modCount != expectedModCount)\n    throw new ConcurrentModificationException();\n }\n```\n\n就是判断modCount和expectedModCount是否相等的，如果不相等，那么抛出`ConcurrentModificationException` 异常。主要是为了防止并发操作，遍历的时候进行数据增删，可能会导致某个元素被重复遍历或遍历不到，是一种fast-fail的解决方式。\n\n看下ArrayList的Remove()方法\n\n```java\npublic E remove(int index) {\n  //index合法性检查 不能大于size\n  rangeCheck(index);\n\n  modCount++;\n  E oldValue = elementData(index);\n\n  int numMoved = size - index - 1;\n  if (numMoved > 0)\n    //数组拷贝 将该元素后面的部分和前面的部分拼接起来 最后面多了一个空的元素\n    System.arraycopy(elementData, index+1, elementData, index,\n                     numMoved);\n  elementData[--size] = null; // clear to let GC do its work\n\n  return oldValue;\n}\n\n\n```\n\n看了以上实现，所以应该明白为什么ArrayList随机访问速度比较快了吧，那个Index就像字典的目录一样，可以很快的根据index找到数据。但是插入和删除操作性能比较低，因为会涉及到数组拷贝。所以结合场景选择合适的框架才是最重要的。\n\n","source":"_posts/死磕ArrayList源码.md","raw":"---\nlayout:    post\ntitle:     死磕ArrayList源码\ncategory:  源码解析\ndescription: 死磕ArrayList源码\ntags: JDK\ndate: 2021/08/11 17:11:10\n\n---\n\nArrayList是List接口的可变数组的实现。实现了所有可选列表的操作。继承自AbstractList，实现了List接口、RandomAccess接口、Cloneable接口、Serializable接口。\n实现的这些接口中，RandomAccess接口和Cloneable接口还有Serializable接口都是表示ArrayList拥有随机访问、克隆、序列化的能力。\n\nAbstractList抽象类主要是提供支持随机访问实现的模版。\n\nIterable是一个遍历接口，提供了获取迭代器的方法，集合可以根据自己的需要实现自己的迭代器\n\n每一个ArrayList都有一个容量，该容量就是存储元素的数组大小。它总是大于等于列表的大小的，随着向ArrayList中不断添加元素，其容量也会自动增长，自动增长会带来数组的拷贝。因此如果提前知道数据量大小，在构造函数提前把容量设置好，可以减少因为扩容带来的数据拷贝的不必要的性能损耗。\n\nArrayList的属性\n\n```java\n//默认容量大小\nprivate static final int DEFAULT_CAPACITY = 10;\n\n//空集合的空实例\nprivate static final Object[] EMPTY_ELEMENTDATA = {};\n\n//默认大小的空实例 和EMPTY_ELEMENTDATA 不同是为了知道添加第一个元素的时候需要膨胀多少\nprivate static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};\n\n//就是集合中的数组元素\ntransient Object[] elementData; // non-private to simplify nested class access\n\n//集合中元素的个数\nprivate int size;\n```\n\n相关注释写在代码上了。然后来看add()方法。\n\n```java\npublic boolean add(E e) {\n  ensureCapacityInternal(size + 1);  // Increments modCount!!\n  elementData[size++] = e;\n  return true;\n}\n```\n\n这里面后面2行基本上不用讲了，主要是ensureCapacityInternal()这个方法干了点啥呢？\n\n```java\nprivate void ensureCapacityInternal(int minCapacity) {\n  ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));\n}\n\n//计算容量\nprivate static int calculateCapacity(Object[] elementData, int minCapacity) {\n  //这里如果是无参构造器创建的数组 那么在第一次插入数据的时候 就可以把数据扩容到默认大小\n  if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\n    return Math.max(DEFAULT_CAPACITY, minCapacity);\n  }\n  //否则就是数组的长度+1\n  return minCapacity;\n}\n\n//检查容量是否足够 不够的话进行扩容\nprivate void ensureExplicitCapacity(int minCapacity) {\n  //这个modCount要注意下\n  modCount++;\n\t\t\t\t\n  //当前数据量大于数组的容量了 进行扩容\n  // overflow-conscious code\n  if (minCapacity - elementData.length > 0)\n    grow(minCapacity);\n}\n\n//扩容\nprivate void grow(int minCapacity) {\n  // overflow-conscious code\n  int oldCapacity = elementData.length;\n  //新容量 = 旧容量 + （旧的容量/2）新的容量就是旧的容量的1.5倍\n  int newCapacity = oldCapacity + (oldCapacity >> 1);\n  //新容量小于需要的容量 需要的容量覆盖新容量\n  if (newCapacity - minCapacity < 0)\n    newCapacity = minCapacity;\n  //新的容量比最大容量大 使用最大容量\n  if (newCapacity - MAX_ARRAY_SIZE > 0)\n    newCapacity = hugeCapacity(minCapacity);\n  //进行数组拷贝 把旧的数据拷贝到新的数组上\n  // minCapacity is usually close to size, so this is a win:\n  elementData = Arrays.copyOf(elementData, newCapacity);\n}\n```\n\n这里有个modCount这里要讲下，modCount就是修改次数，在AbstractList中有这么一段判断\n\n```java\nfinal void checkForComodification() {\n  if (modCount != expectedModCount)\n    throw new ConcurrentModificationException();\n }\n```\n\n就是判断modCount和expectedModCount是否相等的，如果不相等，那么抛出`ConcurrentModificationException` 异常。主要是为了防止并发操作，遍历的时候进行数据增删，可能会导致某个元素被重复遍历或遍历不到，是一种fast-fail的解决方式。\n\n看下ArrayList的Remove()方法\n\n```java\npublic E remove(int index) {\n  //index合法性检查 不能大于size\n  rangeCheck(index);\n\n  modCount++;\n  E oldValue = elementData(index);\n\n  int numMoved = size - index - 1;\n  if (numMoved > 0)\n    //数组拷贝 将该元素后面的部分和前面的部分拼接起来 最后面多了一个空的元素\n    System.arraycopy(elementData, index+1, elementData, index,\n                     numMoved);\n  elementData[--size] = null; // clear to let GC do its work\n\n  return oldValue;\n}\n\n\n```\n\n看了以上实现，所以应该明白为什么ArrayList随机访问速度比较快了吧，那个Index就像字典的目录一样，可以很快的根据index找到数据。但是插入和删除操作性能比较低，因为会涉及到数组拷贝。所以结合场景选择合适的框架才是最重要的。\n\n","slug":"死磕ArrayList源码","published":1,"updated":"2021-08-11T09:11:10.000Z","comments":1,"photos":[],"link":"","_id":"cm1m304x4000731b4gojt2dw2","content":"<p>ArrayList是List接口的可变数组的实现。实现了所有可选列表的操作。继承自AbstractList，实现了List接口、RandomAccess接口、Cloneable接口、Serializable接口。<br>实现的这些接口中，RandomAccess接口和Cloneable接口还有Serializable接口都是表示ArrayList拥有随机访问、克隆、序列化的能力。</p>\n<p>AbstractList抽象类主要是提供支持随机访问实现的模版。</p>\n<p>Iterable是一个遍历接口，提供了获取迭代器的方法，集合可以根据自己的需要实现自己的迭代器</p>\n<p>每一个ArrayList都有一个容量，该容量就是存储元素的数组大小。它总是大于等于列表的大小的，随着向ArrayList中不断添加元素，其容量也会自动增长，自动增长会带来数组的拷贝。因此如果提前知道数据量大小，在构造函数提前把容量设置好，可以减少因为扩容带来的数据拷贝的不必要的性能损耗。</p>\n<p>ArrayList的属性</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//默认容量大小</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_CAPACITY = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//空集合的空实例</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//默认大小的空实例 和EMPTY_ELEMENTDATA 不同是为了知道添加第一个元素的时候需要膨胀多少</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//就是集合中的数组元素</span></span><br><span class=\"line\"><span class=\"keyword\">transient</span> Object[] elementData; <span class=\"comment\">// non-private to simplify nested class access</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//集合中元素的个数</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> size;</span><br></pre></td></tr></table></figure>\n\n<p>相关注释写在代码上了。然后来看add()方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">  ensureCapacityInternal(size + <span class=\"number\">1</span>);  <span class=\"comment\">// Increments modCount!!</span></span><br><span class=\"line\">  elementData[size++] = e;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里面后面2行基本上不用讲了，主要是ensureCapacityInternal()这个方法干了点啥呢？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureCapacityInternal</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">  ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//计算容量</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">calculateCapacity</span><span class=\"params\">(Object[] elementData, <span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//这里如果是无参构造器创建的数组 那么在第一次插入数据的时候 就可以把数据扩容到默认大小</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//否则就是数组的长度+1</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> minCapacity;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//检查容量是否足够 不够的话进行扩容</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureExplicitCapacity</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//这个modCount要注意下</span></span><br><span class=\"line\">  modCount++;</span><br><span class=\"line\">\t\t\t\t</span><br><span class=\"line\">  <span class=\"comment\">//当前数据量大于数组的容量了 进行扩容</span></span><br><span class=\"line\">  <span class=\"comment\">// overflow-conscious code</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (minCapacity - elementData.length &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    grow(minCapacity);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//扩容</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">grow</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// overflow-conscious code</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> oldCapacity = elementData.length;</span><br><span class=\"line\">  <span class=\"comment\">//新容量 = 旧容量 + （旧的容量/2）新的容量就是旧的容量的1.5倍</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">  <span class=\"comment\">//新容量小于需要的容量 需要的容量覆盖新容量</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (newCapacity - minCapacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    newCapacity = minCapacity;</span><br><span class=\"line\">  <span class=\"comment\">//新的容量比最大容量大 使用最大容量</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    newCapacity = hugeCapacity(minCapacity);</span><br><span class=\"line\">  <span class=\"comment\">//进行数组拷贝 把旧的数据拷贝到新的数组上</span></span><br><span class=\"line\">  <span class=\"comment\">// minCapacity is usually close to size, so this is a win:</span></span><br><span class=\"line\">  elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里有个modCount这里要讲下，modCount就是修改次数，在AbstractList中有这么一段判断</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">checkForComodification</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (modCount != expectedModCount)</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ConcurrentModificationException();</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>就是判断modCount和expectedModCount是否相等的，如果不相等，那么抛出<code>ConcurrentModificationException</code> 异常。主要是为了防止并发操作，遍历的时候进行数据增删，可能会导致某个元素被重复遍历或遍历不到，是一种fast-fail的解决方式。</p>\n<p>看下ArrayList的Remove()方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">remove</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//index合法性检查 不能大于size</span></span><br><span class=\"line\">  rangeCheck(index);</span><br><span class=\"line\"></span><br><span class=\"line\">  modCount++;</span><br><span class=\"line\">  E oldValue = elementData(index);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">int</span> numMoved = size - index - <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (numMoved &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"comment\">//数组拷贝 将该元素后面的部分和前面的部分拼接起来 最后面多了一个空的元素</span></span><br><span class=\"line\">    System.arraycopy(elementData, index+<span class=\"number\">1</span>, elementData, index,</span><br><span class=\"line\">                     numMoved);</span><br><span class=\"line\">  elementData[--size] = <span class=\"keyword\">null</span>; <span class=\"comment\">// clear to let GC do its work</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>看了以上实现，所以应该明白为什么ArrayList随机访问速度比较快了吧，那个Index就像字典的目录一样，可以很快的根据index找到数据。但是插入和删除操作性能比较低，因为会涉及到数组拷贝。所以结合场景选择合适的框架才是最重要的。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>ArrayList是List接口的可变数组的实现。实现了所有可选列表的操作。继承自AbstractList，实现了List接口、RandomAccess接口、Cloneable接口、Serializable接口。<br>实现的这些接口中，RandomAccess接口和Cloneable接口还有Serializable接口都是表示ArrayList拥有随机访问、克隆、序列化的能力。</p>\n<p>AbstractList抽象类主要是提供支持随机访问实现的模版。</p>\n<p>Iterable是一个遍历接口，提供了获取迭代器的方法，集合可以根据自己的需要实现自己的迭代器</p>\n<p>每一个ArrayList都有一个容量，该容量就是存储元素的数组大小。它总是大于等于列表的大小的，随着向ArrayList中不断添加元素，其容量也会自动增长，自动增长会带来数组的拷贝。因此如果提前知道数据量大小，在构造函数提前把容量设置好，可以减少因为扩容带来的数据拷贝的不必要的性能损耗。</p>\n<p>ArrayList的属性</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//默认容量大小</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_CAPACITY = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//空集合的空实例</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//默认大小的空实例 和EMPTY_ELEMENTDATA 不同是为了知道添加第一个元素的时候需要膨胀多少</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//就是集合中的数组元素</span></span><br><span class=\"line\"><span class=\"keyword\">transient</span> Object[] elementData; <span class=\"comment\">// non-private to simplify nested class access</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//集合中元素的个数</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> size;</span><br></pre></td></tr></table></figure>\n\n<p>相关注释写在代码上了。然后来看add()方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">  ensureCapacityInternal(size + <span class=\"number\">1</span>);  <span class=\"comment\">// Increments modCount!!</span></span><br><span class=\"line\">  elementData[size++] = e;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里面后面2行基本上不用讲了，主要是ensureCapacityInternal()这个方法干了点啥呢？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureCapacityInternal</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">  ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//计算容量</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">calculateCapacity</span><span class=\"params\">(Object[] elementData, <span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//这里如果是无参构造器创建的数组 那么在第一次插入数据的时候 就可以把数据扩容到默认大小</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//否则就是数组的长度+1</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> minCapacity;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//检查容量是否足够 不够的话进行扩容</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureExplicitCapacity</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//这个modCount要注意下</span></span><br><span class=\"line\">  modCount++;</span><br><span class=\"line\">\t\t\t\t</span><br><span class=\"line\">  <span class=\"comment\">//当前数据量大于数组的容量了 进行扩容</span></span><br><span class=\"line\">  <span class=\"comment\">// overflow-conscious code</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (minCapacity - elementData.length &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    grow(minCapacity);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//扩容</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">grow</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// overflow-conscious code</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> oldCapacity = elementData.length;</span><br><span class=\"line\">  <span class=\"comment\">//新容量 = 旧容量 + （旧的容量/2）新的容量就是旧的容量的1.5倍</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">  <span class=\"comment\">//新容量小于需要的容量 需要的容量覆盖新容量</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (newCapacity - minCapacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    newCapacity = minCapacity;</span><br><span class=\"line\">  <span class=\"comment\">//新的容量比最大容量大 使用最大容量</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    newCapacity = hugeCapacity(minCapacity);</span><br><span class=\"line\">  <span class=\"comment\">//进行数组拷贝 把旧的数据拷贝到新的数组上</span></span><br><span class=\"line\">  <span class=\"comment\">// minCapacity is usually close to size, so this is a win:</span></span><br><span class=\"line\">  elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里有个modCount这里要讲下，modCount就是修改次数，在AbstractList中有这么一段判断</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">checkForComodification</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (modCount != expectedModCount)</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ConcurrentModificationException();</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>就是判断modCount和expectedModCount是否相等的，如果不相等，那么抛出<code>ConcurrentModificationException</code> 异常。主要是为了防止并发操作，遍历的时候进行数据增删，可能会导致某个元素被重复遍历或遍历不到，是一种fast-fail的解决方式。</p>\n<p>看下ArrayList的Remove()方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">remove</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//index合法性检查 不能大于size</span></span><br><span class=\"line\">  rangeCheck(index);</span><br><span class=\"line\"></span><br><span class=\"line\">  modCount++;</span><br><span class=\"line\">  E oldValue = elementData(index);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">int</span> numMoved = size - index - <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (numMoved &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"comment\">//数组拷贝 将该元素后面的部分和前面的部分拼接起来 最后面多了一个空的元素</span></span><br><span class=\"line\">    System.arraycopy(elementData, index+<span class=\"number\">1</span>, elementData, index,</span><br><span class=\"line\">                     numMoved);</span><br><span class=\"line\">  elementData[--size] = <span class=\"keyword\">null</span>; <span class=\"comment\">// clear to let GC do its work</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>看了以上实现，所以应该明白为什么ArrayList随机访问速度比较快了吧，那个Index就像字典的目录一样，可以很快的根据index找到数据。但是插入和删除操作性能比较低，因为会涉及到数组拷贝。所以结合场景选择合适的框架才是最重要的。</p>\n"},{"layout":"post","title":"死磕ConcurrentHashMap源码","description":"死磕ConcurrentHashMap源码","date":"2021-08-16T12:10:10.000Z","_content":"\n由于HashMap不是线程安全的，替代方案有三种：\n\n- 使用Collections.synchronizedMap(Map)创建线程安全的map集合\n- HashTable\n- ConcurrentHashMap\n\n不过出于线程并发度的原因，一般都会选择ConcurrentHashMap。先来看下第一种是怎么实现的。\n\n```java\npublic static <K,V> Map<K,V> synchronizedMap(Map<K,V> m) {\n    return new SynchronizedMap<>(m);\n}\n\nprivate static class SynchronizedMap<K,V>\n    implements Map<K,V>, Serializable {\n    private static final long serialVersionUID = 1978198479659022715L;\n\n    private final Map<K,V> m;     // Backing Map\n    final Object      mutex;        // Object on which to synchronize\n\n    SynchronizedMap(Map<K,V> m) {\n        this.m = Objects.requireNonNull(m);\n        mutex = this;\n    }\n\n    SynchronizedMap(Map<K,V> m, Object mutex) {\n        this.m = m;\n        this.mutex = mutex;\n    }\n}\n\npublic V get(Object key) {\n    synchronized (mutex) {return m.get(key);}\n}\n\npublic V put(K key, V value) {\n    synchronized (mutex) {return m.put(key, value);}\n}\n\npublic V remove(Object key) {\n    synchronized (mutex) {return m.remove(key);}\n}\n```\n\n可以看到SynchronizedMap内部维护了一个Map对象，还有一个互斥锁mutex。然后看我们常用的get()、put()、remove()方法，其实就是在调用实际执行方法的时候加锁。\n\n然后看下HashTable，为了节省篇幅 我就粘一个方法\n\n```java\n public synchronized V put(K key, V value) {\n     // Make sure the value is not null\n     if (value == null) {\n         throw new NullPointerException();\n     }\n\n     // Makes sure the key is not already in the hashtable.\n     Entry<?,?> tab[] = table;\n     int hash = key.hashCode();\n     int index = (hash & 0x7FFFFFFF) % tab.length;\n     @SuppressWarnings(\"unchecked\")\n     Entry<K,V> entry = (Entry<K,V>)tab[index];\n     for(; entry != null ; entry = entry.next) {\n         if ((entry.hash == hash) && entry.key.equals(key)) {\n             V old = entry.value;\n             entry.value = value;\n             return old;\n         }\n     }\n\n     addEntry(hash, key, value, index);\n     return null;\n }\n```\n\n其实和上面的实现类似，都是直接上锁，所以效率比较低。\n\n如果仔细看可能就发现，这个HashTable和HashMap存在一些区别，这个HashTable不允许键值对为空，就是key和value都不能为空。因为value == null 会直接抛NPE，然后key去拿hashCode的时候也会抛NPE。\n\n然后该说我们的重头戏，ConcurrentHashMap了。\n\nConcurrentHashMap是一个`线程安全`、`高吞吐`、`低时延`的数据结构。\n\n```java\npublic class ConcurrentHashMap<K,V> extends AbstractMap<K,V>\n    implements ConcurrentMap<K,V>, Serializable {\n    private static final long serialVersionUID = 7249069246763182397L;\n\n    //最大表容量\n    private static final int MAXIMUM_CAPACITY = 1 << 30;\n\n    //默认初始容量\n    private static final int DEFAULT_CAPACITY = 16;\n\n    //可能的最大数组大小\n    static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;\n\n    //默认并发级别\n    private static final int DEFAULT_CONCURRENCY_LEVEL = 16;\n\n    //负载因子\n    private static final float LOAD_FACTOR = 0.75f;\n\n    //树化阈值\n    static final int TREEIFY_THRESHOLD = 8;\n\n    //树退化阈值\n    static final int UNTREEIFY_THRESHOLD = 6;\n\n    //树化的最小表容量\n    static final int MIN_TREEIFY_CAPACITY = 64;\n\n    private static final int MIN_TRANSFER_STRIDE = 16;\n\n    private static int RESIZE_STAMP_BITS = 16;\n\n    //帮助resize最大线程数\n    private static final int MAX_RESIZERS = (1 << (32 - RESIZE_STAMP_BITS)) - 1;\n\n    private static final int RESIZE_STAMP_SHIFT = 32 - RESIZE_STAMP_BITS;\n\n    static final int MOVED     = -1; // hash for forwarding nodes\n    static final int TREEBIN   = -2; // hash for roots of trees\n    static final int RESERVED  = -3; // hash for transient reservations\n    static final int HASH_BITS = 0x7fffffff; // usable bits of normal node hash\n\n    //cpu个数\n    static final int NCPU = Runtime.getRuntime().availableProcessors();\n\n    /** For serialization compatibility. */\n    private static final ObjectStreamField[] serialPersistentFields = {\n        new ObjectStreamField(\"segments\", Segment[].class),\n        new ObjectStreamField(\"segmentMask\", Integer.TYPE),\n        new ObjectStreamField(\"segmentShift\", Integer.TYPE)\n    };\n    \n    \n    transient volatile Node<K,V>[] table;\n\n    \n    private transient volatile Node<K,V>[] nextTable;\n\n    \n    private transient volatile long baseCount;\n\n    //表初始化和大小控制 负数表示初始化或者调整大小 -1表示初始化 table为null保存创建时使用的初始表大小，或默认为 0\n    //初始化后，保存下一个要调整表格大小的元素计数值。\n    private transient volatile int sizeCtl;\n\n    \n    private transient volatile int transferIndex;\n\n    \n    private transient volatile int cellsBusy;\n\n    \n    private transient volatile CounterCell[] counterCells;\n\n    // views\n    private transient KeySetView<K,V> keySet;\n    private transient ValuesView<K,V> values;\n    private transient EntrySetView<K,V> entrySet;\n\n    // Unsafe mechanics\n    private static final sun.misc.Unsafe U;\n    private static final long SIZECTL;\n    private static final long TRANSFERINDEX;\n    private static final long BASECOUNT;\n    private static final long CELLSBUSY;\n    private static final long CELLVALUE;\n    private static final long ABASE;\n    private static final int ASHIFT;\n\n    static {\n        try {\n            U = sun.misc.Unsafe.getUnsafe();\n            Class<?> k = ConcurrentHashMap.class;\n            SIZECTL = U.objectFieldOffset\n                (k.getDeclaredField(\"sizeCtl\"));\n            TRANSFERINDEX = U.objectFieldOffset\n                (k.getDeclaredField(\"transferIndex\"));\n            BASECOUNT = U.objectFieldOffset\n                (k.getDeclaredField(\"baseCount\"));\n            CELLSBUSY = U.objectFieldOffset\n                (k.getDeclaredField(\"cellsBusy\"));\n            Class<?> ck = CounterCell.class;\n            CELLVALUE = U.objectFieldOffset\n                (ck.getDeclaredField(\"value\"));\n            Class<?> ak = Node[].class;\n            ABASE = U.arrayBaseOffset(ak);\n            int scale = U.arrayIndexScale(ak);\n            if ((scale & (scale - 1)) != 0)\n                throw new Error(\"data type scale not a power of two\");\n            ASHIFT = 31 - Integer.numberOfLeadingZeros(scale);\n        } catch (Exception e) {\n            throw new Error(e);\n        }\n    }\n}\n```\n\n#### 插入\n\n```java\npublic V put(K key, V value) {\n    return putVal(key, value, false);\n}\n\nfinal V putVal(K key, V value, boolean onlyIfAbsent) {\n    if (key == null || value == null) throw new NullPointerException();\n    //这里重新计算了一下hash  (h ^ (h >>> 16)) & HASH_BITS\n    int hash = spread(key.hashCode());\n    int binCount = 0;\n    for (Node<K,V>[] tab = table;;) {\n        Node<K,V> f; int n, i, fh;\n        //如果table为空 那么初始化table\n        if (tab == null || (n = tab.length) == 0)\n            tab = initTable();\n        //获取当前元素\n        else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) {\n            //slot空的时候添加没有锁 \n            if (casTabAt(tab, i, null,\n                         new Node<K,V>(hash, key, value, null)))\n                break;                   // no lock when adding to empty bin\n        }\n        //表示当前slot上的元素已经迁移到新的table上，但是还未完成扩容过程，调用帮助扩容方法，其实最终调用的是transfer(tab,nextTab)\n        //nextTab就是扩容后的新表\n        else if ((fh = f.hash) == MOVED)\n            tab = helpTransfer(tab, f);\n        else {\n            V oldVal = null;\n            //这个锁的粒度是Node\n            synchronized (f) {\n                if (tabAt(tab, i) == f) {\n                    if (fh >= 0) {\n                        binCount = 1;\n                        for (Node<K,V> e = f;; ++binCount) {\n                            K ek;\n                            if (e.hash == hash &&\n                                ((ek = e.key) == key ||\n                                 (ek != null && key.equals(ek)))) {\n                                //key相同 覆盖\n                                oldVal = e.val;\n                                if (!onlyIfAbsent)\n                                    e.val = value;\n                                break;\n                            }\n                            //否则拉链法解决冲突\n                            Node<K,V> pred = e;\n                            if ((e = e.next) == null) {\n                                pred.next = new Node<K,V>(hash, key,\n                                                          value, null);\n                                break;\n                            }\n                        }\n                    }\n                    else if (f instanceof TreeBin) {\n                        Node<K,V> p;\n                        binCount = 2;\n                        //putTreeVal 这个方法是查找或者添加节点 如果添加返回null 如果找到key相同则直接返回TreeNode\n                        if ((p = ((TreeBin<K,V>)f).putTreeVal(hash, key,\n                                                              value)) != null) {\n                            oldVal = p.val;\n                            if (!onlyIfAbsent)\n                                p.val = value;\n                        }\n                    }\n                }\n            }\n            if (binCount != 0) {\n                if (binCount >= TREEIFY_THRESHOLD)\n                    //树化\n                    treeifyBin(tab, i);\n                if (oldVal != null)\n                    return oldVal;\n                break;\n            }\n        }\n    }\n    addCount(1L, binCount);\n    return null;\n}\n```\n\n看下创建table的代码\n\n```java\nprivate final Node<K,V>[] initTable() {\n    Node<K,V>[] tab; int sc;\n    while ((tab = table) == null || tab.length == 0) {\n        if ((sc = sizeCtl) < 0)\n            Thread.yield(); // lost initialization race; just spin\n        //compareAndSwapInt 第一个参数 要更新的对象\n        //第二个参数 实例变量的内存地址偏移量\n        //第三个参数 预期的旧值\n        //第四个参数 要更新的值\n        else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) {\n            try {\n                if ((tab = table) == null || tab.length == 0) {\n                    int n = (sc > 0) ? sc : DEFAULT_CAPACITY;\n                    @SuppressWarnings(\"unchecked\")\n                    Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n];\n                    table = tab = nt;\n                    //相当于容量减去1/4 也就是sc为容量*0.75\n                    sc = n - (n >>> 2);\n                }\n            } finally {\n                sizeCtl = sc;\n            }\n            break;\n        }\n    }\n    return tab;\n}\n```\n\nslot空的时候添加node，这个时候没有锁，这是用CAS去添加。\n\n```java\nstatic final <K,V> boolean casTabAt(Node<K,V>[] tab, int i,\n                                    Node<K,V> c, Node<K,V> v) {\n    return U.compareAndSwapObject(tab, ((long)i << ASHIFT) + ABASE, c, v);\n}\n```\n\n总结一下ConcurrentHashMap插入操作步骤：\n\n1.key-value空值判断，如果为空直接抛NPE\n\n2.对key的hashCode做`spread`运算，算法就是用hashcode的高16位与低16位做异或运算，并与`0x7fffffff`进行与运算，目的就是为了让hash值更分散\n\n3.执行插入操作\n\n- 如果table为空，则执行初始化工作\n- 如果key对应的位置为null，执行`CAS`操作，将KV创建成Node插入，成功即返回，失败则自旋保证成功\n- 如果key对应的位置有值，并且hash值为MOVED，表示当前slot上的所有元素已经迁移到新的table上，但是还未完成扩容，则进行尝试帮助扩容，也就是调用`helpTransfer(tab,f)`方法\n- 对当前slot加锁\n    - 当hash值大于等于0，就是链表节点，如果存在相等的key，则覆盖value。否则往该节点上插入新的节点\n    - 当`Node`为`TreeBin`类型，则调用`putTreeVal()`方法去插入元素。还是存在相等的key，覆盖value并返回，否则插入新的元素，返回null。\n- 对slot的长度进行检查，如果长度大于8，则调用`treeifyBin()`方法去检查是否需要树化，如果slot长度大于8并且table的长度大于64，则会进行树化。否则进行扩容\n- 调用`addCount()`更新size\n\n这里其实我看完代码其实一直有个疑惑，这个hash值计算的结果明明都是正数，怎么到了树节点就成了负数呢？\n\n在转移Node的时候，会有一个`ForwardingNode`，这个类的构造函数里hash值写死是MOVED也就是-1。所以有了上面的如果hash值为MOVED的时候，去帮助transfer了。\n\n在转成树的时候，会有一个`TreeBin`，这个类的构造函数hash也是写死为TREEBIN也就是-2。所以有了树化的时候，hash值为-2了。\n\n但是这里的`ForwardingNode`是在转移的时候放在头部的节点，是一个空节点，来表示当前节点已经在进行扩容转移了。\n\n而`TreeBin`则表示当前节点是红黑树，在构建好红黑树后，将`first`指向链表第一个元素（用来维护原来链表的插入顺序，树退化的时候可以恢复成链表原来的样子），将`root`指向红黑树的根节点。\n\n#### 查询\n\n```java\npublic V get(Object key) {\n    Node<K,V>[] tab; Node<K,V> e, p; int n, eh; K ek;\n    //计算hash值\n    int h = spread(key.hashCode());\n    if ((tab = table) != null && (n = tab.length) > 0 &&\n        (e = tabAt(tab, (n - 1) & h)) != null) {\n        if ((eh = e.hash) == h) {\n            if ((ek = e.key) == key || (ek != null && key.equals(ek)))\n                return e.val;\n        }\n        else if (eh < 0)\n            return (p = e.find(h, key)) != null ? p.val : null;\n        //从链表中循环查找\n        while ((e = e.next) != null) {\n            if (e.hash == h &&\n                ((ek = e.key) == key || (ek != null && key.equals(ek))))\n                return e.val;\n        }\n    }\n    return null;\n}\n```\n\n可以看到get方法比较简单，直接通过计算hash值然后去找到对应的slot，然后去遍历该位置的所有节点，直到找到相等的那个key。\n\n#### 总结\n\n扩容的条件：\n\n- 向map中添加元素的时候，某一节点数目超过8个，并且table长度小于64时，才会触发扩容操作\n- 当数组中元素达到了sizeCtl的数量的时候，则会调用transfer方法来扩容\n\n扩容的时候，是否还可以进行读写操作呢？\n\n当数组扩容的时候，如果当前节点还没被处理（还没有设置为fwd节点），那就可以进行赋值操作。如果该节点已被处理，则当前线程也加入到扩容操作中去。\n\n多线程的时候，如何进行同步处理的呢？\n\n在ConcurrentHashMap中，同步处理主要通过Synchronized和unsafe两种方式来完成。\n\n- 在获取sizeCtl、某个index的Node的时候，都是通过unsafe方法，来达到并发安全的目的\n- 当需要操作数组中的某个位置的节点时，会通过synchronized同步机制，锁定该位置的节点\n- 在数组扩容的时候，通过处理的步长和fwd节点来达到并发安全的目的，通过设置hash值为MOVED\n- 当把某个位置的节点赋值到新的table的时候，也通过synchronized的同步机制来保证线程安全","source":"_posts/死磕ConcurrentHashMap源码.md","raw":"---\nlayout:    post\ntitle:     死磕ConcurrentHashMap源码\ncategory:  源码解析\ndescription: 死磕ConcurrentHashMap源码\ntags: JDK\ndate: 2021/08/16 20:10:10\n\n\n---\n\n由于HashMap不是线程安全的，替代方案有三种：\n\n- 使用Collections.synchronizedMap(Map)创建线程安全的map集合\n- HashTable\n- ConcurrentHashMap\n\n不过出于线程并发度的原因，一般都会选择ConcurrentHashMap。先来看下第一种是怎么实现的。\n\n```java\npublic static <K,V> Map<K,V> synchronizedMap(Map<K,V> m) {\n    return new SynchronizedMap<>(m);\n}\n\nprivate static class SynchronizedMap<K,V>\n    implements Map<K,V>, Serializable {\n    private static final long serialVersionUID = 1978198479659022715L;\n\n    private final Map<K,V> m;     // Backing Map\n    final Object      mutex;        // Object on which to synchronize\n\n    SynchronizedMap(Map<K,V> m) {\n        this.m = Objects.requireNonNull(m);\n        mutex = this;\n    }\n\n    SynchronizedMap(Map<K,V> m, Object mutex) {\n        this.m = m;\n        this.mutex = mutex;\n    }\n}\n\npublic V get(Object key) {\n    synchronized (mutex) {return m.get(key);}\n}\n\npublic V put(K key, V value) {\n    synchronized (mutex) {return m.put(key, value);}\n}\n\npublic V remove(Object key) {\n    synchronized (mutex) {return m.remove(key);}\n}\n```\n\n可以看到SynchronizedMap内部维护了一个Map对象，还有一个互斥锁mutex。然后看我们常用的get()、put()、remove()方法，其实就是在调用实际执行方法的时候加锁。\n\n然后看下HashTable，为了节省篇幅 我就粘一个方法\n\n```java\n public synchronized V put(K key, V value) {\n     // Make sure the value is not null\n     if (value == null) {\n         throw new NullPointerException();\n     }\n\n     // Makes sure the key is not already in the hashtable.\n     Entry<?,?> tab[] = table;\n     int hash = key.hashCode();\n     int index = (hash & 0x7FFFFFFF) % tab.length;\n     @SuppressWarnings(\"unchecked\")\n     Entry<K,V> entry = (Entry<K,V>)tab[index];\n     for(; entry != null ; entry = entry.next) {\n         if ((entry.hash == hash) && entry.key.equals(key)) {\n             V old = entry.value;\n             entry.value = value;\n             return old;\n         }\n     }\n\n     addEntry(hash, key, value, index);\n     return null;\n }\n```\n\n其实和上面的实现类似，都是直接上锁，所以效率比较低。\n\n如果仔细看可能就发现，这个HashTable和HashMap存在一些区别，这个HashTable不允许键值对为空，就是key和value都不能为空。因为value == null 会直接抛NPE，然后key去拿hashCode的时候也会抛NPE。\n\n然后该说我们的重头戏，ConcurrentHashMap了。\n\nConcurrentHashMap是一个`线程安全`、`高吞吐`、`低时延`的数据结构。\n\n```java\npublic class ConcurrentHashMap<K,V> extends AbstractMap<K,V>\n    implements ConcurrentMap<K,V>, Serializable {\n    private static final long serialVersionUID = 7249069246763182397L;\n\n    //最大表容量\n    private static final int MAXIMUM_CAPACITY = 1 << 30;\n\n    //默认初始容量\n    private static final int DEFAULT_CAPACITY = 16;\n\n    //可能的最大数组大小\n    static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;\n\n    //默认并发级别\n    private static final int DEFAULT_CONCURRENCY_LEVEL = 16;\n\n    //负载因子\n    private static final float LOAD_FACTOR = 0.75f;\n\n    //树化阈值\n    static final int TREEIFY_THRESHOLD = 8;\n\n    //树退化阈值\n    static final int UNTREEIFY_THRESHOLD = 6;\n\n    //树化的最小表容量\n    static final int MIN_TREEIFY_CAPACITY = 64;\n\n    private static final int MIN_TRANSFER_STRIDE = 16;\n\n    private static int RESIZE_STAMP_BITS = 16;\n\n    //帮助resize最大线程数\n    private static final int MAX_RESIZERS = (1 << (32 - RESIZE_STAMP_BITS)) - 1;\n\n    private static final int RESIZE_STAMP_SHIFT = 32 - RESIZE_STAMP_BITS;\n\n    static final int MOVED     = -1; // hash for forwarding nodes\n    static final int TREEBIN   = -2; // hash for roots of trees\n    static final int RESERVED  = -3; // hash for transient reservations\n    static final int HASH_BITS = 0x7fffffff; // usable bits of normal node hash\n\n    //cpu个数\n    static final int NCPU = Runtime.getRuntime().availableProcessors();\n\n    /** For serialization compatibility. */\n    private static final ObjectStreamField[] serialPersistentFields = {\n        new ObjectStreamField(\"segments\", Segment[].class),\n        new ObjectStreamField(\"segmentMask\", Integer.TYPE),\n        new ObjectStreamField(\"segmentShift\", Integer.TYPE)\n    };\n    \n    \n    transient volatile Node<K,V>[] table;\n\n    \n    private transient volatile Node<K,V>[] nextTable;\n\n    \n    private transient volatile long baseCount;\n\n    //表初始化和大小控制 负数表示初始化或者调整大小 -1表示初始化 table为null保存创建时使用的初始表大小，或默认为 0\n    //初始化后，保存下一个要调整表格大小的元素计数值。\n    private transient volatile int sizeCtl;\n\n    \n    private transient volatile int transferIndex;\n\n    \n    private transient volatile int cellsBusy;\n\n    \n    private transient volatile CounterCell[] counterCells;\n\n    // views\n    private transient KeySetView<K,V> keySet;\n    private transient ValuesView<K,V> values;\n    private transient EntrySetView<K,V> entrySet;\n\n    // Unsafe mechanics\n    private static final sun.misc.Unsafe U;\n    private static final long SIZECTL;\n    private static final long TRANSFERINDEX;\n    private static final long BASECOUNT;\n    private static final long CELLSBUSY;\n    private static final long CELLVALUE;\n    private static final long ABASE;\n    private static final int ASHIFT;\n\n    static {\n        try {\n            U = sun.misc.Unsafe.getUnsafe();\n            Class<?> k = ConcurrentHashMap.class;\n            SIZECTL = U.objectFieldOffset\n                (k.getDeclaredField(\"sizeCtl\"));\n            TRANSFERINDEX = U.objectFieldOffset\n                (k.getDeclaredField(\"transferIndex\"));\n            BASECOUNT = U.objectFieldOffset\n                (k.getDeclaredField(\"baseCount\"));\n            CELLSBUSY = U.objectFieldOffset\n                (k.getDeclaredField(\"cellsBusy\"));\n            Class<?> ck = CounterCell.class;\n            CELLVALUE = U.objectFieldOffset\n                (ck.getDeclaredField(\"value\"));\n            Class<?> ak = Node[].class;\n            ABASE = U.arrayBaseOffset(ak);\n            int scale = U.arrayIndexScale(ak);\n            if ((scale & (scale - 1)) != 0)\n                throw new Error(\"data type scale not a power of two\");\n            ASHIFT = 31 - Integer.numberOfLeadingZeros(scale);\n        } catch (Exception e) {\n            throw new Error(e);\n        }\n    }\n}\n```\n\n#### 插入\n\n```java\npublic V put(K key, V value) {\n    return putVal(key, value, false);\n}\n\nfinal V putVal(K key, V value, boolean onlyIfAbsent) {\n    if (key == null || value == null) throw new NullPointerException();\n    //这里重新计算了一下hash  (h ^ (h >>> 16)) & HASH_BITS\n    int hash = spread(key.hashCode());\n    int binCount = 0;\n    for (Node<K,V>[] tab = table;;) {\n        Node<K,V> f; int n, i, fh;\n        //如果table为空 那么初始化table\n        if (tab == null || (n = tab.length) == 0)\n            tab = initTable();\n        //获取当前元素\n        else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) {\n            //slot空的时候添加没有锁 \n            if (casTabAt(tab, i, null,\n                         new Node<K,V>(hash, key, value, null)))\n                break;                   // no lock when adding to empty bin\n        }\n        //表示当前slot上的元素已经迁移到新的table上，但是还未完成扩容过程，调用帮助扩容方法，其实最终调用的是transfer(tab,nextTab)\n        //nextTab就是扩容后的新表\n        else if ((fh = f.hash) == MOVED)\n            tab = helpTransfer(tab, f);\n        else {\n            V oldVal = null;\n            //这个锁的粒度是Node\n            synchronized (f) {\n                if (tabAt(tab, i) == f) {\n                    if (fh >= 0) {\n                        binCount = 1;\n                        for (Node<K,V> e = f;; ++binCount) {\n                            K ek;\n                            if (e.hash == hash &&\n                                ((ek = e.key) == key ||\n                                 (ek != null && key.equals(ek)))) {\n                                //key相同 覆盖\n                                oldVal = e.val;\n                                if (!onlyIfAbsent)\n                                    e.val = value;\n                                break;\n                            }\n                            //否则拉链法解决冲突\n                            Node<K,V> pred = e;\n                            if ((e = e.next) == null) {\n                                pred.next = new Node<K,V>(hash, key,\n                                                          value, null);\n                                break;\n                            }\n                        }\n                    }\n                    else if (f instanceof TreeBin) {\n                        Node<K,V> p;\n                        binCount = 2;\n                        //putTreeVal 这个方法是查找或者添加节点 如果添加返回null 如果找到key相同则直接返回TreeNode\n                        if ((p = ((TreeBin<K,V>)f).putTreeVal(hash, key,\n                                                              value)) != null) {\n                            oldVal = p.val;\n                            if (!onlyIfAbsent)\n                                p.val = value;\n                        }\n                    }\n                }\n            }\n            if (binCount != 0) {\n                if (binCount >= TREEIFY_THRESHOLD)\n                    //树化\n                    treeifyBin(tab, i);\n                if (oldVal != null)\n                    return oldVal;\n                break;\n            }\n        }\n    }\n    addCount(1L, binCount);\n    return null;\n}\n```\n\n看下创建table的代码\n\n```java\nprivate final Node<K,V>[] initTable() {\n    Node<K,V>[] tab; int sc;\n    while ((tab = table) == null || tab.length == 0) {\n        if ((sc = sizeCtl) < 0)\n            Thread.yield(); // lost initialization race; just spin\n        //compareAndSwapInt 第一个参数 要更新的对象\n        //第二个参数 实例变量的内存地址偏移量\n        //第三个参数 预期的旧值\n        //第四个参数 要更新的值\n        else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) {\n            try {\n                if ((tab = table) == null || tab.length == 0) {\n                    int n = (sc > 0) ? sc : DEFAULT_CAPACITY;\n                    @SuppressWarnings(\"unchecked\")\n                    Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n];\n                    table = tab = nt;\n                    //相当于容量减去1/4 也就是sc为容量*0.75\n                    sc = n - (n >>> 2);\n                }\n            } finally {\n                sizeCtl = sc;\n            }\n            break;\n        }\n    }\n    return tab;\n}\n```\n\nslot空的时候添加node，这个时候没有锁，这是用CAS去添加。\n\n```java\nstatic final <K,V> boolean casTabAt(Node<K,V>[] tab, int i,\n                                    Node<K,V> c, Node<K,V> v) {\n    return U.compareAndSwapObject(tab, ((long)i << ASHIFT) + ABASE, c, v);\n}\n```\n\n总结一下ConcurrentHashMap插入操作步骤：\n\n1.key-value空值判断，如果为空直接抛NPE\n\n2.对key的hashCode做`spread`运算，算法就是用hashcode的高16位与低16位做异或运算，并与`0x7fffffff`进行与运算，目的就是为了让hash值更分散\n\n3.执行插入操作\n\n- 如果table为空，则执行初始化工作\n- 如果key对应的位置为null，执行`CAS`操作，将KV创建成Node插入，成功即返回，失败则自旋保证成功\n- 如果key对应的位置有值，并且hash值为MOVED，表示当前slot上的所有元素已经迁移到新的table上，但是还未完成扩容，则进行尝试帮助扩容，也就是调用`helpTransfer(tab,f)`方法\n- 对当前slot加锁\n    - 当hash值大于等于0，就是链表节点，如果存在相等的key，则覆盖value。否则往该节点上插入新的节点\n    - 当`Node`为`TreeBin`类型，则调用`putTreeVal()`方法去插入元素。还是存在相等的key，覆盖value并返回，否则插入新的元素，返回null。\n- 对slot的长度进行检查，如果长度大于8，则调用`treeifyBin()`方法去检查是否需要树化，如果slot长度大于8并且table的长度大于64，则会进行树化。否则进行扩容\n- 调用`addCount()`更新size\n\n这里其实我看完代码其实一直有个疑惑，这个hash值计算的结果明明都是正数，怎么到了树节点就成了负数呢？\n\n在转移Node的时候，会有一个`ForwardingNode`，这个类的构造函数里hash值写死是MOVED也就是-1。所以有了上面的如果hash值为MOVED的时候，去帮助transfer了。\n\n在转成树的时候，会有一个`TreeBin`，这个类的构造函数hash也是写死为TREEBIN也就是-2。所以有了树化的时候，hash值为-2了。\n\n但是这里的`ForwardingNode`是在转移的时候放在头部的节点，是一个空节点，来表示当前节点已经在进行扩容转移了。\n\n而`TreeBin`则表示当前节点是红黑树，在构建好红黑树后，将`first`指向链表第一个元素（用来维护原来链表的插入顺序，树退化的时候可以恢复成链表原来的样子），将`root`指向红黑树的根节点。\n\n#### 查询\n\n```java\npublic V get(Object key) {\n    Node<K,V>[] tab; Node<K,V> e, p; int n, eh; K ek;\n    //计算hash值\n    int h = spread(key.hashCode());\n    if ((tab = table) != null && (n = tab.length) > 0 &&\n        (e = tabAt(tab, (n - 1) & h)) != null) {\n        if ((eh = e.hash) == h) {\n            if ((ek = e.key) == key || (ek != null && key.equals(ek)))\n                return e.val;\n        }\n        else if (eh < 0)\n            return (p = e.find(h, key)) != null ? p.val : null;\n        //从链表中循环查找\n        while ((e = e.next) != null) {\n            if (e.hash == h &&\n                ((ek = e.key) == key || (ek != null && key.equals(ek))))\n                return e.val;\n        }\n    }\n    return null;\n}\n```\n\n可以看到get方法比较简单，直接通过计算hash值然后去找到对应的slot，然后去遍历该位置的所有节点，直到找到相等的那个key。\n\n#### 总结\n\n扩容的条件：\n\n- 向map中添加元素的时候，某一节点数目超过8个，并且table长度小于64时，才会触发扩容操作\n- 当数组中元素达到了sizeCtl的数量的时候，则会调用transfer方法来扩容\n\n扩容的时候，是否还可以进行读写操作呢？\n\n当数组扩容的时候，如果当前节点还没被处理（还没有设置为fwd节点），那就可以进行赋值操作。如果该节点已被处理，则当前线程也加入到扩容操作中去。\n\n多线程的时候，如何进行同步处理的呢？\n\n在ConcurrentHashMap中，同步处理主要通过Synchronized和unsafe两种方式来完成。\n\n- 在获取sizeCtl、某个index的Node的时候，都是通过unsafe方法，来达到并发安全的目的\n- 当需要操作数组中的某个位置的节点时，会通过synchronized同步机制，锁定该位置的节点\n- 在数组扩容的时候，通过处理的步长和fwd节点来达到并发安全的目的，通过设置hash值为MOVED\n- 当把某个位置的节点赋值到新的table的时候，也通过synchronized的同步机制来保证线程安全","slug":"死磕ConcurrentHashMap源码","published":1,"updated":"2021-08-16T12:10:10.000Z","comments":1,"photos":[],"link":"","_id":"cm1m304x7000a31b42nvdgz84","content":"<p>由于HashMap不是线程安全的，替代方案有三种：</p>\n<ul>\n<li>使用Collections.synchronizedMap(Map)创建线程安全的map集合</li>\n<li>HashTable</li>\n<li>ConcurrentHashMap</li>\n</ul>\n<p>不过出于线程并发度的原因，一般都会选择ConcurrentHashMap。先来看下第一种是怎么实现的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;K,V&gt; <span class=\"function\">Map&lt;K,V&gt; <span class=\"title\">synchronizedMap</span><span class=\"params\">(Map&lt;K,V&gt; m)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> SynchronizedMap&lt;&gt;(m);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SynchronizedMap</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"keyword\">implements</span> <span class=\"title\">Map</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt;, <span class=\"title\">Serializable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = <span class=\"number\">1978198479659022715L</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;K,V&gt; m;     <span class=\"comment\">// Backing Map</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> Object      mutex;        <span class=\"comment\">// Object on which to synchronize</span></span><br><span class=\"line\"></span><br><span class=\"line\">    SynchronizedMap(Map&lt;K,V&gt; m) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.m = Objects.requireNonNull(m);</span><br><span class=\"line\">        mutex = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    SynchronizedMap(Map&lt;K,V&gt; m, Object mutex) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.m = m;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.mutex = mutex;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (mutex) &#123;<span class=\"keyword\">return</span> m.get(key);&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (mutex) &#123;<span class=\"keyword\">return</span> m.put(key, value);&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">remove</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (mutex) &#123;<span class=\"keyword\">return</span> m.remove(key);&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到SynchronizedMap内部维护了一个Map对象，还有一个互斥锁mutex。然后看我们常用的get()、put()、remove()方法，其实就是在调用实际执行方法的时候加锁。</p>\n<p>然后看下HashTable，为了节省篇幅 我就粘一个方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Make sure the value is not null</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (value == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Makes sure the key is not already in the hashtable.</span></span><br><span class=\"line\">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> hash = key.hashCode();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> index = (hash &amp; <span class=\"number\">0x7FFFFFFF</span>) % tab.length;</span><br><span class=\"line\">    <span class=\"meta\">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class=\"line\">    Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(; entry != <span class=\"keyword\">null</span> ; entry = entry.next) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123;</span><br><span class=\"line\">            V old = entry.value;</span><br><span class=\"line\">            entry.value = value;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> old;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    addEntry(hash, key, value, index);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其实和上面的实现类似，都是直接上锁，所以效率比较低。</p>\n<p>如果仔细看可能就发现，这个HashTable和HashMap存在一些区别，这个HashTable不允许键值对为空，就是key和value都不能为空。因为value == null 会直接抛NPE，然后key去拿hashCode的时候也会抛NPE。</p>\n<p>然后该说我们的重头戏，ConcurrentHashMap了。</p>\n<p>ConcurrentHashMap是一个<code>线程安全</code>、<code>高吞吐</code>、<code>低时延</code>的数据结构。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConcurrentHashMap</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">AbstractMap</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"keyword\">implements</span> <span class=\"title\">ConcurrentMap</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt;, <span class=\"title\">Serializable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = <span class=\"number\">7249069246763182397L</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//最大表容量</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MAXIMUM_CAPACITY = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">30</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//默认初始容量</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_CAPACITY = <span class=\"number\">16</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//可能的最大数组大小</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class=\"number\">8</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//默认并发级别</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class=\"number\">16</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//负载因子</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> LOAD_FACTOR = <span class=\"number\">0.75f</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//树化阈值</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> TREEIFY_THRESHOLD = <span class=\"number\">8</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//树退化阈值</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> UNTREEIFY_THRESHOLD = <span class=\"number\">6</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//树化的最小表容量</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MIN_TREEIFY_CAPACITY = <span class=\"number\">64</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MIN_TRANSFER_STRIDE = <span class=\"number\">16</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> RESIZE_STAMP_BITS = <span class=\"number\">16</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//帮助resize最大线程数</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MAX_RESIZERS = (<span class=\"number\">1</span> &lt;&lt; (<span class=\"number\">32</span> - RESIZE_STAMP_BITS)) - <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> RESIZE_STAMP_SHIFT = <span class=\"number\">32</span> - RESIZE_STAMP_BITS;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MOVED     = -<span class=\"number\">1</span>; <span class=\"comment\">// hash for forwarding nodes</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> TREEBIN   = -<span class=\"number\">2</span>; <span class=\"comment\">// hash for roots of trees</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> RESERVED  = -<span class=\"number\">3</span>; <span class=\"comment\">// hash for transient reservations</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> HASH_BITS = <span class=\"number\">0x7fffffff</span>; <span class=\"comment\">// usable bits of normal node hash</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//cpu个数</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> NCPU = Runtime.getRuntime().availableProcessors();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** For serialization compatibility. */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ObjectStreamField[] serialPersistentFields = &#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> ObjectStreamField(<span class=\"string\">&quot;segments&quot;</span>, Segment[].class),</span><br><span class=\"line\">        <span class=\"keyword\">new</span> ObjectStreamField(<span class=\"string\">&quot;segmentMask&quot;</span>, Integer.TYPE),</span><br><span class=\"line\">        <span class=\"keyword\">new</span> ObjectStreamField(<span class=\"string\">&quot;segmentShift&quot;</span>, Integer.TYPE)</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">transient</span> <span class=\"keyword\">volatile</span> Node&lt;K,V&gt;[] table;</span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> <span class=\"keyword\">volatile</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">long</span> baseCount;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//表初始化和大小控制 负数表示初始化或者调整大小 -1表示初始化 table为null保存创建时使用的初始表大小，或默认为 0</span></span><br><span class=\"line\">    <span class=\"comment\">//初始化后，保存下一个要调整表格大小的元素计数值。</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> sizeCtl;</span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> transferIndex;</span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> cellsBusy;</span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> <span class=\"keyword\">volatile</span> CounterCell[] counterCells;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// views</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> KeySetView&lt;K,V&gt; keySet;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> ValuesView&lt;K,V&gt; values;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> EntrySetView&lt;K,V&gt; entrySet;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Unsafe mechanics</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> sun.misc.Unsafe U;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> SIZECTL;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> TRANSFERINDEX;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> BASECOUNT;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> CELLSBUSY;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> CELLVALUE;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> ABASE;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> ASHIFT;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            U = sun.misc.Unsafe.getUnsafe();</span><br><span class=\"line\">            Class&lt;?&gt; k = ConcurrentHashMap.class;</span><br><span class=\"line\">            SIZECTL = U.objectFieldOffset</span><br><span class=\"line\">                (k.getDeclaredField(<span class=\"string\">&quot;sizeCtl&quot;</span>));</span><br><span class=\"line\">            TRANSFERINDEX = U.objectFieldOffset</span><br><span class=\"line\">                (k.getDeclaredField(<span class=\"string\">&quot;transferIndex&quot;</span>));</span><br><span class=\"line\">            BASECOUNT = U.objectFieldOffset</span><br><span class=\"line\">                (k.getDeclaredField(<span class=\"string\">&quot;baseCount&quot;</span>));</span><br><span class=\"line\">            CELLSBUSY = U.objectFieldOffset</span><br><span class=\"line\">                (k.getDeclaredField(<span class=\"string\">&quot;cellsBusy&quot;</span>));</span><br><span class=\"line\">            Class&lt;?&gt; ck = CounterCell.class;</span><br><span class=\"line\">            CELLVALUE = U.objectFieldOffset</span><br><span class=\"line\">                (ck.getDeclaredField(<span class=\"string\">&quot;value&quot;</span>));</span><br><span class=\"line\">            Class&lt;?&gt; ak = Node[].class;</span><br><span class=\"line\">            ABASE = U.arrayBaseOffset(ak);</span><br><span class=\"line\">            <span class=\"keyword\">int</span> scale = U.arrayIndexScale(ak);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((scale &amp; (scale - <span class=\"number\">1</span>)) != <span class=\"number\">0</span>)</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(<span class=\"string\">&quot;data type scale not a power of two&quot;</span>);</span><br><span class=\"line\">            ASHIFT = <span class=\"number\">31</span> - Integer.numberOfLeadingZeros(scale);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"插入\"><a href=\"#插入\" class=\"headerlink\" title=\"插入\"></a>插入</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> putVal(key, value, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> V <span class=\"title\">putVal</span><span class=\"params\">(K key, V value, <span class=\"keyword\">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key == <span class=\"keyword\">null</span> || value == <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">    <span class=\"comment\">//这里重新计算了一下hash  (h ^ (h &gt;&gt;&gt; 16)) &amp; HASH_BITS</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> hash = spread(key.hashCode());</span><br><span class=\"line\">    <span class=\"keyword\">int</span> binCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class=\"line\">        Node&lt;K,V&gt; f; <span class=\"keyword\">int</span> n, i, fh;</span><br><span class=\"line\">        <span class=\"comment\">//如果table为空 那么初始化table</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (tab == <span class=\"keyword\">null</span> || (n = tab.length) == <span class=\"number\">0</span>)</span><br><span class=\"line\">            tab = initTable();</span><br><span class=\"line\">        <span class=\"comment\">//获取当前元素</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((f = tabAt(tab, i = (n - <span class=\"number\">1</span>) &amp; hash)) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//slot空的时候添加没有锁 </span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (casTabAt(tab, i, <span class=\"keyword\">null</span>,</span><br><span class=\"line\">                         <span class=\"keyword\">new</span> Node&lt;K,V&gt;(hash, key, value, <span class=\"keyword\">null</span>)))</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;                   <span class=\"comment\">// no lock when adding to empty bin</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//表示当前slot上的元素已经迁移到新的table上，但是还未完成扩容过程，调用帮助扩容方法，其实最终调用的是transfer(tab,nextTab)</span></span><br><span class=\"line\">        <span class=\"comment\">//nextTab就是扩容后的新表</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((fh = f.hash) == MOVED)</span><br><span class=\"line\">            tab = helpTransfer(tab, f);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            V oldVal = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"comment\">//这个锁的粒度是Node</span></span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (f) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (fh &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        binCount = <span class=\"number\">1</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class=\"line\">                            K ek;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">                                ((ek = e.key) == key ||</span><br><span class=\"line\">                                 (ek != <span class=\"keyword\">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class=\"line\">                                <span class=\"comment\">//key相同 覆盖</span></span><br><span class=\"line\">                                oldVal = e.val;</span><br><span class=\"line\">                                <span class=\"keyword\">if</span> (!onlyIfAbsent)</span><br><span class=\"line\">                                    e.val = value;</span><br><span class=\"line\">                                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                            <span class=\"comment\">//否则拉链法解决冲突</span></span><br><span class=\"line\">                            Node&lt;K,V&gt; pred = e;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> ((e = e.next) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                                pred.next = <span class=\"keyword\">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class=\"line\">                                                          value, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">                                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (f <span class=\"keyword\">instanceof</span> TreeBin) &#123;</span><br><span class=\"line\">                        Node&lt;K,V&gt; p;</span><br><span class=\"line\">                        binCount = <span class=\"number\">2</span>;</span><br><span class=\"line\">                        <span class=\"comment\">//putTreeVal 这个方法是查找或者添加节点 如果添加返回null 如果找到key相同则直接返回TreeNode</span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class=\"line\">                                                              value)) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                            oldVal = p.val;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (!onlyIfAbsent)</span><br><span class=\"line\">                                p.val = value;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (binCount != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class=\"line\">                    <span class=\"comment\">//树化</span></span><br><span class=\"line\">                    treeifyBin(tab, i);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (oldVal != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> oldVal;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    addCount(<span class=\"number\">1L</span>, binCount);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>看下创建table的代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] tab; <span class=\"keyword\">int</span> sc;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ((tab = table) == <span class=\"keyword\">null</span> || tab.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((sc = sizeCtl) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            Thread.yield(); <span class=\"comment\">// lost initialization race; just spin</span></span><br><span class=\"line\">        <span class=\"comment\">//compareAndSwapInt 第一个参数 要更新的对象</span></span><br><span class=\"line\">        <span class=\"comment\">//第二个参数 实例变量的内存地址偏移量</span></span><br><span class=\"line\">        <span class=\"comment\">//第三个参数 预期的旧值</span></span><br><span class=\"line\">        <span class=\"comment\">//第四个参数 要更新的值</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (U.compareAndSwapInt(<span class=\"keyword\">this</span>, SIZECTL, sc, -<span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((tab = table) == <span class=\"keyword\">null</span> || tab.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> n = (sc &gt; <span class=\"number\">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class=\"line\">                    <span class=\"meta\">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class=\"line\">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class=\"keyword\">new</span> Node&lt;?,?&gt;[n];</span><br><span class=\"line\">                    table = tab = nt;</span><br><span class=\"line\">                    <span class=\"comment\">//相当于容量减去1/4 也就是sc为容量*0.75</span></span><br><span class=\"line\">                    sc = n - (n &gt;&gt;&gt; <span class=\"number\">2</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                sizeCtl = sc;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> tab;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>slot空的时候添加node，这个时候没有锁，这是用CAS去添加。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> &lt;K,V&gt; <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">casTabAt</span><span class=\"params\">(Node&lt;K,V&gt;[] tab, <span class=\"keyword\">int</span> i,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                    Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> U.compareAndSwapObject(tab, ((<span class=\"keyword\">long</span>)i &lt;&lt; ASHIFT) + ABASE, c, v);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>总结一下ConcurrentHashMap插入操作步骤：</p>\n<p>1.key-value空值判断，如果为空直接抛NPE</p>\n<p>2.对key的hashCode做<code>spread</code>运算，算法就是用hashcode的高16位与低16位做异或运算，并与<code>0x7fffffff</code>进行与运算，目的就是为了让hash值更分散</p>\n<p>3.执行插入操作</p>\n<ul>\n<li>如果table为空，则执行初始化工作</li>\n<li>如果key对应的位置为null，执行<code>CAS</code>操作，将KV创建成Node插入，成功即返回，失败则自旋保证成功</li>\n<li>如果key对应的位置有值，并且hash值为MOVED，表示当前slot上的所有元素已经迁移到新的table上，但是还未完成扩容，则进行尝试帮助扩容，也就是调用<code>helpTransfer(tab,f)</code>方法</li>\n<li>对当前slot加锁<ul>\n<li>当hash值大于等于0，就是链表节点，如果存在相等的key，则覆盖value。否则往该节点上插入新的节点</li>\n<li>当<code>Node</code>为<code>TreeBin</code>类型，则调用<code>putTreeVal()</code>方法去插入元素。还是存在相等的key，覆盖value并返回，否则插入新的元素，返回null。</li>\n</ul>\n</li>\n<li>对slot的长度进行检查，如果长度大于8，则调用<code>treeifyBin()</code>方法去检查是否需要树化，如果slot长度大于8并且table的长度大于64，则会进行树化。否则进行扩容</li>\n<li>调用<code>addCount()</code>更新size</li>\n</ul>\n<p>这里其实我看完代码其实一直有个疑惑，这个hash值计算的结果明明都是正数，怎么到了树节点就成了负数呢？</p>\n<p>在转移Node的时候，会有一个<code>ForwardingNode</code>，这个类的构造函数里hash值写死是MOVED也就是-1。所以有了上面的如果hash值为MOVED的时候，去帮助transfer了。</p>\n<p>在转成树的时候，会有一个<code>TreeBin</code>，这个类的构造函数hash也是写死为TREEBIN也就是-2。所以有了树化的时候，hash值为-2了。</p>\n<p>但是这里的<code>ForwardingNode</code>是在转移的时候放在头部的节点，是一个空节点，来表示当前节点已经在进行扩容转移了。</p>\n<p>而<code>TreeBin</code>则表示当前节点是红黑树，在构建好红黑树后，将<code>first</code>指向链表第一个元素（用来维护原来链表的插入顺序，树退化的时候可以恢复成链表原来的样子），将<code>root</code>指向红黑树的根节点。</p>\n<h4 id=\"查询\"><a href=\"#查询\" class=\"headerlink\" title=\"查询\"></a>查询</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class=\"keyword\">int</span> n, eh; K ek;</span><br><span class=\"line\">    <span class=\"comment\">//计算hash值</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> h = spread(key.hashCode());</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((tab = table) != <span class=\"keyword\">null</span> &amp;&amp; (n = tab.length) &gt; <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">        (e = tabAt(tab, (n - <span class=\"number\">1</span>) &amp; h)) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((eh = e.hash) == h) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((ek = e.key) == key || (ek != <span class=\"keyword\">null</span> &amp;&amp; key.equals(ek)))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> e.val;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (eh &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (p = e.find(h, key)) != <span class=\"keyword\">null</span> ? p.val : <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"comment\">//从链表中循环查找</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> ((e = e.next) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (e.hash == h &amp;&amp;</span><br><span class=\"line\">                ((ek = e.key) == key || (ek != <span class=\"keyword\">null</span> &amp;&amp; key.equals(ek))))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> e.val;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到get方法比较简单，直接通过计算hash值然后去找到对应的slot，然后去遍历该位置的所有节点，直到找到相等的那个key。</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>扩容的条件：</p>\n<ul>\n<li>向map中添加元素的时候，某一节点数目超过8个，并且table长度小于64时，才会触发扩容操作</li>\n<li>当数组中元素达到了sizeCtl的数量的时候，则会调用transfer方法来扩容</li>\n</ul>\n<p>扩容的时候，是否还可以进行读写操作呢？</p>\n<p>当数组扩容的时候，如果当前节点还没被处理（还没有设置为fwd节点），那就可以进行赋值操作。如果该节点已被处理，则当前线程也加入到扩容操作中去。</p>\n<p>多线程的时候，如何进行同步处理的呢？</p>\n<p>在ConcurrentHashMap中，同步处理主要通过Synchronized和unsafe两种方式来完成。</p>\n<ul>\n<li>在获取sizeCtl、某个index的Node的时候，都是通过unsafe方法，来达到并发安全的目的</li>\n<li>当需要操作数组中的某个位置的节点时，会通过synchronized同步机制，锁定该位置的节点</li>\n<li>在数组扩容的时候，通过处理的步长和fwd节点来达到并发安全的目的，通过设置hash值为MOVED</li>\n<li>当把某个位置的节点赋值到新的table的时候，也通过synchronized的同步机制来保证线程安全</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>由于HashMap不是线程安全的，替代方案有三种：</p>\n<ul>\n<li>使用Collections.synchronizedMap(Map)创建线程安全的map集合</li>\n<li>HashTable</li>\n<li>ConcurrentHashMap</li>\n</ul>\n<p>不过出于线程并发度的原因，一般都会选择ConcurrentHashMap。先来看下第一种是怎么实现的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;K,V&gt; <span class=\"function\">Map&lt;K,V&gt; <span class=\"title\">synchronizedMap</span><span class=\"params\">(Map&lt;K,V&gt; m)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> SynchronizedMap&lt;&gt;(m);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SynchronizedMap</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"keyword\">implements</span> <span class=\"title\">Map</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt;, <span class=\"title\">Serializable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = <span class=\"number\">1978198479659022715L</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;K,V&gt; m;     <span class=\"comment\">// Backing Map</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> Object      mutex;        <span class=\"comment\">// Object on which to synchronize</span></span><br><span class=\"line\"></span><br><span class=\"line\">    SynchronizedMap(Map&lt;K,V&gt; m) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.m = Objects.requireNonNull(m);</span><br><span class=\"line\">        mutex = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    SynchronizedMap(Map&lt;K,V&gt; m, Object mutex) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.m = m;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.mutex = mutex;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (mutex) &#123;<span class=\"keyword\">return</span> m.get(key);&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (mutex) &#123;<span class=\"keyword\">return</span> m.put(key, value);&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">remove</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (mutex) &#123;<span class=\"keyword\">return</span> m.remove(key);&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到SynchronizedMap内部维护了一个Map对象，还有一个互斥锁mutex。然后看我们常用的get()、put()、remove()方法，其实就是在调用实际执行方法的时候加锁。</p>\n<p>然后看下HashTable，为了节省篇幅 我就粘一个方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Make sure the value is not null</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (value == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Makes sure the key is not already in the hashtable.</span></span><br><span class=\"line\">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> hash = key.hashCode();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> index = (hash &amp; <span class=\"number\">0x7FFFFFFF</span>) % tab.length;</span><br><span class=\"line\">    <span class=\"meta\">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class=\"line\">    Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(; entry != <span class=\"keyword\">null</span> ; entry = entry.next) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123;</span><br><span class=\"line\">            V old = entry.value;</span><br><span class=\"line\">            entry.value = value;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> old;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    addEntry(hash, key, value, index);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其实和上面的实现类似，都是直接上锁，所以效率比较低。</p>\n<p>如果仔细看可能就发现，这个HashTable和HashMap存在一些区别，这个HashTable不允许键值对为空，就是key和value都不能为空。因为value == null 会直接抛NPE，然后key去拿hashCode的时候也会抛NPE。</p>\n<p>然后该说我们的重头戏，ConcurrentHashMap了。</p>\n<p>ConcurrentHashMap是一个<code>线程安全</code>、<code>高吞吐</code>、<code>低时延</code>的数据结构。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConcurrentHashMap</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">AbstractMap</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"keyword\">implements</span> <span class=\"title\">ConcurrentMap</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt;, <span class=\"title\">Serializable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = <span class=\"number\">7249069246763182397L</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//最大表容量</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MAXIMUM_CAPACITY = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">30</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//默认初始容量</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_CAPACITY = <span class=\"number\">16</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//可能的最大数组大小</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class=\"number\">8</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//默认并发级别</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class=\"number\">16</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//负载因子</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> LOAD_FACTOR = <span class=\"number\">0.75f</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//树化阈值</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> TREEIFY_THRESHOLD = <span class=\"number\">8</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//树退化阈值</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> UNTREEIFY_THRESHOLD = <span class=\"number\">6</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//树化的最小表容量</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MIN_TREEIFY_CAPACITY = <span class=\"number\">64</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MIN_TRANSFER_STRIDE = <span class=\"number\">16</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> RESIZE_STAMP_BITS = <span class=\"number\">16</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//帮助resize最大线程数</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MAX_RESIZERS = (<span class=\"number\">1</span> &lt;&lt; (<span class=\"number\">32</span> - RESIZE_STAMP_BITS)) - <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> RESIZE_STAMP_SHIFT = <span class=\"number\">32</span> - RESIZE_STAMP_BITS;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MOVED     = -<span class=\"number\">1</span>; <span class=\"comment\">// hash for forwarding nodes</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> TREEBIN   = -<span class=\"number\">2</span>; <span class=\"comment\">// hash for roots of trees</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> RESERVED  = -<span class=\"number\">3</span>; <span class=\"comment\">// hash for transient reservations</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> HASH_BITS = <span class=\"number\">0x7fffffff</span>; <span class=\"comment\">// usable bits of normal node hash</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//cpu个数</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> NCPU = Runtime.getRuntime().availableProcessors();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** For serialization compatibility. */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ObjectStreamField[] serialPersistentFields = &#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> ObjectStreamField(<span class=\"string\">&quot;segments&quot;</span>, Segment[].class),</span><br><span class=\"line\">        <span class=\"keyword\">new</span> ObjectStreamField(<span class=\"string\">&quot;segmentMask&quot;</span>, Integer.TYPE),</span><br><span class=\"line\">        <span class=\"keyword\">new</span> ObjectStreamField(<span class=\"string\">&quot;segmentShift&quot;</span>, Integer.TYPE)</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">transient</span> <span class=\"keyword\">volatile</span> Node&lt;K,V&gt;[] table;</span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> <span class=\"keyword\">volatile</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">long</span> baseCount;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//表初始化和大小控制 负数表示初始化或者调整大小 -1表示初始化 table为null保存创建时使用的初始表大小，或默认为 0</span></span><br><span class=\"line\">    <span class=\"comment\">//初始化后，保存下一个要调整表格大小的元素计数值。</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> sizeCtl;</span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> transferIndex;</span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> cellsBusy;</span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> <span class=\"keyword\">volatile</span> CounterCell[] counterCells;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// views</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> KeySetView&lt;K,V&gt; keySet;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> ValuesView&lt;K,V&gt; values;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> EntrySetView&lt;K,V&gt; entrySet;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Unsafe mechanics</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> sun.misc.Unsafe U;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> SIZECTL;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> TRANSFERINDEX;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> BASECOUNT;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> CELLSBUSY;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> CELLVALUE;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> ABASE;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> ASHIFT;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            U = sun.misc.Unsafe.getUnsafe();</span><br><span class=\"line\">            Class&lt;?&gt; k = ConcurrentHashMap.class;</span><br><span class=\"line\">            SIZECTL = U.objectFieldOffset</span><br><span class=\"line\">                (k.getDeclaredField(<span class=\"string\">&quot;sizeCtl&quot;</span>));</span><br><span class=\"line\">            TRANSFERINDEX = U.objectFieldOffset</span><br><span class=\"line\">                (k.getDeclaredField(<span class=\"string\">&quot;transferIndex&quot;</span>));</span><br><span class=\"line\">            BASECOUNT = U.objectFieldOffset</span><br><span class=\"line\">                (k.getDeclaredField(<span class=\"string\">&quot;baseCount&quot;</span>));</span><br><span class=\"line\">            CELLSBUSY = U.objectFieldOffset</span><br><span class=\"line\">                (k.getDeclaredField(<span class=\"string\">&quot;cellsBusy&quot;</span>));</span><br><span class=\"line\">            Class&lt;?&gt; ck = CounterCell.class;</span><br><span class=\"line\">            CELLVALUE = U.objectFieldOffset</span><br><span class=\"line\">                (ck.getDeclaredField(<span class=\"string\">&quot;value&quot;</span>));</span><br><span class=\"line\">            Class&lt;?&gt; ak = Node[].class;</span><br><span class=\"line\">            ABASE = U.arrayBaseOffset(ak);</span><br><span class=\"line\">            <span class=\"keyword\">int</span> scale = U.arrayIndexScale(ak);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((scale &amp; (scale - <span class=\"number\">1</span>)) != <span class=\"number\">0</span>)</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(<span class=\"string\">&quot;data type scale not a power of two&quot;</span>);</span><br><span class=\"line\">            ASHIFT = <span class=\"number\">31</span> - Integer.numberOfLeadingZeros(scale);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"插入\"><a href=\"#插入\" class=\"headerlink\" title=\"插入\"></a>插入</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> putVal(key, value, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> V <span class=\"title\">putVal</span><span class=\"params\">(K key, V value, <span class=\"keyword\">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key == <span class=\"keyword\">null</span> || value == <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">    <span class=\"comment\">//这里重新计算了一下hash  (h ^ (h &gt;&gt;&gt; 16)) &amp; HASH_BITS</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> hash = spread(key.hashCode());</span><br><span class=\"line\">    <span class=\"keyword\">int</span> binCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class=\"line\">        Node&lt;K,V&gt; f; <span class=\"keyword\">int</span> n, i, fh;</span><br><span class=\"line\">        <span class=\"comment\">//如果table为空 那么初始化table</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (tab == <span class=\"keyword\">null</span> || (n = tab.length) == <span class=\"number\">0</span>)</span><br><span class=\"line\">            tab = initTable();</span><br><span class=\"line\">        <span class=\"comment\">//获取当前元素</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((f = tabAt(tab, i = (n - <span class=\"number\">1</span>) &amp; hash)) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//slot空的时候添加没有锁 </span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (casTabAt(tab, i, <span class=\"keyword\">null</span>,</span><br><span class=\"line\">                         <span class=\"keyword\">new</span> Node&lt;K,V&gt;(hash, key, value, <span class=\"keyword\">null</span>)))</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;                   <span class=\"comment\">// no lock when adding to empty bin</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//表示当前slot上的元素已经迁移到新的table上，但是还未完成扩容过程，调用帮助扩容方法，其实最终调用的是transfer(tab,nextTab)</span></span><br><span class=\"line\">        <span class=\"comment\">//nextTab就是扩容后的新表</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((fh = f.hash) == MOVED)</span><br><span class=\"line\">            tab = helpTransfer(tab, f);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            V oldVal = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"comment\">//这个锁的粒度是Node</span></span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (f) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (fh &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        binCount = <span class=\"number\">1</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class=\"line\">                            K ek;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">                                ((ek = e.key) == key ||</span><br><span class=\"line\">                                 (ek != <span class=\"keyword\">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class=\"line\">                                <span class=\"comment\">//key相同 覆盖</span></span><br><span class=\"line\">                                oldVal = e.val;</span><br><span class=\"line\">                                <span class=\"keyword\">if</span> (!onlyIfAbsent)</span><br><span class=\"line\">                                    e.val = value;</span><br><span class=\"line\">                                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                            <span class=\"comment\">//否则拉链法解决冲突</span></span><br><span class=\"line\">                            Node&lt;K,V&gt; pred = e;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> ((e = e.next) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                                pred.next = <span class=\"keyword\">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class=\"line\">                                                          value, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">                                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (f <span class=\"keyword\">instanceof</span> TreeBin) &#123;</span><br><span class=\"line\">                        Node&lt;K,V&gt; p;</span><br><span class=\"line\">                        binCount = <span class=\"number\">2</span>;</span><br><span class=\"line\">                        <span class=\"comment\">//putTreeVal 这个方法是查找或者添加节点 如果添加返回null 如果找到key相同则直接返回TreeNode</span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class=\"line\">                                                              value)) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                            oldVal = p.val;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (!onlyIfAbsent)</span><br><span class=\"line\">                                p.val = value;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (binCount != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class=\"line\">                    <span class=\"comment\">//树化</span></span><br><span class=\"line\">                    treeifyBin(tab, i);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (oldVal != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> oldVal;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    addCount(<span class=\"number\">1L</span>, binCount);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>看下创建table的代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] tab; <span class=\"keyword\">int</span> sc;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ((tab = table) == <span class=\"keyword\">null</span> || tab.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((sc = sizeCtl) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            Thread.yield(); <span class=\"comment\">// lost initialization race; just spin</span></span><br><span class=\"line\">        <span class=\"comment\">//compareAndSwapInt 第一个参数 要更新的对象</span></span><br><span class=\"line\">        <span class=\"comment\">//第二个参数 实例变量的内存地址偏移量</span></span><br><span class=\"line\">        <span class=\"comment\">//第三个参数 预期的旧值</span></span><br><span class=\"line\">        <span class=\"comment\">//第四个参数 要更新的值</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (U.compareAndSwapInt(<span class=\"keyword\">this</span>, SIZECTL, sc, -<span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((tab = table) == <span class=\"keyword\">null</span> || tab.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> n = (sc &gt; <span class=\"number\">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class=\"line\">                    <span class=\"meta\">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class=\"line\">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class=\"keyword\">new</span> Node&lt;?,?&gt;[n];</span><br><span class=\"line\">                    table = tab = nt;</span><br><span class=\"line\">                    <span class=\"comment\">//相当于容量减去1/4 也就是sc为容量*0.75</span></span><br><span class=\"line\">                    sc = n - (n &gt;&gt;&gt; <span class=\"number\">2</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                sizeCtl = sc;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> tab;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>slot空的时候添加node，这个时候没有锁，这是用CAS去添加。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> &lt;K,V&gt; <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">casTabAt</span><span class=\"params\">(Node&lt;K,V&gt;[] tab, <span class=\"keyword\">int</span> i,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                    Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> U.compareAndSwapObject(tab, ((<span class=\"keyword\">long</span>)i &lt;&lt; ASHIFT) + ABASE, c, v);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>总结一下ConcurrentHashMap插入操作步骤：</p>\n<p>1.key-value空值判断，如果为空直接抛NPE</p>\n<p>2.对key的hashCode做<code>spread</code>运算，算法就是用hashcode的高16位与低16位做异或运算，并与<code>0x7fffffff</code>进行与运算，目的就是为了让hash值更分散</p>\n<p>3.执行插入操作</p>\n<ul>\n<li>如果table为空，则执行初始化工作</li>\n<li>如果key对应的位置为null，执行<code>CAS</code>操作，将KV创建成Node插入，成功即返回，失败则自旋保证成功</li>\n<li>如果key对应的位置有值，并且hash值为MOVED，表示当前slot上的所有元素已经迁移到新的table上，但是还未完成扩容，则进行尝试帮助扩容，也就是调用<code>helpTransfer(tab,f)</code>方法</li>\n<li>对当前slot加锁<ul>\n<li>当hash值大于等于0，就是链表节点，如果存在相等的key，则覆盖value。否则往该节点上插入新的节点</li>\n<li>当<code>Node</code>为<code>TreeBin</code>类型，则调用<code>putTreeVal()</code>方法去插入元素。还是存在相等的key，覆盖value并返回，否则插入新的元素，返回null。</li>\n</ul>\n</li>\n<li>对slot的长度进行检查，如果长度大于8，则调用<code>treeifyBin()</code>方法去检查是否需要树化，如果slot长度大于8并且table的长度大于64，则会进行树化。否则进行扩容</li>\n<li>调用<code>addCount()</code>更新size</li>\n</ul>\n<p>这里其实我看完代码其实一直有个疑惑，这个hash值计算的结果明明都是正数，怎么到了树节点就成了负数呢？</p>\n<p>在转移Node的时候，会有一个<code>ForwardingNode</code>，这个类的构造函数里hash值写死是MOVED也就是-1。所以有了上面的如果hash值为MOVED的时候，去帮助transfer了。</p>\n<p>在转成树的时候，会有一个<code>TreeBin</code>，这个类的构造函数hash也是写死为TREEBIN也就是-2。所以有了树化的时候，hash值为-2了。</p>\n<p>但是这里的<code>ForwardingNode</code>是在转移的时候放在头部的节点，是一个空节点，来表示当前节点已经在进行扩容转移了。</p>\n<p>而<code>TreeBin</code>则表示当前节点是红黑树，在构建好红黑树后，将<code>first</code>指向链表第一个元素（用来维护原来链表的插入顺序，树退化的时候可以恢复成链表原来的样子），将<code>root</code>指向红黑树的根节点。</p>\n<h4 id=\"查询\"><a href=\"#查询\" class=\"headerlink\" title=\"查询\"></a>查询</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class=\"keyword\">int</span> n, eh; K ek;</span><br><span class=\"line\">    <span class=\"comment\">//计算hash值</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> h = spread(key.hashCode());</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((tab = table) != <span class=\"keyword\">null</span> &amp;&amp; (n = tab.length) &gt; <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">        (e = tabAt(tab, (n - <span class=\"number\">1</span>) &amp; h)) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((eh = e.hash) == h) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((ek = e.key) == key || (ek != <span class=\"keyword\">null</span> &amp;&amp; key.equals(ek)))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> e.val;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (eh &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (p = e.find(h, key)) != <span class=\"keyword\">null</span> ? p.val : <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"comment\">//从链表中循环查找</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> ((e = e.next) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (e.hash == h &amp;&amp;</span><br><span class=\"line\">                ((ek = e.key) == key || (ek != <span class=\"keyword\">null</span> &amp;&amp; key.equals(ek))))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> e.val;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到get方法比较简单，直接通过计算hash值然后去找到对应的slot，然后去遍历该位置的所有节点，直到找到相等的那个key。</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>扩容的条件：</p>\n<ul>\n<li>向map中添加元素的时候，某一节点数目超过8个，并且table长度小于64时，才会触发扩容操作</li>\n<li>当数组中元素达到了sizeCtl的数量的时候，则会调用transfer方法来扩容</li>\n</ul>\n<p>扩容的时候，是否还可以进行读写操作呢？</p>\n<p>当数组扩容的时候，如果当前节点还没被处理（还没有设置为fwd节点），那就可以进行赋值操作。如果该节点已被处理，则当前线程也加入到扩容操作中去。</p>\n<p>多线程的时候，如何进行同步处理的呢？</p>\n<p>在ConcurrentHashMap中，同步处理主要通过Synchronized和unsafe两种方式来完成。</p>\n<ul>\n<li>在获取sizeCtl、某个index的Node的时候，都是通过unsafe方法，来达到并发安全的目的</li>\n<li>当需要操作数组中的某个位置的节点时，会通过synchronized同步机制，锁定该位置的节点</li>\n<li>在数组扩容的时候，通过处理的步长和fwd节点来达到并发安全的目的，通过设置hash值为MOVED</li>\n<li>当把某个位置的节点赋值到新的table的时候，也通过synchronized的同步机制来保证线程安全</li>\n</ul>\n"},{"layout":"post","title":"死磕HashMap源码(一)","description":"死磕HashMap源码(一)","date":"2021-08-12T01:42:10.000Z","_content":"\n> 本文有一部分思路参考自 https://segmentfault.com/a/1190000015812438\n\nHashMap是我们平时常用到的kev-value存储的集合。首先来看类定义.\n\n```java\npublic class HashMap<K,V> extends AbstractMap<K,V>\n    implements Map<K,V>, Cloneable, Serializable{}\n```\n\n继承自AbstractMap，其实就是提供一些Map的通用实现，来减少新开发一个Map时不必要的代码。\n\n实现Map接口 Map就是K-V结构的顶层接口。像List就是集合层次中的根接口。\n\nCloneable、Serializable 这两个接口都是标记作用。\n\n看下HashMap的字段定义\n\n```java\n//默认初始化容量 必须为2的幂\nstatic final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16\n\n//最大容量 最大为2的30次幂\nstatic final int MAXIMUM_CAPACITY = 1 << 30;\n\n//负载因子\nstatic final float DEFAULT_LOAD_FACTOR = 0.75f;\n\n//树化阈值 这个值必须大于2小于8\nstatic final int TREEIFY_THRESHOLD = 8;\n\n//解构阈值 应小于TREEIFY_THRESHOLD 并且最大为6\nstatic final int UNTREEIFY_THRESHOLD = 6;\n\n//bin树化最小容量 就是链表的最小长度 \n//应至少为 4 * TREEIFY_THRESHOLD，以避免调整大小和树化阈值之间发生冲突\nstatic final int MIN_TREEIFY_CAPACITY = 64;\n\n//存储数据的核心结构\ntransient Node<K,V>[] table;\n\n//集合中元素个数\ntransient int size;\n\n//修改次数\ntransient int modCount;\n\n//要调整大小的下一个大小值（容量 * 负载因子）\nint threshold;\n\n//哈希表中的负载因子\nfinal float loadFactor;\n```\n\n我们知道HashMap是用数组和链表构成的数据结构。HashMap会用一个指针数组table[]来分散所有的key，当一个key被加入时，会通过Hash算法算出这个数组的下标，然后就把这个K-V插入到table[]中，如果有两个不同的key算出来的下标相同的i，那么就是发生了冲突，也叫碰撞，这样会在table[i]形成一个链表，这种解决冲突的方式叫拉链法。我们知道table[]的尺寸很小，比如只有2个，如果放入10个key的话，碰撞就会很频繁，就从原来的O(1)的查找算法，变成了链表遍历，也就是O(n)。这也是拉链法去解决冲突的缺陷。所以后面使用红黑树利用红黑树的自平衡来保证查找次数的稳定。\n\n先来看下Node的结构。\n\n```java\nstatic class Node<K,V> implements Map.Entry<K,V> {\n  final int hash;\n  final K key;\n  V value;\n  Node<K,V> next;\n\n  Node(int hash, K key, V value, Node<K,V> next) {\n    this.hash = hash;\n    this.key = key;\n    this.value = value;\n    this.next = next;\n  }\n\n  public final K getKey()        { return key; }\n  public final V getValue()      { return value; }\n  public final String toString() { return key + \"=\" + value; }\n\n  public final int hashCode() {\n    return Objects.hashCode(key) ^ Objects.hashCode(value);\n  }\n\n  public final V setValue(V newValue) {\n    V oldValue = value;\n    value = newValue;\n    return oldValue;\n  }\n\n  public final boolean equals(Object o) {\n    if (o == this)\n      return true;\n    if (o instanceof Map.Entry) {\n      Map.Entry<?,?> e = (Map.Entry<?,?>)o;\n      if (Objects.equals(key, e.getKey()) &&\n          Objects.equals(value, e.getValue()))\n        return true;\n    }\n    return false;\n  }\n}\n```\n\n从Node属性中可以看到Node是一个单向链表，每一个节点保存后继节点的引用。\n\n那么拉链法解决冲突的时候，是怎么插入数据的呢？在Java8之前是使用头插法，就是新来的值取代原有的值，原有的值会被推到链表中去，因为作者认为后来的值被查找的可能性更大一点，想提升查找效率。但是Java8之后，又改成了尾插法。\n\n敲黑板！！这里是重点。为什么后来改成尾插法。\n\n先来看下数据插入的源码。\n\n```java\npublic V put(K key, V value) {\n  //这里看到拿到hash码然后进行putVal\n  return putVal(hash(key), key, value, false, true);\n}\n\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n               boolean evict) {\n  Node<K,V>[] tab; Node<K,V> p; int n, i;\n  //先看当前table是不是空的 空的先进行扩容\n  if ((tab = table) == null || (n = tab.length) == 0)\n    n = (tab = resize()).length;\n  //判断当前元素在不在hash表中 如果不在 那么直接创建新的节点\n  if ((p = tab[i = (n - 1) & hash]) == null)\n    tab[i] = newNode(hash, key, value, null);\n  else {\n    //发生碰撞\n    Node<K,V> e; K k;\n    //hash码相等 && key相等 这里也是为什么重写hashCode 还要重写equals\n    if (p.hash == hash &&\n        ((k = p.key) == key || (key != null && key.equals(k))))\n      e = p;\n    else if (p instanceof TreeNode)\n      //当前节点已经是树节点了 那么直接使用树节点的插入方法\n      e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);\n    else {\n      //此时为链表\n      for (int binCount = 0; ; ++binCount) {\n        if ((e = p.next) == null) {\n          //找到最后一个节点然后将新创建的节点插入 尾插法\n          p.next = newNode(hash, key, value, null);\n          //当链表长度大于树化阈值 树化\n          if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st\n            treeifyBin(tab, hash);\n          break;\n        }\n        //遍历链表中的key是否存在重复\n        if (e.hash == hash &&\n            ((k = e.key) == key || (key != null && key.equals(k))))\n          break;\n        p = e;\n      }\n    }\n    //e不等于空 就是key可以认为是同一个key\n    if (e != null) { // existing mapping for key\n      V oldValue = e.value;\n      if (!onlyIfAbsent || oldValue == null)\n        //更新value\n        e.value = value;\n      //回调通知\n      afterNodeAccess(e);\n      return oldValue;\n    }\n  }\n  ++modCount;\n  if (++size > threshold)\n    //扩容\n    resize();\n  //回调通知\n  afterNodeInsertion(evict);\n  return null;\n}\n```\n\n这里说一下为什么是用(n - 1) & hash。这个是一个取余操作。取余操作中如果除数是2的幂则等价于与其除数减一的与(&)操作，hash%length==hash&(length-1)，前提是长度2的n次方，采用二进制位操作能提高运算效率。这也解释了为什么容量必须是2的幂了。\n\n看下扩容代码\n\n```java\nfinal Node<K,V>[] resize() {\n  Node<K,V>[] oldTab = table;\n  int oldCap = (oldTab == null) ? 0 : oldTab.length;\n  //以前的扩容阈值\n  int oldThr = threshold;\n  int newCap, newThr = 0;\n  if (oldCap > 0) {\n    //容量已经最大 那么直接修改threshold返回\n    if (oldCap >= MAXIMUM_CAPACITY) {\n      threshold = Integer.MAX_VALUE;\n      return oldTab;\n    }\n    //旧容量小于最大值 threshold直接翻倍 容量也翻倍\n    else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&\n             oldCap >= DEFAULT_INITIAL_CAPACITY)\n      newThr = oldThr << 1; // double threshold\n  }\n  else if (oldThr > 0) // initial capacity was placed in threshold\n    newCap = oldThr;\n  else {               // zero initial threshold signifies using defaults\n    newCap = DEFAULT_INITIAL_CAPACITY;\n    //新的容量上限 = 负载因子 * 容量\n    newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n  }\n  //其实这里比较绕 就是创建的时候指定初始化容量如1 然后第一个数据进来 进入resize中\n  if (newThr == 0) {\n    //2*0.75 = 1.5 这里newCap是因为上面进行了容量翻倍\n    float ft = (float)newCap * loadFactor;\n    //newThr = 1\n    newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?\n              (int)ft : Integer.MAX_VALUE);\n  }\n  threshold = newThr;\n  @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n  Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];\n  table = newTab;\n  if (oldTab != null) {\n    for (int j = 0; j < oldCap; ++j) {\n      //遍历旧的table\n      Node<K,V> e;\n      if ((e = oldTab[j]) != null) {\n        oldTab[j] = null;\n        if (e.next == null)\n          //如果当前节点不为空并且后继节点为空 直接在newTab找到位置赋值\n          newTab[e.hash & (newCap - 1)] = e;\n        else if (e instanceof TreeNode)\n          //如果是树的结构 进行树的处理\n          ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);\n        else { // preserve order\n          //如果是链表 需要保持原来的顺序\n          //这里根据字段名猜测应该是2个链表 一个lo队列 一个hi队列\n          Node<K,V> loHead = null, loTail = null;\n          Node<K,V> hiHead = null, hiTail = null;\n          Node<K,V> next;\n          do {\n            next = e.next;\n            //这里根据e.hash & oldCap的结果来判断节点属于lo还是hi\n            if ((e.hash & oldCap) == 0) {\n              //尾插法\n              if (loTail == null)\n                loHead = e;\n              else\n                loTail.next = e;\n              loTail = e;\n            }\n            else {\n              //e.hash & oldCap 结果只会为0或者为1\n              if (hiTail == null)\n                hiHead = e;\n              else\n                hiTail.next = e;\n              hiTail = e;\n            }\n          } while ((e = next) != null);\n          //如果loTail非空 那么将lo链表放到newTab[j]的位置上\n          if (loTail != null) {\n            loTail.next = null;\n            newTab[j] = loHead;\n          }\n          //如果hiTail非空 那么将hi链表放到newTab[j+oldCap]的位置上\n          if (hiTail != null) {\n            hiTail.next = null;\n            newTab[j + oldCap] = hiHead;\n          }\n        }\n      }\n    }\n  }\n  return newTab;\n}\n```\n\n首先来说下，HashMap扩容是2倍扩容的。所以也就意味着原来链表里的key有两个去处，要么是newTab[j] 要么是newTab[j+oldCap]。这个分链表的操作 其实有点像我们站队，老师让我们一二报数，然后按照喊的数字去分组一样。`e.hash & oldCap` 这个操作就是决定这个节点到底喊的是0还是1的关键。\n\n有三点明确下：\n\n-  oldCap一定是2的整数次幂，这里假设是2^m\n-  newCap是oldCap的两倍，则newCap为2^(m+1)\n-  hash对数组大小取模(n-1)&hash其实就是取hash的低m位\n\n假设oldCap = 16 即2^4\n\n16-1 = 15 二进制表示为 `0000 0000 0000 0000 0000 0000 0000 1111` 除了低四位，高位都是0。所以(16-1)&hash 也就可以认为是低四位&hashcode，假设它为abcd。\n\n当oldCap扩大两倍后，新的index就应该是(32-1)&hash，其实就是取hash值的低五位。此时也就2中情况第五位不是0就是1。也就是0abcd、或者1abcd。其中0abcd和原来的值一样，而1abcd = 0abcd + 1 0000 也就是差了一个oldCap。所以同一个key要么和原来的index一致，要么差了一个oldCap。\n\n如何拿到第五位的值呢？\n\nhash & 0000 0000 0000 0000 0000 0000 0001 0000 也就等效于 hash & olcCap\n\n所以可以得出（e.hash & oldCap) == 0 该节点在新表中的下标位置于旧表一致，（e.hash & oldCap) == 1该节点在新表的下标位置为 j + oldCap\n\nHashMap中，决定key位置的就是hash函数，看下哈希函数如何实现的\n\n```java\nstatic final int hash(Object key) {\n  int h;\n  return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n}\n```\n\n这里看到HashMap对hashCode进行了高16位和低16位进行了异或，这充分利用了高半位和低半位的信息，对低位进行扰动，目的就是使该hashCode映射成数组下标是可以更分散。以初始长度为例，16-1=15，与某散列值“与”操作如下\n\n```\n  \t10100101 11000100 00100101\n&\t00000000 00000000 00001111\n----------------------------------\n\t00000000 00000000 00000101       //高位全部归零，只保留末四位\n```\n\n如果散列值算的不够分散，只取最后几位的话，分布上成等差数列的话，碰撞就会很严重。这时候扰动函数的价值就出来了。\n\n![](https://vqianxiao.github.io/blog/images/hashmap/hashcode.png)\n\n右移16位，正好是32bit的一半，自己的高半区和低半区做异或，就是为了混合原始哈希吗的高位和低位，以此来加大随机性。而且混合后的低位参杂了高位的部分特征，这样高位的信息也被变相保留下来。\n\n总结一下HashMap插入数据流程：\n\n1.对key重新计算一个扰动过的hash值，(key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n\n2.看table是否为空或者长度为0，如果是则进行扩容 if ((tab = table) == null || (n = tab.length) == 0)  n = (tab = resize()).length;\n\n3.根据hash值计算index的位置，如果该index没有存放数据，则直接插入，如果有数据，那么需要判断key是否相等以及equals方法是否相等，如果相等则覆盖，不相等时，先判断是不是树节点，树节点执行树节点的插入逻辑，否则就是链表，使用拉链法解决冲突，拉链法解决冲突的时候也会检查链表长度是否大于TREEIFY_THRESHOLD阈值，进而执行判断是否需要树化的逻辑。\n\n4.插入数据完毕，检查当前插入数据是否大于设定容量，进而进行扩容操作。","source":"_posts/死磕HashMap源码(一).md","raw":"---\nlayout:    post\ntitle:     死磕HashMap源码(一)\ncategory:  源码解析\ndescription: 死磕HashMap源码(一)\ntags: JDK\ndate: 2021/08/12 9:42:10\n\n\n\n---\n\n> 本文有一部分思路参考自 https://segmentfault.com/a/1190000015812438\n\nHashMap是我们平时常用到的kev-value存储的集合。首先来看类定义.\n\n```java\npublic class HashMap<K,V> extends AbstractMap<K,V>\n    implements Map<K,V>, Cloneable, Serializable{}\n```\n\n继承自AbstractMap，其实就是提供一些Map的通用实现，来减少新开发一个Map时不必要的代码。\n\n实现Map接口 Map就是K-V结构的顶层接口。像List就是集合层次中的根接口。\n\nCloneable、Serializable 这两个接口都是标记作用。\n\n看下HashMap的字段定义\n\n```java\n//默认初始化容量 必须为2的幂\nstatic final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16\n\n//最大容量 最大为2的30次幂\nstatic final int MAXIMUM_CAPACITY = 1 << 30;\n\n//负载因子\nstatic final float DEFAULT_LOAD_FACTOR = 0.75f;\n\n//树化阈值 这个值必须大于2小于8\nstatic final int TREEIFY_THRESHOLD = 8;\n\n//解构阈值 应小于TREEIFY_THRESHOLD 并且最大为6\nstatic final int UNTREEIFY_THRESHOLD = 6;\n\n//bin树化最小容量 就是链表的最小长度 \n//应至少为 4 * TREEIFY_THRESHOLD，以避免调整大小和树化阈值之间发生冲突\nstatic final int MIN_TREEIFY_CAPACITY = 64;\n\n//存储数据的核心结构\ntransient Node<K,V>[] table;\n\n//集合中元素个数\ntransient int size;\n\n//修改次数\ntransient int modCount;\n\n//要调整大小的下一个大小值（容量 * 负载因子）\nint threshold;\n\n//哈希表中的负载因子\nfinal float loadFactor;\n```\n\n我们知道HashMap是用数组和链表构成的数据结构。HashMap会用一个指针数组table[]来分散所有的key，当一个key被加入时，会通过Hash算法算出这个数组的下标，然后就把这个K-V插入到table[]中，如果有两个不同的key算出来的下标相同的i，那么就是发生了冲突，也叫碰撞，这样会在table[i]形成一个链表，这种解决冲突的方式叫拉链法。我们知道table[]的尺寸很小，比如只有2个，如果放入10个key的话，碰撞就会很频繁，就从原来的O(1)的查找算法，变成了链表遍历，也就是O(n)。这也是拉链法去解决冲突的缺陷。所以后面使用红黑树利用红黑树的自平衡来保证查找次数的稳定。\n\n先来看下Node的结构。\n\n```java\nstatic class Node<K,V> implements Map.Entry<K,V> {\n  final int hash;\n  final K key;\n  V value;\n  Node<K,V> next;\n\n  Node(int hash, K key, V value, Node<K,V> next) {\n    this.hash = hash;\n    this.key = key;\n    this.value = value;\n    this.next = next;\n  }\n\n  public final K getKey()        { return key; }\n  public final V getValue()      { return value; }\n  public final String toString() { return key + \"=\" + value; }\n\n  public final int hashCode() {\n    return Objects.hashCode(key) ^ Objects.hashCode(value);\n  }\n\n  public final V setValue(V newValue) {\n    V oldValue = value;\n    value = newValue;\n    return oldValue;\n  }\n\n  public final boolean equals(Object o) {\n    if (o == this)\n      return true;\n    if (o instanceof Map.Entry) {\n      Map.Entry<?,?> e = (Map.Entry<?,?>)o;\n      if (Objects.equals(key, e.getKey()) &&\n          Objects.equals(value, e.getValue()))\n        return true;\n    }\n    return false;\n  }\n}\n```\n\n从Node属性中可以看到Node是一个单向链表，每一个节点保存后继节点的引用。\n\n那么拉链法解决冲突的时候，是怎么插入数据的呢？在Java8之前是使用头插法，就是新来的值取代原有的值，原有的值会被推到链表中去，因为作者认为后来的值被查找的可能性更大一点，想提升查找效率。但是Java8之后，又改成了尾插法。\n\n敲黑板！！这里是重点。为什么后来改成尾插法。\n\n先来看下数据插入的源码。\n\n```java\npublic V put(K key, V value) {\n  //这里看到拿到hash码然后进行putVal\n  return putVal(hash(key), key, value, false, true);\n}\n\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n               boolean evict) {\n  Node<K,V>[] tab; Node<K,V> p; int n, i;\n  //先看当前table是不是空的 空的先进行扩容\n  if ((tab = table) == null || (n = tab.length) == 0)\n    n = (tab = resize()).length;\n  //判断当前元素在不在hash表中 如果不在 那么直接创建新的节点\n  if ((p = tab[i = (n - 1) & hash]) == null)\n    tab[i] = newNode(hash, key, value, null);\n  else {\n    //发生碰撞\n    Node<K,V> e; K k;\n    //hash码相等 && key相等 这里也是为什么重写hashCode 还要重写equals\n    if (p.hash == hash &&\n        ((k = p.key) == key || (key != null && key.equals(k))))\n      e = p;\n    else if (p instanceof TreeNode)\n      //当前节点已经是树节点了 那么直接使用树节点的插入方法\n      e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);\n    else {\n      //此时为链表\n      for (int binCount = 0; ; ++binCount) {\n        if ((e = p.next) == null) {\n          //找到最后一个节点然后将新创建的节点插入 尾插法\n          p.next = newNode(hash, key, value, null);\n          //当链表长度大于树化阈值 树化\n          if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st\n            treeifyBin(tab, hash);\n          break;\n        }\n        //遍历链表中的key是否存在重复\n        if (e.hash == hash &&\n            ((k = e.key) == key || (key != null && key.equals(k))))\n          break;\n        p = e;\n      }\n    }\n    //e不等于空 就是key可以认为是同一个key\n    if (e != null) { // existing mapping for key\n      V oldValue = e.value;\n      if (!onlyIfAbsent || oldValue == null)\n        //更新value\n        e.value = value;\n      //回调通知\n      afterNodeAccess(e);\n      return oldValue;\n    }\n  }\n  ++modCount;\n  if (++size > threshold)\n    //扩容\n    resize();\n  //回调通知\n  afterNodeInsertion(evict);\n  return null;\n}\n```\n\n这里说一下为什么是用(n - 1) & hash。这个是一个取余操作。取余操作中如果除数是2的幂则等价于与其除数减一的与(&)操作，hash%length==hash&(length-1)，前提是长度2的n次方，采用二进制位操作能提高运算效率。这也解释了为什么容量必须是2的幂了。\n\n看下扩容代码\n\n```java\nfinal Node<K,V>[] resize() {\n  Node<K,V>[] oldTab = table;\n  int oldCap = (oldTab == null) ? 0 : oldTab.length;\n  //以前的扩容阈值\n  int oldThr = threshold;\n  int newCap, newThr = 0;\n  if (oldCap > 0) {\n    //容量已经最大 那么直接修改threshold返回\n    if (oldCap >= MAXIMUM_CAPACITY) {\n      threshold = Integer.MAX_VALUE;\n      return oldTab;\n    }\n    //旧容量小于最大值 threshold直接翻倍 容量也翻倍\n    else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&\n             oldCap >= DEFAULT_INITIAL_CAPACITY)\n      newThr = oldThr << 1; // double threshold\n  }\n  else if (oldThr > 0) // initial capacity was placed in threshold\n    newCap = oldThr;\n  else {               // zero initial threshold signifies using defaults\n    newCap = DEFAULT_INITIAL_CAPACITY;\n    //新的容量上限 = 负载因子 * 容量\n    newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n  }\n  //其实这里比较绕 就是创建的时候指定初始化容量如1 然后第一个数据进来 进入resize中\n  if (newThr == 0) {\n    //2*0.75 = 1.5 这里newCap是因为上面进行了容量翻倍\n    float ft = (float)newCap * loadFactor;\n    //newThr = 1\n    newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?\n              (int)ft : Integer.MAX_VALUE);\n  }\n  threshold = newThr;\n  @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n  Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];\n  table = newTab;\n  if (oldTab != null) {\n    for (int j = 0; j < oldCap; ++j) {\n      //遍历旧的table\n      Node<K,V> e;\n      if ((e = oldTab[j]) != null) {\n        oldTab[j] = null;\n        if (e.next == null)\n          //如果当前节点不为空并且后继节点为空 直接在newTab找到位置赋值\n          newTab[e.hash & (newCap - 1)] = e;\n        else if (e instanceof TreeNode)\n          //如果是树的结构 进行树的处理\n          ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);\n        else { // preserve order\n          //如果是链表 需要保持原来的顺序\n          //这里根据字段名猜测应该是2个链表 一个lo队列 一个hi队列\n          Node<K,V> loHead = null, loTail = null;\n          Node<K,V> hiHead = null, hiTail = null;\n          Node<K,V> next;\n          do {\n            next = e.next;\n            //这里根据e.hash & oldCap的结果来判断节点属于lo还是hi\n            if ((e.hash & oldCap) == 0) {\n              //尾插法\n              if (loTail == null)\n                loHead = e;\n              else\n                loTail.next = e;\n              loTail = e;\n            }\n            else {\n              //e.hash & oldCap 结果只会为0或者为1\n              if (hiTail == null)\n                hiHead = e;\n              else\n                hiTail.next = e;\n              hiTail = e;\n            }\n          } while ((e = next) != null);\n          //如果loTail非空 那么将lo链表放到newTab[j]的位置上\n          if (loTail != null) {\n            loTail.next = null;\n            newTab[j] = loHead;\n          }\n          //如果hiTail非空 那么将hi链表放到newTab[j+oldCap]的位置上\n          if (hiTail != null) {\n            hiTail.next = null;\n            newTab[j + oldCap] = hiHead;\n          }\n        }\n      }\n    }\n  }\n  return newTab;\n}\n```\n\n首先来说下，HashMap扩容是2倍扩容的。所以也就意味着原来链表里的key有两个去处，要么是newTab[j] 要么是newTab[j+oldCap]。这个分链表的操作 其实有点像我们站队，老师让我们一二报数，然后按照喊的数字去分组一样。`e.hash & oldCap` 这个操作就是决定这个节点到底喊的是0还是1的关键。\n\n有三点明确下：\n\n-  oldCap一定是2的整数次幂，这里假设是2^m\n-  newCap是oldCap的两倍，则newCap为2^(m+1)\n-  hash对数组大小取模(n-1)&hash其实就是取hash的低m位\n\n假设oldCap = 16 即2^4\n\n16-1 = 15 二进制表示为 `0000 0000 0000 0000 0000 0000 0000 1111` 除了低四位，高位都是0。所以(16-1)&hash 也就可以认为是低四位&hashcode，假设它为abcd。\n\n当oldCap扩大两倍后，新的index就应该是(32-1)&hash，其实就是取hash值的低五位。此时也就2中情况第五位不是0就是1。也就是0abcd、或者1abcd。其中0abcd和原来的值一样，而1abcd = 0abcd + 1 0000 也就是差了一个oldCap。所以同一个key要么和原来的index一致，要么差了一个oldCap。\n\n如何拿到第五位的值呢？\n\nhash & 0000 0000 0000 0000 0000 0000 0001 0000 也就等效于 hash & olcCap\n\n所以可以得出（e.hash & oldCap) == 0 该节点在新表中的下标位置于旧表一致，（e.hash & oldCap) == 1该节点在新表的下标位置为 j + oldCap\n\nHashMap中，决定key位置的就是hash函数，看下哈希函数如何实现的\n\n```java\nstatic final int hash(Object key) {\n  int h;\n  return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n}\n```\n\n这里看到HashMap对hashCode进行了高16位和低16位进行了异或，这充分利用了高半位和低半位的信息，对低位进行扰动，目的就是使该hashCode映射成数组下标是可以更分散。以初始长度为例，16-1=15，与某散列值“与”操作如下\n\n```\n  \t10100101 11000100 00100101\n&\t00000000 00000000 00001111\n----------------------------------\n\t00000000 00000000 00000101       //高位全部归零，只保留末四位\n```\n\n如果散列值算的不够分散，只取最后几位的话，分布上成等差数列的话，碰撞就会很严重。这时候扰动函数的价值就出来了。\n\n![](https://vqianxiao.github.io/blog/images/hashmap/hashcode.png)\n\n右移16位，正好是32bit的一半，自己的高半区和低半区做异或，就是为了混合原始哈希吗的高位和低位，以此来加大随机性。而且混合后的低位参杂了高位的部分特征，这样高位的信息也被变相保留下来。\n\n总结一下HashMap插入数据流程：\n\n1.对key重新计算一个扰动过的hash值，(key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n\n2.看table是否为空或者长度为0，如果是则进行扩容 if ((tab = table) == null || (n = tab.length) == 0)  n = (tab = resize()).length;\n\n3.根据hash值计算index的位置，如果该index没有存放数据，则直接插入，如果有数据，那么需要判断key是否相等以及equals方法是否相等，如果相等则覆盖，不相等时，先判断是不是树节点，树节点执行树节点的插入逻辑，否则就是链表，使用拉链法解决冲突，拉链法解决冲突的时候也会检查链表长度是否大于TREEIFY_THRESHOLD阈值，进而执行判断是否需要树化的逻辑。\n\n4.插入数据完毕，检查当前插入数据是否大于设定容量，进而进行扩容操作。","slug":"死磕HashMap源码(一)","published":1,"updated":"2021-08-12T01:42:10.000Z","comments":1,"photos":[],"link":"","_id":"cm1m304x8000c31b41amw023m","content":"<blockquote>\n<p>本文有一部分思路参考自 <a href=\"https://segmentfault.com/a/1190000015812438\">https://segmentfault.com/a/1190000015812438</a></p>\n</blockquote>\n<p>HashMap是我们平时常用到的kev-value存储的集合。首先来看类定义.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HashMap</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">AbstractMap</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"keyword\">implements</span> <span class=\"title\">Map</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt;, <span class=\"title\">Cloneable</span>, <span class=\"title\">Serializable</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>继承自AbstractMap，其实就是提供一些Map的通用实现，来减少新开发一个Map时不必要的代码。</p>\n<p>实现Map接口 Map就是K-V结构的顶层接口。像List就是集合层次中的根接口。</p>\n<p>Cloneable、Serializable 这两个接口都是标记作用。</p>\n<p>看下HashMap的字段定义</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//默认初始化容量 必须为2的幂</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_INITIAL_CAPACITY = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">4</span>; <span class=\"comment\">// aka 16</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//最大容量 最大为2的30次幂</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MAXIMUM_CAPACITY = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">30</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//负载因子</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> DEFAULT_LOAD_FACTOR = <span class=\"number\">0.75f</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//树化阈值 这个值必须大于2小于8</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> TREEIFY_THRESHOLD = <span class=\"number\">8</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//解构阈值 应小于TREEIFY_THRESHOLD 并且最大为6</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> UNTREEIFY_THRESHOLD = <span class=\"number\">6</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//bin树化最小容量 就是链表的最小长度 </span></span><br><span class=\"line\"><span class=\"comment\">//应至少为 4 * TREEIFY_THRESHOLD，以避免调整大小和树化阈值之间发生冲突</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MIN_TREEIFY_CAPACITY = <span class=\"number\">64</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//存储数据的核心结构</span></span><br><span class=\"line\"><span class=\"keyword\">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//集合中元素个数</span></span><br><span class=\"line\"><span class=\"keyword\">transient</span> <span class=\"keyword\">int</span> size;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//修改次数</span></span><br><span class=\"line\"><span class=\"keyword\">transient</span> <span class=\"keyword\">int</span> modCount;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//要调整大小的下一个大小值（容量 * 负载因子）</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> threshold;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//哈希表中的负载因子</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">float</span> loadFactor;</span><br></pre></td></tr></table></figure>\n\n<p>我们知道HashMap是用数组和链表构成的数据结构。HashMap会用一个指针数组table[]来分散所有的key，当一个key被加入时，会通过Hash算法算出这个数组的下标，然后就把这个K-V插入到table[]中，如果有两个不同的key算出来的下标相同的i，那么就是发生了冲突，也叫碰撞，这样会在table[i]形成一个链表，这种解决冲突的方式叫拉链法。我们知道table[]的尺寸很小，比如只有2个，如果放入10个key的话，碰撞就会很频繁，就从原来的O(1)的查找算法，变成了链表遍历，也就是O(n)。这也是拉链法去解决冲突的缺陷。所以后面使用红黑树利用红黑树的自平衡来保证查找次数的稳定。</p>\n<p>先来看下Node的结构。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Map</span>.<span class=\"title\">Entry</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> hash;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> K key;</span><br><span class=\"line\">  V value;</span><br><span class=\"line\">  Node&lt;K,V&gt; next;</span><br><span class=\"line\"></span><br><span class=\"line\">  Node(<span class=\"keyword\">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.hash = hash;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.key = key;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.value = value;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.next = next;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> K <span class=\"title\">getKey</span><span class=\"params\">()</span>        </span>&#123; <span class=\"keyword\">return</span> key; &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> V <span class=\"title\">getValue</span><span class=\"params\">()</span>      </span>&#123; <span class=\"keyword\">return</span> value; &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> key + <span class=\"string\">&quot;=&quot;</span> + value; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> V <span class=\"title\">setValue</span><span class=\"params\">(V newValue)</span> </span>&#123;</span><br><span class=\"line\">    V oldValue = value;</span><br><span class=\"line\">    value = newValue;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (o == <span class=\"keyword\">this</span>)</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (o <span class=\"keyword\">instanceof</span> Map.Entry) &#123;</span><br><span class=\"line\">      Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class=\"line\">          Objects.equals(value, e.getValue()))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从Node属性中可以看到Node是一个单向链表，每一个节点保存后继节点的引用。</p>\n<p>那么拉链法解决冲突的时候，是怎么插入数据的呢？在Java8之前是使用头插法，就是新来的值取代原有的值，原有的值会被推到链表中去，因为作者认为后来的值被查找的可能性更大一点，想提升查找效率。但是Java8之后，又改成了尾插法。</p>\n<p>敲黑板！！这里是重点。为什么后来改成尾插法。</p>\n<p>先来看下数据插入的源码。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//这里看到拿到hash码然后进行putVal</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> putVal(hash(key), key, value, <span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> V <span class=\"title\">putVal</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, K key, V value, <span class=\"keyword\">boolean</span> onlyIfAbsent,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">               <span class=\"keyword\">boolean</span> evict)</span> </span>&#123;</span><br><span class=\"line\">  Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class=\"keyword\">int</span> n, i;</span><br><span class=\"line\">  <span class=\"comment\">//先看当前table是不是空的 空的先进行扩容</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> ((tab = table) == <span class=\"keyword\">null</span> || (n = tab.length) == <span class=\"number\">0</span>)</span><br><span class=\"line\">    n = (tab = resize()).length;</span><br><span class=\"line\">  <span class=\"comment\">//判断当前元素在不在hash表中 如果不在 那么直接创建新的节点</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> ((p = tab[i = (n - <span class=\"number\">1</span>) &amp; hash]) == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">    tab[i] = newNode(hash, key, value, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">  <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//发生碰撞</span></span><br><span class=\"line\">    Node&lt;K,V&gt; e; K k;</span><br><span class=\"line\">    <span class=\"comment\">//hash码相等 &amp;&amp; key相等 这里也是为什么重写hashCode 还要重写equals</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p.hash == hash &amp;&amp;</span><br><span class=\"line\">        ((k = p.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">      e = p;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">      <span class=\"comment\">//当前节点已经是树节点了 那么直接使用树节点的插入方法</span></span><br><span class=\"line\">      e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class=\"keyword\">this</span>, tab, hash, key, value);</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">//此时为链表</span></span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> binCount = <span class=\"number\">0</span>; ; ++binCount) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((e = p.next) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">          <span class=\"comment\">//找到最后一个节点然后将新创建的节点插入 尾插法</span></span><br><span class=\"line\">          p.next = newNode(hash, key, value, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">          <span class=\"comment\">//当链表长度大于树化阈值 树化</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class=\"number\">1</span>) <span class=\"comment\">// -1 for 1st</span></span><br><span class=\"line\">            treeifyBin(tab, hash);</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//遍历链表中的key是否存在重复</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">            ((k = e.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        p = e;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//e不等于空 就是key可以认为是同一个key</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// existing mapping for key</span></span><br><span class=\"line\">      V oldValue = e.value;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!onlyIfAbsent || oldValue == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"comment\">//更新value</span></span><br><span class=\"line\">        e.value = value;</span><br><span class=\"line\">      <span class=\"comment\">//回调通知</span></span><br><span class=\"line\">      afterNodeAccess(e);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ++modCount;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (++size &gt; threshold)</span><br><span class=\"line\">    <span class=\"comment\">//扩容</span></span><br><span class=\"line\">    resize();</span><br><span class=\"line\">  <span class=\"comment\">//回调通知</span></span><br><span class=\"line\">  afterNodeInsertion(evict);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里说一下为什么是用(n - 1) &amp; hash。这个是一个取余操作。取余操作中如果除数是2的幂则等价于与其除数减一的与(&amp;)操作，hash%length==hash&amp;(length-1)，前提是长度2的n次方，采用二进制位操作能提高运算效率。这也解释了为什么容量必须是2的幂了。</p>\n<p>看下扩容代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class=\"line\">  Node&lt;K,V&gt;[] oldTab = table;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> oldCap = (oldTab == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : oldTab.length;</span><br><span class=\"line\">  <span class=\"comment\">//以前的扩容阈值</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> oldThr = threshold;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> newCap, newThr = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (oldCap &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//容量已经最大 那么直接修改threshold返回</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class=\"line\">      threshold = Integer.MAX_VALUE;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> oldTab;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//旧容量小于最大值 threshold直接翻倍 容量也翻倍</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((newCap = oldCap &lt;&lt; <span class=\"number\">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class=\"line\">             oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class=\"line\">      newThr = oldThr &lt;&lt; <span class=\"number\">1</span>; <span class=\"comment\">// double threshold</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (oldThr &gt; <span class=\"number\">0</span>) <span class=\"comment\">// initial capacity was placed in threshold</span></span><br><span class=\"line\">    newCap = oldThr;</span><br><span class=\"line\">  <span class=\"keyword\">else</span> &#123;               <span class=\"comment\">// zero initial threshold signifies using defaults</span></span><br><span class=\"line\">    newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class=\"line\">    <span class=\"comment\">//新的容量上限 = 负载因子 * 容量</span></span><br><span class=\"line\">    newThr = (<span class=\"keyword\">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//其实这里比较绕 就是创建的时候指定初始化容量如1 然后第一个数据进来 进入resize中</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (newThr == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//2*0.75 = 1.5 这里newCap是因为上面进行了容量翻倍</span></span><br><span class=\"line\">    <span class=\"keyword\">float</span> ft = (<span class=\"keyword\">float</span>)newCap * loadFactor;</span><br><span class=\"line\">    <span class=\"comment\">//newThr = 1</span></span><br><span class=\"line\">    newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class=\"keyword\">float</span>)MAXIMUM_CAPACITY ?</span><br><span class=\"line\">              (<span class=\"keyword\">int</span>)ft : Integer.MAX_VALUE);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  threshold = newThr;</span><br><span class=\"line\">  <span class=\"meta\">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class=\"line\">  Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class=\"keyword\">new</span> Node[newCap];</span><br><span class=\"line\">  table = newTab;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (oldTab != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//遍历旧的table</span></span><br><span class=\"line\">      Node&lt;K,V&gt; e;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> ((e = oldTab[j]) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        oldTab[j] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e.next == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">          <span class=\"comment\">//如果当前节点不为空并且后继节点为空 直接在newTab找到位置赋值</span></span><br><span class=\"line\">          newTab[e.hash &amp; (newCap - <span class=\"number\">1</span>)] = e;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (e <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">          <span class=\"comment\">//如果是树的结构 进行树的处理</span></span><br><span class=\"line\">          ((TreeNode&lt;K,V&gt;)e).split(<span class=\"keyword\">this</span>, newTab, j, oldCap);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// preserve order</span></span><br><span class=\"line\">          <span class=\"comment\">//如果是链表 需要保持原来的顺序</span></span><br><span class=\"line\">          <span class=\"comment\">//这里根据字段名猜测应该是2个链表 一个lo队列 一个hi队列</span></span><br><span class=\"line\">          Node&lt;K,V&gt; loHead = <span class=\"keyword\">null</span>, loTail = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">          Node&lt;K,V&gt; hiHead = <span class=\"keyword\">null</span>, hiTail = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">          Node&lt;K,V&gt; next;</span><br><span class=\"line\">          <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">            next = e.next;</span><br><span class=\"line\">            <span class=\"comment\">//这里根据e.hash &amp; oldCap的结果来判断节点属于lo还是hi</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((e.hash &amp; oldCap) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">              <span class=\"comment\">//尾插法</span></span><br><span class=\"line\">              <span class=\"keyword\">if</span> (loTail == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                loHead = e;</span><br><span class=\"line\">              <span class=\"keyword\">else</span></span><br><span class=\"line\">                loTail.next = e;</span><br><span class=\"line\">              loTail = e;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">              <span class=\"comment\">//e.hash &amp; oldCap 结果只会为0或者为1</span></span><br><span class=\"line\">              <span class=\"keyword\">if</span> (hiTail == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                hiHead = e;</span><br><span class=\"line\">              <span class=\"keyword\">else</span></span><br><span class=\"line\">                hiTail.next = e;</span><br><span class=\"line\">              hiTail = e;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125; <span class=\"keyword\">while</span> ((e = next) != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">          <span class=\"comment\">//如果loTail非空 那么将lo链表放到newTab[j]的位置上</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (loTail != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            loTail.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            newTab[j] = loHead;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"comment\">//如果hiTail非空 那么将hi链表放到newTab[j+oldCap]的位置上</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (hiTail != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            hiTail.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            newTab[j + oldCap] = hiHead;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> newTab;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>首先来说下，HashMap扩容是2倍扩容的。所以也就意味着原来链表里的key有两个去处，要么是newTab[j] 要么是newTab[j+oldCap]。这个分链表的操作 其实有点像我们站队，老师让我们一二报数，然后按照喊的数字去分组一样。<code>e.hash &amp; oldCap</code> 这个操作就是决定这个节点到底喊的是0还是1的关键。</p>\n<p>有三点明确下：</p>\n<ul>\n<li> oldCap一定是2的整数次幂，这里假设是2^m</li>\n<li> newCap是oldCap的两倍，则newCap为2^(m+1)</li>\n<li> hash对数组大小取模(n-1)&amp;hash其实就是取hash的低m位</li>\n</ul>\n<p>假设oldCap = 16 即2^4</p>\n<p>16-1 = 15 二进制表示为 <code>0000 0000 0000 0000 0000 0000 0000 1111</code> 除了低四位，高位都是0。所以(16-1)&amp;hash 也就可以认为是低四位&amp;hashcode，假设它为abcd。</p>\n<p>当oldCap扩大两倍后，新的index就应该是(32-1)&amp;hash，其实就是取hash值的低五位。此时也就2中情况第五位不是0就是1。也就是0abcd、或者1abcd。其中0abcd和原来的值一样，而1abcd = 0abcd + 1 0000 也就是差了一个oldCap。所以同一个key要么和原来的index一致，要么差了一个oldCap。</p>\n<p>如何拿到第五位的值呢？</p>\n<p>hash &amp; 0000 0000 0000 0000 0000 0000 0001 0000 也就等效于 hash &amp; olcCap</p>\n<p>所以可以得出（e.hash &amp; oldCap) == 0 该节点在新表中的下标位置于旧表一致，（e.hash &amp; oldCap) == 1该节点在新表的下标位置为 j + oldCap</p>\n<p>HashMap中，决定key位置的就是hash函数，看下哈希函数如何实现的</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> h;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (key == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class=\"number\">16</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里看到HashMap对hashCode进行了高16位和低16位进行了异或，这充分利用了高半位和低半位的信息，对低位进行扰动，目的就是使该hashCode映射成数组下标是可以更分散。以初始长度为例，16-1=15，与某散列值“与”操作如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  \t10100101 11000100 00100101</span><br><span class=\"line\">&amp;\t00000000 00000000 00001111</span><br><span class=\"line\">----------------------------------</span><br><span class=\"line\">\t00000000 00000000 00000101       //高位全部归零，只保留末四位</span><br></pre></td></tr></table></figure>\n\n<p>如果散列值算的不够分散，只取最后几位的话，分布上成等差数列的话，碰撞就会很严重。这时候扰动函数的价值就出来了。</p>\n<p><img src=\"https://vqianxiao.github.io/blog/images/hashmap/hashcode.png\"></p>\n<p>右移16位，正好是32bit的一半，自己的高半区和低半区做异或，就是为了混合原始哈希吗的高位和低位，以此来加大随机性。而且混合后的低位参杂了高位的部分特征，这样高位的信息也被变相保留下来。</p>\n<p>总结一下HashMap插入数据流程：</p>\n<p>1.对key重新计算一个扰动过的hash值，(key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</p>\n<p>2.看table是否为空或者长度为0，如果是则进行扩容 if ((tab = table) == null || (n = tab.length) == 0)  n = (tab = resize()).length;</p>\n<p>3.根据hash值计算index的位置，如果该index没有存放数据，则直接插入，如果有数据，那么需要判断key是否相等以及equals方法是否相等，如果相等则覆盖，不相等时，先判断是不是树节点，树节点执行树节点的插入逻辑，否则就是链表，使用拉链法解决冲突，拉链法解决冲突的时候也会检查链表长度是否大于TREEIFY_THRESHOLD阈值，进而执行判断是否需要树化的逻辑。</p>\n<p>4.插入数据完毕，检查当前插入数据是否大于设定容量，进而进行扩容操作。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>本文有一部分思路参考自 <a href=\"https://segmentfault.com/a/1190000015812438\">https://segmentfault.com/a/1190000015812438</a></p>\n</blockquote>\n<p>HashMap是我们平时常用到的kev-value存储的集合。首先来看类定义.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HashMap</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">AbstractMap</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"keyword\">implements</span> <span class=\"title\">Map</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt;, <span class=\"title\">Cloneable</span>, <span class=\"title\">Serializable</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>继承自AbstractMap，其实就是提供一些Map的通用实现，来减少新开发一个Map时不必要的代码。</p>\n<p>实现Map接口 Map就是K-V结构的顶层接口。像List就是集合层次中的根接口。</p>\n<p>Cloneable、Serializable 这两个接口都是标记作用。</p>\n<p>看下HashMap的字段定义</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//默认初始化容量 必须为2的幂</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_INITIAL_CAPACITY = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">4</span>; <span class=\"comment\">// aka 16</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//最大容量 最大为2的30次幂</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MAXIMUM_CAPACITY = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">30</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//负载因子</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> DEFAULT_LOAD_FACTOR = <span class=\"number\">0.75f</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//树化阈值 这个值必须大于2小于8</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> TREEIFY_THRESHOLD = <span class=\"number\">8</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//解构阈值 应小于TREEIFY_THRESHOLD 并且最大为6</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> UNTREEIFY_THRESHOLD = <span class=\"number\">6</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//bin树化最小容量 就是链表的最小长度 </span></span><br><span class=\"line\"><span class=\"comment\">//应至少为 4 * TREEIFY_THRESHOLD，以避免调整大小和树化阈值之间发生冲突</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MIN_TREEIFY_CAPACITY = <span class=\"number\">64</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//存储数据的核心结构</span></span><br><span class=\"line\"><span class=\"keyword\">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//集合中元素个数</span></span><br><span class=\"line\"><span class=\"keyword\">transient</span> <span class=\"keyword\">int</span> size;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//修改次数</span></span><br><span class=\"line\"><span class=\"keyword\">transient</span> <span class=\"keyword\">int</span> modCount;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//要调整大小的下一个大小值（容量 * 负载因子）</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> threshold;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//哈希表中的负载因子</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">float</span> loadFactor;</span><br></pre></td></tr></table></figure>\n\n<p>我们知道HashMap是用数组和链表构成的数据结构。HashMap会用一个指针数组table[]来分散所有的key，当一个key被加入时，会通过Hash算法算出这个数组的下标，然后就把这个K-V插入到table[]中，如果有两个不同的key算出来的下标相同的i，那么就是发生了冲突，也叫碰撞，这样会在table[i]形成一个链表，这种解决冲突的方式叫拉链法。我们知道table[]的尺寸很小，比如只有2个，如果放入10个key的话，碰撞就会很频繁，就从原来的O(1)的查找算法，变成了链表遍历，也就是O(n)。这也是拉链法去解决冲突的缺陷。所以后面使用红黑树利用红黑树的自平衡来保证查找次数的稳定。</p>\n<p>先来看下Node的结构。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Map</span>.<span class=\"title\">Entry</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> hash;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> K key;</span><br><span class=\"line\">  V value;</span><br><span class=\"line\">  Node&lt;K,V&gt; next;</span><br><span class=\"line\"></span><br><span class=\"line\">  Node(<span class=\"keyword\">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.hash = hash;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.key = key;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.value = value;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.next = next;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> K <span class=\"title\">getKey</span><span class=\"params\">()</span>        </span>&#123; <span class=\"keyword\">return</span> key; &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> V <span class=\"title\">getValue</span><span class=\"params\">()</span>      </span>&#123; <span class=\"keyword\">return</span> value; &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> key + <span class=\"string\">&quot;=&quot;</span> + value; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> V <span class=\"title\">setValue</span><span class=\"params\">(V newValue)</span> </span>&#123;</span><br><span class=\"line\">    V oldValue = value;</span><br><span class=\"line\">    value = newValue;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (o == <span class=\"keyword\">this</span>)</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (o <span class=\"keyword\">instanceof</span> Map.Entry) &#123;</span><br><span class=\"line\">      Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class=\"line\">          Objects.equals(value, e.getValue()))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从Node属性中可以看到Node是一个单向链表，每一个节点保存后继节点的引用。</p>\n<p>那么拉链法解决冲突的时候，是怎么插入数据的呢？在Java8之前是使用头插法，就是新来的值取代原有的值，原有的值会被推到链表中去，因为作者认为后来的值被查找的可能性更大一点，想提升查找效率。但是Java8之后，又改成了尾插法。</p>\n<p>敲黑板！！这里是重点。为什么后来改成尾插法。</p>\n<p>先来看下数据插入的源码。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//这里看到拿到hash码然后进行putVal</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> putVal(hash(key), key, value, <span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> V <span class=\"title\">putVal</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, K key, V value, <span class=\"keyword\">boolean</span> onlyIfAbsent,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">               <span class=\"keyword\">boolean</span> evict)</span> </span>&#123;</span><br><span class=\"line\">  Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class=\"keyword\">int</span> n, i;</span><br><span class=\"line\">  <span class=\"comment\">//先看当前table是不是空的 空的先进行扩容</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> ((tab = table) == <span class=\"keyword\">null</span> || (n = tab.length) == <span class=\"number\">0</span>)</span><br><span class=\"line\">    n = (tab = resize()).length;</span><br><span class=\"line\">  <span class=\"comment\">//判断当前元素在不在hash表中 如果不在 那么直接创建新的节点</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> ((p = tab[i = (n - <span class=\"number\">1</span>) &amp; hash]) == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">    tab[i] = newNode(hash, key, value, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">  <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//发生碰撞</span></span><br><span class=\"line\">    Node&lt;K,V&gt; e; K k;</span><br><span class=\"line\">    <span class=\"comment\">//hash码相等 &amp;&amp; key相等 这里也是为什么重写hashCode 还要重写equals</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p.hash == hash &amp;&amp;</span><br><span class=\"line\">        ((k = p.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">      e = p;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">      <span class=\"comment\">//当前节点已经是树节点了 那么直接使用树节点的插入方法</span></span><br><span class=\"line\">      e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class=\"keyword\">this</span>, tab, hash, key, value);</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">//此时为链表</span></span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> binCount = <span class=\"number\">0</span>; ; ++binCount) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((e = p.next) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">          <span class=\"comment\">//找到最后一个节点然后将新创建的节点插入 尾插法</span></span><br><span class=\"line\">          p.next = newNode(hash, key, value, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">          <span class=\"comment\">//当链表长度大于树化阈值 树化</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class=\"number\">1</span>) <span class=\"comment\">// -1 for 1st</span></span><br><span class=\"line\">            treeifyBin(tab, hash);</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//遍历链表中的key是否存在重复</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">            ((k = e.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        p = e;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//e不等于空 就是key可以认为是同一个key</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// existing mapping for key</span></span><br><span class=\"line\">      V oldValue = e.value;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!onlyIfAbsent || oldValue == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"comment\">//更新value</span></span><br><span class=\"line\">        e.value = value;</span><br><span class=\"line\">      <span class=\"comment\">//回调通知</span></span><br><span class=\"line\">      afterNodeAccess(e);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ++modCount;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (++size &gt; threshold)</span><br><span class=\"line\">    <span class=\"comment\">//扩容</span></span><br><span class=\"line\">    resize();</span><br><span class=\"line\">  <span class=\"comment\">//回调通知</span></span><br><span class=\"line\">  afterNodeInsertion(evict);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里说一下为什么是用(n - 1) &amp; hash。这个是一个取余操作。取余操作中如果除数是2的幂则等价于与其除数减一的与(&amp;)操作，hash%length==hash&amp;(length-1)，前提是长度2的n次方，采用二进制位操作能提高运算效率。这也解释了为什么容量必须是2的幂了。</p>\n<p>看下扩容代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class=\"line\">  Node&lt;K,V&gt;[] oldTab = table;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> oldCap = (oldTab == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : oldTab.length;</span><br><span class=\"line\">  <span class=\"comment\">//以前的扩容阈值</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> oldThr = threshold;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> newCap, newThr = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (oldCap &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//容量已经最大 那么直接修改threshold返回</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class=\"line\">      threshold = Integer.MAX_VALUE;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> oldTab;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//旧容量小于最大值 threshold直接翻倍 容量也翻倍</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((newCap = oldCap &lt;&lt; <span class=\"number\">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class=\"line\">             oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class=\"line\">      newThr = oldThr &lt;&lt; <span class=\"number\">1</span>; <span class=\"comment\">// double threshold</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (oldThr &gt; <span class=\"number\">0</span>) <span class=\"comment\">// initial capacity was placed in threshold</span></span><br><span class=\"line\">    newCap = oldThr;</span><br><span class=\"line\">  <span class=\"keyword\">else</span> &#123;               <span class=\"comment\">// zero initial threshold signifies using defaults</span></span><br><span class=\"line\">    newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class=\"line\">    <span class=\"comment\">//新的容量上限 = 负载因子 * 容量</span></span><br><span class=\"line\">    newThr = (<span class=\"keyword\">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//其实这里比较绕 就是创建的时候指定初始化容量如1 然后第一个数据进来 进入resize中</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (newThr == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//2*0.75 = 1.5 这里newCap是因为上面进行了容量翻倍</span></span><br><span class=\"line\">    <span class=\"keyword\">float</span> ft = (<span class=\"keyword\">float</span>)newCap * loadFactor;</span><br><span class=\"line\">    <span class=\"comment\">//newThr = 1</span></span><br><span class=\"line\">    newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class=\"keyword\">float</span>)MAXIMUM_CAPACITY ?</span><br><span class=\"line\">              (<span class=\"keyword\">int</span>)ft : Integer.MAX_VALUE);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  threshold = newThr;</span><br><span class=\"line\">  <span class=\"meta\">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class=\"line\">  Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class=\"keyword\">new</span> Node[newCap];</span><br><span class=\"line\">  table = newTab;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (oldTab != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//遍历旧的table</span></span><br><span class=\"line\">      Node&lt;K,V&gt; e;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> ((e = oldTab[j]) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        oldTab[j] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e.next == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">          <span class=\"comment\">//如果当前节点不为空并且后继节点为空 直接在newTab找到位置赋值</span></span><br><span class=\"line\">          newTab[e.hash &amp; (newCap - <span class=\"number\">1</span>)] = e;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (e <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">          <span class=\"comment\">//如果是树的结构 进行树的处理</span></span><br><span class=\"line\">          ((TreeNode&lt;K,V&gt;)e).split(<span class=\"keyword\">this</span>, newTab, j, oldCap);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// preserve order</span></span><br><span class=\"line\">          <span class=\"comment\">//如果是链表 需要保持原来的顺序</span></span><br><span class=\"line\">          <span class=\"comment\">//这里根据字段名猜测应该是2个链表 一个lo队列 一个hi队列</span></span><br><span class=\"line\">          Node&lt;K,V&gt; loHead = <span class=\"keyword\">null</span>, loTail = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">          Node&lt;K,V&gt; hiHead = <span class=\"keyword\">null</span>, hiTail = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">          Node&lt;K,V&gt; next;</span><br><span class=\"line\">          <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">            next = e.next;</span><br><span class=\"line\">            <span class=\"comment\">//这里根据e.hash &amp; oldCap的结果来判断节点属于lo还是hi</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((e.hash &amp; oldCap) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">              <span class=\"comment\">//尾插法</span></span><br><span class=\"line\">              <span class=\"keyword\">if</span> (loTail == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                loHead = e;</span><br><span class=\"line\">              <span class=\"keyword\">else</span></span><br><span class=\"line\">                loTail.next = e;</span><br><span class=\"line\">              loTail = e;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">              <span class=\"comment\">//e.hash &amp; oldCap 结果只会为0或者为1</span></span><br><span class=\"line\">              <span class=\"keyword\">if</span> (hiTail == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                hiHead = e;</span><br><span class=\"line\">              <span class=\"keyword\">else</span></span><br><span class=\"line\">                hiTail.next = e;</span><br><span class=\"line\">              hiTail = e;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125; <span class=\"keyword\">while</span> ((e = next) != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">          <span class=\"comment\">//如果loTail非空 那么将lo链表放到newTab[j]的位置上</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (loTail != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            loTail.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            newTab[j] = loHead;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"comment\">//如果hiTail非空 那么将hi链表放到newTab[j+oldCap]的位置上</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (hiTail != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            hiTail.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            newTab[j + oldCap] = hiHead;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> newTab;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>首先来说下，HashMap扩容是2倍扩容的。所以也就意味着原来链表里的key有两个去处，要么是newTab[j] 要么是newTab[j+oldCap]。这个分链表的操作 其实有点像我们站队，老师让我们一二报数，然后按照喊的数字去分组一样。<code>e.hash &amp; oldCap</code> 这个操作就是决定这个节点到底喊的是0还是1的关键。</p>\n<p>有三点明确下：</p>\n<ul>\n<li> oldCap一定是2的整数次幂，这里假设是2^m</li>\n<li> newCap是oldCap的两倍，则newCap为2^(m+1)</li>\n<li> hash对数组大小取模(n-1)&amp;hash其实就是取hash的低m位</li>\n</ul>\n<p>假设oldCap = 16 即2^4</p>\n<p>16-1 = 15 二进制表示为 <code>0000 0000 0000 0000 0000 0000 0000 1111</code> 除了低四位，高位都是0。所以(16-1)&amp;hash 也就可以认为是低四位&amp;hashcode，假设它为abcd。</p>\n<p>当oldCap扩大两倍后，新的index就应该是(32-1)&amp;hash，其实就是取hash值的低五位。此时也就2中情况第五位不是0就是1。也就是0abcd、或者1abcd。其中0abcd和原来的值一样，而1abcd = 0abcd + 1 0000 也就是差了一个oldCap。所以同一个key要么和原来的index一致，要么差了一个oldCap。</p>\n<p>如何拿到第五位的值呢？</p>\n<p>hash &amp; 0000 0000 0000 0000 0000 0000 0001 0000 也就等效于 hash &amp; olcCap</p>\n<p>所以可以得出（e.hash &amp; oldCap) == 0 该节点在新表中的下标位置于旧表一致，（e.hash &amp; oldCap) == 1该节点在新表的下标位置为 j + oldCap</p>\n<p>HashMap中，决定key位置的就是hash函数，看下哈希函数如何实现的</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> h;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (key == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class=\"number\">16</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里看到HashMap对hashCode进行了高16位和低16位进行了异或，这充分利用了高半位和低半位的信息，对低位进行扰动，目的就是使该hashCode映射成数组下标是可以更分散。以初始长度为例，16-1=15，与某散列值“与”操作如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  \t10100101 11000100 00100101</span><br><span class=\"line\">&amp;\t00000000 00000000 00001111</span><br><span class=\"line\">----------------------------------</span><br><span class=\"line\">\t00000000 00000000 00000101       //高位全部归零，只保留末四位</span><br></pre></td></tr></table></figure>\n\n<p>如果散列值算的不够分散，只取最后几位的话，分布上成等差数列的话，碰撞就会很严重。这时候扰动函数的价值就出来了。</p>\n<p><img src=\"https://vqianxiao.github.io/blog/images/hashmap/hashcode.png\"></p>\n<p>右移16位，正好是32bit的一半，自己的高半区和低半区做异或，就是为了混合原始哈希吗的高位和低位，以此来加大随机性。而且混合后的低位参杂了高位的部分特征，这样高位的信息也被变相保留下来。</p>\n<p>总结一下HashMap插入数据流程：</p>\n<p>1.对key重新计算一个扰动过的hash值，(key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</p>\n<p>2.看table是否为空或者长度为0，如果是则进行扩容 if ((tab = table) == null || (n = tab.length) == 0)  n = (tab = resize()).length;</p>\n<p>3.根据hash值计算index的位置，如果该index没有存放数据，则直接插入，如果有数据，那么需要判断key是否相等以及equals方法是否相等，如果相等则覆盖，不相等时，先判断是不是树节点，树节点执行树节点的插入逻辑，否则就是链表，使用拉链法解决冲突，拉链法解决冲突的时候也会检查链表长度是否大于TREEIFY_THRESHOLD阈值，进而执行判断是否需要树化的逻辑。</p>\n<p>4.插入数据完毕，检查当前插入数据是否大于设定容量，进而进行扩容操作。</p>\n"},{"layout":"post","title":"死磕LinkedList源码","description":"死磕LinkedList源码","date":"2021-08-11T11:42:10.000Z","_content":"\nLinkedList底层使用的是双向链表来保存元素的。继承自`AbstractSequentialList` 实现了List、Deque、Cloneable、Serializable接口。\n\nDeque接口表明是双向链表，说明LinkedList支持双向链表的特性。\n\n还是看下属性\n\n```java\n//长度\ntransient int size = 0;\n\n//头结点\ntransient Node<E> first;\n\n//尾结点\ntransient Node<E> last;\n```\n\n先看下Node长什么样吧\n\n```java\n//item 表示元素 next表示后面的节点 prev表示前面的节点\nprivate static class Node<E> {\n  E item;\n  Node<E> next;\n  Node<E> prev;\n\n  Node(Node<E> prev, E element, Node<E> next) {\n    this.item = element;\n    this.next = next;\n    this.prev = prev;\n  }\n}\n```\n\n链表和数组操作不太一样，一般就是头插法和尾插法。\n\n```java\npublic void addFirst(E e) {\n  linkFirst(e);\n}\nprivate void linkFirst(E e) {\n  //先拿到当前的第一个节点\n  final Node<E> f = first;\n  //创建一个新的结点\n  final Node<E> newNode = new Node<>(null, e, f);\n  //将新的节点放到第一个节点的位置上\n  first = newNode;\n  if (f == null)\n    //如果头节点为空 把新的节点赋值给最后一个节点 此时头节点 尾节点都为同一个节点\n    last = newNode;\n  else\n    //头节点有值 那么把新的节点赋值给原来头节点的前驱节点\n    f.prev = newNode;\n  size++;\n  modCount++;\n}\n\npublic void addLast(E e) {\n  linkLast(e);\n}\n\n//与头插法类似\nvoid linkLast(E e) {\n  final Node<E> l = last;\n  final Node<E> newNode = new Node<>(l, e, null);\n  last = newNode;\n  if (l == null)\n    first = newNode;\n  else\n    l.next = newNode;\n  size++;\n  modCount++;\n}\n```\n\n假设链表此时为空，那么插入一个元素1，此时first节点就是1，该节点的前驱节点后继节点都为空，last节点也为1。然后再从头部插入一个元素2，元素2节点的后继节点为1的那个节点，然后头节点变成元素2的那个节点，元素1的前驱节点变成元素2的节点。\n\n这里说一下双向链表和单向链表，单向链表就是从头到尾只有这种关系的链表，前一个节点只保存后一个节点的位置和自身的值，只可以从前往后遍历。双向链表是每一个节点保存一个前驱节点和一个后续节点以及自身的值，可以向前也可以向后遍历。\n\n删除的元素的话，也是和插入一样，可以从头部删除也可以从尾部删除。\n\n```java\npublic E removeFirst() {\n  final Node<E> f = first;\n  if (f == null)\n    throw new NoSuchElementException();\n  return unlinkFirst(f);\n}\n\nprivate E unlinkFirst(Node<E> f) {\n  // assert f == first && f != null;\n  final E element = f.item;\n  //拿到当前节点的下一个节点\n  final Node<E> next = f.next;\n  f.item = null;\n  f.next = null; // help GC\n  //将头节点指向下一个节点\n  first = next;\n  if (next == null)\n    //此时链表为空了所以last要清空\n    last = null;\n  else\n    next.prev = null;\n  size--;\n  modCount++;\n  return element;\n}\n\npublic E removeLast() {\n  final Node<E> l = last;\n  if (l == null)\n    throw new NoSuchElementException();\n  return unlinkLast(l);\n}\n\nprivate E unlinkLast(Node<E> l) {\n  // assert l == last && l != null;\n  final E element = l.item;\n  final Node<E> prev = l.prev;\n  l.item = null;\n  l.prev = null; // help GC\n  last = prev;\n  if (prev == null)\n    first = null;\n  else\n    prev.next = null;\n  size--;\n  modCount++;\n  return element;\n}\n```\n\n还有一种根据对象去删除元素，其实就是遍历去找这个元素，然后把这个元素的前驱节点和后继节点直接连接起来。\n\n```java\npublic boolean remove(Object o) {\n  if (o == null) {\n    for (Node<E> x = first; x != null; x = x.next) {\n      if (x.item == null) {\n        unlink(x);\n        return true;\n      }\n    }\n  } else {\n    for (Node<E> x = first; x != null; x = x.next) {\n      if (o.equals(x.item)) {\n        unlink(x);\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nE unlink(Node<E> x) {\n  // assert x != null;\n  final E element = x.item;\n  final Node<E> next = x.next;\n  final Node<E> prev = x.prev;\n\n  //如果当前节点前驱节点为空 那么只要将头节点指向当前节点的后继节点即可\n  if (prev == null) {\n    first = next;\n  } else {\n    //将前驱节点的后继节点指向当前节点的后继节点\n    prev.next = next;\n    x.prev = null;\n  }\n\n  //如果当前节点后继节点为空 那么只要将尾节点指向当前节点的前驱节点即可\n  if (next == null) {\n    last = prev;\n  } else {\n    //将后继节点的前驱节点指向当前节点的前驱节点\n    next.prev = prev;\n    x.next = null;\n  }\n\n  x.item = null;\n  size--;\n  modCount++;\n  return element;\n}\n```\n\n看下根据index查找Node的方法\n\n```java\nNode<E> node(int index) {\n  // assert isElementIndex(index);\n\n  //当index<(size/2)的时候 那么从前往后找\n  if (index < (size >> 1)) {\n    Node<E> x = first;\n    for (int i = 0; i < index; i++)\n      x = x.next;\n    return x;\n  } else {\n  //当(index>=size/2)的时候 从后往前找\n    Node<E> x = last;\n    for (int i = size - 1; i > index; i--)\n      x = x.prev;\n    return x;\n  }\n}\n```\n\n其实就是为了找到一个离index比较近的方向，然后从那个方向开始遍历。这里需要注意一下，虽然LinkedList不是数组，但是index还是从0开始的。\n\n然后看下往指定位置插入元素的方法\n\n```java\npublic void add(int index, E element) {\n  checkPositionIndex(index);\n  //当index等于size时 直接往最后插入 其实这里有点奇怪 为什么不把往头部插入也一起判断出来呢\n  if (index == size)\n    linkLast(element);\n  else\n    linkBefore(element, node(index));\n}\n\n//其实这个思路就是新创建一个节点 然后将当前节点的前驱节点指向新创建的节点\nvoid linkBefore(E e, Node<E> succ) {\n  // assert succ != null;\n  //拿到当前节点的前驱节点\n  final Node<E> pred = succ.prev;\n  //创建新的节点\n  final Node<E> newNode = new Node<>(pred, e, succ);\n  //当前节点的前驱指向新创建的节点\n  succ.prev = newNode;\n  if (pred == null)\n    first = newNode;\n  else\n    pred.next = newNode;\n  size++;\n  modCount++;\n}\n```\n\n所以以上这些设计，导致了LinkedList的插入删除操作成本较低，因为没有扩容，但是随机访问效率不如ArrayList。所以可以根据实际场景选择合适的集合。\n\n","source":"_posts/死磕LinkedList源码.md","raw":"---\nlayout:    post\ntitle:     死磕LinkedList源码\ncategory:  源码解析\ndescription: 死磕LinkedList源码\ntags: JDK\ndate: 2021/08/11 19:42:10\n\n\n---\n\nLinkedList底层使用的是双向链表来保存元素的。继承自`AbstractSequentialList` 实现了List、Deque、Cloneable、Serializable接口。\n\nDeque接口表明是双向链表，说明LinkedList支持双向链表的特性。\n\n还是看下属性\n\n```java\n//长度\ntransient int size = 0;\n\n//头结点\ntransient Node<E> first;\n\n//尾结点\ntransient Node<E> last;\n```\n\n先看下Node长什么样吧\n\n```java\n//item 表示元素 next表示后面的节点 prev表示前面的节点\nprivate static class Node<E> {\n  E item;\n  Node<E> next;\n  Node<E> prev;\n\n  Node(Node<E> prev, E element, Node<E> next) {\n    this.item = element;\n    this.next = next;\n    this.prev = prev;\n  }\n}\n```\n\n链表和数组操作不太一样，一般就是头插法和尾插法。\n\n```java\npublic void addFirst(E e) {\n  linkFirst(e);\n}\nprivate void linkFirst(E e) {\n  //先拿到当前的第一个节点\n  final Node<E> f = first;\n  //创建一个新的结点\n  final Node<E> newNode = new Node<>(null, e, f);\n  //将新的节点放到第一个节点的位置上\n  first = newNode;\n  if (f == null)\n    //如果头节点为空 把新的节点赋值给最后一个节点 此时头节点 尾节点都为同一个节点\n    last = newNode;\n  else\n    //头节点有值 那么把新的节点赋值给原来头节点的前驱节点\n    f.prev = newNode;\n  size++;\n  modCount++;\n}\n\npublic void addLast(E e) {\n  linkLast(e);\n}\n\n//与头插法类似\nvoid linkLast(E e) {\n  final Node<E> l = last;\n  final Node<E> newNode = new Node<>(l, e, null);\n  last = newNode;\n  if (l == null)\n    first = newNode;\n  else\n    l.next = newNode;\n  size++;\n  modCount++;\n}\n```\n\n假设链表此时为空，那么插入一个元素1，此时first节点就是1，该节点的前驱节点后继节点都为空，last节点也为1。然后再从头部插入一个元素2，元素2节点的后继节点为1的那个节点，然后头节点变成元素2的那个节点，元素1的前驱节点变成元素2的节点。\n\n这里说一下双向链表和单向链表，单向链表就是从头到尾只有这种关系的链表，前一个节点只保存后一个节点的位置和自身的值，只可以从前往后遍历。双向链表是每一个节点保存一个前驱节点和一个后续节点以及自身的值，可以向前也可以向后遍历。\n\n删除的元素的话，也是和插入一样，可以从头部删除也可以从尾部删除。\n\n```java\npublic E removeFirst() {\n  final Node<E> f = first;\n  if (f == null)\n    throw new NoSuchElementException();\n  return unlinkFirst(f);\n}\n\nprivate E unlinkFirst(Node<E> f) {\n  // assert f == first && f != null;\n  final E element = f.item;\n  //拿到当前节点的下一个节点\n  final Node<E> next = f.next;\n  f.item = null;\n  f.next = null; // help GC\n  //将头节点指向下一个节点\n  first = next;\n  if (next == null)\n    //此时链表为空了所以last要清空\n    last = null;\n  else\n    next.prev = null;\n  size--;\n  modCount++;\n  return element;\n}\n\npublic E removeLast() {\n  final Node<E> l = last;\n  if (l == null)\n    throw new NoSuchElementException();\n  return unlinkLast(l);\n}\n\nprivate E unlinkLast(Node<E> l) {\n  // assert l == last && l != null;\n  final E element = l.item;\n  final Node<E> prev = l.prev;\n  l.item = null;\n  l.prev = null; // help GC\n  last = prev;\n  if (prev == null)\n    first = null;\n  else\n    prev.next = null;\n  size--;\n  modCount++;\n  return element;\n}\n```\n\n还有一种根据对象去删除元素，其实就是遍历去找这个元素，然后把这个元素的前驱节点和后继节点直接连接起来。\n\n```java\npublic boolean remove(Object o) {\n  if (o == null) {\n    for (Node<E> x = first; x != null; x = x.next) {\n      if (x.item == null) {\n        unlink(x);\n        return true;\n      }\n    }\n  } else {\n    for (Node<E> x = first; x != null; x = x.next) {\n      if (o.equals(x.item)) {\n        unlink(x);\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nE unlink(Node<E> x) {\n  // assert x != null;\n  final E element = x.item;\n  final Node<E> next = x.next;\n  final Node<E> prev = x.prev;\n\n  //如果当前节点前驱节点为空 那么只要将头节点指向当前节点的后继节点即可\n  if (prev == null) {\n    first = next;\n  } else {\n    //将前驱节点的后继节点指向当前节点的后继节点\n    prev.next = next;\n    x.prev = null;\n  }\n\n  //如果当前节点后继节点为空 那么只要将尾节点指向当前节点的前驱节点即可\n  if (next == null) {\n    last = prev;\n  } else {\n    //将后继节点的前驱节点指向当前节点的前驱节点\n    next.prev = prev;\n    x.next = null;\n  }\n\n  x.item = null;\n  size--;\n  modCount++;\n  return element;\n}\n```\n\n看下根据index查找Node的方法\n\n```java\nNode<E> node(int index) {\n  // assert isElementIndex(index);\n\n  //当index<(size/2)的时候 那么从前往后找\n  if (index < (size >> 1)) {\n    Node<E> x = first;\n    for (int i = 0; i < index; i++)\n      x = x.next;\n    return x;\n  } else {\n  //当(index>=size/2)的时候 从后往前找\n    Node<E> x = last;\n    for (int i = size - 1; i > index; i--)\n      x = x.prev;\n    return x;\n  }\n}\n```\n\n其实就是为了找到一个离index比较近的方向，然后从那个方向开始遍历。这里需要注意一下，虽然LinkedList不是数组，但是index还是从0开始的。\n\n然后看下往指定位置插入元素的方法\n\n```java\npublic void add(int index, E element) {\n  checkPositionIndex(index);\n  //当index等于size时 直接往最后插入 其实这里有点奇怪 为什么不把往头部插入也一起判断出来呢\n  if (index == size)\n    linkLast(element);\n  else\n    linkBefore(element, node(index));\n}\n\n//其实这个思路就是新创建一个节点 然后将当前节点的前驱节点指向新创建的节点\nvoid linkBefore(E e, Node<E> succ) {\n  // assert succ != null;\n  //拿到当前节点的前驱节点\n  final Node<E> pred = succ.prev;\n  //创建新的节点\n  final Node<E> newNode = new Node<>(pred, e, succ);\n  //当前节点的前驱指向新创建的节点\n  succ.prev = newNode;\n  if (pred == null)\n    first = newNode;\n  else\n    pred.next = newNode;\n  size++;\n  modCount++;\n}\n```\n\n所以以上这些设计，导致了LinkedList的插入删除操作成本较低，因为没有扩容，但是随机访问效率不如ArrayList。所以可以根据实际场景选择合适的集合。\n\n","slug":"死磕LinkedList源码","published":1,"updated":"2021-08-11T11:42:10.000Z","comments":1,"photos":[],"link":"","_id":"cm1m304xa000h31b40ybvboak","content":"<p>LinkedList底层使用的是双向链表来保存元素的。继承自<code>AbstractSequentialList</code> 实现了List、Deque、Cloneable、Serializable接口。</p>\n<p>Deque接口表明是双向链表，说明LinkedList支持双向链表的特性。</p>\n<p>还是看下属性</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//长度</span></span><br><span class=\"line\"><span class=\"keyword\">transient</span> <span class=\"keyword\">int</span> size = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//头结点</span></span><br><span class=\"line\"><span class=\"keyword\">transient</span> Node&lt;E&gt; first;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//尾结点</span></span><br><span class=\"line\"><span class=\"keyword\">transient</span> Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure>\n\n<p>先看下Node长什么样吧</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//item 表示元素 next表示后面的节点 prev表示前面的节点</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span>&lt;<span class=\"title\">E</span>&gt; </span>&#123;</span><br><span class=\"line\">  E item;</span><br><span class=\"line\">  Node&lt;E&gt; next;</span><br><span class=\"line\">  Node&lt;E&gt; prev;</span><br><span class=\"line\"></span><br><span class=\"line\">  Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.item = element;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.next = next;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.prev = prev;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>链表和数组操作不太一样，一般就是头插法和尾插法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addFirst</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">  linkFirst(e);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">linkFirst</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//先拿到当前的第一个节点</span></span><br><span class=\"line\">  <span class=\"keyword\">final</span> Node&lt;E&gt; f = first;</span><br><span class=\"line\">  <span class=\"comment\">//创建一个新的结点</span></span><br><span class=\"line\">  <span class=\"keyword\">final</span> Node&lt;E&gt; newNode = <span class=\"keyword\">new</span> Node&lt;&gt;(<span class=\"keyword\">null</span>, e, f);</span><br><span class=\"line\">  <span class=\"comment\">//将新的节点放到第一个节点的位置上</span></span><br><span class=\"line\">  first = newNode;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (f == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">    <span class=\"comment\">//如果头节点为空 把新的节点赋值给最后一个节点 此时头节点 尾节点都为同一个节点</span></span><br><span class=\"line\">    last = newNode;</span><br><span class=\"line\">  <span class=\"keyword\">else</span></span><br><span class=\"line\">    <span class=\"comment\">//头节点有值 那么把新的节点赋值给原来头节点的前驱节点</span></span><br><span class=\"line\">    f.prev = newNode;</span><br><span class=\"line\">  size++;</span><br><span class=\"line\">  modCount++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addLast</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">  linkLast(e);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//与头插法类似</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">linkLast</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> Node&lt;E&gt; l = last;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> Node&lt;E&gt; newNode = <span class=\"keyword\">new</span> Node&lt;&gt;(l, e, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">  last = newNode;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (l == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">    first = newNode;</span><br><span class=\"line\">  <span class=\"keyword\">else</span></span><br><span class=\"line\">    l.next = newNode;</span><br><span class=\"line\">  size++;</span><br><span class=\"line\">  modCount++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>假设链表此时为空，那么插入一个元素1，此时first节点就是1，该节点的前驱节点后继节点都为空，last节点也为1。然后再从头部插入一个元素2，元素2节点的后继节点为1的那个节点，然后头节点变成元素2的那个节点，元素1的前驱节点变成元素2的节点。</p>\n<p>这里说一下双向链表和单向链表，单向链表就是从头到尾只有这种关系的链表，前一个节点只保存后一个节点的位置和自身的值，只可以从前往后遍历。双向链表是每一个节点保存一个前驱节点和一个后续节点以及自身的值，可以向前也可以向后遍历。</p>\n<p>删除的元素的话，也是和插入一样，可以从头部删除也可以从尾部删除。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">removeFirst</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> Node&lt;E&gt; f = first;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (f == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NoSuchElementException();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> unlinkFirst(f);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> E <span class=\"title\">unlinkFirst</span><span class=\"params\">(Node&lt;E&gt; f)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// assert f == first &amp;&amp; f != null;</span></span><br><span class=\"line\">  <span class=\"keyword\">final</span> E element = f.item;</span><br><span class=\"line\">  <span class=\"comment\">//拿到当前节点的下一个节点</span></span><br><span class=\"line\">  <span class=\"keyword\">final</span> Node&lt;E&gt; next = f.next;</span><br><span class=\"line\">  f.item = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">  f.next = <span class=\"keyword\">null</span>; <span class=\"comment\">// help GC</span></span><br><span class=\"line\">  <span class=\"comment\">//将头节点指向下一个节点</span></span><br><span class=\"line\">  first = next;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (next == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">    <span class=\"comment\">//此时链表为空了所以last要清空</span></span><br><span class=\"line\">    last = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">else</span></span><br><span class=\"line\">    next.prev = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">  size--;</span><br><span class=\"line\">  modCount++;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> element;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">removeLast</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> Node&lt;E&gt; l = last;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (l == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NoSuchElementException();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> unlinkLast(l);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> E <span class=\"title\">unlinkLast</span><span class=\"params\">(Node&lt;E&gt; l)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// assert l == last &amp;&amp; l != null;</span></span><br><span class=\"line\">  <span class=\"keyword\">final</span> E element = l.item;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> Node&lt;E&gt; prev = l.prev;</span><br><span class=\"line\">  l.item = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">  l.prev = <span class=\"keyword\">null</span>; <span class=\"comment\">// help GC</span></span><br><span class=\"line\">  last = prev;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (prev == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">    first = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">else</span></span><br><span class=\"line\">    prev.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">  size--;</span><br><span class=\"line\">  modCount++;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> element;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>还有一种根据对象去删除元素，其实就是遍历去找这个元素，然后把这个元素的前驱节点和后继节点直接连接起来。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">remove</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (o == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Node&lt;E&gt; x = first; x != <span class=\"keyword\">null</span>; x = x.next) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (x.item == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        unlink(x);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Node&lt;E&gt; x = first; x != <span class=\"keyword\">null</span>; x = x.next) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (o.equals(x.item)) &#123;</span><br><span class=\"line\">        unlink(x);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">E <span class=\"title\">unlink</span><span class=\"params\">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// assert x != null;</span></span><br><span class=\"line\">  <span class=\"keyword\">final</span> E element = x.item;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> Node&lt;E&gt; next = x.next;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//如果当前节点前驱节点为空 那么只要将头节点指向当前节点的后继节点即可</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (prev == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    first = next;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//将前驱节点的后继节点指向当前节点的后继节点</span></span><br><span class=\"line\">    prev.next = next;</span><br><span class=\"line\">    x.prev = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//如果当前节点后继节点为空 那么只要将尾节点指向当前节点的前驱节点即可</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (next == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    last = prev;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//将后继节点的前驱节点指向当前节点的前驱节点</span></span><br><span class=\"line\">    next.prev = prev;</span><br><span class=\"line\">    x.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  x.item = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">  size--;</span><br><span class=\"line\">  modCount++;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> element;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>看下根据index查找Node的方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Node&lt;E&gt; <span class=\"title\">node</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// assert isElementIndex(index);</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//当index&lt;(size/2)的时候 那么从前往后找</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (index &lt; (size &gt;&gt; <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">    Node&lt;E&gt; x = first;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; index; i++)</span><br><span class=\"line\">      x = x.next;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">//当(index&gt;=size/2)的时候 从后往前找</span></span><br><span class=\"line\">    Node&lt;E&gt; x = last;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = size - <span class=\"number\">1</span>; i &gt; index; i--)</span><br><span class=\"line\">      x = x.prev;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其实就是为了找到一个离index比较近的方向，然后从那个方向开始遍历。这里需要注意一下，虽然LinkedList不是数组，但是index还是从0开始的。</p>\n<p>然后看下往指定位置插入元素的方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> index, E element)</span> </span>&#123;</span><br><span class=\"line\">  checkPositionIndex(index);</span><br><span class=\"line\">  <span class=\"comment\">//当index等于size时 直接往最后插入 其实这里有点奇怪 为什么不把往头部插入也一起判断出来呢</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (index == size)</span><br><span class=\"line\">    linkLast(element);</span><br><span class=\"line\">  <span class=\"keyword\">else</span></span><br><span class=\"line\">    linkBefore(element, node(index));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//其实这个思路就是新创建一个节点 然后将当前节点的前驱节点指向新创建的节点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">linkBefore</span><span class=\"params\">(E e, Node&lt;E&gt; succ)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// assert succ != null;</span></span><br><span class=\"line\">  <span class=\"comment\">//拿到当前节点的前驱节点</span></span><br><span class=\"line\">  <span class=\"keyword\">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class=\"line\">  <span class=\"comment\">//创建新的节点</span></span><br><span class=\"line\">  <span class=\"keyword\">final</span> Node&lt;E&gt; newNode = <span class=\"keyword\">new</span> Node&lt;&gt;(pred, e, succ);</span><br><span class=\"line\">  <span class=\"comment\">//当前节点的前驱指向新创建的节点</span></span><br><span class=\"line\">  succ.prev = newNode;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (pred == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">    first = newNode;</span><br><span class=\"line\">  <span class=\"keyword\">else</span></span><br><span class=\"line\">    pred.next = newNode;</span><br><span class=\"line\">  size++;</span><br><span class=\"line\">  modCount++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>所以以上这些设计，导致了LinkedList的插入删除操作成本较低，因为没有扩容，但是随机访问效率不如ArrayList。所以可以根据实际场景选择合适的集合。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>LinkedList底层使用的是双向链表来保存元素的。继承自<code>AbstractSequentialList</code> 实现了List、Deque、Cloneable、Serializable接口。</p>\n<p>Deque接口表明是双向链表，说明LinkedList支持双向链表的特性。</p>\n<p>还是看下属性</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//长度</span></span><br><span class=\"line\"><span class=\"keyword\">transient</span> <span class=\"keyword\">int</span> size = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//头结点</span></span><br><span class=\"line\"><span class=\"keyword\">transient</span> Node&lt;E&gt; first;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//尾结点</span></span><br><span class=\"line\"><span class=\"keyword\">transient</span> Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure>\n\n<p>先看下Node长什么样吧</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//item 表示元素 next表示后面的节点 prev表示前面的节点</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span>&lt;<span class=\"title\">E</span>&gt; </span>&#123;</span><br><span class=\"line\">  E item;</span><br><span class=\"line\">  Node&lt;E&gt; next;</span><br><span class=\"line\">  Node&lt;E&gt; prev;</span><br><span class=\"line\"></span><br><span class=\"line\">  Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.item = element;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.next = next;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.prev = prev;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>链表和数组操作不太一样，一般就是头插法和尾插法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addFirst</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">  linkFirst(e);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">linkFirst</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//先拿到当前的第一个节点</span></span><br><span class=\"line\">  <span class=\"keyword\">final</span> Node&lt;E&gt; f = first;</span><br><span class=\"line\">  <span class=\"comment\">//创建一个新的结点</span></span><br><span class=\"line\">  <span class=\"keyword\">final</span> Node&lt;E&gt; newNode = <span class=\"keyword\">new</span> Node&lt;&gt;(<span class=\"keyword\">null</span>, e, f);</span><br><span class=\"line\">  <span class=\"comment\">//将新的节点放到第一个节点的位置上</span></span><br><span class=\"line\">  first = newNode;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (f == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">    <span class=\"comment\">//如果头节点为空 把新的节点赋值给最后一个节点 此时头节点 尾节点都为同一个节点</span></span><br><span class=\"line\">    last = newNode;</span><br><span class=\"line\">  <span class=\"keyword\">else</span></span><br><span class=\"line\">    <span class=\"comment\">//头节点有值 那么把新的节点赋值给原来头节点的前驱节点</span></span><br><span class=\"line\">    f.prev = newNode;</span><br><span class=\"line\">  size++;</span><br><span class=\"line\">  modCount++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addLast</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">  linkLast(e);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//与头插法类似</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">linkLast</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> Node&lt;E&gt; l = last;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> Node&lt;E&gt; newNode = <span class=\"keyword\">new</span> Node&lt;&gt;(l, e, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">  last = newNode;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (l == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">    first = newNode;</span><br><span class=\"line\">  <span class=\"keyword\">else</span></span><br><span class=\"line\">    l.next = newNode;</span><br><span class=\"line\">  size++;</span><br><span class=\"line\">  modCount++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>假设链表此时为空，那么插入一个元素1，此时first节点就是1，该节点的前驱节点后继节点都为空，last节点也为1。然后再从头部插入一个元素2，元素2节点的后继节点为1的那个节点，然后头节点变成元素2的那个节点，元素1的前驱节点变成元素2的节点。</p>\n<p>这里说一下双向链表和单向链表，单向链表就是从头到尾只有这种关系的链表，前一个节点只保存后一个节点的位置和自身的值，只可以从前往后遍历。双向链表是每一个节点保存一个前驱节点和一个后续节点以及自身的值，可以向前也可以向后遍历。</p>\n<p>删除的元素的话，也是和插入一样，可以从头部删除也可以从尾部删除。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">removeFirst</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> Node&lt;E&gt; f = first;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (f == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NoSuchElementException();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> unlinkFirst(f);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> E <span class=\"title\">unlinkFirst</span><span class=\"params\">(Node&lt;E&gt; f)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// assert f == first &amp;&amp; f != null;</span></span><br><span class=\"line\">  <span class=\"keyword\">final</span> E element = f.item;</span><br><span class=\"line\">  <span class=\"comment\">//拿到当前节点的下一个节点</span></span><br><span class=\"line\">  <span class=\"keyword\">final</span> Node&lt;E&gt; next = f.next;</span><br><span class=\"line\">  f.item = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">  f.next = <span class=\"keyword\">null</span>; <span class=\"comment\">// help GC</span></span><br><span class=\"line\">  <span class=\"comment\">//将头节点指向下一个节点</span></span><br><span class=\"line\">  first = next;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (next == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">    <span class=\"comment\">//此时链表为空了所以last要清空</span></span><br><span class=\"line\">    last = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">else</span></span><br><span class=\"line\">    next.prev = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">  size--;</span><br><span class=\"line\">  modCount++;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> element;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">removeLast</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> Node&lt;E&gt; l = last;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (l == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NoSuchElementException();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> unlinkLast(l);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> E <span class=\"title\">unlinkLast</span><span class=\"params\">(Node&lt;E&gt; l)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// assert l == last &amp;&amp; l != null;</span></span><br><span class=\"line\">  <span class=\"keyword\">final</span> E element = l.item;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> Node&lt;E&gt; prev = l.prev;</span><br><span class=\"line\">  l.item = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">  l.prev = <span class=\"keyword\">null</span>; <span class=\"comment\">// help GC</span></span><br><span class=\"line\">  last = prev;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (prev == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">    first = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">else</span></span><br><span class=\"line\">    prev.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">  size--;</span><br><span class=\"line\">  modCount++;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> element;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>还有一种根据对象去删除元素，其实就是遍历去找这个元素，然后把这个元素的前驱节点和后继节点直接连接起来。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">remove</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (o == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Node&lt;E&gt; x = first; x != <span class=\"keyword\">null</span>; x = x.next) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (x.item == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        unlink(x);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Node&lt;E&gt; x = first; x != <span class=\"keyword\">null</span>; x = x.next) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (o.equals(x.item)) &#123;</span><br><span class=\"line\">        unlink(x);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">E <span class=\"title\">unlink</span><span class=\"params\">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// assert x != null;</span></span><br><span class=\"line\">  <span class=\"keyword\">final</span> E element = x.item;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> Node&lt;E&gt; next = x.next;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//如果当前节点前驱节点为空 那么只要将头节点指向当前节点的后继节点即可</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (prev == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    first = next;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//将前驱节点的后继节点指向当前节点的后继节点</span></span><br><span class=\"line\">    prev.next = next;</span><br><span class=\"line\">    x.prev = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//如果当前节点后继节点为空 那么只要将尾节点指向当前节点的前驱节点即可</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (next == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    last = prev;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//将后继节点的前驱节点指向当前节点的前驱节点</span></span><br><span class=\"line\">    next.prev = prev;</span><br><span class=\"line\">    x.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  x.item = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">  size--;</span><br><span class=\"line\">  modCount++;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> element;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>看下根据index查找Node的方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Node&lt;E&gt; <span class=\"title\">node</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// assert isElementIndex(index);</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//当index&lt;(size/2)的时候 那么从前往后找</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (index &lt; (size &gt;&gt; <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">    Node&lt;E&gt; x = first;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; index; i++)</span><br><span class=\"line\">      x = x.next;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">//当(index&gt;=size/2)的时候 从后往前找</span></span><br><span class=\"line\">    Node&lt;E&gt; x = last;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = size - <span class=\"number\">1</span>; i &gt; index; i--)</span><br><span class=\"line\">      x = x.prev;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其实就是为了找到一个离index比较近的方向，然后从那个方向开始遍历。这里需要注意一下，虽然LinkedList不是数组，但是index还是从0开始的。</p>\n<p>然后看下往指定位置插入元素的方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> index, E element)</span> </span>&#123;</span><br><span class=\"line\">  checkPositionIndex(index);</span><br><span class=\"line\">  <span class=\"comment\">//当index等于size时 直接往最后插入 其实这里有点奇怪 为什么不把往头部插入也一起判断出来呢</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (index == size)</span><br><span class=\"line\">    linkLast(element);</span><br><span class=\"line\">  <span class=\"keyword\">else</span></span><br><span class=\"line\">    linkBefore(element, node(index));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//其实这个思路就是新创建一个节点 然后将当前节点的前驱节点指向新创建的节点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">linkBefore</span><span class=\"params\">(E e, Node&lt;E&gt; succ)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// assert succ != null;</span></span><br><span class=\"line\">  <span class=\"comment\">//拿到当前节点的前驱节点</span></span><br><span class=\"line\">  <span class=\"keyword\">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class=\"line\">  <span class=\"comment\">//创建新的节点</span></span><br><span class=\"line\">  <span class=\"keyword\">final</span> Node&lt;E&gt; newNode = <span class=\"keyword\">new</span> Node&lt;&gt;(pred, e, succ);</span><br><span class=\"line\">  <span class=\"comment\">//当前节点的前驱指向新创建的节点</span></span><br><span class=\"line\">  succ.prev = newNode;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (pred == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">    first = newNode;</span><br><span class=\"line\">  <span class=\"keyword\">else</span></span><br><span class=\"line\">    pred.next = newNode;</span><br><span class=\"line\">  size++;</span><br><span class=\"line\">  modCount++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>所以以上这些设计，导致了LinkedList的插入删除操作成本较低，因为没有扩容，但是随机访问效率不如ArrayList。所以可以根据实际场景选择合适的集合。</p>\n"},{"layout":"post","title":"死磕ThreadLocal源码","description":"死磕ThreadLocal源码","date":"2021-08-13T13:52:10.000Z","_content":"\n`ThreadLocal` 是我们常用的和线程绑定的线程安全的对象，别的线程是无法访问的，所以该对象不存在线程安全问题。今天就来看下源码，看下ThreadLocal是怎么做的吧。\n\n先看下用法 \n\n```java\nprivate static ThreadLocal threadLocal = new ThreadLocal();\nthreadLocal.set(new SimpleDateFormat(\"yyyy-MM-dd ss:hh:ss\"));\n```\n\n##### 插入\n\n这里直接看set()方法做了点啥\n\n```java\npublic void set(T value) {\n    Thread t = Thread.currentThread();\n    ThreadLocalMap map = getMap(t);\n    if (map != null)\n        map.set(this, value);\n    else\n        createMap(t, value);\n}\n\nThreadLocalMap getMap(Thread t) {\n    return t.threadLocals;\n}\n\nvoid createMap(Thread t, T firstValue) {\n    t.threadLocals = new ThreadLocalMap(this, firstValue);\n}\n```\n\n看到这里可以知道ThreadLocal的实现其实就是通过Thread中ThreadLocalMap类型的threadLocals去实现的。可能比较绕，我来描述一下。我们通过`ThreadLocal`对象调用set方法，其实是往`Thread类`中的`threadLocals`这个`ThreadLocalMap`中存值，然后这个`ThreadLocalMap`中`key`就是`ThreadLocal`对象，`value`就是我们`set`的`value`。\n\n这里看到set()根据map是否为空执行了两种逻辑，一种是直接创建一个ThreadLocalMap，一种是往已有的ThreadLocalMap中插入数据。\n\n```java\nThreadLocalMap(ThreadLocal<?> firstKey, Object firstValue) {\n    //创建保存对象的table\n    table = new Entry[INITIAL_CAPACITY];\n    //寻找这个threadLocal应该放的index\n    int i = firstKey.threadLocalHashCode & (INITIAL_CAPACITY - 1);\n    //创建Entry对象放入table中\n    table[i] = new Entry(firstKey, firstValue);\n    size = 1;\n    setThreshold(INITIAL_CAPACITY);\n}\n\n//这个Entry一会儿要用，我先拿过来 可以看到这个不是一个链表\n//因为ThreadLocalMap的key就是ThreadLocal对象 如果同一个threadLocal，set多次后面的值会覆盖 因为key相同\nstatic class Entry extends WeakReference<ThreadLocal<?>> {\n    /** The value associated with this ThreadLocal. */\n    Object value;\n\n    Entry(ThreadLocal<?> k, Object v) {\n        super(k);\n        value = v;\n    }\n}\n\nprivate void set(ThreadLocal<?> key, Object value) {\n\n    Entry[] tab = table;\n    int len = tab.length;\n    int i = key.threadLocalHashCode & (len-1);\n\n    //如果tab[i]没有值，不进入循环 否则一直循环 直到找到一个tab[i] == null为止\n    //就是如果算出来的i对应的tab[i]被占了，就会往后拿桶\n    for (Entry e = tab[i];\n         e != null;\n         e = tab[i = nextIndex(i, len)]) {\n        ThreadLocal<?> k = e.get();\n\t\t\n        //key相等 直接覆盖\n        if (k == key) {\n            e.value = value;\n            return;\n        }\n\n        //如果key为nul，说明该key被GC了，用当前值替换老值\n        //注意，这里不能直接将value替换成e.value是因为当前的key已经是null了，无法确定key是否和当前的key一样\n        //仅仅是计算出来的index一样，需要遍历整个table去找对应的key 再根据实际情况进行赋值\n        if (k == null) {\n            replaceStaleEntry(key, value, i);\n            return;\n        }\n    }\n\n    tab[i] = new Entry(key, value);\n    int sz = ++size;\n    //做一次过期清理，如果没有元素被清理并且元素值超过扩容阈值 进行rehash扩容\n    if (!cleanSomeSlots(i, sz) && sz >= threshold)\n        rehash();\n}\n\nprivate void replaceStaleEntry(ThreadLocal<?> key, Object value,\n                                       int staleSlot) {\n    Entry[] tab = table;\n    int len = tab.length;\n    Entry e;\n\n    //往前检查 记录下最后一个不为空并且key为null的元素的位置 以便后续的删除\n    int slotToExpunge = staleSlot;\n    for (int i = prevIndex(staleSlot, len);\n         (e = tab[i]) != null;\n         i = prevIndex(i, len))\n        if (e.get() == null)\n            slotToExpunge = i;\n\n    //往后检查 元素不为空并且key相等 就用value替换 直到元素为空\n    for (int i = nextIndex(staleSlot, len);\n         (e = tab[i]) != null;\n         i = nextIndex(i, len)) {\n        ThreadLocal<?> k = e.get();\n\n        //找到需要被替换的过期元素\n        if (k == key) {\n            //替换value\n            e.value = value;\n\n            //交换 table[i]和table[staleSolt]\n            tab[i] = tab[staleSlot];\n            tab[staleSlot] = e;\n\n            // Start expunge at preceding stale entry if it exists\n            //重置slotToExpunge为i\n            if (slotToExpunge == staleSlot)\n                slotToExpunge = i;\n            //执行清理逻辑\n            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);\n            return;\n        }\n\n        //如果前面没有找到过期的元素 slotToExpunge的位置应该从i开始\n        if (k == null && slotToExpunge == staleSlot)\n            slotToExpunge = i;\n    }\n\n    // 如果没有找到匹配的元素 则直接替换把新的值赋值给staleSlot\n    tab[staleSlot].value = null;\n    tab[staleSlot] = new Entry(key, value);\n\n    //如果存在需要被清理的元素 执行清理\n    if (slotToExpunge != staleSlot)\n        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);\n}\n```\n\n清理的逻辑如下\n\n```java\nprivate boolean cleanSomeSlots(int i, int n) {\n    boolean removed = false;\n    Entry[] tab = table;\n    int len = tab.length;\n    do {\n        i = nextIndex(i, len);\n        Entry e = tab[i];\n        if (e != null && e.get() == null) {\n            n = len;\n            removed = true;\n            i = expungeStaleEntry(i);\n        }\n    } while ( (n >>>= 1) != 0);\n    return removed;\n}\n```\n\n\n\n这里看到getMap()这个方法又从Thread中拿了个`threadLocals`返回了，这个threadLocals在Thread类中定义如下：\n\n```java\nThreadLocal.ThreadLocalMap threadLocals = null;\n```\n\n那这个ThreadLocal.ThreadLocalMap又是个啥呢？看名字的话，知道它是个Map一样的结构。不过它的这些Map相关的操作都是自己实现的，总体逻辑其实和HashMap是类似的。\n\n##### 获取\n\n获取通过get()方法。\n\n```java\npublic T get() {\n    Thread t = Thread.currentThread();\n    //拿到当前线程的threadLocals\n    ThreadLocalMap map = getMap(t);\n    if (map != null) {\n        ThreadLocalMap.Entry e = map.getEntry(this);\n        if (e != null) {\n            @SuppressWarnings(\"unchecked\")\n            T result = (T)e.value;\n            return result;\n        }\n    }\n    //如果上面没有找到ThreadLocal对应的值，尝试调用setInitialValue来取值，因为可能重写了initialValue方法来获取值 \n    //ThreadLocal threadLocal = ThreadLocal.withInitial(()->new SimpleDateFormat(\"yyyy-MM-dd ss:hh:ss\")); 通过这种方式创建\n    return setInitialValue();\n}\n\nprivate T setInitialValue() {\n    T value = initialValue();\n    Thread t = Thread.currentThread();\n    ThreadLocalMap map = getMap(t);\n    if (map != null)\n        map.set(this, value);\n    else\n        createMap(t, value);\n    return value;\n}\n\nstatic final class SuppliedThreadLocal<T> extends ThreadLocal<T> {\n\n    private final Supplier<? extends T> supplier;\n\n    SuppliedThreadLocal(Supplier<? extends T> supplier) {\n        this.supplier = Objects.requireNonNull(supplier);\n    }\n\n    @Override\n    protected T initialValue() {\n        return supplier.get();\n    }\n}\n\n//因为我们遇到hash冲突的时候不是拉链法去解决的，而是往后找了一个空的位置放进去，所以查询的时候也需要特殊处理一下\nprivate Entry getEntry(ThreadLocal<?> key) {\n    int i = key.threadLocalHashCode & (table.length - 1);\n    Entry e = table[i];\n    if (e != null && e.get() == key)\n        return e;\n    else\n        return getEntryAfterMiss(key, i, e); //这里就是特殊处理的地方\n}\n\n//这个就是如果没有找到就去下一slot去拿 直到拿到元素为止\nprivate Entry getEntryAfterMiss(ThreadLocal<?> key, int i, Entry e) {\n    Entry[] tab = table;\n    int len = tab.length;\n\n    while (e != null) {\n        ThreadLocal<?> k = e.get();\n        if (k == key)\n            return e;\n        if (k == null)\n            expungeStaleEntry(i);\n        else\n            i = nextIndex(i, len);\n        e = tab[i];\n    }\n    return null;\n}\n\n//这个方法主要是\n//删除staleSlot的值\n//从staleSlot位置开始，直到下一个table[i]为null的元素之间，删除table[i].key为null的元素，同时调整该区间内的元素位置到合适的位置\nprivate int expungeStaleEntry(int staleSlot) {\n    Entry[] tab = table;\n    int len = tab.length;\n\n    // expunge entry at staleSlot\n    //删除staleSlot位置的元素\n    tab[staleSlot].value = null;\n    tab[staleSlot] = null;\n    size--;\n\n    // Rehash until we encounter null\n    //从staleSlot开始查找需要删除或者更新位置的元素\n    Entry e;\n    int i;\n    for (i = nextIndex(staleSlot, len);\n         (e = tab[i]) != null;\n         i = nextIndex(i, len)) {\n        ThreadLocal<?> k = e.get();\n        if (k == null) {\n            e.value = null;\n            tab[i] = null;\n            size--;\n        } else {\n            int h = k.threadLocalHashCode & (len - 1);\n            if (h != i) {\n                tab[i] = null;\n\n                // Unlike Knuth 6.4 Algorithm R, we must scan until\n                // null because multiple entries could have been stale.\n                while (tab[h] != null)\n                    h = nextIndex(h, len);\n                tab[h] = e;\n            }\n        }\n    }\n    return i;\n}\n```\n\n##### 删除\n\n与Map的remove(key)思想一致。\n\n```java\npublic void remove() {\n    ThreadLocalMap m = getMap(Thread.currentThread());\n    if (m != null)\n        m.remove(this);\n}\n\nprivate void remove(ThreadLocal<?> key) {\n    Entry[] tab = table;\n    int len = tab.length;\n    int i = key.threadLocalHashCode & (len-1);\n    for (Entry e = tab[i];\n         e != null;\n         e = tab[i = nextIndex(i, len)]) {\n        if (e.get() == key) {\n            e.clear();\n            expungeStaleEntry(i);\n            return;\n        }\n    }\n}\n```\n\n#### 总结一下\n\nThreadLocalMap的key是WeekReference的，这就决定了，在GC时，只要没有任何强引用指向Map中的key，那么该key就会在下一次GC时被回收，从而key.get()就会返回null，而在set、get等方法时，会对key.get()为null的KV键值对进行清理操作，从而释放内存，避免内存泄露。但是和WeekHashMap一样，即使key被GC掉了，变成null，但是如果从此之后不再对map做任何操作，那么这些空key对应的value所占用的内存也是不可能被GC的，这种情况下，有可能发生内存泄漏。\n\nThreadLocalMap对hash冲突的处理不是通过拉链法来解决的，而是从当前计算的index往后寻找为空的slot。\n\n虽然说ThreadLocalMap中的key是弱引用，但是一旦外面还有其他强引用指向该key，意味着该key永远都不可能会被gc掉，那么WeakReferece的能力就基本失去了作用，这就导致内存无法回收的后果，所以每次使用完，确定不再需要该key，就需要调用ThreadLocal的remove方法或者set(null)来帮助GC回收相关内存。\n\n#### 比较容易踩的坑\n\n1.使用线程池处理事务时，如果同一线程上一次处理过的ThreadLocal对象，在用完后没有及时清理，很有可能导致该线程在处理下一个事务时，由于没有重新设置该ThreadLocal对象，而导致处理下一个事务的时候，读取到了上一次处理过程中ThreadLocal中的值。\n\n2.内存泄露问题，因为一般情况下，ThreadLocal对象可能是静态对象，意味着在Thread的ThreadLocalMap中该ThreadLocal的弱引用失效（因为静态对象的引用是强引用），从而无法达到key被GC掉，并且在后续操作Thread的ThreadLocalMap时，无法自动将不再需要的对象清除掉而造成内存泄漏的问题。\n\n\n\n","source":"_posts/死磕ThreadLocal源码.md","raw":"---\nlayout:    post\ntitle:     死磕ThreadLocal源码\ncategory:  源码解析\ndescription: 死磕ThreadLocal源码\ntags: JDK\ndate: 2021/08/13 21:52:10\n\n---\n\n`ThreadLocal` 是我们常用的和线程绑定的线程安全的对象，别的线程是无法访问的，所以该对象不存在线程安全问题。今天就来看下源码，看下ThreadLocal是怎么做的吧。\n\n先看下用法 \n\n```java\nprivate static ThreadLocal threadLocal = new ThreadLocal();\nthreadLocal.set(new SimpleDateFormat(\"yyyy-MM-dd ss:hh:ss\"));\n```\n\n##### 插入\n\n这里直接看set()方法做了点啥\n\n```java\npublic void set(T value) {\n    Thread t = Thread.currentThread();\n    ThreadLocalMap map = getMap(t);\n    if (map != null)\n        map.set(this, value);\n    else\n        createMap(t, value);\n}\n\nThreadLocalMap getMap(Thread t) {\n    return t.threadLocals;\n}\n\nvoid createMap(Thread t, T firstValue) {\n    t.threadLocals = new ThreadLocalMap(this, firstValue);\n}\n```\n\n看到这里可以知道ThreadLocal的实现其实就是通过Thread中ThreadLocalMap类型的threadLocals去实现的。可能比较绕，我来描述一下。我们通过`ThreadLocal`对象调用set方法，其实是往`Thread类`中的`threadLocals`这个`ThreadLocalMap`中存值，然后这个`ThreadLocalMap`中`key`就是`ThreadLocal`对象，`value`就是我们`set`的`value`。\n\n这里看到set()根据map是否为空执行了两种逻辑，一种是直接创建一个ThreadLocalMap，一种是往已有的ThreadLocalMap中插入数据。\n\n```java\nThreadLocalMap(ThreadLocal<?> firstKey, Object firstValue) {\n    //创建保存对象的table\n    table = new Entry[INITIAL_CAPACITY];\n    //寻找这个threadLocal应该放的index\n    int i = firstKey.threadLocalHashCode & (INITIAL_CAPACITY - 1);\n    //创建Entry对象放入table中\n    table[i] = new Entry(firstKey, firstValue);\n    size = 1;\n    setThreshold(INITIAL_CAPACITY);\n}\n\n//这个Entry一会儿要用，我先拿过来 可以看到这个不是一个链表\n//因为ThreadLocalMap的key就是ThreadLocal对象 如果同一个threadLocal，set多次后面的值会覆盖 因为key相同\nstatic class Entry extends WeakReference<ThreadLocal<?>> {\n    /** The value associated with this ThreadLocal. */\n    Object value;\n\n    Entry(ThreadLocal<?> k, Object v) {\n        super(k);\n        value = v;\n    }\n}\n\nprivate void set(ThreadLocal<?> key, Object value) {\n\n    Entry[] tab = table;\n    int len = tab.length;\n    int i = key.threadLocalHashCode & (len-1);\n\n    //如果tab[i]没有值，不进入循环 否则一直循环 直到找到一个tab[i] == null为止\n    //就是如果算出来的i对应的tab[i]被占了，就会往后拿桶\n    for (Entry e = tab[i];\n         e != null;\n         e = tab[i = nextIndex(i, len)]) {\n        ThreadLocal<?> k = e.get();\n\t\t\n        //key相等 直接覆盖\n        if (k == key) {\n            e.value = value;\n            return;\n        }\n\n        //如果key为nul，说明该key被GC了，用当前值替换老值\n        //注意，这里不能直接将value替换成e.value是因为当前的key已经是null了，无法确定key是否和当前的key一样\n        //仅仅是计算出来的index一样，需要遍历整个table去找对应的key 再根据实际情况进行赋值\n        if (k == null) {\n            replaceStaleEntry(key, value, i);\n            return;\n        }\n    }\n\n    tab[i] = new Entry(key, value);\n    int sz = ++size;\n    //做一次过期清理，如果没有元素被清理并且元素值超过扩容阈值 进行rehash扩容\n    if (!cleanSomeSlots(i, sz) && sz >= threshold)\n        rehash();\n}\n\nprivate void replaceStaleEntry(ThreadLocal<?> key, Object value,\n                                       int staleSlot) {\n    Entry[] tab = table;\n    int len = tab.length;\n    Entry e;\n\n    //往前检查 记录下最后一个不为空并且key为null的元素的位置 以便后续的删除\n    int slotToExpunge = staleSlot;\n    for (int i = prevIndex(staleSlot, len);\n         (e = tab[i]) != null;\n         i = prevIndex(i, len))\n        if (e.get() == null)\n            slotToExpunge = i;\n\n    //往后检查 元素不为空并且key相等 就用value替换 直到元素为空\n    for (int i = nextIndex(staleSlot, len);\n         (e = tab[i]) != null;\n         i = nextIndex(i, len)) {\n        ThreadLocal<?> k = e.get();\n\n        //找到需要被替换的过期元素\n        if (k == key) {\n            //替换value\n            e.value = value;\n\n            //交换 table[i]和table[staleSolt]\n            tab[i] = tab[staleSlot];\n            tab[staleSlot] = e;\n\n            // Start expunge at preceding stale entry if it exists\n            //重置slotToExpunge为i\n            if (slotToExpunge == staleSlot)\n                slotToExpunge = i;\n            //执行清理逻辑\n            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);\n            return;\n        }\n\n        //如果前面没有找到过期的元素 slotToExpunge的位置应该从i开始\n        if (k == null && slotToExpunge == staleSlot)\n            slotToExpunge = i;\n    }\n\n    // 如果没有找到匹配的元素 则直接替换把新的值赋值给staleSlot\n    tab[staleSlot].value = null;\n    tab[staleSlot] = new Entry(key, value);\n\n    //如果存在需要被清理的元素 执行清理\n    if (slotToExpunge != staleSlot)\n        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);\n}\n```\n\n清理的逻辑如下\n\n```java\nprivate boolean cleanSomeSlots(int i, int n) {\n    boolean removed = false;\n    Entry[] tab = table;\n    int len = tab.length;\n    do {\n        i = nextIndex(i, len);\n        Entry e = tab[i];\n        if (e != null && e.get() == null) {\n            n = len;\n            removed = true;\n            i = expungeStaleEntry(i);\n        }\n    } while ( (n >>>= 1) != 0);\n    return removed;\n}\n```\n\n\n\n这里看到getMap()这个方法又从Thread中拿了个`threadLocals`返回了，这个threadLocals在Thread类中定义如下：\n\n```java\nThreadLocal.ThreadLocalMap threadLocals = null;\n```\n\n那这个ThreadLocal.ThreadLocalMap又是个啥呢？看名字的话，知道它是个Map一样的结构。不过它的这些Map相关的操作都是自己实现的，总体逻辑其实和HashMap是类似的。\n\n##### 获取\n\n获取通过get()方法。\n\n```java\npublic T get() {\n    Thread t = Thread.currentThread();\n    //拿到当前线程的threadLocals\n    ThreadLocalMap map = getMap(t);\n    if (map != null) {\n        ThreadLocalMap.Entry e = map.getEntry(this);\n        if (e != null) {\n            @SuppressWarnings(\"unchecked\")\n            T result = (T)e.value;\n            return result;\n        }\n    }\n    //如果上面没有找到ThreadLocal对应的值，尝试调用setInitialValue来取值，因为可能重写了initialValue方法来获取值 \n    //ThreadLocal threadLocal = ThreadLocal.withInitial(()->new SimpleDateFormat(\"yyyy-MM-dd ss:hh:ss\")); 通过这种方式创建\n    return setInitialValue();\n}\n\nprivate T setInitialValue() {\n    T value = initialValue();\n    Thread t = Thread.currentThread();\n    ThreadLocalMap map = getMap(t);\n    if (map != null)\n        map.set(this, value);\n    else\n        createMap(t, value);\n    return value;\n}\n\nstatic final class SuppliedThreadLocal<T> extends ThreadLocal<T> {\n\n    private final Supplier<? extends T> supplier;\n\n    SuppliedThreadLocal(Supplier<? extends T> supplier) {\n        this.supplier = Objects.requireNonNull(supplier);\n    }\n\n    @Override\n    protected T initialValue() {\n        return supplier.get();\n    }\n}\n\n//因为我们遇到hash冲突的时候不是拉链法去解决的，而是往后找了一个空的位置放进去，所以查询的时候也需要特殊处理一下\nprivate Entry getEntry(ThreadLocal<?> key) {\n    int i = key.threadLocalHashCode & (table.length - 1);\n    Entry e = table[i];\n    if (e != null && e.get() == key)\n        return e;\n    else\n        return getEntryAfterMiss(key, i, e); //这里就是特殊处理的地方\n}\n\n//这个就是如果没有找到就去下一slot去拿 直到拿到元素为止\nprivate Entry getEntryAfterMiss(ThreadLocal<?> key, int i, Entry e) {\n    Entry[] tab = table;\n    int len = tab.length;\n\n    while (e != null) {\n        ThreadLocal<?> k = e.get();\n        if (k == key)\n            return e;\n        if (k == null)\n            expungeStaleEntry(i);\n        else\n            i = nextIndex(i, len);\n        e = tab[i];\n    }\n    return null;\n}\n\n//这个方法主要是\n//删除staleSlot的值\n//从staleSlot位置开始，直到下一个table[i]为null的元素之间，删除table[i].key为null的元素，同时调整该区间内的元素位置到合适的位置\nprivate int expungeStaleEntry(int staleSlot) {\n    Entry[] tab = table;\n    int len = tab.length;\n\n    // expunge entry at staleSlot\n    //删除staleSlot位置的元素\n    tab[staleSlot].value = null;\n    tab[staleSlot] = null;\n    size--;\n\n    // Rehash until we encounter null\n    //从staleSlot开始查找需要删除或者更新位置的元素\n    Entry e;\n    int i;\n    for (i = nextIndex(staleSlot, len);\n         (e = tab[i]) != null;\n         i = nextIndex(i, len)) {\n        ThreadLocal<?> k = e.get();\n        if (k == null) {\n            e.value = null;\n            tab[i] = null;\n            size--;\n        } else {\n            int h = k.threadLocalHashCode & (len - 1);\n            if (h != i) {\n                tab[i] = null;\n\n                // Unlike Knuth 6.4 Algorithm R, we must scan until\n                // null because multiple entries could have been stale.\n                while (tab[h] != null)\n                    h = nextIndex(h, len);\n                tab[h] = e;\n            }\n        }\n    }\n    return i;\n}\n```\n\n##### 删除\n\n与Map的remove(key)思想一致。\n\n```java\npublic void remove() {\n    ThreadLocalMap m = getMap(Thread.currentThread());\n    if (m != null)\n        m.remove(this);\n}\n\nprivate void remove(ThreadLocal<?> key) {\n    Entry[] tab = table;\n    int len = tab.length;\n    int i = key.threadLocalHashCode & (len-1);\n    for (Entry e = tab[i];\n         e != null;\n         e = tab[i = nextIndex(i, len)]) {\n        if (e.get() == key) {\n            e.clear();\n            expungeStaleEntry(i);\n            return;\n        }\n    }\n}\n```\n\n#### 总结一下\n\nThreadLocalMap的key是WeekReference的，这就决定了，在GC时，只要没有任何强引用指向Map中的key，那么该key就会在下一次GC时被回收，从而key.get()就会返回null，而在set、get等方法时，会对key.get()为null的KV键值对进行清理操作，从而释放内存，避免内存泄露。但是和WeekHashMap一样，即使key被GC掉了，变成null，但是如果从此之后不再对map做任何操作，那么这些空key对应的value所占用的内存也是不可能被GC的，这种情况下，有可能发生内存泄漏。\n\nThreadLocalMap对hash冲突的处理不是通过拉链法来解决的，而是从当前计算的index往后寻找为空的slot。\n\n虽然说ThreadLocalMap中的key是弱引用，但是一旦外面还有其他强引用指向该key，意味着该key永远都不可能会被gc掉，那么WeakReferece的能力就基本失去了作用，这就导致内存无法回收的后果，所以每次使用完，确定不再需要该key，就需要调用ThreadLocal的remove方法或者set(null)来帮助GC回收相关内存。\n\n#### 比较容易踩的坑\n\n1.使用线程池处理事务时，如果同一线程上一次处理过的ThreadLocal对象，在用完后没有及时清理，很有可能导致该线程在处理下一个事务时，由于没有重新设置该ThreadLocal对象，而导致处理下一个事务的时候，读取到了上一次处理过程中ThreadLocal中的值。\n\n2.内存泄露问题，因为一般情况下，ThreadLocal对象可能是静态对象，意味着在Thread的ThreadLocalMap中该ThreadLocal的弱引用失效（因为静态对象的引用是强引用），从而无法达到key被GC掉，并且在后续操作Thread的ThreadLocalMap时，无法自动将不再需要的对象清除掉而造成内存泄漏的问题。\n\n\n\n","slug":"死磕ThreadLocal源码","published":1,"updated":"2021-08-13T13:52:10.000Z","comments":1,"photos":[],"link":"","_id":"cm1m304xb000j31b4ew2t1fdy","content":"<p><code>ThreadLocal</code> 是我们常用的和线程绑定的线程安全的对象，别的线程是无法访问的，所以该对象不存在线程安全问题。今天就来看下源码，看下ThreadLocal是怎么做的吧。</p>\n<p>先看下用法 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> ThreadLocal threadLocal = <span class=\"keyword\">new</span> ThreadLocal();</span><br><span class=\"line\">threadLocal.set(<span class=\"keyword\">new</span> SimpleDateFormat(<span class=\"string\">&quot;yyyy-MM-dd ss:hh:ss&quot;</span>));</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"插入\"><a href=\"#插入\" class=\"headerlink\" title=\"插入\"></a>插入</h5><p>这里直接看set()方法做了点啥</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">set</span><span class=\"params\">(T value)</span> </span>&#123;</span><br><span class=\"line\">    Thread t = Thread.currentThread();</span><br><span class=\"line\">    ThreadLocalMap map = getMap(t);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (map != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        map.set(<span class=\"keyword\">this</span>, value);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        createMap(t, value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">ThreadLocalMap <span class=\"title\">getMap</span><span class=\"params\">(Thread t)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> t.threadLocals;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">createMap</span><span class=\"params\">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class=\"line\">    t.threadLocals = <span class=\"keyword\">new</span> ThreadLocalMap(<span class=\"keyword\">this</span>, firstValue);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>看到这里可以知道ThreadLocal的实现其实就是通过Thread中ThreadLocalMap类型的threadLocals去实现的。可能比较绕，我来描述一下。我们通过<code>ThreadLocal</code>对象调用set方法，其实是往<code>Thread类</code>中的<code>threadLocals</code>这个<code>ThreadLocalMap</code>中存值，然后这个<code>ThreadLocalMap</code>中<code>key</code>就是<code>ThreadLocal</code>对象，<code>value</code>就是我们<code>set</code>的<code>value</code>。</p>\n<p>这里看到set()根据map是否为空执行了两种逻辑，一种是直接创建一个ThreadLocalMap，一种是往已有的ThreadLocalMap中插入数据。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//创建保存对象的table</span></span><br><span class=\"line\">    table = <span class=\"keyword\">new</span> Entry[INITIAL_CAPACITY];</span><br><span class=\"line\">    <span class=\"comment\">//寻找这个threadLocal应该放的index</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"comment\">//创建Entry对象放入table中</span></span><br><span class=\"line\">    table[i] = <span class=\"keyword\">new</span> Entry(firstKey, firstValue);</span><br><span class=\"line\">    size = <span class=\"number\">1</span>;</span><br><span class=\"line\">    setThreshold(INITIAL_CAPACITY);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//这个Entry一会儿要用，我先拿过来 可以看到这个不是一个链表</span></span><br><span class=\"line\"><span class=\"comment\">//因为ThreadLocalMap的key就是ThreadLocal对象 如果同一个threadLocal，set多次后面的值会覆盖 因为key相同</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Entry</span> <span class=\"keyword\">extends</span> <span class=\"title\">WeakReference</span>&lt;<span class=\"title\">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/** The value associated with this ThreadLocal. */</span></span><br><span class=\"line\">    Object value;</span><br><span class=\"line\"></span><br><span class=\"line\">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(k);</span><br><span class=\"line\">        value = v;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">set</span><span class=\"params\">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    Entry[] tab = table;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = tab.length;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = key.threadLocalHashCode &amp; (len-<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//如果tab[i]没有值，不进入循环 否则一直循环 直到找到一个tab[i] == null为止</span></span><br><span class=\"line\">    <span class=\"comment\">//就是如果算出来的i对应的tab[i]被占了，就会往后拿桶</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Entry e = tab[i];</span><br><span class=\"line\">         e != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class=\"line\">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">        <span class=\"comment\">//key相等 直接覆盖</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (k == key) &#123;</span><br><span class=\"line\">            e.value = value;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//如果key为nul，说明该key被GC了，用当前值替换老值</span></span><br><span class=\"line\">        <span class=\"comment\">//注意，这里不能直接将value替换成e.value是因为当前的key已经是null了，无法确定key是否和当前的key一样</span></span><br><span class=\"line\">        <span class=\"comment\">//仅仅是计算出来的index一样，需要遍历整个table去找对应的key 再根据实际情况进行赋值</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (k == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            replaceStaleEntry(key, value, i);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    tab[i] = <span class=\"keyword\">new</span> Entry(key, value);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> sz = ++size;</span><br><span class=\"line\">    <span class=\"comment\">//做一次过期清理，如果没有元素被清理并且元素值超过扩容阈值 进行rehash扩容</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class=\"line\">        rehash();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">replaceStaleEntry</span><span class=\"params\">(ThreadLocal&lt;?&gt; key, Object value,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                       <span class=\"keyword\">int</span> staleSlot)</span> </span>&#123;</span><br><span class=\"line\">    Entry[] tab = table;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = tab.length;</span><br><span class=\"line\">    Entry e;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//往前检查 记录下最后一个不为空并且key为null的元素的位置 以便后续的删除</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> slotToExpunge = staleSlot;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = prevIndex(staleSlot, len);</span><br><span class=\"line\">         (e = tab[i]) != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">         i = prevIndex(i, len))</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e.get() == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            slotToExpunge = i;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//往后检查 元素不为空并且key相等 就用value替换 直到元素为空</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = nextIndex(staleSlot, len);</span><br><span class=\"line\">         (e = tab[i]) != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">         i = nextIndex(i, len)) &#123;</span><br><span class=\"line\">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//找到需要被替换的过期元素</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (k == key) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//替换value</span></span><br><span class=\"line\">            e.value = value;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//交换 table[i]和table[staleSolt]</span></span><br><span class=\"line\">            tab[i] = tab[staleSlot];</span><br><span class=\"line\">            tab[staleSlot] = e;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// Start expunge at preceding stale entry if it exists</span></span><br><span class=\"line\">            <span class=\"comment\">//重置slotToExpunge为i</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (slotToExpunge == staleSlot)</span><br><span class=\"line\">                slotToExpunge = i;</span><br><span class=\"line\">            <span class=\"comment\">//执行清理逻辑</span></span><br><span class=\"line\">            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//如果前面没有找到过期的元素 slotToExpunge的位置应该从i开始</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (k == <span class=\"keyword\">null</span> &amp;&amp; slotToExpunge == staleSlot)</span><br><span class=\"line\">            slotToExpunge = i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果没有找到匹配的元素 则直接替换把新的值赋值给staleSlot</span></span><br><span class=\"line\">    tab[staleSlot].value = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    tab[staleSlot] = <span class=\"keyword\">new</span> Entry(key, value);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//如果存在需要被清理的元素 执行清理</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (slotToExpunge != staleSlot)</span><br><span class=\"line\">        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>清理的逻辑如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">cleanSomeSlots</span><span class=\"params\">(<span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> removed = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    Entry[] tab = table;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = tab.length;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        i = nextIndex(i, len);</span><br><span class=\"line\">        Entry e = tab[i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span> &amp;&amp; e.get() == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            n = len;</span><br><span class=\"line\">            removed = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            i = expungeStaleEntry(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> ( (n &gt;&gt;&gt;= <span class=\"number\">1</span>) != <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> removed;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>这里看到getMap()这个方法又从Thread中拿了个<code>threadLocals</code>返回了，这个threadLocals在Thread类中定义如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ThreadLocal.ThreadLocalMap threadLocals = <span class=\"keyword\">null</span>;</span><br></pre></td></tr></table></figure>\n\n<p>那这个ThreadLocal.ThreadLocalMap又是个啥呢？看名字的话，知道它是个Map一样的结构。不过它的这些Map相关的操作都是自己实现的，总体逻辑其实和HashMap是类似的。</p>\n<h5 id=\"获取\"><a href=\"#获取\" class=\"headerlink\" title=\"获取\"></a>获取</h5><p>获取通过get()方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Thread t = Thread.currentThread();</span><br><span class=\"line\">    <span class=\"comment\">//拿到当前线程的threadLocals</span></span><br><span class=\"line\">    ThreadLocalMap map = getMap(t);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (map != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        ThreadLocalMap.Entry e = map.getEntry(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"meta\">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class=\"line\">            T result = (T)e.value;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//如果上面没有找到ThreadLocal对应的值，尝试调用setInitialValue来取值，因为可能重写了initialValue方法来获取值 </span></span><br><span class=\"line\">    <span class=\"comment\">//ThreadLocal threadLocal = ThreadLocal.withInitial(()-&gt;new SimpleDateFormat(&quot;yyyy-MM-dd ss:hh:ss&quot;)); 通过这种方式创建</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> setInitialValue();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> T <span class=\"title\">setInitialValue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    T value = initialValue();</span><br><span class=\"line\">    Thread t = Thread.currentThread();</span><br><span class=\"line\">    ThreadLocalMap map = getMap(t);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (map != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        map.set(<span class=\"keyword\">this</span>, value);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        createMap(t, value);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SuppliedThreadLocal</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">ThreadLocal</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Supplier&lt;? extends T&gt; supplier;</span><br><span class=\"line\"></span><br><span class=\"line\">    SuppliedThreadLocal(Supplier&lt;? extends T&gt; supplier) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.supplier = Objects.requireNonNull(supplier);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> T <span class=\"title\">initialValue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> supplier.get();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//因为我们遇到hash冲突的时候不是拉链法去解决的，而是往后找了一个空的位置放进去，所以查询的时候也需要特殊处理一下</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Entry <span class=\"title\">getEntry</span><span class=\"params\">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class=\"number\">1</span>);</span><br><span class=\"line\">    Entry e = table[i];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span> &amp;&amp; e.get() == key)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> e;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> getEntryAfterMiss(key, i, e); <span class=\"comment\">//这里就是特殊处理的地方</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//这个就是如果没有找到就去下一slot去拿 直到拿到元素为止</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Entry <span class=\"title\">getEntryAfterMiss</span><span class=\"params\">(ThreadLocal&lt;?&gt; key, <span class=\"keyword\">int</span> i, Entry e)</span> </span>&#123;</span><br><span class=\"line\">    Entry[] tab = table;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = tab.length;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (e != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (k == key)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> e;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (k == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            expungeStaleEntry(i);</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            i = nextIndex(i, len);</span><br><span class=\"line\">        e = tab[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//这个方法主要是</span></span><br><span class=\"line\"><span class=\"comment\">//删除staleSlot的值</span></span><br><span class=\"line\"><span class=\"comment\">//从staleSlot位置开始，直到下一个table[i]为null的元素之间，删除table[i].key为null的元素，同时调整该区间内的元素位置到合适的位置</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">expungeStaleEntry</span><span class=\"params\">(<span class=\"keyword\">int</span> staleSlot)</span> </span>&#123;</span><br><span class=\"line\">    Entry[] tab = table;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = tab.length;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// expunge entry at staleSlot</span></span><br><span class=\"line\">    <span class=\"comment\">//删除staleSlot位置的元素</span></span><br><span class=\"line\">    tab[staleSlot].value = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    tab[staleSlot] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    size--;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Rehash until we encounter null</span></span><br><span class=\"line\">    <span class=\"comment\">//从staleSlot开始查找需要删除或者更新位置的元素</span></span><br><span class=\"line\">    Entry e;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = nextIndex(staleSlot, len);</span><br><span class=\"line\">         (e = tab[i]) != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">         i = nextIndex(i, len)) &#123;</span><br><span class=\"line\">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (k == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            e.value = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            tab[i] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            size--;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> h = k.threadLocalHashCode &amp; (len - <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (h != i) &#123;</span><br><span class=\"line\">                tab[i] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// Unlike Knuth 6.4 Algorithm R, we must scan until</span></span><br><span class=\"line\">                <span class=\"comment\">// null because multiple entries could have been stale.</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span> (tab[h] != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    h = nextIndex(h, len);</span><br><span class=\"line\">                tab[h] = e;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"删除\"><a href=\"#删除\" class=\"headerlink\" title=\"删除\"></a>删除</h5><p>与Map的remove(key)思想一致。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (m != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        m.remove(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class=\"line\">    Entry[] tab = table;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = tab.length;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = key.threadLocalHashCode &amp; (len-<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Entry e = tab[i];</span><br><span class=\"line\">         e != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e.get() == key) &#123;</span><br><span class=\"line\">            e.clear();</span><br><span class=\"line\">            expungeStaleEntry(i);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"总结一下\"><a href=\"#总结一下\" class=\"headerlink\" title=\"总结一下\"></a>总结一下</h4><p>ThreadLocalMap的key是WeekReference的，这就决定了，在GC时，只要没有任何强引用指向Map中的key，那么该key就会在下一次GC时被回收，从而key.get()就会返回null，而在set、get等方法时，会对key.get()为null的KV键值对进行清理操作，从而释放内存，避免内存泄露。但是和WeekHashMap一样，即使key被GC掉了，变成null，但是如果从此之后不再对map做任何操作，那么这些空key对应的value所占用的内存也是不可能被GC的，这种情况下，有可能发生内存泄漏。</p>\n<p>ThreadLocalMap对hash冲突的处理不是通过拉链法来解决的，而是从当前计算的index往后寻找为空的slot。</p>\n<p>虽然说ThreadLocalMap中的key是弱引用，但是一旦外面还有其他强引用指向该key，意味着该key永远都不可能会被gc掉，那么WeakReferece的能力就基本失去了作用，这就导致内存无法回收的后果，所以每次使用完，确定不再需要该key，就需要调用ThreadLocal的remove方法或者set(null)来帮助GC回收相关内存。</p>\n<h4 id=\"比较容易踩的坑\"><a href=\"#比较容易踩的坑\" class=\"headerlink\" title=\"比较容易踩的坑\"></a>比较容易踩的坑</h4><p>1.使用线程池处理事务时，如果同一线程上一次处理过的ThreadLocal对象，在用完后没有及时清理，很有可能导致该线程在处理下一个事务时，由于没有重新设置该ThreadLocal对象，而导致处理下一个事务的时候，读取到了上一次处理过程中ThreadLocal中的值。</p>\n<p>2.内存泄露问题，因为一般情况下，ThreadLocal对象可能是静态对象，意味着在Thread的ThreadLocalMap中该ThreadLocal的弱引用失效（因为静态对象的引用是强引用），从而无法达到key被GC掉，并且在后续操作Thread的ThreadLocalMap时，无法自动将不再需要的对象清除掉而造成内存泄漏的问题。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><code>ThreadLocal</code> 是我们常用的和线程绑定的线程安全的对象，别的线程是无法访问的，所以该对象不存在线程安全问题。今天就来看下源码，看下ThreadLocal是怎么做的吧。</p>\n<p>先看下用法 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> ThreadLocal threadLocal = <span class=\"keyword\">new</span> ThreadLocal();</span><br><span class=\"line\">threadLocal.set(<span class=\"keyword\">new</span> SimpleDateFormat(<span class=\"string\">&quot;yyyy-MM-dd ss:hh:ss&quot;</span>));</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"插入\"><a href=\"#插入\" class=\"headerlink\" title=\"插入\"></a>插入</h5><p>这里直接看set()方法做了点啥</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">set</span><span class=\"params\">(T value)</span> </span>&#123;</span><br><span class=\"line\">    Thread t = Thread.currentThread();</span><br><span class=\"line\">    ThreadLocalMap map = getMap(t);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (map != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        map.set(<span class=\"keyword\">this</span>, value);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        createMap(t, value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">ThreadLocalMap <span class=\"title\">getMap</span><span class=\"params\">(Thread t)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> t.threadLocals;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">createMap</span><span class=\"params\">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class=\"line\">    t.threadLocals = <span class=\"keyword\">new</span> ThreadLocalMap(<span class=\"keyword\">this</span>, firstValue);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>看到这里可以知道ThreadLocal的实现其实就是通过Thread中ThreadLocalMap类型的threadLocals去实现的。可能比较绕，我来描述一下。我们通过<code>ThreadLocal</code>对象调用set方法，其实是往<code>Thread类</code>中的<code>threadLocals</code>这个<code>ThreadLocalMap</code>中存值，然后这个<code>ThreadLocalMap</code>中<code>key</code>就是<code>ThreadLocal</code>对象，<code>value</code>就是我们<code>set</code>的<code>value</code>。</p>\n<p>这里看到set()根据map是否为空执行了两种逻辑，一种是直接创建一个ThreadLocalMap，一种是往已有的ThreadLocalMap中插入数据。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//创建保存对象的table</span></span><br><span class=\"line\">    table = <span class=\"keyword\">new</span> Entry[INITIAL_CAPACITY];</span><br><span class=\"line\">    <span class=\"comment\">//寻找这个threadLocal应该放的index</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"comment\">//创建Entry对象放入table中</span></span><br><span class=\"line\">    table[i] = <span class=\"keyword\">new</span> Entry(firstKey, firstValue);</span><br><span class=\"line\">    size = <span class=\"number\">1</span>;</span><br><span class=\"line\">    setThreshold(INITIAL_CAPACITY);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//这个Entry一会儿要用，我先拿过来 可以看到这个不是一个链表</span></span><br><span class=\"line\"><span class=\"comment\">//因为ThreadLocalMap的key就是ThreadLocal对象 如果同一个threadLocal，set多次后面的值会覆盖 因为key相同</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Entry</span> <span class=\"keyword\">extends</span> <span class=\"title\">WeakReference</span>&lt;<span class=\"title\">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/** The value associated with this ThreadLocal. */</span></span><br><span class=\"line\">    Object value;</span><br><span class=\"line\"></span><br><span class=\"line\">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(k);</span><br><span class=\"line\">        value = v;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">set</span><span class=\"params\">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    Entry[] tab = table;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = tab.length;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = key.threadLocalHashCode &amp; (len-<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//如果tab[i]没有值，不进入循环 否则一直循环 直到找到一个tab[i] == null为止</span></span><br><span class=\"line\">    <span class=\"comment\">//就是如果算出来的i对应的tab[i]被占了，就会往后拿桶</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Entry e = tab[i];</span><br><span class=\"line\">         e != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class=\"line\">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">        <span class=\"comment\">//key相等 直接覆盖</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (k == key) &#123;</span><br><span class=\"line\">            e.value = value;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//如果key为nul，说明该key被GC了，用当前值替换老值</span></span><br><span class=\"line\">        <span class=\"comment\">//注意，这里不能直接将value替换成e.value是因为当前的key已经是null了，无法确定key是否和当前的key一样</span></span><br><span class=\"line\">        <span class=\"comment\">//仅仅是计算出来的index一样，需要遍历整个table去找对应的key 再根据实际情况进行赋值</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (k == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            replaceStaleEntry(key, value, i);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    tab[i] = <span class=\"keyword\">new</span> Entry(key, value);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> sz = ++size;</span><br><span class=\"line\">    <span class=\"comment\">//做一次过期清理，如果没有元素被清理并且元素值超过扩容阈值 进行rehash扩容</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class=\"line\">        rehash();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">replaceStaleEntry</span><span class=\"params\">(ThreadLocal&lt;?&gt; key, Object value,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                       <span class=\"keyword\">int</span> staleSlot)</span> </span>&#123;</span><br><span class=\"line\">    Entry[] tab = table;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = tab.length;</span><br><span class=\"line\">    Entry e;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//往前检查 记录下最后一个不为空并且key为null的元素的位置 以便后续的删除</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> slotToExpunge = staleSlot;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = prevIndex(staleSlot, len);</span><br><span class=\"line\">         (e = tab[i]) != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">         i = prevIndex(i, len))</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e.get() == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            slotToExpunge = i;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//往后检查 元素不为空并且key相等 就用value替换 直到元素为空</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = nextIndex(staleSlot, len);</span><br><span class=\"line\">         (e = tab[i]) != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">         i = nextIndex(i, len)) &#123;</span><br><span class=\"line\">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//找到需要被替换的过期元素</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (k == key) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//替换value</span></span><br><span class=\"line\">            e.value = value;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//交换 table[i]和table[staleSolt]</span></span><br><span class=\"line\">            tab[i] = tab[staleSlot];</span><br><span class=\"line\">            tab[staleSlot] = e;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// Start expunge at preceding stale entry if it exists</span></span><br><span class=\"line\">            <span class=\"comment\">//重置slotToExpunge为i</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (slotToExpunge == staleSlot)</span><br><span class=\"line\">                slotToExpunge = i;</span><br><span class=\"line\">            <span class=\"comment\">//执行清理逻辑</span></span><br><span class=\"line\">            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//如果前面没有找到过期的元素 slotToExpunge的位置应该从i开始</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (k == <span class=\"keyword\">null</span> &amp;&amp; slotToExpunge == staleSlot)</span><br><span class=\"line\">            slotToExpunge = i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果没有找到匹配的元素 则直接替换把新的值赋值给staleSlot</span></span><br><span class=\"line\">    tab[staleSlot].value = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    tab[staleSlot] = <span class=\"keyword\">new</span> Entry(key, value);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//如果存在需要被清理的元素 执行清理</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (slotToExpunge != staleSlot)</span><br><span class=\"line\">        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>清理的逻辑如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">cleanSomeSlots</span><span class=\"params\">(<span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> removed = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    Entry[] tab = table;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = tab.length;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        i = nextIndex(i, len);</span><br><span class=\"line\">        Entry e = tab[i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span> &amp;&amp; e.get() == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            n = len;</span><br><span class=\"line\">            removed = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            i = expungeStaleEntry(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> ( (n &gt;&gt;&gt;= <span class=\"number\">1</span>) != <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> removed;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>这里看到getMap()这个方法又从Thread中拿了个<code>threadLocals</code>返回了，这个threadLocals在Thread类中定义如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ThreadLocal.ThreadLocalMap threadLocals = <span class=\"keyword\">null</span>;</span><br></pre></td></tr></table></figure>\n\n<p>那这个ThreadLocal.ThreadLocalMap又是个啥呢？看名字的话，知道它是个Map一样的结构。不过它的这些Map相关的操作都是自己实现的，总体逻辑其实和HashMap是类似的。</p>\n<h5 id=\"获取\"><a href=\"#获取\" class=\"headerlink\" title=\"获取\"></a>获取</h5><p>获取通过get()方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Thread t = Thread.currentThread();</span><br><span class=\"line\">    <span class=\"comment\">//拿到当前线程的threadLocals</span></span><br><span class=\"line\">    ThreadLocalMap map = getMap(t);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (map != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        ThreadLocalMap.Entry e = map.getEntry(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"meta\">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class=\"line\">            T result = (T)e.value;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//如果上面没有找到ThreadLocal对应的值，尝试调用setInitialValue来取值，因为可能重写了initialValue方法来获取值 </span></span><br><span class=\"line\">    <span class=\"comment\">//ThreadLocal threadLocal = ThreadLocal.withInitial(()-&gt;new SimpleDateFormat(&quot;yyyy-MM-dd ss:hh:ss&quot;)); 通过这种方式创建</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> setInitialValue();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> T <span class=\"title\">setInitialValue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    T value = initialValue();</span><br><span class=\"line\">    Thread t = Thread.currentThread();</span><br><span class=\"line\">    ThreadLocalMap map = getMap(t);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (map != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        map.set(<span class=\"keyword\">this</span>, value);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        createMap(t, value);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SuppliedThreadLocal</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">ThreadLocal</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Supplier&lt;? extends T&gt; supplier;</span><br><span class=\"line\"></span><br><span class=\"line\">    SuppliedThreadLocal(Supplier&lt;? extends T&gt; supplier) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.supplier = Objects.requireNonNull(supplier);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> T <span class=\"title\">initialValue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> supplier.get();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//因为我们遇到hash冲突的时候不是拉链法去解决的，而是往后找了一个空的位置放进去，所以查询的时候也需要特殊处理一下</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Entry <span class=\"title\">getEntry</span><span class=\"params\">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class=\"number\">1</span>);</span><br><span class=\"line\">    Entry e = table[i];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span> &amp;&amp; e.get() == key)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> e;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> getEntryAfterMiss(key, i, e); <span class=\"comment\">//这里就是特殊处理的地方</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//这个就是如果没有找到就去下一slot去拿 直到拿到元素为止</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Entry <span class=\"title\">getEntryAfterMiss</span><span class=\"params\">(ThreadLocal&lt;?&gt; key, <span class=\"keyword\">int</span> i, Entry e)</span> </span>&#123;</span><br><span class=\"line\">    Entry[] tab = table;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = tab.length;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (e != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (k == key)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> e;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (k == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            expungeStaleEntry(i);</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            i = nextIndex(i, len);</span><br><span class=\"line\">        e = tab[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//这个方法主要是</span></span><br><span class=\"line\"><span class=\"comment\">//删除staleSlot的值</span></span><br><span class=\"line\"><span class=\"comment\">//从staleSlot位置开始，直到下一个table[i]为null的元素之间，删除table[i].key为null的元素，同时调整该区间内的元素位置到合适的位置</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">expungeStaleEntry</span><span class=\"params\">(<span class=\"keyword\">int</span> staleSlot)</span> </span>&#123;</span><br><span class=\"line\">    Entry[] tab = table;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = tab.length;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// expunge entry at staleSlot</span></span><br><span class=\"line\">    <span class=\"comment\">//删除staleSlot位置的元素</span></span><br><span class=\"line\">    tab[staleSlot].value = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    tab[staleSlot] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    size--;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Rehash until we encounter null</span></span><br><span class=\"line\">    <span class=\"comment\">//从staleSlot开始查找需要删除或者更新位置的元素</span></span><br><span class=\"line\">    Entry e;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = nextIndex(staleSlot, len);</span><br><span class=\"line\">         (e = tab[i]) != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">         i = nextIndex(i, len)) &#123;</span><br><span class=\"line\">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (k == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            e.value = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            tab[i] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            size--;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> h = k.threadLocalHashCode &amp; (len - <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (h != i) &#123;</span><br><span class=\"line\">                tab[i] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// Unlike Knuth 6.4 Algorithm R, we must scan until</span></span><br><span class=\"line\">                <span class=\"comment\">// null because multiple entries could have been stale.</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span> (tab[h] != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    h = nextIndex(h, len);</span><br><span class=\"line\">                tab[h] = e;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"删除\"><a href=\"#删除\" class=\"headerlink\" title=\"删除\"></a>删除</h5><p>与Map的remove(key)思想一致。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (m != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        m.remove(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class=\"line\">    Entry[] tab = table;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = tab.length;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = key.threadLocalHashCode &amp; (len-<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Entry e = tab[i];</span><br><span class=\"line\">         e != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e.get() == key) &#123;</span><br><span class=\"line\">            e.clear();</span><br><span class=\"line\">            expungeStaleEntry(i);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"总结一下\"><a href=\"#总结一下\" class=\"headerlink\" title=\"总结一下\"></a>总结一下</h4><p>ThreadLocalMap的key是WeekReference的，这就决定了，在GC时，只要没有任何强引用指向Map中的key，那么该key就会在下一次GC时被回收，从而key.get()就会返回null，而在set、get等方法时，会对key.get()为null的KV键值对进行清理操作，从而释放内存，避免内存泄露。但是和WeekHashMap一样，即使key被GC掉了，变成null，但是如果从此之后不再对map做任何操作，那么这些空key对应的value所占用的内存也是不可能被GC的，这种情况下，有可能发生内存泄漏。</p>\n<p>ThreadLocalMap对hash冲突的处理不是通过拉链法来解决的，而是从当前计算的index往后寻找为空的slot。</p>\n<p>虽然说ThreadLocalMap中的key是弱引用，但是一旦外面还有其他强引用指向该key，意味着该key永远都不可能会被gc掉，那么WeakReferece的能力就基本失去了作用，这就导致内存无法回收的后果，所以每次使用完，确定不再需要该key，就需要调用ThreadLocal的remove方法或者set(null)来帮助GC回收相关内存。</p>\n<h4 id=\"比较容易踩的坑\"><a href=\"#比较容易踩的坑\" class=\"headerlink\" title=\"比较容易踩的坑\"></a>比较容易踩的坑</h4><p>1.使用线程池处理事务时，如果同一线程上一次处理过的ThreadLocal对象，在用完后没有及时清理，很有可能导致该线程在处理下一个事务时，由于没有重新设置该ThreadLocal对象，而导致处理下一个事务的时候，读取到了上一次处理过程中ThreadLocal中的值。</p>\n<p>2.内存泄露问题，因为一般情况下，ThreadLocal对象可能是静态对象，意味着在Thread的ThreadLocalMap中该ThreadLocal的弱引用失效（因为静态对象的引用是强引用），从而无法达到key被GC掉，并且在后续操作Thread的ThreadLocalMap时，无法自动将不再需要的对象清除掉而造成内存泄漏的问题。</p>\n"},{"layout":"post","title":"设计原则-规范与重构","description":"规范与重构","date":"2021-02-25T05:26:10.000Z","_content":"\n### 重构\n\n重构是一种对软件内部结构的改善，目的是在不改变软件的可见行为的情况下，使其更易理解，修改成本更低\n\n可以理解为在保持功能不变的前提下，利用设计思想、原则、模式、变成规范等理论来优化代码，修改设计上的不足，提高代码质量。\n\n**大规模高层次重构**（对顶层代码设计的重构）\n\n重构内容：系统、模块、代码结构、类与类之间的关系等的重构，\n\n重构手段：分层、模块化、解耦、抽象可复用组件等等\n\n这类重构涉及的代码改动会比较多，影响面会比较大，所以难度也较大，耗时较长，引入bug的风险也会相对比较大\n\n**小规模低层次重构**\n\n重构内容：针对类、函数、变量等代码级别的重构，比如规范命名、规范注释、消除超大类或函数、提取重复代码等\n\n重构手段：根据编码规范修改代码\n\n修改的地方比较集中，比较简单，可操作性较强，耗时较短，引入bug的风险较小。只需要熟练掌握各种编码规范，就可以得心应手\n\n**重构的时机**\n\n持续重构。没有事情的时候可以看哪些代码写的不够好、可以优化的代码，主动重构一下。修改、添加某个功能代码的时候，可以顺手把不符合编码规范、不好的设计重构一下。把持续重构也作为开发的一部分，成为一种开发习惯，对项目、对自己都会很有好处。\n\n**重构的方法**\n\n大型重构时，需要提前做好完善的重构计划，有条不紊地分阶段来进行。每个阶段完成一小部分代码的重构，然后提交、测试、运行，没有问题后，再继续进行下一阶段的重构，保证仓库中的代码一直处于可运行、逻辑正确的状态。每个阶段，都要控制好重构影响到的代码范围，考虑好如何兼容老的代码逻辑，必要的时候还要写一些兼容过渡代码。只有这样，才能让每一阶段的重构都不至于耗时太长（最好一天就能完成），不至于与心的功能开发相冲突。大规模高层次的重构一定是有组织、有计划，并且非常谨慎的，需要有经验、熟悉业务的资深同事来主导。\n\n小规模低层次的重构，因为影响范围小，改动耗时短，所以只要有时间，随时都可以去做。除了人工去发现低层次的质量问题，还可以借助很多成熟的静态代码分析工具（C heckStyle、FindBugs、PMD）来自动发现代码中的问题，然后针对性的进行重构优化。\n\n### 单元测试\n\n集成测试的测试对象是整个系统或者某个功能模块，比如测试用户注册、登陆功能是否正常，是一种端到端的测试。单元测试的测试对象是类或者函数，用来测试一个类和函数是否都按照预期的逻辑执行，是代码层级的测试。\n\n单元测试能够有效地发现代码中的bug，可以节省很多修复低级bug的四件，能够有更多时间去做其他更有意义的事情\n\n单元测试能发现代码设计上的问题，可以发现 没有使用依赖注入 大量使用静态函数 全局变量 代码耦合度高等问题\n\n单元测试是对集成测试的有力补充，可以在边界条件、异常情况下测试出bug。如果可以保证每个类、每个函数都能按照我们的预期来执行，底层bug少了，那组装起来的整个系统，出问题的概率也就相应减少了。\n\n写单元测试的过程本身就是代码重构的过程，设计和实现的时候很难把所有的问题都想清楚。编写单元测试相当于一个review，可以发现一些设计上的问题及代码编写方面的问题等，然后进行重构。\n\n阅读单元测试可以快速熟悉代码，阅读代码的最有效手段，就是先了解它的业务背景和设计思路，然后再去看代码，这样代码读起来就会轻松很多。\n\n单元测试是TDD可落地执行的改进方案。测试驱动开发（Test-Driven Development）核心指导思想是测试用例优先于代码编写。\n\n编写单元测试尽管繁琐，但并不是太耗时\n\n我们可以稍微放低对单元测试代码质量的要求\n\n覆盖率作为衡量单元测试质量的唯一标准是不合理的\n\n单元测试不要依赖被测代码的具体实现逻辑\n\n单元测试框架无法测试，多半是因为代码的可测试性不好\n\n**编写可测试性代码的最有效手段**\n\n依赖注入是编写可测试性代码的最有效手段，通过依赖注入，在编写单元测试的时候，可以通过mock的方法解决依赖外部服务，这也是在编写单元测试的过程中最有技术挑战的地方。\n\n**常见的反模式 Anti-Patterns**\n\n代码中包含未决行为逻辑\n\n未决行为逻辑就是，代码的输出是随机或者说不确定的，比如和时间、随机数有关系的代码\n\n滥用可变全局变量\n\n全局变量是一种面向过程的编程风格。存在线程安全及被意料之外的修改等问题，可能会被多行代码影响函数的执行结果\n\n滥用静态方法\n\n静态方法很难mock 只有静态方法执行耗时太长，依赖外部资源，逻辑复杂，行为未决等情况下才需要单元测试mock这个静态方法。如果是类似工具类的Math.abs()这样的简单静态方法，并不会影响代码的可测试性\n\n使用复杂的继承关系\n\n继承关系的代码结构更加耦合、不灵活，更加不易扩展、不易维护。如果父类需要mock某个依赖对象才能进行单元测试，那么所有的子类、子类的子类在单元测试的时候，都需要mock这个依赖对象。\n\n高度耦合的代码\n\n如果一个类职责很重，需要依赖十几个外部对象才能完成工作，代码高度耦合，编写单元测试的时候也需要mock这十几个依赖的对象。不管从代码设计的角度来说还是编写单元测试的角度来说，都是不合理的。\n\n### 解耦\n\n如果说重构是保证代码质量不至于腐化到无可救药地步的有效手段，那么利用解耦的方法对代码重构，就是保证代码不至于复杂到无法控制的有效手段。不管是阅读代码还是修改代码，高内聚、松耦合的特性可以让我们聚焦在某一模块或类中，不需要了解太多其他模块或类的代码，让我们的焦点不至于过于发散，降低了阅读和修改代码的难度。\n\n**如何给代码“解耦”**\n\n1.封装与抽象\n\n封装和抽象可以有效地隐藏实现的复杂性，隔离实现的易变性，给依赖的模块提供稳定且易用的抽象接口。\n\n2.中间层\n\n引入中间层能简化模块或类之间的依赖关系。如A、B、C分别依赖内存以及缓存、Redis二级缓存、DB持久化存储，可以引入数据存储中间层，A、B、C都只需要依赖数据存储中间层就可以实现原有功能，明显的简化了依赖关系，让代码结构更加清晰。\n\n3.模块化\n\n将系统划分成各个独立的模块，让不同的人负责不同的模块，这样即便在不了解全部细节的情况下，管理者也能协调各个模块，让整个系统有效运转。模块化思想更加本质的东西就是分而治之。\n\n4.其他设计思想和原则\n\n单一职责原则\n\n模块或者类的职责设计得单一，而不是大而全，那依赖它的类和它依赖的类就会比较少，代码耦合也就降低了。\n\n基于接口而非实现编程\n\n基于接口而非实现编程能通过接口这样一个中间层，隔离变化和具体的实现。在有依赖关系的两个模块或类之间，一个模块或者类的改动。不会影响到另一个模块或类。\n\n依赖注入\n\n跟基于接口而非实现编程思想类似，依赖注入也是将代码的强耦合变为弱耦合。尽管没办法解耦成没有依赖关系，但是可以让耦合关系没那么紧密，容易做到插拔替换。\n\n多用组合少用继承\n\n继承是一种强依赖关系，父类和子类高度耦合，且这种耦合关系非常脆弱，牵一发而动全身，父类的每一次改动都会影响所有的子类。\n\n迪米特法则\n\n不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口。\n\n观察者模式\n\n\n\n### 编程规范\n\n**程序出错返回值**\n\n1.错误码还是异常\n\n编程语言中有异常语法机制，就不要使用错误码。异常相对于错误码，可以携带更多的错误信息，异常中可以有message，stack trace等信息。\n\n2.NULL\n\nnull表示不存在这种语义。查询返回null还是异常，主要看项目约定，但是对于查找函数来说，查找下标的时候，比如indexOf()函数，返回的是int就没办法用null了，所以-1更加合理。没有查找到是一种正常而非异常的行为，是判断返回null还是异常的标准。\n\n3.返回空对象\n\n比较特殊的空对象就是空字符串和空集合。当函数返回的数据是字符串类型或者集合类型的时候，可以用空字符串或空集合替代NULL值，用来表示不存在的情况，这样在使用函数的时候，就可以不用做null值判断了。\n\n4.抛出异常对象\n\n异常可以将正常逻辑和异常逻辑分离开来，这样代码的可读性就会更好。异常处理是否继续往上抛，需要看上层代码是否关心这个异常，关心就将异常抛出，否则就直接吞掉。是否需要包装成新的异常，看上层代码是否能理解这个异常、是否和业务相关\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/设计原则与思想-规范与重构.md","raw":"---\nlayout:    post\ntitle:     设计原则-规范与重构\ncategory:  设计模式之美\ndescription: 规范与重构\ntags: 设计模式之美\ndate: 2021/02/25 13:26:10\n---\n\n### 重构\n\n重构是一种对软件内部结构的改善，目的是在不改变软件的可见行为的情况下，使其更易理解，修改成本更低\n\n可以理解为在保持功能不变的前提下，利用设计思想、原则、模式、变成规范等理论来优化代码，修改设计上的不足，提高代码质量。\n\n**大规模高层次重构**（对顶层代码设计的重构）\n\n重构内容：系统、模块、代码结构、类与类之间的关系等的重构，\n\n重构手段：分层、模块化、解耦、抽象可复用组件等等\n\n这类重构涉及的代码改动会比较多，影响面会比较大，所以难度也较大，耗时较长，引入bug的风险也会相对比较大\n\n**小规模低层次重构**\n\n重构内容：针对类、函数、变量等代码级别的重构，比如规范命名、规范注释、消除超大类或函数、提取重复代码等\n\n重构手段：根据编码规范修改代码\n\n修改的地方比较集中，比较简单，可操作性较强，耗时较短，引入bug的风险较小。只需要熟练掌握各种编码规范，就可以得心应手\n\n**重构的时机**\n\n持续重构。没有事情的时候可以看哪些代码写的不够好、可以优化的代码，主动重构一下。修改、添加某个功能代码的时候，可以顺手把不符合编码规范、不好的设计重构一下。把持续重构也作为开发的一部分，成为一种开发习惯，对项目、对自己都会很有好处。\n\n**重构的方法**\n\n大型重构时，需要提前做好完善的重构计划，有条不紊地分阶段来进行。每个阶段完成一小部分代码的重构，然后提交、测试、运行，没有问题后，再继续进行下一阶段的重构，保证仓库中的代码一直处于可运行、逻辑正确的状态。每个阶段，都要控制好重构影响到的代码范围，考虑好如何兼容老的代码逻辑，必要的时候还要写一些兼容过渡代码。只有这样，才能让每一阶段的重构都不至于耗时太长（最好一天就能完成），不至于与心的功能开发相冲突。大规模高层次的重构一定是有组织、有计划，并且非常谨慎的，需要有经验、熟悉业务的资深同事来主导。\n\n小规模低层次的重构，因为影响范围小，改动耗时短，所以只要有时间，随时都可以去做。除了人工去发现低层次的质量问题，还可以借助很多成熟的静态代码分析工具（C heckStyle、FindBugs、PMD）来自动发现代码中的问题，然后针对性的进行重构优化。\n\n### 单元测试\n\n集成测试的测试对象是整个系统或者某个功能模块，比如测试用户注册、登陆功能是否正常，是一种端到端的测试。单元测试的测试对象是类或者函数，用来测试一个类和函数是否都按照预期的逻辑执行，是代码层级的测试。\n\n单元测试能够有效地发现代码中的bug，可以节省很多修复低级bug的四件，能够有更多时间去做其他更有意义的事情\n\n单元测试能发现代码设计上的问题，可以发现 没有使用依赖注入 大量使用静态函数 全局变量 代码耦合度高等问题\n\n单元测试是对集成测试的有力补充，可以在边界条件、异常情况下测试出bug。如果可以保证每个类、每个函数都能按照我们的预期来执行，底层bug少了，那组装起来的整个系统，出问题的概率也就相应减少了。\n\n写单元测试的过程本身就是代码重构的过程，设计和实现的时候很难把所有的问题都想清楚。编写单元测试相当于一个review，可以发现一些设计上的问题及代码编写方面的问题等，然后进行重构。\n\n阅读单元测试可以快速熟悉代码，阅读代码的最有效手段，就是先了解它的业务背景和设计思路，然后再去看代码，这样代码读起来就会轻松很多。\n\n单元测试是TDD可落地执行的改进方案。测试驱动开发（Test-Driven Development）核心指导思想是测试用例优先于代码编写。\n\n编写单元测试尽管繁琐，但并不是太耗时\n\n我们可以稍微放低对单元测试代码质量的要求\n\n覆盖率作为衡量单元测试质量的唯一标准是不合理的\n\n单元测试不要依赖被测代码的具体实现逻辑\n\n单元测试框架无法测试，多半是因为代码的可测试性不好\n\n**编写可测试性代码的最有效手段**\n\n依赖注入是编写可测试性代码的最有效手段，通过依赖注入，在编写单元测试的时候，可以通过mock的方法解决依赖外部服务，这也是在编写单元测试的过程中最有技术挑战的地方。\n\n**常见的反模式 Anti-Patterns**\n\n代码中包含未决行为逻辑\n\n未决行为逻辑就是，代码的输出是随机或者说不确定的，比如和时间、随机数有关系的代码\n\n滥用可变全局变量\n\n全局变量是一种面向过程的编程风格。存在线程安全及被意料之外的修改等问题，可能会被多行代码影响函数的执行结果\n\n滥用静态方法\n\n静态方法很难mock 只有静态方法执行耗时太长，依赖外部资源，逻辑复杂，行为未决等情况下才需要单元测试mock这个静态方法。如果是类似工具类的Math.abs()这样的简单静态方法，并不会影响代码的可测试性\n\n使用复杂的继承关系\n\n继承关系的代码结构更加耦合、不灵活，更加不易扩展、不易维护。如果父类需要mock某个依赖对象才能进行单元测试，那么所有的子类、子类的子类在单元测试的时候，都需要mock这个依赖对象。\n\n高度耦合的代码\n\n如果一个类职责很重，需要依赖十几个外部对象才能完成工作，代码高度耦合，编写单元测试的时候也需要mock这十几个依赖的对象。不管从代码设计的角度来说还是编写单元测试的角度来说，都是不合理的。\n\n### 解耦\n\n如果说重构是保证代码质量不至于腐化到无可救药地步的有效手段，那么利用解耦的方法对代码重构，就是保证代码不至于复杂到无法控制的有效手段。不管是阅读代码还是修改代码，高内聚、松耦合的特性可以让我们聚焦在某一模块或类中，不需要了解太多其他模块或类的代码，让我们的焦点不至于过于发散，降低了阅读和修改代码的难度。\n\n**如何给代码“解耦”**\n\n1.封装与抽象\n\n封装和抽象可以有效地隐藏实现的复杂性，隔离实现的易变性，给依赖的模块提供稳定且易用的抽象接口。\n\n2.中间层\n\n引入中间层能简化模块或类之间的依赖关系。如A、B、C分别依赖内存以及缓存、Redis二级缓存、DB持久化存储，可以引入数据存储中间层，A、B、C都只需要依赖数据存储中间层就可以实现原有功能，明显的简化了依赖关系，让代码结构更加清晰。\n\n3.模块化\n\n将系统划分成各个独立的模块，让不同的人负责不同的模块，这样即便在不了解全部细节的情况下，管理者也能协调各个模块，让整个系统有效运转。模块化思想更加本质的东西就是分而治之。\n\n4.其他设计思想和原则\n\n单一职责原则\n\n模块或者类的职责设计得单一，而不是大而全，那依赖它的类和它依赖的类就会比较少，代码耦合也就降低了。\n\n基于接口而非实现编程\n\n基于接口而非实现编程能通过接口这样一个中间层，隔离变化和具体的实现。在有依赖关系的两个模块或类之间，一个模块或者类的改动。不会影响到另一个模块或类。\n\n依赖注入\n\n跟基于接口而非实现编程思想类似，依赖注入也是将代码的强耦合变为弱耦合。尽管没办法解耦成没有依赖关系，但是可以让耦合关系没那么紧密，容易做到插拔替换。\n\n多用组合少用继承\n\n继承是一种强依赖关系，父类和子类高度耦合，且这种耦合关系非常脆弱，牵一发而动全身，父类的每一次改动都会影响所有的子类。\n\n迪米特法则\n\n不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口。\n\n观察者模式\n\n\n\n### 编程规范\n\n**程序出错返回值**\n\n1.错误码还是异常\n\n编程语言中有异常语法机制，就不要使用错误码。异常相对于错误码，可以携带更多的错误信息，异常中可以有message，stack trace等信息。\n\n2.NULL\n\nnull表示不存在这种语义。查询返回null还是异常，主要看项目约定，但是对于查找函数来说，查找下标的时候，比如indexOf()函数，返回的是int就没办法用null了，所以-1更加合理。没有查找到是一种正常而非异常的行为，是判断返回null还是异常的标准。\n\n3.返回空对象\n\n比较特殊的空对象就是空字符串和空集合。当函数返回的数据是字符串类型或者集合类型的时候，可以用空字符串或空集合替代NULL值，用来表示不存在的情况，这样在使用函数的时候，就可以不用做null值判断了。\n\n4.抛出异常对象\n\n异常可以将正常逻辑和异常逻辑分离开来，这样代码的可读性就会更好。异常处理是否继续往上抛，需要看上层代码是否关心这个异常，关心就将异常抛出，否则就直接吞掉。是否需要包装成新的异常，看上层代码是否能理解这个异常、是否和业务相关\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"设计原则与思想-规范与重构","published":1,"updated":"2021-02-25T05:26:10.000Z","comments":1,"photos":[],"link":"","_id":"cm1m304xc000o31b48qahgksa","content":"<h3 id=\"重构\"><a href=\"#重构\" class=\"headerlink\" title=\"重构\"></a>重构</h3><p>重构是一种对软件内部结构的改善，目的是在不改变软件的可见行为的情况下，使其更易理解，修改成本更低</p>\n<p>可以理解为在保持功能不变的前提下，利用设计思想、原则、模式、变成规范等理论来优化代码，修改设计上的不足，提高代码质量。</p>\n<p><strong>大规模高层次重构</strong>（对顶层代码设计的重构）</p>\n<p>重构内容：系统、模块、代码结构、类与类之间的关系等的重构，</p>\n<p>重构手段：分层、模块化、解耦、抽象可复用组件等等</p>\n<p>这类重构涉及的代码改动会比较多，影响面会比较大，所以难度也较大，耗时较长，引入bug的风险也会相对比较大</p>\n<p><strong>小规模低层次重构</strong></p>\n<p>重构内容：针对类、函数、变量等代码级别的重构，比如规范命名、规范注释、消除超大类或函数、提取重复代码等</p>\n<p>重构手段：根据编码规范修改代码</p>\n<p>修改的地方比较集中，比较简单，可操作性较强，耗时较短，引入bug的风险较小。只需要熟练掌握各种编码规范，就可以得心应手</p>\n<p><strong>重构的时机</strong></p>\n<p>持续重构。没有事情的时候可以看哪些代码写的不够好、可以优化的代码，主动重构一下。修改、添加某个功能代码的时候，可以顺手把不符合编码规范、不好的设计重构一下。把持续重构也作为开发的一部分，成为一种开发习惯，对项目、对自己都会很有好处。</p>\n<p><strong>重构的方法</strong></p>\n<p>大型重构时，需要提前做好完善的重构计划，有条不紊地分阶段来进行。每个阶段完成一小部分代码的重构，然后提交、测试、运行，没有问题后，再继续进行下一阶段的重构，保证仓库中的代码一直处于可运行、逻辑正确的状态。每个阶段，都要控制好重构影响到的代码范围，考虑好如何兼容老的代码逻辑，必要的时候还要写一些兼容过渡代码。只有这样，才能让每一阶段的重构都不至于耗时太长（最好一天就能完成），不至于与心的功能开发相冲突。大规模高层次的重构一定是有组织、有计划，并且非常谨慎的，需要有经验、熟悉业务的资深同事来主导。</p>\n<p>小规模低层次的重构，因为影响范围小，改动耗时短，所以只要有时间，随时都可以去做。除了人工去发现低层次的质量问题，还可以借助很多成熟的静态代码分析工具（C heckStyle、FindBugs、PMD）来自动发现代码中的问题，然后针对性的进行重构优化。</p>\n<h3 id=\"单元测试\"><a href=\"#单元测试\" class=\"headerlink\" title=\"单元测试\"></a>单元测试</h3><p>集成测试的测试对象是整个系统或者某个功能模块，比如测试用户注册、登陆功能是否正常，是一种端到端的测试。单元测试的测试对象是类或者函数，用来测试一个类和函数是否都按照预期的逻辑执行，是代码层级的测试。</p>\n<p>单元测试能够有效地发现代码中的bug，可以节省很多修复低级bug的四件，能够有更多时间去做其他更有意义的事情</p>\n<p>单元测试能发现代码设计上的问题，可以发现 没有使用依赖注入 大量使用静态函数 全局变量 代码耦合度高等问题</p>\n<p>单元测试是对集成测试的有力补充，可以在边界条件、异常情况下测试出bug。如果可以保证每个类、每个函数都能按照我们的预期来执行，底层bug少了，那组装起来的整个系统，出问题的概率也就相应减少了。</p>\n<p>写单元测试的过程本身就是代码重构的过程，设计和实现的时候很难把所有的问题都想清楚。编写单元测试相当于一个review，可以发现一些设计上的问题及代码编写方面的问题等，然后进行重构。</p>\n<p>阅读单元测试可以快速熟悉代码，阅读代码的最有效手段，就是先了解它的业务背景和设计思路，然后再去看代码，这样代码读起来就会轻松很多。</p>\n<p>单元测试是TDD可落地执行的改进方案。测试驱动开发（Test-Driven Development）核心指导思想是测试用例优先于代码编写。</p>\n<p>编写单元测试尽管繁琐，但并不是太耗时</p>\n<p>我们可以稍微放低对单元测试代码质量的要求</p>\n<p>覆盖率作为衡量单元测试质量的唯一标准是不合理的</p>\n<p>单元测试不要依赖被测代码的具体实现逻辑</p>\n<p>单元测试框架无法测试，多半是因为代码的可测试性不好</p>\n<p><strong>编写可测试性代码的最有效手段</strong></p>\n<p>依赖注入是编写可测试性代码的最有效手段，通过依赖注入，在编写单元测试的时候，可以通过mock的方法解决依赖外部服务，这也是在编写单元测试的过程中最有技术挑战的地方。</p>\n<p><strong>常见的反模式 Anti-Patterns</strong></p>\n<p>代码中包含未决行为逻辑</p>\n<p>未决行为逻辑就是，代码的输出是随机或者说不确定的，比如和时间、随机数有关系的代码</p>\n<p>滥用可变全局变量</p>\n<p>全局变量是一种面向过程的编程风格。存在线程安全及被意料之外的修改等问题，可能会被多行代码影响函数的执行结果</p>\n<p>滥用静态方法</p>\n<p>静态方法很难mock 只有静态方法执行耗时太长，依赖外部资源，逻辑复杂，行为未决等情况下才需要单元测试mock这个静态方法。如果是类似工具类的Math.abs()这样的简单静态方法，并不会影响代码的可测试性</p>\n<p>使用复杂的继承关系</p>\n<p>继承关系的代码结构更加耦合、不灵活，更加不易扩展、不易维护。如果父类需要mock某个依赖对象才能进行单元测试，那么所有的子类、子类的子类在单元测试的时候，都需要mock这个依赖对象。</p>\n<p>高度耦合的代码</p>\n<p>如果一个类职责很重，需要依赖十几个外部对象才能完成工作，代码高度耦合，编写单元测试的时候也需要mock这十几个依赖的对象。不管从代码设计的角度来说还是编写单元测试的角度来说，都是不合理的。</p>\n<h3 id=\"解耦\"><a href=\"#解耦\" class=\"headerlink\" title=\"解耦\"></a>解耦</h3><p>如果说重构是保证代码质量不至于腐化到无可救药地步的有效手段，那么利用解耦的方法对代码重构，就是保证代码不至于复杂到无法控制的有效手段。不管是阅读代码还是修改代码，高内聚、松耦合的特性可以让我们聚焦在某一模块或类中，不需要了解太多其他模块或类的代码，让我们的焦点不至于过于发散，降低了阅读和修改代码的难度。</p>\n<p><strong>如何给代码“解耦”</strong></p>\n<p>1.封装与抽象</p>\n<p>封装和抽象可以有效地隐藏实现的复杂性，隔离实现的易变性，给依赖的模块提供稳定且易用的抽象接口。</p>\n<p>2.中间层</p>\n<p>引入中间层能简化模块或类之间的依赖关系。如A、B、C分别依赖内存以及缓存、Redis二级缓存、DB持久化存储，可以引入数据存储中间层，A、B、C都只需要依赖数据存储中间层就可以实现原有功能，明显的简化了依赖关系，让代码结构更加清晰。</p>\n<p>3.模块化</p>\n<p>将系统划分成各个独立的模块，让不同的人负责不同的模块，这样即便在不了解全部细节的情况下，管理者也能协调各个模块，让整个系统有效运转。模块化思想更加本质的东西就是分而治之。</p>\n<p>4.其他设计思想和原则</p>\n<p>单一职责原则</p>\n<p>模块或者类的职责设计得单一，而不是大而全，那依赖它的类和它依赖的类就会比较少，代码耦合也就降低了。</p>\n<p>基于接口而非实现编程</p>\n<p>基于接口而非实现编程能通过接口这样一个中间层，隔离变化和具体的实现。在有依赖关系的两个模块或类之间，一个模块或者类的改动。不会影响到另一个模块或类。</p>\n<p>依赖注入</p>\n<p>跟基于接口而非实现编程思想类似，依赖注入也是将代码的强耦合变为弱耦合。尽管没办法解耦成没有依赖关系，但是可以让耦合关系没那么紧密，容易做到插拔替换。</p>\n<p>多用组合少用继承</p>\n<p>继承是一种强依赖关系，父类和子类高度耦合，且这种耦合关系非常脆弱，牵一发而动全身，父类的每一次改动都会影响所有的子类。</p>\n<p>迪米特法则</p>\n<p>不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口。</p>\n<p>观察者模式</p>\n<h3 id=\"编程规范\"><a href=\"#编程规范\" class=\"headerlink\" title=\"编程规范\"></a>编程规范</h3><p><strong>程序出错返回值</strong></p>\n<p>1.错误码还是异常</p>\n<p>编程语言中有异常语法机制，就不要使用错误码。异常相对于错误码，可以携带更多的错误信息，异常中可以有message，stack trace等信息。</p>\n<p>2.NULL</p>\n<p>null表示不存在这种语义。查询返回null还是异常，主要看项目约定，但是对于查找函数来说，查找下标的时候，比如indexOf()函数，返回的是int就没办法用null了，所以-1更加合理。没有查找到是一种正常而非异常的行为，是判断返回null还是异常的标准。</p>\n<p>3.返回空对象</p>\n<p>比较特殊的空对象就是空字符串和空集合。当函数返回的数据是字符串类型或者集合类型的时候，可以用空字符串或空集合替代NULL值，用来表示不存在的情况，这样在使用函数的时候，就可以不用做null值判断了。</p>\n<p>4.抛出异常对象</p>\n<p>异常可以将正常逻辑和异常逻辑分离开来，这样代码的可读性就会更好。异常处理是否继续往上抛，需要看上层代码是否关心这个异常，关心就将异常抛出，否则就直接吞掉。是否需要包装成新的异常，看上层代码是否能理解这个异常、是否和业务相关</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"重构\"><a href=\"#重构\" class=\"headerlink\" title=\"重构\"></a>重构</h3><p>重构是一种对软件内部结构的改善，目的是在不改变软件的可见行为的情况下，使其更易理解，修改成本更低</p>\n<p>可以理解为在保持功能不变的前提下，利用设计思想、原则、模式、变成规范等理论来优化代码，修改设计上的不足，提高代码质量。</p>\n<p><strong>大规模高层次重构</strong>（对顶层代码设计的重构）</p>\n<p>重构内容：系统、模块、代码结构、类与类之间的关系等的重构，</p>\n<p>重构手段：分层、模块化、解耦、抽象可复用组件等等</p>\n<p>这类重构涉及的代码改动会比较多，影响面会比较大，所以难度也较大，耗时较长，引入bug的风险也会相对比较大</p>\n<p><strong>小规模低层次重构</strong></p>\n<p>重构内容：针对类、函数、变量等代码级别的重构，比如规范命名、规范注释、消除超大类或函数、提取重复代码等</p>\n<p>重构手段：根据编码规范修改代码</p>\n<p>修改的地方比较集中，比较简单，可操作性较强，耗时较短，引入bug的风险较小。只需要熟练掌握各种编码规范，就可以得心应手</p>\n<p><strong>重构的时机</strong></p>\n<p>持续重构。没有事情的时候可以看哪些代码写的不够好、可以优化的代码，主动重构一下。修改、添加某个功能代码的时候，可以顺手把不符合编码规范、不好的设计重构一下。把持续重构也作为开发的一部分，成为一种开发习惯，对项目、对自己都会很有好处。</p>\n<p><strong>重构的方法</strong></p>\n<p>大型重构时，需要提前做好完善的重构计划，有条不紊地分阶段来进行。每个阶段完成一小部分代码的重构，然后提交、测试、运行，没有问题后，再继续进行下一阶段的重构，保证仓库中的代码一直处于可运行、逻辑正确的状态。每个阶段，都要控制好重构影响到的代码范围，考虑好如何兼容老的代码逻辑，必要的时候还要写一些兼容过渡代码。只有这样，才能让每一阶段的重构都不至于耗时太长（最好一天就能完成），不至于与心的功能开发相冲突。大规模高层次的重构一定是有组织、有计划，并且非常谨慎的，需要有经验、熟悉业务的资深同事来主导。</p>\n<p>小规模低层次的重构，因为影响范围小，改动耗时短，所以只要有时间，随时都可以去做。除了人工去发现低层次的质量问题，还可以借助很多成熟的静态代码分析工具（C heckStyle、FindBugs、PMD）来自动发现代码中的问题，然后针对性的进行重构优化。</p>\n<h3 id=\"单元测试\"><a href=\"#单元测试\" class=\"headerlink\" title=\"单元测试\"></a>单元测试</h3><p>集成测试的测试对象是整个系统或者某个功能模块，比如测试用户注册、登陆功能是否正常，是一种端到端的测试。单元测试的测试对象是类或者函数，用来测试一个类和函数是否都按照预期的逻辑执行，是代码层级的测试。</p>\n<p>单元测试能够有效地发现代码中的bug，可以节省很多修复低级bug的四件，能够有更多时间去做其他更有意义的事情</p>\n<p>单元测试能发现代码设计上的问题，可以发现 没有使用依赖注入 大量使用静态函数 全局变量 代码耦合度高等问题</p>\n<p>单元测试是对集成测试的有力补充，可以在边界条件、异常情况下测试出bug。如果可以保证每个类、每个函数都能按照我们的预期来执行，底层bug少了，那组装起来的整个系统，出问题的概率也就相应减少了。</p>\n<p>写单元测试的过程本身就是代码重构的过程，设计和实现的时候很难把所有的问题都想清楚。编写单元测试相当于一个review，可以发现一些设计上的问题及代码编写方面的问题等，然后进行重构。</p>\n<p>阅读单元测试可以快速熟悉代码，阅读代码的最有效手段，就是先了解它的业务背景和设计思路，然后再去看代码，这样代码读起来就会轻松很多。</p>\n<p>单元测试是TDD可落地执行的改进方案。测试驱动开发（Test-Driven Development）核心指导思想是测试用例优先于代码编写。</p>\n<p>编写单元测试尽管繁琐，但并不是太耗时</p>\n<p>我们可以稍微放低对单元测试代码质量的要求</p>\n<p>覆盖率作为衡量单元测试质量的唯一标准是不合理的</p>\n<p>单元测试不要依赖被测代码的具体实现逻辑</p>\n<p>单元测试框架无法测试，多半是因为代码的可测试性不好</p>\n<p><strong>编写可测试性代码的最有效手段</strong></p>\n<p>依赖注入是编写可测试性代码的最有效手段，通过依赖注入，在编写单元测试的时候，可以通过mock的方法解决依赖外部服务，这也是在编写单元测试的过程中最有技术挑战的地方。</p>\n<p><strong>常见的反模式 Anti-Patterns</strong></p>\n<p>代码中包含未决行为逻辑</p>\n<p>未决行为逻辑就是，代码的输出是随机或者说不确定的，比如和时间、随机数有关系的代码</p>\n<p>滥用可变全局变量</p>\n<p>全局变量是一种面向过程的编程风格。存在线程安全及被意料之外的修改等问题，可能会被多行代码影响函数的执行结果</p>\n<p>滥用静态方法</p>\n<p>静态方法很难mock 只有静态方法执行耗时太长，依赖外部资源，逻辑复杂，行为未决等情况下才需要单元测试mock这个静态方法。如果是类似工具类的Math.abs()这样的简单静态方法，并不会影响代码的可测试性</p>\n<p>使用复杂的继承关系</p>\n<p>继承关系的代码结构更加耦合、不灵活，更加不易扩展、不易维护。如果父类需要mock某个依赖对象才能进行单元测试，那么所有的子类、子类的子类在单元测试的时候，都需要mock这个依赖对象。</p>\n<p>高度耦合的代码</p>\n<p>如果一个类职责很重，需要依赖十几个外部对象才能完成工作，代码高度耦合，编写单元测试的时候也需要mock这十几个依赖的对象。不管从代码设计的角度来说还是编写单元测试的角度来说，都是不合理的。</p>\n<h3 id=\"解耦\"><a href=\"#解耦\" class=\"headerlink\" title=\"解耦\"></a>解耦</h3><p>如果说重构是保证代码质量不至于腐化到无可救药地步的有效手段，那么利用解耦的方法对代码重构，就是保证代码不至于复杂到无法控制的有效手段。不管是阅读代码还是修改代码，高内聚、松耦合的特性可以让我们聚焦在某一模块或类中，不需要了解太多其他模块或类的代码，让我们的焦点不至于过于发散，降低了阅读和修改代码的难度。</p>\n<p><strong>如何给代码“解耦”</strong></p>\n<p>1.封装与抽象</p>\n<p>封装和抽象可以有效地隐藏实现的复杂性，隔离实现的易变性，给依赖的模块提供稳定且易用的抽象接口。</p>\n<p>2.中间层</p>\n<p>引入中间层能简化模块或类之间的依赖关系。如A、B、C分别依赖内存以及缓存、Redis二级缓存、DB持久化存储，可以引入数据存储中间层，A、B、C都只需要依赖数据存储中间层就可以实现原有功能，明显的简化了依赖关系，让代码结构更加清晰。</p>\n<p>3.模块化</p>\n<p>将系统划分成各个独立的模块，让不同的人负责不同的模块，这样即便在不了解全部细节的情况下，管理者也能协调各个模块，让整个系统有效运转。模块化思想更加本质的东西就是分而治之。</p>\n<p>4.其他设计思想和原则</p>\n<p>单一职责原则</p>\n<p>模块或者类的职责设计得单一，而不是大而全，那依赖它的类和它依赖的类就会比较少，代码耦合也就降低了。</p>\n<p>基于接口而非实现编程</p>\n<p>基于接口而非实现编程能通过接口这样一个中间层，隔离变化和具体的实现。在有依赖关系的两个模块或类之间，一个模块或者类的改动。不会影响到另一个模块或类。</p>\n<p>依赖注入</p>\n<p>跟基于接口而非实现编程思想类似，依赖注入也是将代码的强耦合变为弱耦合。尽管没办法解耦成没有依赖关系，但是可以让耦合关系没那么紧密，容易做到插拔替换。</p>\n<p>多用组合少用继承</p>\n<p>继承是一种强依赖关系，父类和子类高度耦合，且这种耦合关系非常脆弱，牵一发而动全身，父类的每一次改动都会影响所有的子类。</p>\n<p>迪米特法则</p>\n<p>不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口。</p>\n<p>观察者模式</p>\n<h3 id=\"编程规范\"><a href=\"#编程规范\" class=\"headerlink\" title=\"编程规范\"></a>编程规范</h3><p><strong>程序出错返回值</strong></p>\n<p>1.错误码还是异常</p>\n<p>编程语言中有异常语法机制，就不要使用错误码。异常相对于错误码，可以携带更多的错误信息，异常中可以有message，stack trace等信息。</p>\n<p>2.NULL</p>\n<p>null表示不存在这种语义。查询返回null还是异常，主要看项目约定，但是对于查找函数来说，查找下标的时候，比如indexOf()函数，返回的是int就没办法用null了，所以-1更加合理。没有查找到是一种正常而非异常的行为，是判断返回null还是异常的标准。</p>\n<p>3.返回空对象</p>\n<p>比较特殊的空对象就是空字符串和空集合。当函数返回的数据是字符串类型或者集合类型的时候，可以用空字符串或空集合替代NULL值，用来表示不存在的情况，这样在使用函数的时候，就可以不用做null值判断了。</p>\n<p>4.抛出异常对象</p>\n<p>异常可以将正常逻辑和异常逻辑分离开来，这样代码的可读性就会更好。异常处理是否继续往上抛，需要看上层代码是否关心这个异常，关心就将异常抛出，否则就直接吞掉。是否需要包装成新的异常，看上层代码是否能理解这个异常、是否和业务相关</p>\n"},{"layout":"post","title":"设计原则","description":"设计模式与设计原则","date":"2020-11-30T15:11:10.000Z","_content":"\n#### 开闭原则\n\n开闭原则(Open-Closed Principle,OCP)是指一个软件实体，如类、模块和函数应该对扩展开放，对修改关闭。强调用抽象构建框架，用实现扩展细节，可以提高系统的可复用性及可维护性。\n\n```java\n//假设有一个课程接口 各个课程需要实现课程接口成为课程\npublic interface ICourse {\n    Integer getId();\n\n    String getName();\n\n    Double getPrice();\n}\n```\n\n此时需要给课程增加一个优惠活动，如果修改一个已经存在的课程的getPrice()，可能会造成风险，影响别的地方的调用结果。我们可以写一个处理优惠逻辑的类，来专门处理这种情况。\n\n```java\npublic class JavaDiscountCourse extends JavaCourse {\n    public JavaDiscountCourse(Integer id, String name, Double price) {\n        super(id, name, price);\n    }\n\n    public Double getOriginPrice() {\n        return super.getPrice();\n    }\n\n    public Double getPrice() {\n        return super.getPrice() * 0.61;\n    }\n}\n```\n\n#### 依赖倒置原则\n\n依赖倒置原则(Dependence Inversion Principle,DIP)是指设计代码结构时，高层模块不应该依赖底层模块，二者都应该依赖其抽象。抽象不应该依赖细节；细节应该依赖抽象。通过依赖倒置，可以减少类与类之间的耦合性，提高系统的稳定性，提高代码的可读性和可维护性，降低修改程序造成的风险。\n\n```java\npublic class Tom {\n    public void studyJavaCourse() {\n        System.out.println(\"Tom 在学习 Java 的课程\");\n    }\n\n    public void studyPythonCourse() {\n        System.out.println(\"Tom 在学习 Python 的课程\");\n    }\n}\n```\n\n假设需要增加一个新的课程，那么需要从底层到调用层修改代码，这样就非常不灵活，还可能会有意想不到的风险。\n\n我们可以创建一个接口作为课程，然后通过set方法将实例设置进来，调用对应的逻辑。\n\n```java\npublic class JavaCourse implements ICourse {\n    @Override\n    public void study() {\n        System.out.println(\"学习Java课程\");\n    }\n}\n```\n\n```java\npublic Class Tom{\n    public void study(ICourse course){\n        course.study();\n    }\n}\n```\n\n```java\npublic static void main(String[]args){\n        Tom tom=new Tom();\n        tom.study(new JavaCourse());\n}\n```\n\n这样无论想学什么课，我们只需要新建一个类，然后通过参数的方式告诉Tom，而不需要修改底层代码。实际是这是依赖注入，注入的方式还有构造器方式和setter方式。以抽象为基准比以细节为基准搭建起来的架构要稳定的多，因此要面向接口编程，先顶层再细节来设计代码结构。\n\n#### 单一职责原则\n\n单一职责(Simple Responsibility Pinciple，SRP)是指不要存在多于一个导致类变更的原因。也就是说一个Class/Interface/Method只负责一项职责。\n\n#### 接口隔离原则\n\n接口隔离原则(Interface Segregation Principle，ISP)是指用多个专门的接口，而不是用一个总接口，客户端不应该依赖它不需要的接口。这个原则指导我们在接口设计时应当注意以下几点：\n\n1.一个类对一类的依赖应该建立在最小的接口上\n\n2.建立单一接口，不要建立庞大臃肿的接口\n\n3.尽量细化接口，接口中的方法尽量少(不是越少越好，一定要适度)\n\n写一个动物的接口\n\n```java\npublic interface IAnimal {\n    void eat();\n\n    void fly();\n\n    void swim();\n}\n```\n\n当Dog去实现动物接口的时候，因为Dog不会飞，所以fly()要空实现。这个时候其实我们发现这个接口是一个总接口，我们应该设计专用的接口，让需要功能的动物去实现。\n\n```java\npublic interface IFlyAnimal {\n    void fly();\n}\n```\n\n```java\npublic interface IEatAnimal {\n    void eat();\n}\n```\n\n```java\npublic class Bird implements IFlyAnimal, IEatAnimal {\n    @Override\n    public void eat() {\n    }\n\n    @Override\n    public void fly() {\n    }\n}\n```\n\n#### 迪米特法则\n\n迪米特法则(Law of Demeter LoD)是指一个对象应该对其他对象保持最少的了解，又叫最少知道原则(Least Knowledge Principle,LKP)\n，尽量降低类与类之间的耦合。迪米特原则强调只和朋友交流，不和陌生人说话。出现在成员变量、方法的输入、输出参数中的类都可以称之为成员朋友类，而出现在方法体内部的类不属于朋友类。\n\n设计一个权限系统，TeamLeader需要查看目前发布到线上的课程数量。这时候TeamLeader要找员工Employee进行统计，Employee再把统计结果告诉TeamLeader\n\n```java\npublic class Course {\n}\n```\n\n```java\npublic class Employee {\n    public void checkNumberOfCourse(List<Course> courseList) {\n        System.out.println(\"目前已经发布的课程数量是：\" + courseList.size());\n    }\n}\n```\n\n```java\npublic class TeamLeader {\n    public void commandCheckNumber(Employee employee) {\n        List<Course> courseList = new ArrayList<Course>();\n        for (int i = 0; i < 20; i++) {\n            courseList.add(new Course());\n        }\n        employee.checkNumberOfCourse(courseList);\n    }\n}\n```\n\n功能基本上实现了，但是根据迪米特法则，TeamLeader只想要结果，不需要根Course产生直接的交流。而Employee统计需要引用Course对象。根据迪米特法则改造下\n\n```java\npublic class Employee {\n    public void checkNumberOfCourse() {\n        List<Course> courseList = new ArrayList<Course>();\n        for (int i = 0; i < 20; i++) {\n            courseList.add(new Course());\n        }\n        System.out.println(\"目前已经发布的课程数量是：\" + courseList.size());\n    }\n}\n```\n\n```java\npublic class TeamLeader {\n    public void commandCheckNumber(Employee employee) {\n        employee.checkNumberOfCourse();\n    }\n}\n```\n\n#### 里氏替换原则\n\n里氏替换原则 (Liskov Substitution Principle,LSP)\n是指如果对一个类型为T1的对象o1，都有类型为T2的对象o2，使得以T1定义的所有程序P在所有的对象o1都替换成o2时，程序P的行为没有发生变化，那么类型T2是类型T1的子类型。\n\n定义比较抽象，多读几遍理解的话，其实就是子类对象能够替换程序中父类对象出现的任何地方，并且保证原来程序的逻辑行为不变及正确性不被破坏。\n\n1. 子类可以实现父类的抽象方法，但不能改变父类原有的功能\n\n2. 子类中可以增加自己特有的方法\n\n3. 当子类的方法重载父类的方法时，方法的前置条件 (方法的输入/入参) 要比父类的输入参数更宽松\n\n4. 当子类的方法实现父类的方法时 (重写/重载或实现抽象方法) 方法，方法的后置条件 (方法的输出/返回值) 要比父类更严格或相等\n\n   下面举个例子，父类Transporter使用org.apache.http库中的HttpClient类来传输网络数据。子类SecurityTransporter继承父类Transport，增加了额外的功能，支持appId和appToken安全认证信息\n\n```java\n   public class Transport {\n     private HttpClient httpClient;\n     \n     public Transport(HttpClient httpClient){\n       this.httpClient = httpClient;\n     }\n     \n     public Response sendRequest(Request request){\n       //...use httpClient to send request\n     }\n   }\n```\n\n```java\n   public class SecurityTransport extends Transport {\n     private String appId;\n     private String appToken;\n     \n     public SecurityTransport(HttpClient httpClient,String appId,String appToken) {\n       super(httpClient);\n       this.appId = appId;\n       this.appToken = appToken;\n     }\n     \n     @Override\n     public Response sendRequest(Request request){\n       if(StringUtils.isNotBlank(appId)&&StringUtils.isNotBlank(appToken)){\n         request.addPayload(\"app-id\",appId);\n         request.addPayload(\"app-token\",appToken);\n       }\n       return super.sendRequest(request);\n     }\n   }\n```\n\n#### 合成复用原则\n\n合成复用原则 (Composite/Aggregate Reuse Principle,CARP) 是指尽量使用对象组合 (has-a)/聚合 (contains-a),而不是继承关系达到软件复用的目的。可以使系统更加灵活，降低类与类之间的耦合度，一个类的变化对其他类造成的影响相对较少。以操作数据库为例\n\n```java\n   public class DBConnection{\n     public String getConnection(){\n       return \"MySQL 数据库连接\";\n     }\n   }\n```\n\n```java\n   public class ProductDao{\n     private DBConnection dbConnection;\n     \n     public ProductDao(Dbconnection dbConnection){\n       this.dbConnection = dbConnection;\n     }\n   }\n```\n\n这是一种典型的合成复用场景，但是目前的设计不利于系统扩展。目前的数据库连接仅支持MySQL。我们可以在DbConnection中增加对别的数据库的支持，但是这违背了开闭原则，我们可以把DBConnection修改为一个抽象类，然后分别让不同的数据库继承这个抽象类，来实现对各个数据库连接的支持。\n\n```java\n   public abstract class DBConnection{\n     public abstract String getConnection();\n   }\n```\n\n```java\n   public class MySQLConnection extends DBConnection {\n     @Override\n     public String getConnection() {\n       return \"MySQL 数据库连接\";\n     }\n   }\n```\n\n####  设计原则总结\n我们在开发中，并不是一定要求所有的代码都遵循设计原则，我们要考虑人力、时间、成本、质量，在适当的场景遵循设计原则，体现的是一种动态取舍，帮助我们设计出更加优雅的代码结构。\n","source":"_posts/设计原则.md","raw":"---\nlayout:    post\ntitle:     设计原则\ncategory:  设计模式之美\ndescription: 设计模式与设计原则\ntags: 设计模式之美\ndate: 2020/11/30 23:11:10\n---\n\n#### 开闭原则\n\n开闭原则(Open-Closed Principle,OCP)是指一个软件实体，如类、模块和函数应该对扩展开放，对修改关闭。强调用抽象构建框架，用实现扩展细节，可以提高系统的可复用性及可维护性。\n\n```java\n//假设有一个课程接口 各个课程需要实现课程接口成为课程\npublic interface ICourse {\n    Integer getId();\n\n    String getName();\n\n    Double getPrice();\n}\n```\n\n此时需要给课程增加一个优惠活动，如果修改一个已经存在的课程的getPrice()，可能会造成风险，影响别的地方的调用结果。我们可以写一个处理优惠逻辑的类，来专门处理这种情况。\n\n```java\npublic class JavaDiscountCourse extends JavaCourse {\n    public JavaDiscountCourse(Integer id, String name, Double price) {\n        super(id, name, price);\n    }\n\n    public Double getOriginPrice() {\n        return super.getPrice();\n    }\n\n    public Double getPrice() {\n        return super.getPrice() * 0.61;\n    }\n}\n```\n\n#### 依赖倒置原则\n\n依赖倒置原则(Dependence Inversion Principle,DIP)是指设计代码结构时，高层模块不应该依赖底层模块，二者都应该依赖其抽象。抽象不应该依赖细节；细节应该依赖抽象。通过依赖倒置，可以减少类与类之间的耦合性，提高系统的稳定性，提高代码的可读性和可维护性，降低修改程序造成的风险。\n\n```java\npublic class Tom {\n    public void studyJavaCourse() {\n        System.out.println(\"Tom 在学习 Java 的课程\");\n    }\n\n    public void studyPythonCourse() {\n        System.out.println(\"Tom 在学习 Python 的课程\");\n    }\n}\n```\n\n假设需要增加一个新的课程，那么需要从底层到调用层修改代码，这样就非常不灵活，还可能会有意想不到的风险。\n\n我们可以创建一个接口作为课程，然后通过set方法将实例设置进来，调用对应的逻辑。\n\n```java\npublic class JavaCourse implements ICourse {\n    @Override\n    public void study() {\n        System.out.println(\"学习Java课程\");\n    }\n}\n```\n\n```java\npublic Class Tom{\n    public void study(ICourse course){\n        course.study();\n    }\n}\n```\n\n```java\npublic static void main(String[]args){\n        Tom tom=new Tom();\n        tom.study(new JavaCourse());\n}\n```\n\n这样无论想学什么课，我们只需要新建一个类，然后通过参数的方式告诉Tom，而不需要修改底层代码。实际是这是依赖注入，注入的方式还有构造器方式和setter方式。以抽象为基准比以细节为基准搭建起来的架构要稳定的多，因此要面向接口编程，先顶层再细节来设计代码结构。\n\n#### 单一职责原则\n\n单一职责(Simple Responsibility Pinciple，SRP)是指不要存在多于一个导致类变更的原因。也就是说一个Class/Interface/Method只负责一项职责。\n\n#### 接口隔离原则\n\n接口隔离原则(Interface Segregation Principle，ISP)是指用多个专门的接口，而不是用一个总接口，客户端不应该依赖它不需要的接口。这个原则指导我们在接口设计时应当注意以下几点：\n\n1.一个类对一类的依赖应该建立在最小的接口上\n\n2.建立单一接口，不要建立庞大臃肿的接口\n\n3.尽量细化接口，接口中的方法尽量少(不是越少越好，一定要适度)\n\n写一个动物的接口\n\n```java\npublic interface IAnimal {\n    void eat();\n\n    void fly();\n\n    void swim();\n}\n```\n\n当Dog去实现动物接口的时候，因为Dog不会飞，所以fly()要空实现。这个时候其实我们发现这个接口是一个总接口，我们应该设计专用的接口，让需要功能的动物去实现。\n\n```java\npublic interface IFlyAnimal {\n    void fly();\n}\n```\n\n```java\npublic interface IEatAnimal {\n    void eat();\n}\n```\n\n```java\npublic class Bird implements IFlyAnimal, IEatAnimal {\n    @Override\n    public void eat() {\n    }\n\n    @Override\n    public void fly() {\n    }\n}\n```\n\n#### 迪米特法则\n\n迪米特法则(Law of Demeter LoD)是指一个对象应该对其他对象保持最少的了解，又叫最少知道原则(Least Knowledge Principle,LKP)\n，尽量降低类与类之间的耦合。迪米特原则强调只和朋友交流，不和陌生人说话。出现在成员变量、方法的输入、输出参数中的类都可以称之为成员朋友类，而出现在方法体内部的类不属于朋友类。\n\n设计一个权限系统，TeamLeader需要查看目前发布到线上的课程数量。这时候TeamLeader要找员工Employee进行统计，Employee再把统计结果告诉TeamLeader\n\n```java\npublic class Course {\n}\n```\n\n```java\npublic class Employee {\n    public void checkNumberOfCourse(List<Course> courseList) {\n        System.out.println(\"目前已经发布的课程数量是：\" + courseList.size());\n    }\n}\n```\n\n```java\npublic class TeamLeader {\n    public void commandCheckNumber(Employee employee) {\n        List<Course> courseList = new ArrayList<Course>();\n        for (int i = 0; i < 20; i++) {\n            courseList.add(new Course());\n        }\n        employee.checkNumberOfCourse(courseList);\n    }\n}\n```\n\n功能基本上实现了，但是根据迪米特法则，TeamLeader只想要结果，不需要根Course产生直接的交流。而Employee统计需要引用Course对象。根据迪米特法则改造下\n\n```java\npublic class Employee {\n    public void checkNumberOfCourse() {\n        List<Course> courseList = new ArrayList<Course>();\n        for (int i = 0; i < 20; i++) {\n            courseList.add(new Course());\n        }\n        System.out.println(\"目前已经发布的课程数量是：\" + courseList.size());\n    }\n}\n```\n\n```java\npublic class TeamLeader {\n    public void commandCheckNumber(Employee employee) {\n        employee.checkNumberOfCourse();\n    }\n}\n```\n\n#### 里氏替换原则\n\n里氏替换原则 (Liskov Substitution Principle,LSP)\n是指如果对一个类型为T1的对象o1，都有类型为T2的对象o2，使得以T1定义的所有程序P在所有的对象o1都替换成o2时，程序P的行为没有发生变化，那么类型T2是类型T1的子类型。\n\n定义比较抽象，多读几遍理解的话，其实就是子类对象能够替换程序中父类对象出现的任何地方，并且保证原来程序的逻辑行为不变及正确性不被破坏。\n\n1. 子类可以实现父类的抽象方法，但不能改变父类原有的功能\n\n2. 子类中可以增加自己特有的方法\n\n3. 当子类的方法重载父类的方法时，方法的前置条件 (方法的输入/入参) 要比父类的输入参数更宽松\n\n4. 当子类的方法实现父类的方法时 (重写/重载或实现抽象方法) 方法，方法的后置条件 (方法的输出/返回值) 要比父类更严格或相等\n\n   下面举个例子，父类Transporter使用org.apache.http库中的HttpClient类来传输网络数据。子类SecurityTransporter继承父类Transport，增加了额外的功能，支持appId和appToken安全认证信息\n\n```java\n   public class Transport {\n     private HttpClient httpClient;\n     \n     public Transport(HttpClient httpClient){\n       this.httpClient = httpClient;\n     }\n     \n     public Response sendRequest(Request request){\n       //...use httpClient to send request\n     }\n   }\n```\n\n```java\n   public class SecurityTransport extends Transport {\n     private String appId;\n     private String appToken;\n     \n     public SecurityTransport(HttpClient httpClient,String appId,String appToken) {\n       super(httpClient);\n       this.appId = appId;\n       this.appToken = appToken;\n     }\n     \n     @Override\n     public Response sendRequest(Request request){\n       if(StringUtils.isNotBlank(appId)&&StringUtils.isNotBlank(appToken)){\n         request.addPayload(\"app-id\",appId);\n         request.addPayload(\"app-token\",appToken);\n       }\n       return super.sendRequest(request);\n     }\n   }\n```\n\n#### 合成复用原则\n\n合成复用原则 (Composite/Aggregate Reuse Principle,CARP) 是指尽量使用对象组合 (has-a)/聚合 (contains-a),而不是继承关系达到软件复用的目的。可以使系统更加灵活，降低类与类之间的耦合度，一个类的变化对其他类造成的影响相对较少。以操作数据库为例\n\n```java\n   public class DBConnection{\n     public String getConnection(){\n       return \"MySQL 数据库连接\";\n     }\n   }\n```\n\n```java\n   public class ProductDao{\n     private DBConnection dbConnection;\n     \n     public ProductDao(Dbconnection dbConnection){\n       this.dbConnection = dbConnection;\n     }\n   }\n```\n\n这是一种典型的合成复用场景，但是目前的设计不利于系统扩展。目前的数据库连接仅支持MySQL。我们可以在DbConnection中增加对别的数据库的支持，但是这违背了开闭原则，我们可以把DBConnection修改为一个抽象类，然后分别让不同的数据库继承这个抽象类，来实现对各个数据库连接的支持。\n\n```java\n   public abstract class DBConnection{\n     public abstract String getConnection();\n   }\n```\n\n```java\n   public class MySQLConnection extends DBConnection {\n     @Override\n     public String getConnection() {\n       return \"MySQL 数据库连接\";\n     }\n   }\n```\n\n####  设计原则总结\n我们在开发中，并不是一定要求所有的代码都遵循设计原则，我们要考虑人力、时间、成本、质量，在适当的场景遵循设计原则，体现的是一种动态取舍，帮助我们设计出更加优雅的代码结构。\n","slug":"设计原则","published":1,"updated":"2020-11-30T15:11:10.000Z","comments":1,"photos":[],"link":"","_id":"cm1m304xd000q31b428tc3gue","content":"<h4 id=\"开闭原则\"><a href=\"#开闭原则\" class=\"headerlink\" title=\"开闭原则\"></a>开闭原则</h4><p>开闭原则(Open-Closed Principle,OCP)是指一个软件实体，如类、模块和函数应该对扩展开放，对修改关闭。强调用抽象构建框架，用实现扩展细节，可以提高系统的可复用性及可维护性。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//假设有一个课程接口 各个课程需要实现课程接口成为课程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ICourse</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Integer <span class=\"title\">getId</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">getName</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">Double <span class=\"title\">getPrice</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>此时需要给课程增加一个优惠活动，如果修改一个已经存在的课程的getPrice()，可能会造成风险，影响别的地方的调用结果。我们可以写一个处理优惠逻辑的类，来专门处理这种情况。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JavaDiscountCourse</span> <span class=\"keyword\">extends</span> <span class=\"title\">JavaCourse</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">JavaDiscountCourse</span><span class=\"params\">(Integer id, String name, Double price)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(id, name, price);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Double <span class=\"title\">getOriginPrice</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.getPrice();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Double <span class=\"title\">getPrice</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.getPrice() * <span class=\"number\">0.61</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"依赖倒置原则\"><a href=\"#依赖倒置原则\" class=\"headerlink\" title=\"依赖倒置原则\"></a>依赖倒置原则</h4><p>依赖倒置原则(Dependence Inversion Principle,DIP)是指设计代码结构时，高层模块不应该依赖底层模块，二者都应该依赖其抽象。抽象不应该依赖细节；细节应该依赖抽象。通过依赖倒置，可以减少类与类之间的耦合性，提高系统的稳定性，提高代码的可读性和可维护性，降低修改程序造成的风险。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Tom</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">studyJavaCourse</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Tom 在学习 Java 的课程&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">studyPythonCourse</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Tom 在学习 Python 的课程&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>假设需要增加一个新的课程，那么需要从底层到调用层修改代码，这样就非常不灵活，还可能会有意想不到的风险。</p>\n<p>我们可以创建一个接口作为课程，然后通过set方法将实例设置进来，调用对应的逻辑。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JavaCourse</span> <span class=\"keyword\">implements</span> <span class=\"title\">ICourse</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">study</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;学习Java课程&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Class Tom&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">study</span><span class=\"params\">(ICourse course)</span></span>&#123;</span><br><span class=\"line\">        course.study();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[]args)</span></span>&#123;</span><br><span class=\"line\">        Tom tom=<span class=\"keyword\">new</span> Tom();</span><br><span class=\"line\">        tom.study(<span class=\"keyword\">new</span> JavaCourse());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样无论想学什么课，我们只需要新建一个类，然后通过参数的方式告诉Tom，而不需要修改底层代码。实际是这是依赖注入，注入的方式还有构造器方式和setter方式。以抽象为基准比以细节为基准搭建起来的架构要稳定的多，因此要面向接口编程，先顶层再细节来设计代码结构。</p>\n<h4 id=\"单一职责原则\"><a href=\"#单一职责原则\" class=\"headerlink\" title=\"单一职责原则\"></a>单一职责原则</h4><p>单一职责(Simple Responsibility Pinciple，SRP)是指不要存在多于一个导致类变更的原因。也就是说一个Class/Interface/Method只负责一项职责。</p>\n<h4 id=\"接口隔离原则\"><a href=\"#接口隔离原则\" class=\"headerlink\" title=\"接口隔离原则\"></a>接口隔离原则</h4><p>接口隔离原则(Interface Segregation Principle，ISP)是指用多个专门的接口，而不是用一个总接口，客户端不应该依赖它不需要的接口。这个原则指导我们在接口设计时应当注意以下几点：</p>\n<p>1.一个类对一类的依赖应该建立在最小的接口上</p>\n<p>2.建立单一接口，不要建立庞大臃肿的接口</p>\n<p>3.尽量细化接口，接口中的方法尽量少(不是越少越好，一定要适度)</p>\n<p>写一个动物的接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">IAnimal</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">eat</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fly</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">swim</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当Dog去实现动物接口的时候，因为Dog不会飞，所以fly()要空实现。这个时候其实我们发现这个接口是一个总接口，我们应该设计专用的接口，让需要功能的动物去实现。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">IFlyAnimal</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fly</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">IEatAnimal</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">eat</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bird</span> <span class=\"keyword\">implements</span> <span class=\"title\">IFlyAnimal</span>, <span class=\"title\">IEatAnimal</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">eat</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">fly</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"迪米特法则\"><a href=\"#迪米特法则\" class=\"headerlink\" title=\"迪米特法则\"></a>迪米特法则</h4><p>迪米特法则(Law of Demeter LoD)是指一个对象应该对其他对象保持最少的了解，又叫最少知道原则(Least Knowledge Principle,LKP)<br>，尽量降低类与类之间的耦合。迪米特原则强调只和朋友交流，不和陌生人说话。出现在成员变量、方法的输入、输出参数中的类都可以称之为成员朋友类，而出现在方法体内部的类不属于朋友类。</p>\n<p>设计一个权限系统，TeamLeader需要查看目前发布到线上的课程数量。这时候TeamLeader要找员工Employee进行统计，Employee再把统计结果告诉TeamLeader</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Course</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Employee</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">checkNumberOfCourse</span><span class=\"params\">(List&lt;Course&gt; courseList)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;目前已经发布的课程数量是：&quot;</span> + courseList.size());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TeamLeader</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">commandCheckNumber</span><span class=\"params\">(Employee employee)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;Course&gt; courseList = <span class=\"keyword\">new</span> ArrayList&lt;Course&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">20</span>; i++) &#123;</span><br><span class=\"line\">            courseList.add(<span class=\"keyword\">new</span> Course());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        employee.checkNumberOfCourse(courseList);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>功能基本上实现了，但是根据迪米特法则，TeamLeader只想要结果，不需要根Course产生直接的交流。而Employee统计需要引用Course对象。根据迪米特法则改造下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Employee</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">checkNumberOfCourse</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        List&lt;Course&gt; courseList = <span class=\"keyword\">new</span> ArrayList&lt;Course&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">20</span>; i++) &#123;</span><br><span class=\"line\">            courseList.add(<span class=\"keyword\">new</span> Course());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;目前已经发布的课程数量是：&quot;</span> + courseList.size());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TeamLeader</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">commandCheckNumber</span><span class=\"params\">(Employee employee)</span> </span>&#123;</span><br><span class=\"line\">        employee.checkNumberOfCourse();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"里氏替换原则\"><a href=\"#里氏替换原则\" class=\"headerlink\" title=\"里氏替换原则\"></a>里氏替换原则</h4><p>里氏替换原则 (Liskov Substitution Principle,LSP)<br>是指如果对一个类型为T1的对象o1，都有类型为T2的对象o2，使得以T1定义的所有程序P在所有的对象o1都替换成o2时，程序P的行为没有发生变化，那么类型T2是类型T1的子类型。</p>\n<p>定义比较抽象，多读几遍理解的话，其实就是子类对象能够替换程序中父类对象出现的任何地方，并且保证原来程序的逻辑行为不变及正确性不被破坏。</p>\n<ol>\n<li><p>子类可以实现父类的抽象方法，但不能改变父类原有的功能</p>\n</li>\n<li><p>子类中可以增加自己特有的方法</p>\n</li>\n<li><p>当子类的方法重载父类的方法时，方法的前置条件 (方法的输入/入参) 要比父类的输入参数更宽松</p>\n</li>\n<li><p>当子类的方法实现父类的方法时 (重写/重载或实现抽象方法) 方法，方法的后置条件 (方法的输出/返回值) 要比父类更严格或相等</p>\n<p>下面举个例子，父类Transporter使用org.apache.http库中的HttpClient类来传输网络数据。子类SecurityTransporter继承父类Transport，增加了额外的功能，支持appId和appToken安全认证信息</p>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Transport</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> HttpClient httpClient;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Transport</span><span class=\"params\">(HttpClient httpClient)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.httpClient = httpClient;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> Response <span class=\"title\">sendRequest</span><span class=\"params\">(Request request)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...use httpClient to send request</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SecurityTransport</span> <span class=\"keyword\">extends</span> <span class=\"title\">Transport</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> String appId;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> String appToken;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SecurityTransport</span><span class=\"params\">(HttpClient httpClient,String appId,String appToken)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(httpClient);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.appId = appId;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.appToken = appToken;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> Response <span class=\"title\">sendRequest</span><span class=\"params\">(Request request)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(StringUtils.isNotBlank(appId)&amp;&amp;StringUtils.isNotBlank(appToken))&#123;</span><br><span class=\"line\">      request.addPayload(<span class=\"string\">&quot;app-id&quot;</span>,appId);</span><br><span class=\"line\">      request.addPayload(<span class=\"string\">&quot;app-token&quot;</span>,appToken);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.sendRequest(request);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"合成复用原则\"><a href=\"#合成复用原则\" class=\"headerlink\" title=\"合成复用原则\"></a>合成复用原则</h4><p>合成复用原则 (Composite/Aggregate Reuse Principle,CARP) 是指尽量使用对象组合 (has-a)/聚合 (contains-a),而不是继承关系达到软件复用的目的。可以使系统更加灵活，降低类与类之间的耦合度，一个类的变化对其他类造成的影响相对较少。以操作数据库为例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DBConnection</span></span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getConnection</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;MySQL 数据库连接&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProductDao</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> DBConnection dbConnection;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ProductDao</span><span class=\"params\">(Dbconnection dbConnection)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.dbConnection = dbConnection;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这是一种典型的合成复用场景，但是目前的设计不利于系统扩展。目前的数据库连接仅支持MySQL。我们可以在DbConnection中增加对别的数据库的支持，但是这违背了开闭原则，我们可以把DBConnection修改为一个抽象类，然后分别让不同的数据库继承这个抽象类，来实现对各个数据库连接的支持。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DBConnection</span></span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> String <span class=\"title\">getConnection</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MySQLConnection</span> <span class=\"keyword\">extends</span> <span class=\"title\">DBConnection</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getConnection</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;MySQL 数据库连接&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"设计原则总结\"><a href=\"#设计原则总结\" class=\"headerlink\" title=\"设计原则总结\"></a>设计原则总结</h4><p>我们在开发中，并不是一定要求所有的代码都遵循设计原则，我们要考虑人力、时间、成本、质量，在适当的场景遵循设计原则，体现的是一种动态取舍，帮助我们设计出更加优雅的代码结构。</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"开闭原则\"><a href=\"#开闭原则\" class=\"headerlink\" title=\"开闭原则\"></a>开闭原则</h4><p>开闭原则(Open-Closed Principle,OCP)是指一个软件实体，如类、模块和函数应该对扩展开放，对修改关闭。强调用抽象构建框架，用实现扩展细节，可以提高系统的可复用性及可维护性。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//假设有一个课程接口 各个课程需要实现课程接口成为课程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ICourse</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Integer <span class=\"title\">getId</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">getName</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">Double <span class=\"title\">getPrice</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>此时需要给课程增加一个优惠活动，如果修改一个已经存在的课程的getPrice()，可能会造成风险，影响别的地方的调用结果。我们可以写一个处理优惠逻辑的类，来专门处理这种情况。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JavaDiscountCourse</span> <span class=\"keyword\">extends</span> <span class=\"title\">JavaCourse</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">JavaDiscountCourse</span><span class=\"params\">(Integer id, String name, Double price)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(id, name, price);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Double <span class=\"title\">getOriginPrice</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.getPrice();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Double <span class=\"title\">getPrice</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.getPrice() * <span class=\"number\">0.61</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"依赖倒置原则\"><a href=\"#依赖倒置原则\" class=\"headerlink\" title=\"依赖倒置原则\"></a>依赖倒置原则</h4><p>依赖倒置原则(Dependence Inversion Principle,DIP)是指设计代码结构时，高层模块不应该依赖底层模块，二者都应该依赖其抽象。抽象不应该依赖细节；细节应该依赖抽象。通过依赖倒置，可以减少类与类之间的耦合性，提高系统的稳定性，提高代码的可读性和可维护性，降低修改程序造成的风险。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Tom</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">studyJavaCourse</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Tom 在学习 Java 的课程&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">studyPythonCourse</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Tom 在学习 Python 的课程&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>假设需要增加一个新的课程，那么需要从底层到调用层修改代码，这样就非常不灵活，还可能会有意想不到的风险。</p>\n<p>我们可以创建一个接口作为课程，然后通过set方法将实例设置进来，调用对应的逻辑。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JavaCourse</span> <span class=\"keyword\">implements</span> <span class=\"title\">ICourse</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">study</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;学习Java课程&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Class Tom&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">study</span><span class=\"params\">(ICourse course)</span></span>&#123;</span><br><span class=\"line\">        course.study();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[]args)</span></span>&#123;</span><br><span class=\"line\">        Tom tom=<span class=\"keyword\">new</span> Tom();</span><br><span class=\"line\">        tom.study(<span class=\"keyword\">new</span> JavaCourse());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样无论想学什么课，我们只需要新建一个类，然后通过参数的方式告诉Tom，而不需要修改底层代码。实际是这是依赖注入，注入的方式还有构造器方式和setter方式。以抽象为基准比以细节为基准搭建起来的架构要稳定的多，因此要面向接口编程，先顶层再细节来设计代码结构。</p>\n<h4 id=\"单一职责原则\"><a href=\"#单一职责原则\" class=\"headerlink\" title=\"单一职责原则\"></a>单一职责原则</h4><p>单一职责(Simple Responsibility Pinciple，SRP)是指不要存在多于一个导致类变更的原因。也就是说一个Class/Interface/Method只负责一项职责。</p>\n<h4 id=\"接口隔离原则\"><a href=\"#接口隔离原则\" class=\"headerlink\" title=\"接口隔离原则\"></a>接口隔离原则</h4><p>接口隔离原则(Interface Segregation Principle，ISP)是指用多个专门的接口，而不是用一个总接口，客户端不应该依赖它不需要的接口。这个原则指导我们在接口设计时应当注意以下几点：</p>\n<p>1.一个类对一类的依赖应该建立在最小的接口上</p>\n<p>2.建立单一接口，不要建立庞大臃肿的接口</p>\n<p>3.尽量细化接口，接口中的方法尽量少(不是越少越好，一定要适度)</p>\n<p>写一个动物的接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">IAnimal</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">eat</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fly</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">swim</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当Dog去实现动物接口的时候，因为Dog不会飞，所以fly()要空实现。这个时候其实我们发现这个接口是一个总接口，我们应该设计专用的接口，让需要功能的动物去实现。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">IFlyAnimal</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fly</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">IEatAnimal</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">eat</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bird</span> <span class=\"keyword\">implements</span> <span class=\"title\">IFlyAnimal</span>, <span class=\"title\">IEatAnimal</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">eat</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">fly</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"迪米特法则\"><a href=\"#迪米特法则\" class=\"headerlink\" title=\"迪米特法则\"></a>迪米特法则</h4><p>迪米特法则(Law of Demeter LoD)是指一个对象应该对其他对象保持最少的了解，又叫最少知道原则(Least Knowledge Principle,LKP)<br>，尽量降低类与类之间的耦合。迪米特原则强调只和朋友交流，不和陌生人说话。出现在成员变量、方法的输入、输出参数中的类都可以称之为成员朋友类，而出现在方法体内部的类不属于朋友类。</p>\n<p>设计一个权限系统，TeamLeader需要查看目前发布到线上的课程数量。这时候TeamLeader要找员工Employee进行统计，Employee再把统计结果告诉TeamLeader</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Course</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Employee</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">checkNumberOfCourse</span><span class=\"params\">(List&lt;Course&gt; courseList)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;目前已经发布的课程数量是：&quot;</span> + courseList.size());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TeamLeader</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">commandCheckNumber</span><span class=\"params\">(Employee employee)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;Course&gt; courseList = <span class=\"keyword\">new</span> ArrayList&lt;Course&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">20</span>; i++) &#123;</span><br><span class=\"line\">            courseList.add(<span class=\"keyword\">new</span> Course());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        employee.checkNumberOfCourse(courseList);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>功能基本上实现了，但是根据迪米特法则，TeamLeader只想要结果，不需要根Course产生直接的交流。而Employee统计需要引用Course对象。根据迪米特法则改造下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Employee</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">checkNumberOfCourse</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        List&lt;Course&gt; courseList = <span class=\"keyword\">new</span> ArrayList&lt;Course&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">20</span>; i++) &#123;</span><br><span class=\"line\">            courseList.add(<span class=\"keyword\">new</span> Course());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;目前已经发布的课程数量是：&quot;</span> + courseList.size());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TeamLeader</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">commandCheckNumber</span><span class=\"params\">(Employee employee)</span> </span>&#123;</span><br><span class=\"line\">        employee.checkNumberOfCourse();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"里氏替换原则\"><a href=\"#里氏替换原则\" class=\"headerlink\" title=\"里氏替换原则\"></a>里氏替换原则</h4><p>里氏替换原则 (Liskov Substitution Principle,LSP)<br>是指如果对一个类型为T1的对象o1，都有类型为T2的对象o2，使得以T1定义的所有程序P在所有的对象o1都替换成o2时，程序P的行为没有发生变化，那么类型T2是类型T1的子类型。</p>\n<p>定义比较抽象，多读几遍理解的话，其实就是子类对象能够替换程序中父类对象出现的任何地方，并且保证原来程序的逻辑行为不变及正确性不被破坏。</p>\n<ol>\n<li><p>子类可以实现父类的抽象方法，但不能改变父类原有的功能</p>\n</li>\n<li><p>子类中可以增加自己特有的方法</p>\n</li>\n<li><p>当子类的方法重载父类的方法时，方法的前置条件 (方法的输入/入参) 要比父类的输入参数更宽松</p>\n</li>\n<li><p>当子类的方法实现父类的方法时 (重写/重载或实现抽象方法) 方法，方法的后置条件 (方法的输出/返回值) 要比父类更严格或相等</p>\n<p>下面举个例子，父类Transporter使用org.apache.http库中的HttpClient类来传输网络数据。子类SecurityTransporter继承父类Transport，增加了额外的功能，支持appId和appToken安全认证信息</p>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Transport</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> HttpClient httpClient;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Transport</span><span class=\"params\">(HttpClient httpClient)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.httpClient = httpClient;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> Response <span class=\"title\">sendRequest</span><span class=\"params\">(Request request)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...use httpClient to send request</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SecurityTransport</span> <span class=\"keyword\">extends</span> <span class=\"title\">Transport</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> String appId;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> String appToken;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SecurityTransport</span><span class=\"params\">(HttpClient httpClient,String appId,String appToken)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(httpClient);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.appId = appId;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.appToken = appToken;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> Response <span class=\"title\">sendRequest</span><span class=\"params\">(Request request)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(StringUtils.isNotBlank(appId)&amp;&amp;StringUtils.isNotBlank(appToken))&#123;</span><br><span class=\"line\">      request.addPayload(<span class=\"string\">&quot;app-id&quot;</span>,appId);</span><br><span class=\"line\">      request.addPayload(<span class=\"string\">&quot;app-token&quot;</span>,appToken);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.sendRequest(request);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"合成复用原则\"><a href=\"#合成复用原则\" class=\"headerlink\" title=\"合成复用原则\"></a>合成复用原则</h4><p>合成复用原则 (Composite/Aggregate Reuse Principle,CARP) 是指尽量使用对象组合 (has-a)/聚合 (contains-a),而不是继承关系达到软件复用的目的。可以使系统更加灵活，降低类与类之间的耦合度，一个类的变化对其他类造成的影响相对较少。以操作数据库为例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DBConnection</span></span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getConnection</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;MySQL 数据库连接&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProductDao</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> DBConnection dbConnection;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ProductDao</span><span class=\"params\">(Dbconnection dbConnection)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.dbConnection = dbConnection;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这是一种典型的合成复用场景，但是目前的设计不利于系统扩展。目前的数据库连接仅支持MySQL。我们可以在DbConnection中增加对别的数据库的支持，但是这违背了开闭原则，我们可以把DBConnection修改为一个抽象类，然后分别让不同的数据库继承这个抽象类，来实现对各个数据库连接的支持。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DBConnection</span></span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> String <span class=\"title\">getConnection</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MySQLConnection</span> <span class=\"keyword\">extends</span> <span class=\"title\">DBConnection</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getConnection</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;MySQL 数据库连接&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"设计原则总结\"><a href=\"#设计原则总结\" class=\"headerlink\" title=\"设计原则总结\"></a>设计原则总结</h4><p>我们在开发中，并不是一定要求所有的代码都遵循设计原则，我们要考虑人力、时间、成本、质量，在适当的场景遵循设计原则，体现的是一种动态取舍，帮助我们设计出更加优雅的代码结构。</p>\n"},{"layout":"post","title":"消息队列选型(转载)","description":"消息队列选型","date":"2024-09-19T15:11:10.000Z","_content":"\n作者：emoryliang\n\n原文地址  \nhttps://mp.weixin.qq.com/s/jWKHAic4Tt4Ohsj4pTmYFw\n>\n消息队列是重要的分布式系统组件，在高性能、高可用、低耦合等系统架构中扮演着重要作用。可用于异步通信、削峰填谷、解耦系统、数据缓存等多种业务场景。本文是关于消息队列（MQ）选型和常见问题的精心整理。在这篇文章中，我嗯将详细介绍消息队列的概念、作用以及如何选择适合自己需求的消息队列系统。\n\n![](https://vqianxiao.github.io/blog/images/mq/mq1.png)\n\n# 1 概诉\n\n消息队列是分布式系统中重要的中间件，在高性能、高可用、低耦合等系统架构中扮演着重要作用。分布式系统可以借助消息队列的能力，轻松实现以下功能：\n\n- 解耦：将一个流程的上下游拆解开，上游专注于生产消息，下游专注于处理消息；\n- 广播：上游生产的消息可以轻松被多个下游服务处理；\n- 缓冲：应对突发流量，消息队列扮演缓冲器的作用，保护下游服务，使其可以根据自身的实际消费能力处理消息；\n- 异步：上游发送消息后可以马上返回，下游可以异步处理消息；\n- 冗余：保留历史消息，处理失败或当出现异常时可以进行重试或者回溯，防止丢失；\n\n# 2 架构简介\n\n## 2.1 Kafka\n\n### 2.1.1 系统架构\n\n![](https://vqianxiao.github.io/blog/images/mq/mq2.png)\n一个Kafka集群由多个Broker和一个ZooKeeper集群组成，Broker作为Kafka节点的服务器。同一个消息主题Topic可以由多个分区Partition组成，分区物理存储在Broker上。负载均衡考虑，同一个Topic的多个分区存储在多个不同的Broker上，为了提高可靠性，每个分区在不同的Broker都会存在副本。\n\nZooKeeper是一个分布式开源的应用程序协调服务，可以实现统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等工作。Kafka里的ZooKeeper主要有以下几个作用：\n\n- Broker注册，当有Broker故障的时候能及时感知。\n- Topic注册，维护Topic各分区的各副本所在的Broker节点，以及对应leader/follower的角色。\n- Consumer注册，维护消费者组的offset以及消费者与分区的对应关系，实现负载均衡。\n\n### 2.1.2 基本术语\n\n**Producer:** 消息生产者。一般情况下，一条消息会被发送到特定的主题上。通常情况下，写入的消息会通过轮询将消息写入各分区。生产者也可以通过设定消息key值将消息写入指定分区。写入分区的数据越均匀Kafka的性能才能更好发挥。\n\n**Topic:** Topic是一个抽象的虚拟概念，一个集群可以有多个Topic，作为一类消息的标识。一个生产者将消息发送到Topic，消费者通过订阅Topic获取分区消息。\n\n**Partition:**\nPartition是个物理概念，一个Topic对应一个或多个Partition。新消息会以追加的方式写入分区里，在同一个Partition里消息是有序的。Kafka通过分区，实现消息的冗余和伸缩性，以及支持物理上的并发读、写，大大提高了吞吐量。\n\n**Replicas:**\n一个Partition有多个Replicas副本。这些副本保存在Broker，每个broker存储着成百上千个不同主题和分区的副本，存储的内容分为两种：master副本，每个Partition都有一个Master副本，所有内容的写入和消费都会经过Master副本；follower副本不处理任何客户端的请求，只同步master的内容进行复制。如果master发生了异常，很快会有一个follower成为新的master。\n\n**Consumer:** 消息读取者。消费者订阅主题，并按照一定顺序读取消息。Kafka保证每个分区只能被一个消费者使用。\n\n**Offset:** 偏移量是一种元数据，是不断递增的整数。在消息写入时Kafka会把它添加到消息里。在分区内偏移量是唯一的。消费过程中，会将最后读取的偏移量存储在Kafka中，消费者关闭偏移量不会丢失，重启会继续从上次位置开始消费。\n\n**Broker:**\n独立的Kafka服务器。一个Topic有N个Partition，一个集群有N个Broker，那么每个Broker都会存储一个这个Topic的Partition。如果某个Topic有N个partition，集群有（N+M）个Broker，那么其中有N个Broker存储该Topic的一个Partition，剩下的M个Broker不存储该Topic的Partition数据。如果某个Topic有N个Partition，集群中broker数目少于N个，那么一个Broker存储该Topic的一个或多个Partition。在实际生产环境中，尽量避免这种情况的发生，这种情况容易导致Kafka集群数据不均衡。\n\n## 2.2 Pulsar\n\n### 2.2.1 系统架构\n\n![](https://vqianxiao.github.io/blog/images/mq/mq3.png)\nPulsar有三个重要的组件，Broker、BookKeeper和ZooKeeper，Broker是无状态服务，客户端需要连接到Broker上进行消息的传递。BookKeeper与ZoKeeper是有状态服务。\nBookKeeper的节点叫Bookie，负责存储消息和游标，ZooKeeper存储Broker和Bookie的元数据。Pulsar以这种架构，实现存储和计算分离，Broker负责计算，Bookie负责有状态存储。\n![](https://vqianxiao.github.io/blog/images/mq/mq4.png)\nPulsar的多层架构影响了存储数据的方式。Pulsar将Topic分区划分为分片（Segment）,然后将这些分片存储在Apache\nBookKeeper的存储节点上，以提高性能、可伸缩性和可用性。\nPulsar的分布式日志以分片为中心，借助扩展日志存储（通过Apache\nbookKeeper）实现，内置分层存储支持，因此分片可以均匀地分布在存储节点上。由于与任一给定Topic相关的数据都不会与特定存储节点进行捆绑，因此很容易替换存储节点或扩缩容。另外，集群中最小或最慢的节点也不会成为存储或带宽的短板。\n\n### 2.2.2 基本术语\n\n**Property:** 代表租户，每个property都可以代表一个团队、一个功能、一个产品线。一个property可包含多个namespace，多租户是一种资源隔离手段，可以提高资源利用率。\n\n**Namespace:**\nPulsar的基本管理单元，在namespace级别可设置权限、消息TTL、Retention策略等。一个namespace里的所有topic都继承相同的设置。命名空间分为两种：本地命名空间，只在集群内可见；全局命名空间对多个集群可见。\n![](https://vqianxiao.github.io/blog/images/mq/mq5.png)\n\n**Producer:** 数据生产方，负责创建消息并将消息投递到Pulsar中。\n\n**Consumer:** 数据消费方，连接到Pulsar接收消息并进行相应的处理。\n\n**Broker:** 无状态Proxy服务，负责接收消息、传递消息、集群负载均衡等操作，它对client屏蔽了服务端读写流程的复杂性，是保证数据一致性与数据负载均衡的重要角色。Broker不会持久化保存元数据。可以扩容但不能缩容。\n\n**BookKeeper:**\n有状态，负责持久化存储消息。当集群扩容时，Pulsar会在新增BookKeeper和Segment（即BookKeeper的Ledger），不需要想kafka一样扩容时进行ReBalance。扩容结果时Fragments跨多个Bookies以带状分布，同一个Ledger的Fragments分布在多个Bookie上，导致读取和写入会在多个Bookies之间跳跃。\n\n**ZooKeeper:** 存储Pulsar、BookKeeper的元数据，集群配置等信息，负责集群间的协调、服务发现等。\n\n**Topic:** 用作从producer到consumer传输消息。Pulsar在Topic级别拥有一个leader\nBroker，称之为拥有Topic的所有权，针对该Topic所有的R/W都经过该Broker完成。Topic的Ledger和Fragment之间映射关系等元数据存储在Zookeeper中，Pulsar Broker需要事实跟踪这些关系进行读写流程。\n\n**Ledger:** 即Segment，Pulsar底层数据以Ledger的形式存储在BookKeeper上。是Pulsar删除的最小单位。\n\n**Fragment:** 每个Ledger由若干个Fragment组成。\n\n## 2.3 RocketMQ\n### 2.3.1 系统框架\n![](https://vqianxiao.github.io/blog/images/mq/mq6.png)\nRocketMQ是阿里开源的消息中间件，它是一个开源的分布式消息传递和流式数据平台。总共有四大部分：NameServer，Broker，Producer，Consumer。\n\nNameServer主要用来管理brokers以及路由信息。broker服务器启动时会注册到NameServer上，并且两者之间保持心跳监测机制，以此来保证NameServer知道broker的存活状态。而且，每一台NameServer都存有全部的broker集群信息和生产者/消费者客户端的请求信息。\n\nBroker负载管理消息存储分发，主从数据同步，为消息建立索引，提供消息查询等能力。\n\n### 2.3.2 基本术语\n**Topic:** 一个Topic可以有0个、1个多个生产者向其发送消息，一个生产者也可以同时向不同的Topic发送消息。一个Topic也可以被0个、1个、多个消费者订阅。\n\n**Tag:** 消息二级类型，可以为用户提供额外的灵活度，一条消息可以没有Tag。\n\n**Producer:** 消息生产者。\n\n**Broker:** 存储消息，以Topic为纬度轻量级的队列；转发消息，单个Broker节点与所有的NameServer节点保持长连接及心跳，会定时将Topic信息注册到NameServer。\n\n**Consumer:** 消息消费者，负责接收并消费消息。\n\n**MessageQueue:** 消息的物理管理单位，一个Topic可以有多个Queue，Queue的的引入是西安了水平扩展的能力。\n\n**NameServer:** 负责对元数据的管理，包括Topic和路由信息，每个NameServer之间是没有通信的。\n\n**Group:** 一个组可以订阅多个Topic，ProducerGroup、ConsumerGroup分别是一类生产者和一类消费者。\n\n**Offset:** 通过Offset访问存储单元，RocketMQ中所有消息都是持久化的，且存储单元定长。Offset为Java Long类型，理论上100年内不会溢出，所以认为Message Queue是无限长的数据，Offset是下标。\n\n**Consumer:** 支持PUSH和PULL两种消费模式，支持集群消费和广播消费。\n\n## 2.4 RabbitMQ\n### 2.4.1 系统框架\n![](https://vqianxiao.github.io/blog/images/mq/mq7.png)\nRabbitMQ基于AMQP协议来实现，主要由Exchange和Queue两部分组成，然后通过RoutingKey关联起来，消息投递到Exchange然后通过Queue接收。\n\n### 2.4.2 基本术语\n**Broker:** 接收客户端连接实体，实现AMQP消息队列和路由功能。\n\n**Virtual Host:** 是一个虚拟概念，权限控制的最小单位。一个Virtual Host里包含多个Exchange和Queue。\n\n**Exchange:** 接收消息生产者的消息并将消息转发到队列。发送消息时根据不同ExchangeType决定路由规则，ExchangeType常用的有：direct、fanout和topic三种。\n\n**Message Queue:** 消息队列，存储被消费的消息。\n\n**Message:** 由Header和Body组成，Header是生产者添加的各种属性，包含Message是否持久化、哪个MessageQueue接收、优先级。Body是具体的消息内容。\n\n**Binding:** Binding连接起了Exchange和Message Queue。在服务器运行时，会生成一张路由表，这张路由表上记录者MessageQueue的条件和BindingKey值。当Exchange收到消息后，会解析消息中的Header得到BindingKey，并根据路由表和ExchangeType将消息发送到对应的MessageQueue。最终的匹配模式是由ExchangeType决定。\n\n**Connection:** 在Broker和客户端之间的TCP连接。\n\n**Channel:** 信道。Broker和客户端只有tcp连接是不能发送消息的，必须创建信道。AMQP协议规定只有通过Channel才能执行AMQP命令。一个Connection可以包含多个Channel。之所以需要建立Channel，是因为每个TCP连接都是很宝贵的。如果每个客户端、每个线程都需要和Broker交互，都需要维护一个TCP连接的话是很耗费机器资源的，一般建议共享Connection。RabbitMQ不建议客户端线程之间共享Channel，至少保证同一Channel发消息是串行的。\n\n**Command:** AMQP命令，客户端通过Command来完成和AMQP服务器的交互。\n\n## 2.5 NSQ\n### 2.5.1 系统框架\n![](https://vqianxiao.github.io/blog/images/mq/mq8.png)\nNSQ主要有nsqlookup、nsqd两部分组成:\n- Nsqlookup为守护进程，负责管理拓扑信息并提供发现服务。客户端通过查询nsqlookupd获取指定Topic所在的nsqd节点。nsqd往nsqlookup上注册和广播自身topic和channel的信息。\n- nsqd在服务端运行的守护进程，负责接收，排队，投递消息给客户端。\n\nNSQ由3个守护进程组成：\n- nsqd是接收、队列和传送消息到客户端的守护进程。\n- nsqlookupd是管理的拓扑信息，并提供了最终一致发现服务的守护进程。客户端通过查询nsqlookupd获取指定Topic所在的nsqd节点。nsqd往nsqlookup上注册和广播自身topic和channel的信息。\n- nsqadmin是一个WebUI来实时监控集群（和执行各种管理任务）。\n\n# 3选型要点\n## 3.1选型参考\n- 消息顺序：发送到队列的消息，消费时是否可以保证消费的顺序。\n- 伸缩：当消息队列性能有问题，比如消费太慢，是否可以快速支持扩容；当消费队列过多，浪费系统资源，是否可以支持缩容。\n- 消息留存：消息消费成功后，是否还会继续保留在消息队列。\n- 容错性：当一条消息消费失败后，是否有一些机制，保证这条消息一定能成功，比如异步第三方退款消息，需要保证这条消息消费掉，才能确定给用户退款成功，所以必须保证这条消息消费的准确性。\n- 消息可靠性：是否会存在丢消息的情况，比如有A/B两个消息，最后只有B消息能消费，A消息丢失\n- 消息时序：主要包括“消息存活时间”和“延迟消息”\n- 吞吐量：支持的最高并发数\n- 消息路由：根据路由规则，只订阅匹配路由规则的消息，比如有A/B两者规则的消息，消费者可以只订阅A消息，B消息不会消费。\n\n## 3.2消息队列对比\n![](https://vqianxiao.github.io/blog/images/mq/mq9.png)\n![](https://vqianxiao.github.io/blog/images/mq/mq10.png)\n\n# 4功能剖析\n## 4.1消费推拉模式\n客户端消费者获取消息的方式，Kafka和RocketMQ是通过长轮训Pull的方式拉取消息，RabbitMQ、Pulsar、NSQ都是通过Push的方式。\npull类型的消息队列更适合高吞吐量的场景，允许消费者自己进行流量控制，根据消费者实际的消费能力去获取消息。而push类型的消息队列，实时性更好，但需要有一套良好的流控策略(backpressure)当消费者消费能力不足时，减少push的消费数量，避免压垮消费端。\n\n## 4.2延迟队列\n\n\n\n\n\n\n","source":"_posts/消息队列选型-[转载].md","raw":"---\nlayout: post\ntitle: 消息队列选型(转载)\ncategory: 消息队列\ndescription: 消息队列选型\ntags: 消息队列\ndate: 2024/09/19 23:11:10\n---\n\n作者：emoryliang\n\n原文地址  \nhttps://mp.weixin.qq.com/s/jWKHAic4Tt4Ohsj4pTmYFw\n>\n消息队列是重要的分布式系统组件，在高性能、高可用、低耦合等系统架构中扮演着重要作用。可用于异步通信、削峰填谷、解耦系统、数据缓存等多种业务场景。本文是关于消息队列（MQ）选型和常见问题的精心整理。在这篇文章中，我嗯将详细介绍消息队列的概念、作用以及如何选择适合自己需求的消息队列系统。\n\n![](https://vqianxiao.github.io/blog/images/mq/mq1.png)\n\n# 1 概诉\n\n消息队列是分布式系统中重要的中间件，在高性能、高可用、低耦合等系统架构中扮演着重要作用。分布式系统可以借助消息队列的能力，轻松实现以下功能：\n\n- 解耦：将一个流程的上下游拆解开，上游专注于生产消息，下游专注于处理消息；\n- 广播：上游生产的消息可以轻松被多个下游服务处理；\n- 缓冲：应对突发流量，消息队列扮演缓冲器的作用，保护下游服务，使其可以根据自身的实际消费能力处理消息；\n- 异步：上游发送消息后可以马上返回，下游可以异步处理消息；\n- 冗余：保留历史消息，处理失败或当出现异常时可以进行重试或者回溯，防止丢失；\n\n# 2 架构简介\n\n## 2.1 Kafka\n\n### 2.1.1 系统架构\n\n![](https://vqianxiao.github.io/blog/images/mq/mq2.png)\n一个Kafka集群由多个Broker和一个ZooKeeper集群组成，Broker作为Kafka节点的服务器。同一个消息主题Topic可以由多个分区Partition组成，分区物理存储在Broker上。负载均衡考虑，同一个Topic的多个分区存储在多个不同的Broker上，为了提高可靠性，每个分区在不同的Broker都会存在副本。\n\nZooKeeper是一个分布式开源的应用程序协调服务，可以实现统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等工作。Kafka里的ZooKeeper主要有以下几个作用：\n\n- Broker注册，当有Broker故障的时候能及时感知。\n- Topic注册，维护Topic各分区的各副本所在的Broker节点，以及对应leader/follower的角色。\n- Consumer注册，维护消费者组的offset以及消费者与分区的对应关系，实现负载均衡。\n\n### 2.1.2 基本术语\n\n**Producer:** 消息生产者。一般情况下，一条消息会被发送到特定的主题上。通常情况下，写入的消息会通过轮询将消息写入各分区。生产者也可以通过设定消息key值将消息写入指定分区。写入分区的数据越均匀Kafka的性能才能更好发挥。\n\n**Topic:** Topic是一个抽象的虚拟概念，一个集群可以有多个Topic，作为一类消息的标识。一个生产者将消息发送到Topic，消费者通过订阅Topic获取分区消息。\n\n**Partition:**\nPartition是个物理概念，一个Topic对应一个或多个Partition。新消息会以追加的方式写入分区里，在同一个Partition里消息是有序的。Kafka通过分区，实现消息的冗余和伸缩性，以及支持物理上的并发读、写，大大提高了吞吐量。\n\n**Replicas:**\n一个Partition有多个Replicas副本。这些副本保存在Broker，每个broker存储着成百上千个不同主题和分区的副本，存储的内容分为两种：master副本，每个Partition都有一个Master副本，所有内容的写入和消费都会经过Master副本；follower副本不处理任何客户端的请求，只同步master的内容进行复制。如果master发生了异常，很快会有一个follower成为新的master。\n\n**Consumer:** 消息读取者。消费者订阅主题，并按照一定顺序读取消息。Kafka保证每个分区只能被一个消费者使用。\n\n**Offset:** 偏移量是一种元数据，是不断递增的整数。在消息写入时Kafka会把它添加到消息里。在分区内偏移量是唯一的。消费过程中，会将最后读取的偏移量存储在Kafka中，消费者关闭偏移量不会丢失，重启会继续从上次位置开始消费。\n\n**Broker:**\n独立的Kafka服务器。一个Topic有N个Partition，一个集群有N个Broker，那么每个Broker都会存储一个这个Topic的Partition。如果某个Topic有N个partition，集群有（N+M）个Broker，那么其中有N个Broker存储该Topic的一个Partition，剩下的M个Broker不存储该Topic的Partition数据。如果某个Topic有N个Partition，集群中broker数目少于N个，那么一个Broker存储该Topic的一个或多个Partition。在实际生产环境中，尽量避免这种情况的发生，这种情况容易导致Kafka集群数据不均衡。\n\n## 2.2 Pulsar\n\n### 2.2.1 系统架构\n\n![](https://vqianxiao.github.io/blog/images/mq/mq3.png)\nPulsar有三个重要的组件，Broker、BookKeeper和ZooKeeper，Broker是无状态服务，客户端需要连接到Broker上进行消息的传递。BookKeeper与ZoKeeper是有状态服务。\nBookKeeper的节点叫Bookie，负责存储消息和游标，ZooKeeper存储Broker和Bookie的元数据。Pulsar以这种架构，实现存储和计算分离，Broker负责计算，Bookie负责有状态存储。\n![](https://vqianxiao.github.io/blog/images/mq/mq4.png)\nPulsar的多层架构影响了存储数据的方式。Pulsar将Topic分区划分为分片（Segment）,然后将这些分片存储在Apache\nBookKeeper的存储节点上，以提高性能、可伸缩性和可用性。\nPulsar的分布式日志以分片为中心，借助扩展日志存储（通过Apache\nbookKeeper）实现，内置分层存储支持，因此分片可以均匀地分布在存储节点上。由于与任一给定Topic相关的数据都不会与特定存储节点进行捆绑，因此很容易替换存储节点或扩缩容。另外，集群中最小或最慢的节点也不会成为存储或带宽的短板。\n\n### 2.2.2 基本术语\n\n**Property:** 代表租户，每个property都可以代表一个团队、一个功能、一个产品线。一个property可包含多个namespace，多租户是一种资源隔离手段，可以提高资源利用率。\n\n**Namespace:**\nPulsar的基本管理单元，在namespace级别可设置权限、消息TTL、Retention策略等。一个namespace里的所有topic都继承相同的设置。命名空间分为两种：本地命名空间，只在集群内可见；全局命名空间对多个集群可见。\n![](https://vqianxiao.github.io/blog/images/mq/mq5.png)\n\n**Producer:** 数据生产方，负责创建消息并将消息投递到Pulsar中。\n\n**Consumer:** 数据消费方，连接到Pulsar接收消息并进行相应的处理。\n\n**Broker:** 无状态Proxy服务，负责接收消息、传递消息、集群负载均衡等操作，它对client屏蔽了服务端读写流程的复杂性，是保证数据一致性与数据负载均衡的重要角色。Broker不会持久化保存元数据。可以扩容但不能缩容。\n\n**BookKeeper:**\n有状态，负责持久化存储消息。当集群扩容时，Pulsar会在新增BookKeeper和Segment（即BookKeeper的Ledger），不需要想kafka一样扩容时进行ReBalance。扩容结果时Fragments跨多个Bookies以带状分布，同一个Ledger的Fragments分布在多个Bookie上，导致读取和写入会在多个Bookies之间跳跃。\n\n**ZooKeeper:** 存储Pulsar、BookKeeper的元数据，集群配置等信息，负责集群间的协调、服务发现等。\n\n**Topic:** 用作从producer到consumer传输消息。Pulsar在Topic级别拥有一个leader\nBroker，称之为拥有Topic的所有权，针对该Topic所有的R/W都经过该Broker完成。Topic的Ledger和Fragment之间映射关系等元数据存储在Zookeeper中，Pulsar Broker需要事实跟踪这些关系进行读写流程。\n\n**Ledger:** 即Segment，Pulsar底层数据以Ledger的形式存储在BookKeeper上。是Pulsar删除的最小单位。\n\n**Fragment:** 每个Ledger由若干个Fragment组成。\n\n## 2.3 RocketMQ\n### 2.3.1 系统框架\n![](https://vqianxiao.github.io/blog/images/mq/mq6.png)\nRocketMQ是阿里开源的消息中间件，它是一个开源的分布式消息传递和流式数据平台。总共有四大部分：NameServer，Broker，Producer，Consumer。\n\nNameServer主要用来管理brokers以及路由信息。broker服务器启动时会注册到NameServer上，并且两者之间保持心跳监测机制，以此来保证NameServer知道broker的存活状态。而且，每一台NameServer都存有全部的broker集群信息和生产者/消费者客户端的请求信息。\n\nBroker负载管理消息存储分发，主从数据同步，为消息建立索引，提供消息查询等能力。\n\n### 2.3.2 基本术语\n**Topic:** 一个Topic可以有0个、1个多个生产者向其发送消息，一个生产者也可以同时向不同的Topic发送消息。一个Topic也可以被0个、1个、多个消费者订阅。\n\n**Tag:** 消息二级类型，可以为用户提供额外的灵活度，一条消息可以没有Tag。\n\n**Producer:** 消息生产者。\n\n**Broker:** 存储消息，以Topic为纬度轻量级的队列；转发消息，单个Broker节点与所有的NameServer节点保持长连接及心跳，会定时将Topic信息注册到NameServer。\n\n**Consumer:** 消息消费者，负责接收并消费消息。\n\n**MessageQueue:** 消息的物理管理单位，一个Topic可以有多个Queue，Queue的的引入是西安了水平扩展的能力。\n\n**NameServer:** 负责对元数据的管理，包括Topic和路由信息，每个NameServer之间是没有通信的。\n\n**Group:** 一个组可以订阅多个Topic，ProducerGroup、ConsumerGroup分别是一类生产者和一类消费者。\n\n**Offset:** 通过Offset访问存储单元，RocketMQ中所有消息都是持久化的，且存储单元定长。Offset为Java Long类型，理论上100年内不会溢出，所以认为Message Queue是无限长的数据，Offset是下标。\n\n**Consumer:** 支持PUSH和PULL两种消费模式，支持集群消费和广播消费。\n\n## 2.4 RabbitMQ\n### 2.4.1 系统框架\n![](https://vqianxiao.github.io/blog/images/mq/mq7.png)\nRabbitMQ基于AMQP协议来实现，主要由Exchange和Queue两部分组成，然后通过RoutingKey关联起来，消息投递到Exchange然后通过Queue接收。\n\n### 2.4.2 基本术语\n**Broker:** 接收客户端连接实体，实现AMQP消息队列和路由功能。\n\n**Virtual Host:** 是一个虚拟概念，权限控制的最小单位。一个Virtual Host里包含多个Exchange和Queue。\n\n**Exchange:** 接收消息生产者的消息并将消息转发到队列。发送消息时根据不同ExchangeType决定路由规则，ExchangeType常用的有：direct、fanout和topic三种。\n\n**Message Queue:** 消息队列，存储被消费的消息。\n\n**Message:** 由Header和Body组成，Header是生产者添加的各种属性，包含Message是否持久化、哪个MessageQueue接收、优先级。Body是具体的消息内容。\n\n**Binding:** Binding连接起了Exchange和Message Queue。在服务器运行时，会生成一张路由表，这张路由表上记录者MessageQueue的条件和BindingKey值。当Exchange收到消息后，会解析消息中的Header得到BindingKey，并根据路由表和ExchangeType将消息发送到对应的MessageQueue。最终的匹配模式是由ExchangeType决定。\n\n**Connection:** 在Broker和客户端之间的TCP连接。\n\n**Channel:** 信道。Broker和客户端只有tcp连接是不能发送消息的，必须创建信道。AMQP协议规定只有通过Channel才能执行AMQP命令。一个Connection可以包含多个Channel。之所以需要建立Channel，是因为每个TCP连接都是很宝贵的。如果每个客户端、每个线程都需要和Broker交互，都需要维护一个TCP连接的话是很耗费机器资源的，一般建议共享Connection。RabbitMQ不建议客户端线程之间共享Channel，至少保证同一Channel发消息是串行的。\n\n**Command:** AMQP命令，客户端通过Command来完成和AMQP服务器的交互。\n\n## 2.5 NSQ\n### 2.5.1 系统框架\n![](https://vqianxiao.github.io/blog/images/mq/mq8.png)\nNSQ主要有nsqlookup、nsqd两部分组成:\n- Nsqlookup为守护进程，负责管理拓扑信息并提供发现服务。客户端通过查询nsqlookupd获取指定Topic所在的nsqd节点。nsqd往nsqlookup上注册和广播自身topic和channel的信息。\n- nsqd在服务端运行的守护进程，负责接收，排队，投递消息给客户端。\n\nNSQ由3个守护进程组成：\n- nsqd是接收、队列和传送消息到客户端的守护进程。\n- nsqlookupd是管理的拓扑信息，并提供了最终一致发现服务的守护进程。客户端通过查询nsqlookupd获取指定Topic所在的nsqd节点。nsqd往nsqlookup上注册和广播自身topic和channel的信息。\n- nsqadmin是一个WebUI来实时监控集群（和执行各种管理任务）。\n\n# 3选型要点\n## 3.1选型参考\n- 消息顺序：发送到队列的消息，消费时是否可以保证消费的顺序。\n- 伸缩：当消息队列性能有问题，比如消费太慢，是否可以快速支持扩容；当消费队列过多，浪费系统资源，是否可以支持缩容。\n- 消息留存：消息消费成功后，是否还会继续保留在消息队列。\n- 容错性：当一条消息消费失败后，是否有一些机制，保证这条消息一定能成功，比如异步第三方退款消息，需要保证这条消息消费掉，才能确定给用户退款成功，所以必须保证这条消息消费的准确性。\n- 消息可靠性：是否会存在丢消息的情况，比如有A/B两个消息，最后只有B消息能消费，A消息丢失\n- 消息时序：主要包括“消息存活时间”和“延迟消息”\n- 吞吐量：支持的最高并发数\n- 消息路由：根据路由规则，只订阅匹配路由规则的消息，比如有A/B两者规则的消息，消费者可以只订阅A消息，B消息不会消费。\n\n## 3.2消息队列对比\n![](https://vqianxiao.github.io/blog/images/mq/mq9.png)\n![](https://vqianxiao.github.io/blog/images/mq/mq10.png)\n\n# 4功能剖析\n## 4.1消费推拉模式\n客户端消费者获取消息的方式，Kafka和RocketMQ是通过长轮训Pull的方式拉取消息，RabbitMQ、Pulsar、NSQ都是通过Push的方式。\npull类型的消息队列更适合高吞吐量的场景，允许消费者自己进行流量控制，根据消费者实际的消费能力去获取消息。而push类型的消息队列，实时性更好，但需要有一套良好的流控策略(backpressure)当消费者消费能力不足时，减少push的消费数量，避免压垮消费端。\n\n## 4.2延迟队列\n\n\n\n\n\n\n","slug":"消息队列选型-[转载]","published":1,"updated":"2024-09-19T15:11:10.000Z","comments":1,"photos":[],"link":"","_id":"cm1m304xe000v31b410je3ode","content":"<p>作者：emoryliang</p>\n<p>原文地址<br><a href=\"https://mp.weixin.qq.com/s/jWKHAic4Tt4Ohsj4pTmYFw\">https://mp.weixin.qq.com/s/jWKHAic4Tt4Ohsj4pTmYFw</a></p>\n<blockquote>\n</blockquote>\n<p>消息队列是重要的分布式系统组件，在高性能、高可用、低耦合等系统架构中扮演着重要作用。可用于异步通信、削峰填谷、解耦系统、数据缓存等多种业务场景。本文是关于消息队列（MQ）选型和常见问题的精心整理。在这篇文章中，我嗯将详细介绍消息队列的概念、作用以及如何选择适合自己需求的消息队列系统。</p>\n<p><img src=\"https://vqianxiao.github.io/blog/images/mq/mq1.png\"></p>\n<h1 id=\"1-概诉\"><a href=\"#1-概诉\" class=\"headerlink\" title=\"1 概诉\"></a>1 概诉</h1><p>消息队列是分布式系统中重要的中间件，在高性能、高可用、低耦合等系统架构中扮演着重要作用。分布式系统可以借助消息队列的能力，轻松实现以下功能：</p>\n<ul>\n<li>解耦：将一个流程的上下游拆解开，上游专注于生产消息，下游专注于处理消息；</li>\n<li>广播：上游生产的消息可以轻松被多个下游服务处理；</li>\n<li>缓冲：应对突发流量，消息队列扮演缓冲器的作用，保护下游服务，使其可以根据自身的实际消费能力处理消息；</li>\n<li>异步：上游发送消息后可以马上返回，下游可以异步处理消息；</li>\n<li>冗余：保留历史消息，处理失败或当出现异常时可以进行重试或者回溯，防止丢失；</li>\n</ul>\n<h1 id=\"2-架构简介\"><a href=\"#2-架构简介\" class=\"headerlink\" title=\"2 架构简介\"></a>2 架构简介</h1><h2 id=\"2-1-Kafka\"><a href=\"#2-1-Kafka\" class=\"headerlink\" title=\"2.1 Kafka\"></a>2.1 Kafka</h2><h3 id=\"2-1-1-系统架构\"><a href=\"#2-1-1-系统架构\" class=\"headerlink\" title=\"2.1.1 系统架构\"></a>2.1.1 系统架构</h3><p><img src=\"https://vqianxiao.github.io/blog/images/mq/mq2.png\"><br>一个Kafka集群由多个Broker和一个ZooKeeper集群组成，Broker作为Kafka节点的服务器。同一个消息主题Topic可以由多个分区Partition组成，分区物理存储在Broker上。负载均衡考虑，同一个Topic的多个分区存储在多个不同的Broker上，为了提高可靠性，每个分区在不同的Broker都会存在副本。</p>\n<p>ZooKeeper是一个分布式开源的应用程序协调服务，可以实现统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等工作。Kafka里的ZooKeeper主要有以下几个作用：</p>\n<ul>\n<li>Broker注册，当有Broker故障的时候能及时感知。</li>\n<li>Topic注册，维护Topic各分区的各副本所在的Broker节点，以及对应leader/follower的角色。</li>\n<li>Consumer注册，维护消费者组的offset以及消费者与分区的对应关系，实现负载均衡。</li>\n</ul>\n<h3 id=\"2-1-2-基本术语\"><a href=\"#2-1-2-基本术语\" class=\"headerlink\" title=\"2.1.2 基本术语\"></a>2.1.2 基本术语</h3><p><strong>Producer:</strong> 消息生产者。一般情况下，一条消息会被发送到特定的主题上。通常情况下，写入的消息会通过轮询将消息写入各分区。生产者也可以通过设定消息key值将消息写入指定分区。写入分区的数据越均匀Kafka的性能才能更好发挥。</p>\n<p><strong>Topic:</strong> Topic是一个抽象的虚拟概念，一个集群可以有多个Topic，作为一类消息的标识。一个生产者将消息发送到Topic，消费者通过订阅Topic获取分区消息。</p>\n<p><strong>Partition:</strong><br>Partition是个物理概念，一个Topic对应一个或多个Partition。新消息会以追加的方式写入分区里，在同一个Partition里消息是有序的。Kafka通过分区，实现消息的冗余和伸缩性，以及支持物理上的并发读、写，大大提高了吞吐量。</p>\n<p><strong>Replicas:</strong><br>一个Partition有多个Replicas副本。这些副本保存在Broker，每个broker存储着成百上千个不同主题和分区的副本，存储的内容分为两种：master副本，每个Partition都有一个Master副本，所有内容的写入和消费都会经过Master副本；follower副本不处理任何客户端的请求，只同步master的内容进行复制。如果master发生了异常，很快会有一个follower成为新的master。</p>\n<p><strong>Consumer:</strong> 消息读取者。消费者订阅主题，并按照一定顺序读取消息。Kafka保证每个分区只能被一个消费者使用。</p>\n<p><strong>Offset:</strong> 偏移量是一种元数据，是不断递增的整数。在消息写入时Kafka会把它添加到消息里。在分区内偏移量是唯一的。消费过程中，会将最后读取的偏移量存储在Kafka中，消费者关闭偏移量不会丢失，重启会继续从上次位置开始消费。</p>\n<p><strong>Broker:</strong><br>独立的Kafka服务器。一个Topic有N个Partition，一个集群有N个Broker，那么每个Broker都会存储一个这个Topic的Partition。如果某个Topic有N个partition，集群有（N+M）个Broker，那么其中有N个Broker存储该Topic的一个Partition，剩下的M个Broker不存储该Topic的Partition数据。如果某个Topic有N个Partition，集群中broker数目少于N个，那么一个Broker存储该Topic的一个或多个Partition。在实际生产环境中，尽量避免这种情况的发生，这种情况容易导致Kafka集群数据不均衡。</p>\n<h2 id=\"2-2-Pulsar\"><a href=\"#2-2-Pulsar\" class=\"headerlink\" title=\"2.2 Pulsar\"></a>2.2 Pulsar</h2><h3 id=\"2-2-1-系统架构\"><a href=\"#2-2-1-系统架构\" class=\"headerlink\" title=\"2.2.1 系统架构\"></a>2.2.1 系统架构</h3><p><img src=\"https://vqianxiao.github.io/blog/images/mq/mq3.png\"><br>Pulsar有三个重要的组件，Broker、BookKeeper和ZooKeeper，Broker是无状态服务，客户端需要连接到Broker上进行消息的传递。BookKeeper与ZoKeeper是有状态服务。<br>BookKeeper的节点叫Bookie，负责存储消息和游标，ZooKeeper存储Broker和Bookie的元数据。Pulsar以这种架构，实现存储和计算分离，Broker负责计算，Bookie负责有状态存储。<br><img src=\"https://vqianxiao.github.io/blog/images/mq/mq4.png\"><br>Pulsar的多层架构影响了存储数据的方式。Pulsar将Topic分区划分为分片（Segment）,然后将这些分片存储在Apache<br>BookKeeper的存储节点上，以提高性能、可伸缩性和可用性。<br>Pulsar的分布式日志以分片为中心，借助扩展日志存储（通过Apache<br>bookKeeper）实现，内置分层存储支持，因此分片可以均匀地分布在存储节点上。由于与任一给定Topic相关的数据都不会与特定存储节点进行捆绑，因此很容易替换存储节点或扩缩容。另外，集群中最小或最慢的节点也不会成为存储或带宽的短板。</p>\n<h3 id=\"2-2-2-基本术语\"><a href=\"#2-2-2-基本术语\" class=\"headerlink\" title=\"2.2.2 基本术语\"></a>2.2.2 基本术语</h3><p><strong>Property:</strong> 代表租户，每个property都可以代表一个团队、一个功能、一个产品线。一个property可包含多个namespace，多租户是一种资源隔离手段，可以提高资源利用率。</p>\n<p><strong>Namespace:</strong><br>Pulsar的基本管理单元，在namespace级别可设置权限、消息TTL、Retention策略等。一个namespace里的所有topic都继承相同的设置。命名空间分为两种：本地命名空间，只在集群内可见；全局命名空间对多个集群可见。<br><img src=\"https://vqianxiao.github.io/blog/images/mq/mq5.png\"></p>\n<p><strong>Producer:</strong> 数据生产方，负责创建消息并将消息投递到Pulsar中。</p>\n<p><strong>Consumer:</strong> 数据消费方，连接到Pulsar接收消息并进行相应的处理。</p>\n<p><strong>Broker:</strong> 无状态Proxy服务，负责接收消息、传递消息、集群负载均衡等操作，它对client屏蔽了服务端读写流程的复杂性，是保证数据一致性与数据负载均衡的重要角色。Broker不会持久化保存元数据。可以扩容但不能缩容。</p>\n<p><strong>BookKeeper:</strong><br>有状态，负责持久化存储消息。当集群扩容时，Pulsar会在新增BookKeeper和Segment（即BookKeeper的Ledger），不需要想kafka一样扩容时进行ReBalance。扩容结果时Fragments跨多个Bookies以带状分布，同一个Ledger的Fragments分布在多个Bookie上，导致读取和写入会在多个Bookies之间跳跃。</p>\n<p><strong>ZooKeeper:</strong> 存储Pulsar、BookKeeper的元数据，集群配置等信息，负责集群间的协调、服务发现等。</p>\n<p><strong>Topic:</strong> 用作从producer到consumer传输消息。Pulsar在Topic级别拥有一个leader<br>Broker，称之为拥有Topic的所有权，针对该Topic所有的R/W都经过该Broker完成。Topic的Ledger和Fragment之间映射关系等元数据存储在Zookeeper中，Pulsar Broker需要事实跟踪这些关系进行读写流程。</p>\n<p><strong>Ledger:</strong> 即Segment，Pulsar底层数据以Ledger的形式存储在BookKeeper上。是Pulsar删除的最小单位。</p>\n<p><strong>Fragment:</strong> 每个Ledger由若干个Fragment组成。</p>\n<h2 id=\"2-3-RocketMQ\"><a href=\"#2-3-RocketMQ\" class=\"headerlink\" title=\"2.3 RocketMQ\"></a>2.3 RocketMQ</h2><h3 id=\"2-3-1-系统框架\"><a href=\"#2-3-1-系统框架\" class=\"headerlink\" title=\"2.3.1 系统框架\"></a>2.3.1 系统框架</h3><p><img src=\"https://vqianxiao.github.io/blog/images/mq/mq6.png\"><br>RocketMQ是阿里开源的消息中间件，它是一个开源的分布式消息传递和流式数据平台。总共有四大部分：NameServer，Broker，Producer，Consumer。</p>\n<p>NameServer主要用来管理brokers以及路由信息。broker服务器启动时会注册到NameServer上，并且两者之间保持心跳监测机制，以此来保证NameServer知道broker的存活状态。而且，每一台NameServer都存有全部的broker集群信息和生产者/消费者客户端的请求信息。</p>\n<p>Broker负载管理消息存储分发，主从数据同步，为消息建立索引，提供消息查询等能力。</p>\n<h3 id=\"2-3-2-基本术语\"><a href=\"#2-3-2-基本术语\" class=\"headerlink\" title=\"2.3.2 基本术语\"></a>2.3.2 基本术语</h3><p><strong>Topic:</strong> 一个Topic可以有0个、1个多个生产者向其发送消息，一个生产者也可以同时向不同的Topic发送消息。一个Topic也可以被0个、1个、多个消费者订阅。</p>\n<p><strong>Tag:</strong> 消息二级类型，可以为用户提供额外的灵活度，一条消息可以没有Tag。</p>\n<p><strong>Producer:</strong> 消息生产者。</p>\n<p><strong>Broker:</strong> 存储消息，以Topic为纬度轻量级的队列；转发消息，单个Broker节点与所有的NameServer节点保持长连接及心跳，会定时将Topic信息注册到NameServer。</p>\n<p><strong>Consumer:</strong> 消息消费者，负责接收并消费消息。</p>\n<p><strong>MessageQueue:</strong> 消息的物理管理单位，一个Topic可以有多个Queue，Queue的的引入是西安了水平扩展的能力。</p>\n<p><strong>NameServer:</strong> 负责对元数据的管理，包括Topic和路由信息，每个NameServer之间是没有通信的。</p>\n<p><strong>Group:</strong> 一个组可以订阅多个Topic，ProducerGroup、ConsumerGroup分别是一类生产者和一类消费者。</p>\n<p><strong>Offset:</strong> 通过Offset访问存储单元，RocketMQ中所有消息都是持久化的，且存储单元定长。Offset为Java Long类型，理论上100年内不会溢出，所以认为Message Queue是无限长的数据，Offset是下标。</p>\n<p><strong>Consumer:</strong> 支持PUSH和PULL两种消费模式，支持集群消费和广播消费。</p>\n<h2 id=\"2-4-RabbitMQ\"><a href=\"#2-4-RabbitMQ\" class=\"headerlink\" title=\"2.4 RabbitMQ\"></a>2.4 RabbitMQ</h2><h3 id=\"2-4-1-系统框架\"><a href=\"#2-4-1-系统框架\" class=\"headerlink\" title=\"2.4.1 系统框架\"></a>2.4.1 系统框架</h3><p><img src=\"https://vqianxiao.github.io/blog/images/mq/mq7.png\"><br>RabbitMQ基于AMQP协议来实现，主要由Exchange和Queue两部分组成，然后通过RoutingKey关联起来，消息投递到Exchange然后通过Queue接收。</p>\n<h3 id=\"2-4-2-基本术语\"><a href=\"#2-4-2-基本术语\" class=\"headerlink\" title=\"2.4.2 基本术语\"></a>2.4.2 基本术语</h3><p><strong>Broker:</strong> 接收客户端连接实体，实现AMQP消息队列和路由功能。</p>\n<p><strong>Virtual Host:</strong> 是一个虚拟概念，权限控制的最小单位。一个Virtual Host里包含多个Exchange和Queue。</p>\n<p><strong>Exchange:</strong> 接收消息生产者的消息并将消息转发到队列。发送消息时根据不同ExchangeType决定路由规则，ExchangeType常用的有：direct、fanout和topic三种。</p>\n<p><strong>Message Queue:</strong> 消息队列，存储被消费的消息。</p>\n<p><strong>Message:</strong> 由Header和Body组成，Header是生产者添加的各种属性，包含Message是否持久化、哪个MessageQueue接收、优先级。Body是具体的消息内容。</p>\n<p><strong>Binding:</strong> Binding连接起了Exchange和Message Queue。在服务器运行时，会生成一张路由表，这张路由表上记录者MessageQueue的条件和BindingKey值。当Exchange收到消息后，会解析消息中的Header得到BindingKey，并根据路由表和ExchangeType将消息发送到对应的MessageQueue。最终的匹配模式是由ExchangeType决定。</p>\n<p><strong>Connection:</strong> 在Broker和客户端之间的TCP连接。</p>\n<p><strong>Channel:</strong> 信道。Broker和客户端只有tcp连接是不能发送消息的，必须创建信道。AMQP协议规定只有通过Channel才能执行AMQP命令。一个Connection可以包含多个Channel。之所以需要建立Channel，是因为每个TCP连接都是很宝贵的。如果每个客户端、每个线程都需要和Broker交互，都需要维护一个TCP连接的话是很耗费机器资源的，一般建议共享Connection。RabbitMQ不建议客户端线程之间共享Channel，至少保证同一Channel发消息是串行的。</p>\n<p><strong>Command:</strong> AMQP命令，客户端通过Command来完成和AMQP服务器的交互。</p>\n<h2 id=\"2-5-NSQ\"><a href=\"#2-5-NSQ\" class=\"headerlink\" title=\"2.5 NSQ\"></a>2.5 NSQ</h2><h3 id=\"2-5-1-系统框架\"><a href=\"#2-5-1-系统框架\" class=\"headerlink\" title=\"2.5.1 系统框架\"></a>2.5.1 系统框架</h3><p><img src=\"https://vqianxiao.github.io/blog/images/mq/mq8.png\"><br>NSQ主要有nsqlookup、nsqd两部分组成:</p>\n<ul>\n<li>Nsqlookup为守护进程，负责管理拓扑信息并提供发现服务。客户端通过查询nsqlookupd获取指定Topic所在的nsqd节点。nsqd往nsqlookup上注册和广播自身topic和channel的信息。</li>\n<li>nsqd在服务端运行的守护进程，负责接收，排队，投递消息给客户端。</li>\n</ul>\n<p>NSQ由3个守护进程组成：</p>\n<ul>\n<li>nsqd是接收、队列和传送消息到客户端的守护进程。</li>\n<li>nsqlookupd是管理的拓扑信息，并提供了最终一致发现服务的守护进程。客户端通过查询nsqlookupd获取指定Topic所在的nsqd节点。nsqd往nsqlookup上注册和广播自身topic和channel的信息。</li>\n<li>nsqadmin是一个WebUI来实时监控集群（和执行各种管理任务）。</li>\n</ul>\n<h1 id=\"3选型要点\"><a href=\"#3选型要点\" class=\"headerlink\" title=\"3选型要点\"></a>3选型要点</h1><h2 id=\"3-1选型参考\"><a href=\"#3-1选型参考\" class=\"headerlink\" title=\"3.1选型参考\"></a>3.1选型参考</h2><ul>\n<li>消息顺序：发送到队列的消息，消费时是否可以保证消费的顺序。</li>\n<li>伸缩：当消息队列性能有问题，比如消费太慢，是否可以快速支持扩容；当消费队列过多，浪费系统资源，是否可以支持缩容。</li>\n<li>消息留存：消息消费成功后，是否还会继续保留在消息队列。</li>\n<li>容错性：当一条消息消费失败后，是否有一些机制，保证这条消息一定能成功，比如异步第三方退款消息，需要保证这条消息消费掉，才能确定给用户退款成功，所以必须保证这条消息消费的准确性。</li>\n<li>消息可靠性：是否会存在丢消息的情况，比如有A/B两个消息，最后只有B消息能消费，A消息丢失</li>\n<li>消息时序：主要包括“消息存活时间”和“延迟消息”</li>\n<li>吞吐量：支持的最高并发数</li>\n<li>消息路由：根据路由规则，只订阅匹配路由规则的消息，比如有A/B两者规则的消息，消费者可以只订阅A消息，B消息不会消费。</li>\n</ul>\n<h2 id=\"3-2消息队列对比\"><a href=\"#3-2消息队列对比\" class=\"headerlink\" title=\"3.2消息队列对比\"></a>3.2消息队列对比</h2><p><img src=\"https://vqianxiao.github.io/blog/images/mq/mq9.png\"><br><img src=\"https://vqianxiao.github.io/blog/images/mq/mq10.png\"></p>\n<h1 id=\"4功能剖析\"><a href=\"#4功能剖析\" class=\"headerlink\" title=\"4功能剖析\"></a>4功能剖析</h1><h2 id=\"4-1消费推拉模式\"><a href=\"#4-1消费推拉模式\" class=\"headerlink\" title=\"4.1消费推拉模式\"></a>4.1消费推拉模式</h2><p>客户端消费者获取消息的方式，Kafka和RocketMQ是通过长轮训Pull的方式拉取消息，RabbitMQ、Pulsar、NSQ都是通过Push的方式。<br>pull类型的消息队列更适合高吞吐量的场景，允许消费者自己进行流量控制，根据消费者实际的消费能力去获取消息。而push类型的消息队列，实时性更好，但需要有一套良好的流控策略(backpressure)当消费者消费能力不足时，减少push的消费数量，避免压垮消费端。</p>\n<h2 id=\"4-2延迟队列\"><a href=\"#4-2延迟队列\" class=\"headerlink\" title=\"4.2延迟队列\"></a>4.2延迟队列</h2>","site":{"data":{}},"excerpt":"","more":"<p>作者：emoryliang</p>\n<p>原文地址<br><a href=\"https://mp.weixin.qq.com/s/jWKHAic4Tt4Ohsj4pTmYFw\">https://mp.weixin.qq.com/s/jWKHAic4Tt4Ohsj4pTmYFw</a></p>\n<blockquote>\n</blockquote>\n<p>消息队列是重要的分布式系统组件，在高性能、高可用、低耦合等系统架构中扮演着重要作用。可用于异步通信、削峰填谷、解耦系统、数据缓存等多种业务场景。本文是关于消息队列（MQ）选型和常见问题的精心整理。在这篇文章中，我嗯将详细介绍消息队列的概念、作用以及如何选择适合自己需求的消息队列系统。</p>\n<p><img src=\"https://vqianxiao.github.io/blog/images/mq/mq1.png\"></p>\n<h1 id=\"1-概诉\"><a href=\"#1-概诉\" class=\"headerlink\" title=\"1 概诉\"></a>1 概诉</h1><p>消息队列是分布式系统中重要的中间件，在高性能、高可用、低耦合等系统架构中扮演着重要作用。分布式系统可以借助消息队列的能力，轻松实现以下功能：</p>\n<ul>\n<li>解耦：将一个流程的上下游拆解开，上游专注于生产消息，下游专注于处理消息；</li>\n<li>广播：上游生产的消息可以轻松被多个下游服务处理；</li>\n<li>缓冲：应对突发流量，消息队列扮演缓冲器的作用，保护下游服务，使其可以根据自身的实际消费能力处理消息；</li>\n<li>异步：上游发送消息后可以马上返回，下游可以异步处理消息；</li>\n<li>冗余：保留历史消息，处理失败或当出现异常时可以进行重试或者回溯，防止丢失；</li>\n</ul>\n<h1 id=\"2-架构简介\"><a href=\"#2-架构简介\" class=\"headerlink\" title=\"2 架构简介\"></a>2 架构简介</h1><h2 id=\"2-1-Kafka\"><a href=\"#2-1-Kafka\" class=\"headerlink\" title=\"2.1 Kafka\"></a>2.1 Kafka</h2><h3 id=\"2-1-1-系统架构\"><a href=\"#2-1-1-系统架构\" class=\"headerlink\" title=\"2.1.1 系统架构\"></a>2.1.1 系统架构</h3><p><img src=\"https://vqianxiao.github.io/blog/images/mq/mq2.png\"><br>一个Kafka集群由多个Broker和一个ZooKeeper集群组成，Broker作为Kafka节点的服务器。同一个消息主题Topic可以由多个分区Partition组成，分区物理存储在Broker上。负载均衡考虑，同一个Topic的多个分区存储在多个不同的Broker上，为了提高可靠性，每个分区在不同的Broker都会存在副本。</p>\n<p>ZooKeeper是一个分布式开源的应用程序协调服务，可以实现统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等工作。Kafka里的ZooKeeper主要有以下几个作用：</p>\n<ul>\n<li>Broker注册，当有Broker故障的时候能及时感知。</li>\n<li>Topic注册，维护Topic各分区的各副本所在的Broker节点，以及对应leader/follower的角色。</li>\n<li>Consumer注册，维护消费者组的offset以及消费者与分区的对应关系，实现负载均衡。</li>\n</ul>\n<h3 id=\"2-1-2-基本术语\"><a href=\"#2-1-2-基本术语\" class=\"headerlink\" title=\"2.1.2 基本术语\"></a>2.1.2 基本术语</h3><p><strong>Producer:</strong> 消息生产者。一般情况下，一条消息会被发送到特定的主题上。通常情况下，写入的消息会通过轮询将消息写入各分区。生产者也可以通过设定消息key值将消息写入指定分区。写入分区的数据越均匀Kafka的性能才能更好发挥。</p>\n<p><strong>Topic:</strong> Topic是一个抽象的虚拟概念，一个集群可以有多个Topic，作为一类消息的标识。一个生产者将消息发送到Topic，消费者通过订阅Topic获取分区消息。</p>\n<p><strong>Partition:</strong><br>Partition是个物理概念，一个Topic对应一个或多个Partition。新消息会以追加的方式写入分区里，在同一个Partition里消息是有序的。Kafka通过分区，实现消息的冗余和伸缩性，以及支持物理上的并发读、写，大大提高了吞吐量。</p>\n<p><strong>Replicas:</strong><br>一个Partition有多个Replicas副本。这些副本保存在Broker，每个broker存储着成百上千个不同主题和分区的副本，存储的内容分为两种：master副本，每个Partition都有一个Master副本，所有内容的写入和消费都会经过Master副本；follower副本不处理任何客户端的请求，只同步master的内容进行复制。如果master发生了异常，很快会有一个follower成为新的master。</p>\n<p><strong>Consumer:</strong> 消息读取者。消费者订阅主题，并按照一定顺序读取消息。Kafka保证每个分区只能被一个消费者使用。</p>\n<p><strong>Offset:</strong> 偏移量是一种元数据，是不断递增的整数。在消息写入时Kafka会把它添加到消息里。在分区内偏移量是唯一的。消费过程中，会将最后读取的偏移量存储在Kafka中，消费者关闭偏移量不会丢失，重启会继续从上次位置开始消费。</p>\n<p><strong>Broker:</strong><br>独立的Kafka服务器。一个Topic有N个Partition，一个集群有N个Broker，那么每个Broker都会存储一个这个Topic的Partition。如果某个Topic有N个partition，集群有（N+M）个Broker，那么其中有N个Broker存储该Topic的一个Partition，剩下的M个Broker不存储该Topic的Partition数据。如果某个Topic有N个Partition，集群中broker数目少于N个，那么一个Broker存储该Topic的一个或多个Partition。在实际生产环境中，尽量避免这种情况的发生，这种情况容易导致Kafka集群数据不均衡。</p>\n<h2 id=\"2-2-Pulsar\"><a href=\"#2-2-Pulsar\" class=\"headerlink\" title=\"2.2 Pulsar\"></a>2.2 Pulsar</h2><h3 id=\"2-2-1-系统架构\"><a href=\"#2-2-1-系统架构\" class=\"headerlink\" title=\"2.2.1 系统架构\"></a>2.2.1 系统架构</h3><p><img src=\"https://vqianxiao.github.io/blog/images/mq/mq3.png\"><br>Pulsar有三个重要的组件，Broker、BookKeeper和ZooKeeper，Broker是无状态服务，客户端需要连接到Broker上进行消息的传递。BookKeeper与ZoKeeper是有状态服务。<br>BookKeeper的节点叫Bookie，负责存储消息和游标，ZooKeeper存储Broker和Bookie的元数据。Pulsar以这种架构，实现存储和计算分离，Broker负责计算，Bookie负责有状态存储。<br><img src=\"https://vqianxiao.github.io/blog/images/mq/mq4.png\"><br>Pulsar的多层架构影响了存储数据的方式。Pulsar将Topic分区划分为分片（Segment）,然后将这些分片存储在Apache<br>BookKeeper的存储节点上，以提高性能、可伸缩性和可用性。<br>Pulsar的分布式日志以分片为中心，借助扩展日志存储（通过Apache<br>bookKeeper）实现，内置分层存储支持，因此分片可以均匀地分布在存储节点上。由于与任一给定Topic相关的数据都不会与特定存储节点进行捆绑，因此很容易替换存储节点或扩缩容。另外，集群中最小或最慢的节点也不会成为存储或带宽的短板。</p>\n<h3 id=\"2-2-2-基本术语\"><a href=\"#2-2-2-基本术语\" class=\"headerlink\" title=\"2.2.2 基本术语\"></a>2.2.2 基本术语</h3><p><strong>Property:</strong> 代表租户，每个property都可以代表一个团队、一个功能、一个产品线。一个property可包含多个namespace，多租户是一种资源隔离手段，可以提高资源利用率。</p>\n<p><strong>Namespace:</strong><br>Pulsar的基本管理单元，在namespace级别可设置权限、消息TTL、Retention策略等。一个namespace里的所有topic都继承相同的设置。命名空间分为两种：本地命名空间，只在集群内可见；全局命名空间对多个集群可见。<br><img src=\"https://vqianxiao.github.io/blog/images/mq/mq5.png\"></p>\n<p><strong>Producer:</strong> 数据生产方，负责创建消息并将消息投递到Pulsar中。</p>\n<p><strong>Consumer:</strong> 数据消费方，连接到Pulsar接收消息并进行相应的处理。</p>\n<p><strong>Broker:</strong> 无状态Proxy服务，负责接收消息、传递消息、集群负载均衡等操作，它对client屏蔽了服务端读写流程的复杂性，是保证数据一致性与数据负载均衡的重要角色。Broker不会持久化保存元数据。可以扩容但不能缩容。</p>\n<p><strong>BookKeeper:</strong><br>有状态，负责持久化存储消息。当集群扩容时，Pulsar会在新增BookKeeper和Segment（即BookKeeper的Ledger），不需要想kafka一样扩容时进行ReBalance。扩容结果时Fragments跨多个Bookies以带状分布，同一个Ledger的Fragments分布在多个Bookie上，导致读取和写入会在多个Bookies之间跳跃。</p>\n<p><strong>ZooKeeper:</strong> 存储Pulsar、BookKeeper的元数据，集群配置等信息，负责集群间的协调、服务发现等。</p>\n<p><strong>Topic:</strong> 用作从producer到consumer传输消息。Pulsar在Topic级别拥有一个leader<br>Broker，称之为拥有Topic的所有权，针对该Topic所有的R/W都经过该Broker完成。Topic的Ledger和Fragment之间映射关系等元数据存储在Zookeeper中，Pulsar Broker需要事实跟踪这些关系进行读写流程。</p>\n<p><strong>Ledger:</strong> 即Segment，Pulsar底层数据以Ledger的形式存储在BookKeeper上。是Pulsar删除的最小单位。</p>\n<p><strong>Fragment:</strong> 每个Ledger由若干个Fragment组成。</p>\n<h2 id=\"2-3-RocketMQ\"><a href=\"#2-3-RocketMQ\" class=\"headerlink\" title=\"2.3 RocketMQ\"></a>2.3 RocketMQ</h2><h3 id=\"2-3-1-系统框架\"><a href=\"#2-3-1-系统框架\" class=\"headerlink\" title=\"2.3.1 系统框架\"></a>2.3.1 系统框架</h3><p><img src=\"https://vqianxiao.github.io/blog/images/mq/mq6.png\"><br>RocketMQ是阿里开源的消息中间件，它是一个开源的分布式消息传递和流式数据平台。总共有四大部分：NameServer，Broker，Producer，Consumer。</p>\n<p>NameServer主要用来管理brokers以及路由信息。broker服务器启动时会注册到NameServer上，并且两者之间保持心跳监测机制，以此来保证NameServer知道broker的存活状态。而且，每一台NameServer都存有全部的broker集群信息和生产者/消费者客户端的请求信息。</p>\n<p>Broker负载管理消息存储分发，主从数据同步，为消息建立索引，提供消息查询等能力。</p>\n<h3 id=\"2-3-2-基本术语\"><a href=\"#2-3-2-基本术语\" class=\"headerlink\" title=\"2.3.2 基本术语\"></a>2.3.2 基本术语</h3><p><strong>Topic:</strong> 一个Topic可以有0个、1个多个生产者向其发送消息，一个生产者也可以同时向不同的Topic发送消息。一个Topic也可以被0个、1个、多个消费者订阅。</p>\n<p><strong>Tag:</strong> 消息二级类型，可以为用户提供额外的灵活度，一条消息可以没有Tag。</p>\n<p><strong>Producer:</strong> 消息生产者。</p>\n<p><strong>Broker:</strong> 存储消息，以Topic为纬度轻量级的队列；转发消息，单个Broker节点与所有的NameServer节点保持长连接及心跳，会定时将Topic信息注册到NameServer。</p>\n<p><strong>Consumer:</strong> 消息消费者，负责接收并消费消息。</p>\n<p><strong>MessageQueue:</strong> 消息的物理管理单位，一个Topic可以有多个Queue，Queue的的引入是西安了水平扩展的能力。</p>\n<p><strong>NameServer:</strong> 负责对元数据的管理，包括Topic和路由信息，每个NameServer之间是没有通信的。</p>\n<p><strong>Group:</strong> 一个组可以订阅多个Topic，ProducerGroup、ConsumerGroup分别是一类生产者和一类消费者。</p>\n<p><strong>Offset:</strong> 通过Offset访问存储单元，RocketMQ中所有消息都是持久化的，且存储单元定长。Offset为Java Long类型，理论上100年内不会溢出，所以认为Message Queue是无限长的数据，Offset是下标。</p>\n<p><strong>Consumer:</strong> 支持PUSH和PULL两种消费模式，支持集群消费和广播消费。</p>\n<h2 id=\"2-4-RabbitMQ\"><a href=\"#2-4-RabbitMQ\" class=\"headerlink\" title=\"2.4 RabbitMQ\"></a>2.4 RabbitMQ</h2><h3 id=\"2-4-1-系统框架\"><a href=\"#2-4-1-系统框架\" class=\"headerlink\" title=\"2.4.1 系统框架\"></a>2.4.1 系统框架</h3><p><img src=\"https://vqianxiao.github.io/blog/images/mq/mq7.png\"><br>RabbitMQ基于AMQP协议来实现，主要由Exchange和Queue两部分组成，然后通过RoutingKey关联起来，消息投递到Exchange然后通过Queue接收。</p>\n<h3 id=\"2-4-2-基本术语\"><a href=\"#2-4-2-基本术语\" class=\"headerlink\" title=\"2.4.2 基本术语\"></a>2.4.2 基本术语</h3><p><strong>Broker:</strong> 接收客户端连接实体，实现AMQP消息队列和路由功能。</p>\n<p><strong>Virtual Host:</strong> 是一个虚拟概念，权限控制的最小单位。一个Virtual Host里包含多个Exchange和Queue。</p>\n<p><strong>Exchange:</strong> 接收消息生产者的消息并将消息转发到队列。发送消息时根据不同ExchangeType决定路由规则，ExchangeType常用的有：direct、fanout和topic三种。</p>\n<p><strong>Message Queue:</strong> 消息队列，存储被消费的消息。</p>\n<p><strong>Message:</strong> 由Header和Body组成，Header是生产者添加的各种属性，包含Message是否持久化、哪个MessageQueue接收、优先级。Body是具体的消息内容。</p>\n<p><strong>Binding:</strong> Binding连接起了Exchange和Message Queue。在服务器运行时，会生成一张路由表，这张路由表上记录者MessageQueue的条件和BindingKey值。当Exchange收到消息后，会解析消息中的Header得到BindingKey，并根据路由表和ExchangeType将消息发送到对应的MessageQueue。最终的匹配模式是由ExchangeType决定。</p>\n<p><strong>Connection:</strong> 在Broker和客户端之间的TCP连接。</p>\n<p><strong>Channel:</strong> 信道。Broker和客户端只有tcp连接是不能发送消息的，必须创建信道。AMQP协议规定只有通过Channel才能执行AMQP命令。一个Connection可以包含多个Channel。之所以需要建立Channel，是因为每个TCP连接都是很宝贵的。如果每个客户端、每个线程都需要和Broker交互，都需要维护一个TCP连接的话是很耗费机器资源的，一般建议共享Connection。RabbitMQ不建议客户端线程之间共享Channel，至少保证同一Channel发消息是串行的。</p>\n<p><strong>Command:</strong> AMQP命令，客户端通过Command来完成和AMQP服务器的交互。</p>\n<h2 id=\"2-5-NSQ\"><a href=\"#2-5-NSQ\" class=\"headerlink\" title=\"2.5 NSQ\"></a>2.5 NSQ</h2><h3 id=\"2-5-1-系统框架\"><a href=\"#2-5-1-系统框架\" class=\"headerlink\" title=\"2.5.1 系统框架\"></a>2.5.1 系统框架</h3><p><img src=\"https://vqianxiao.github.io/blog/images/mq/mq8.png\"><br>NSQ主要有nsqlookup、nsqd两部分组成:</p>\n<ul>\n<li>Nsqlookup为守护进程，负责管理拓扑信息并提供发现服务。客户端通过查询nsqlookupd获取指定Topic所在的nsqd节点。nsqd往nsqlookup上注册和广播自身topic和channel的信息。</li>\n<li>nsqd在服务端运行的守护进程，负责接收，排队，投递消息给客户端。</li>\n</ul>\n<p>NSQ由3个守护进程组成：</p>\n<ul>\n<li>nsqd是接收、队列和传送消息到客户端的守护进程。</li>\n<li>nsqlookupd是管理的拓扑信息，并提供了最终一致发现服务的守护进程。客户端通过查询nsqlookupd获取指定Topic所在的nsqd节点。nsqd往nsqlookup上注册和广播自身topic和channel的信息。</li>\n<li>nsqadmin是一个WebUI来实时监控集群（和执行各种管理任务）。</li>\n</ul>\n<h1 id=\"3选型要点\"><a href=\"#3选型要点\" class=\"headerlink\" title=\"3选型要点\"></a>3选型要点</h1><h2 id=\"3-1选型参考\"><a href=\"#3-1选型参考\" class=\"headerlink\" title=\"3.1选型参考\"></a>3.1选型参考</h2><ul>\n<li>消息顺序：发送到队列的消息，消费时是否可以保证消费的顺序。</li>\n<li>伸缩：当消息队列性能有问题，比如消费太慢，是否可以快速支持扩容；当消费队列过多，浪费系统资源，是否可以支持缩容。</li>\n<li>消息留存：消息消费成功后，是否还会继续保留在消息队列。</li>\n<li>容错性：当一条消息消费失败后，是否有一些机制，保证这条消息一定能成功，比如异步第三方退款消息，需要保证这条消息消费掉，才能确定给用户退款成功，所以必须保证这条消息消费的准确性。</li>\n<li>消息可靠性：是否会存在丢消息的情况，比如有A/B两个消息，最后只有B消息能消费，A消息丢失</li>\n<li>消息时序：主要包括“消息存活时间”和“延迟消息”</li>\n<li>吞吐量：支持的最高并发数</li>\n<li>消息路由：根据路由规则，只订阅匹配路由规则的消息，比如有A/B两者规则的消息，消费者可以只订阅A消息，B消息不会消费。</li>\n</ul>\n<h2 id=\"3-2消息队列对比\"><a href=\"#3-2消息队列对比\" class=\"headerlink\" title=\"3.2消息队列对比\"></a>3.2消息队列对比</h2><p><img src=\"https://vqianxiao.github.io/blog/images/mq/mq9.png\"><br><img src=\"https://vqianxiao.github.io/blog/images/mq/mq10.png\"></p>\n<h1 id=\"4功能剖析\"><a href=\"#4功能剖析\" class=\"headerlink\" title=\"4功能剖析\"></a>4功能剖析</h1><h2 id=\"4-1消费推拉模式\"><a href=\"#4-1消费推拉模式\" class=\"headerlink\" title=\"4.1消费推拉模式\"></a>4.1消费推拉模式</h2><p>客户端消费者获取消息的方式，Kafka和RocketMQ是通过长轮训Pull的方式拉取消息，RabbitMQ、Pulsar、NSQ都是通过Push的方式。<br>pull类型的消息队列更适合高吞吐量的场景，允许消费者自己进行流量控制，根据消费者实际的消费能力去获取消息。而push类型的消息队列，实时性更好，但需要有一套良好的流控策略(backpressure)当消费者消费能力不足时，减少push的消费数量，避免压垮消费端。</p>\n<h2 id=\"4-2延迟队列\"><a href=\"#4-2延迟队列\" class=\"headerlink\" title=\"4.2延迟队列\"></a>4.2延迟队列</h2>"},{"layout":"post","title":"设计原则","description":"设计原则","date":"2021-05-29T05:26:10.000Z","_content":"\n## 单一职责原则\n\n### 理解\n\n一个类只负责完成一个职责或者功能。不要设计大而全的类，要设计粒度小、功能单一的类。\n\n### 如何判断是否足够单一\n\n结合具体的应用场景。可以先写一个粗力度的类，满足业务需求。随着业务发展，如果粗力度的类越来越庞大，代码越来越多，就可以把这个粗粒度的类拆分成几个更细粒度的类。这就是所谓的持续重构。\n\n总结了几条判断原则：\n\n- 类中的代码行数、函数或属性过多，会影响代码的可读性和可维护性，我们就需要考虑对类进行拆分\n- 类依赖的其他类过多，或者依赖类的其他类过多，不符合高内聚、低耦合的设计思想，我们就需要考虑对类进行拆分\n- 私有方法过多，我们就要考虑是否能将私有方法独立到新的类中，设置为public方法，供更多的类使用，从而提高代码的复用性\n- 比较难给类起一个合适的名字，很难用一个业务名词概括，或者只能用一些笼统的Manager、Context之类的词语来命名，这就说明类的职责定义得可能不够清晰\n- 类中大量的方法都是集中操作类中的某几个属性，就可以考虑将这几个属性和对应的方法拆分出来。\n\n### 类的职责是否设计得越单一越好\n\n如果拆分的过细，实际上会适得其反，会降低内聚性，也会影响代码的可维护性。\n\n## 开闭原则\n\n**理解**\n\n添加一个新的功能是在已有代码基础上扩展代码（新增模块、类、方法等）而非修改已有代码（修改模块、类、方法等）。开闭原则并不是说完全杜绝修改，而是以最小的修改代码的代价来完成新功能的开发。同样的代码改动，修改和扩展在不同代码粒度下可能为修改和扩展，不必太过纠结。\n\n**完全不修改？**\n\n添加一个新功能，不可能任何模块、类、方法的代码都不“修改”，这个是做不到的。类需要创建、组装、做一些初始化操作，才能构建成可运行的程序，这部分代码的修改是在所难免的。我们要做的是尽量让修改操作更集中、更少、更上层，尽量让最核心、最复杂的那部分逻辑代码满足开闭原则。\n\n**如何做到对扩展开放，对修改关闭**\n\n思想，为了尽量写出扩展性好的代码，要时刻具备扩展意识、抽象意识、封装意识。这些“潜意识”可能比任何开发技巧都重要。\n\n写代码的时候，多花时间往前多思考一下，这段代码未来可能有哪些需求变更、如何设计代码结构，实现留好扩展点，以便在需求变更的时候，不需要改动代码整体结构、做到最小代码改动的情况下，新的代码能够很灵活的插入到扩展点上。在识别出代码可变部分和不可变部分后，将可变部分封装起来，隔离变化，提供抽象化的不可变接口，给上层系统使用。当具体的实现发生变化的时候，我们呢只需要基于相同的抽象接口，扩展一个新的实现，替换掉老的实现即可，上游系统的代码几乎不需要修改。\n\n常用来提高代码扩展性的方法有：多态、依赖注入、基于接口而非实现编程\n\n**项目中如何应用开闭原则**\n\n对于一些确定的、短期内可能就会扩展，或者需求改动对代码结构影响比较大的情况，或者实现成本不高的扩展点，在编写代码的时候，我们就可以实现做些扩展性设计。但对于一些不确定未来是否要支持的需求，或者实现起来比较复杂的扩展点，我们可以等到有需求驱动的时候，在通过重构代码的方式来支持扩展的需求。\n\n## 里氏替换原则\n\n**如何理解**\n\n子类对象能够替换程序中父类对象出现的任何地方，并且保证原来程序的逻辑行为不变及正确性不被破坏。\n\n**与多态的区别**\n\n多态是面向对象的一大特性，也是面向对象编程语言的一种语法。\n\n里氏替换原则是一种设计原则，是用来指导继承关系中子类该如何设计，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑以及不破坏程序的正确性。\n\n**不符合里氏替换原则的例子**\n\n1.子类违背父类声明要实现的功能\n\n2.子类违背父类对输入、输出、异常的约定\n\n3.子类违背父类注释中所罗列的任何特殊说明\n\n## 接口隔离原则\n\n**理解**\n\n调用者不应该被强迫依赖它不需要的接口。\n\n**一组API接口集合**\n\n可以是某个微服务的接口，也可以是某个类库的接口。在设计微服务或者类库接口的时候，如果部分接口只被部分调用者使用，那就需要将这部分接口隔离出来，单独给对应的调用者使用，而不是强迫其他调用者也依赖这部分不会用到的接口。\n\n**单个接口或函数**\n\n其实这样理解和单一职责有点相似，但是单一职责针对类、模块、接口的设计。接口隔离原则通过调用者如何使用接口来间接的判定，如果调用者只使用部分功能，那接口的设计就不够职责单一。\n\n**OOP中的接口**\n\n就是面向对象编程语言中的接口。接口设计要尽量单一，不要让接口的实现类和调用者，依赖不需要的接口函数。\n\n## 提高代码的复用性\n\n1.减少代码耦合\n\n对于高度耦合的代码，当我们想复用其中一个功能，想把这个功能的代码抽取出来成为一个独立的模块、类或者函数的时候，往往会发现牵一发而动全身。所以，高耦合的代码会影响到代码的复用性，我们要尽量减少代码耦合。\n\n2.满足单一职责\n\n职责不够单一，模块、类设计得大而全，那依赖它的代码或者它依赖的代码会比较多，进而增加了代码的耦合。细粒度的代码，代码的通用型会越好，越容易被复用。\n\n3.模块化\n\n模块不单指一组类构成的模块，还可以理解为单个类，函数。要善于将功能独立的代码，封装成模块。独立的模块就像一块一块的积木，更加容易复用，可以直接拿来搭建更加复杂的系统。\n\n4.业务与非业务分离\n\n越是和业务无关的代码越容易复用，越是针对特定业务的代码越难复用。所以为了复用和业务无关的代码，我们将业务和非业务逻辑代码分离，抽取成一些通用的框架、类库、组件等。\n\n5.通用代码下沉\n\n从分层的角度看，越底层的代码越通用、会被越多的模块调用，越应该设计的足够可复用。进行代码分层后，为了避免交叉调用导致关系混乱，我们只允许上层调用下层代码以及用层之间的调用，杜绝下层调用上层代码，所以通用代码我们尽量下沉到更下层。\n\n6.封装、多态、抽象、封装\n\n利用继承，可以讲公共的代码抽取到父类，子类复用父类的属性和方法。利用多态，可以动态的替换一段代码的部分逻辑，让这段代码可复用。抽象和封装，越抽象越不依赖具体的实现，越容易复用。代码封装成模块，隐藏可变的细节、暴露不变的接口，越容易复用。\n\n7.应用模版等设计模式\n\n一些设计模式也能提高代码的复用性，模版模式利用了多态来实现，可以灵活地替换其中的部分代码，整个流程模版可复用。\n\n## 迪米特法则\n\n最小知识原则，The Least Knowledge Principle。不应该有直接依赖关系的类之间，不要有依赖。有依赖关系的类之间，尽量只依赖必要的接口。\n\n\n\n### 实战思考\n\n1.业务系统的开发\n\n学会借鉴，可以通过线框图和用户用例来细化业务流程，挖掘一些比较细节的、不容易想到的功能点。面向对象设计主要聚焦在代码层面（主要针对类），系统设计就是聚焦在架构层面（主要针对模块）。类比面向对象设计，系统设计就是把合适的功能放到合适的模块中。合理地划分模块也可以做到模块层面的高内聚、低耦合，架构整洁清晰。类设计好之后，我们需要设计类之间的交互关系。类比到系统设计，系统职责划分好之后，接下来就是设计系统之间的交互。\n\n2.非业务的通用框架开发\n\n在做非业务通用框架的开发，在做需求分析的时候，除了功能性需求分析之外，还需要考虑框架的非功能性需求。比如框架的易用性、性能、扩展性、容错性、通用性等。\n\n在设计时，可以通过画产品线框图，聚焦简单应用场景，设计实现最小原型，画系统设计图来让问题简化、具体、明确，提供一个迭代设计开发的基础，逐步推进。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/设计原则与思想-设计原则.md","raw":"---\nlayout:    post\ntitle:     设计原则\ncategory:  设计模式之美\ndescription: 设计原则\ntags: 设计模式之美\ndate: 2021/05/29 13:26:10\n---\n\n## 单一职责原则\n\n### 理解\n\n一个类只负责完成一个职责或者功能。不要设计大而全的类，要设计粒度小、功能单一的类。\n\n### 如何判断是否足够单一\n\n结合具体的应用场景。可以先写一个粗力度的类，满足业务需求。随着业务发展，如果粗力度的类越来越庞大，代码越来越多，就可以把这个粗粒度的类拆分成几个更细粒度的类。这就是所谓的持续重构。\n\n总结了几条判断原则：\n\n- 类中的代码行数、函数或属性过多，会影响代码的可读性和可维护性，我们就需要考虑对类进行拆分\n- 类依赖的其他类过多，或者依赖类的其他类过多，不符合高内聚、低耦合的设计思想，我们就需要考虑对类进行拆分\n- 私有方法过多，我们就要考虑是否能将私有方法独立到新的类中，设置为public方法，供更多的类使用，从而提高代码的复用性\n- 比较难给类起一个合适的名字，很难用一个业务名词概括，或者只能用一些笼统的Manager、Context之类的词语来命名，这就说明类的职责定义得可能不够清晰\n- 类中大量的方法都是集中操作类中的某几个属性，就可以考虑将这几个属性和对应的方法拆分出来。\n\n### 类的职责是否设计得越单一越好\n\n如果拆分的过细，实际上会适得其反，会降低内聚性，也会影响代码的可维护性。\n\n## 开闭原则\n\n**理解**\n\n添加一个新的功能是在已有代码基础上扩展代码（新增模块、类、方法等）而非修改已有代码（修改模块、类、方法等）。开闭原则并不是说完全杜绝修改，而是以最小的修改代码的代价来完成新功能的开发。同样的代码改动，修改和扩展在不同代码粒度下可能为修改和扩展，不必太过纠结。\n\n**完全不修改？**\n\n添加一个新功能，不可能任何模块、类、方法的代码都不“修改”，这个是做不到的。类需要创建、组装、做一些初始化操作，才能构建成可运行的程序，这部分代码的修改是在所难免的。我们要做的是尽量让修改操作更集中、更少、更上层，尽量让最核心、最复杂的那部分逻辑代码满足开闭原则。\n\n**如何做到对扩展开放，对修改关闭**\n\n思想，为了尽量写出扩展性好的代码，要时刻具备扩展意识、抽象意识、封装意识。这些“潜意识”可能比任何开发技巧都重要。\n\n写代码的时候，多花时间往前多思考一下，这段代码未来可能有哪些需求变更、如何设计代码结构，实现留好扩展点，以便在需求变更的时候，不需要改动代码整体结构、做到最小代码改动的情况下，新的代码能够很灵活的插入到扩展点上。在识别出代码可变部分和不可变部分后，将可变部分封装起来，隔离变化，提供抽象化的不可变接口，给上层系统使用。当具体的实现发生变化的时候，我们呢只需要基于相同的抽象接口，扩展一个新的实现，替换掉老的实现即可，上游系统的代码几乎不需要修改。\n\n常用来提高代码扩展性的方法有：多态、依赖注入、基于接口而非实现编程\n\n**项目中如何应用开闭原则**\n\n对于一些确定的、短期内可能就会扩展，或者需求改动对代码结构影响比较大的情况，或者实现成本不高的扩展点，在编写代码的时候，我们就可以实现做些扩展性设计。但对于一些不确定未来是否要支持的需求，或者实现起来比较复杂的扩展点，我们可以等到有需求驱动的时候，在通过重构代码的方式来支持扩展的需求。\n\n## 里氏替换原则\n\n**如何理解**\n\n子类对象能够替换程序中父类对象出现的任何地方，并且保证原来程序的逻辑行为不变及正确性不被破坏。\n\n**与多态的区别**\n\n多态是面向对象的一大特性，也是面向对象编程语言的一种语法。\n\n里氏替换原则是一种设计原则，是用来指导继承关系中子类该如何设计，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑以及不破坏程序的正确性。\n\n**不符合里氏替换原则的例子**\n\n1.子类违背父类声明要实现的功能\n\n2.子类违背父类对输入、输出、异常的约定\n\n3.子类违背父类注释中所罗列的任何特殊说明\n\n## 接口隔离原则\n\n**理解**\n\n调用者不应该被强迫依赖它不需要的接口。\n\n**一组API接口集合**\n\n可以是某个微服务的接口，也可以是某个类库的接口。在设计微服务或者类库接口的时候，如果部分接口只被部分调用者使用，那就需要将这部分接口隔离出来，单独给对应的调用者使用，而不是强迫其他调用者也依赖这部分不会用到的接口。\n\n**单个接口或函数**\n\n其实这样理解和单一职责有点相似，但是单一职责针对类、模块、接口的设计。接口隔离原则通过调用者如何使用接口来间接的判定，如果调用者只使用部分功能，那接口的设计就不够职责单一。\n\n**OOP中的接口**\n\n就是面向对象编程语言中的接口。接口设计要尽量单一，不要让接口的实现类和调用者，依赖不需要的接口函数。\n\n## 提高代码的复用性\n\n1.减少代码耦合\n\n对于高度耦合的代码，当我们想复用其中一个功能，想把这个功能的代码抽取出来成为一个独立的模块、类或者函数的时候，往往会发现牵一发而动全身。所以，高耦合的代码会影响到代码的复用性，我们要尽量减少代码耦合。\n\n2.满足单一职责\n\n职责不够单一，模块、类设计得大而全，那依赖它的代码或者它依赖的代码会比较多，进而增加了代码的耦合。细粒度的代码，代码的通用型会越好，越容易被复用。\n\n3.模块化\n\n模块不单指一组类构成的模块，还可以理解为单个类，函数。要善于将功能独立的代码，封装成模块。独立的模块就像一块一块的积木，更加容易复用，可以直接拿来搭建更加复杂的系统。\n\n4.业务与非业务分离\n\n越是和业务无关的代码越容易复用，越是针对特定业务的代码越难复用。所以为了复用和业务无关的代码，我们将业务和非业务逻辑代码分离，抽取成一些通用的框架、类库、组件等。\n\n5.通用代码下沉\n\n从分层的角度看，越底层的代码越通用、会被越多的模块调用，越应该设计的足够可复用。进行代码分层后，为了避免交叉调用导致关系混乱，我们只允许上层调用下层代码以及用层之间的调用，杜绝下层调用上层代码，所以通用代码我们尽量下沉到更下层。\n\n6.封装、多态、抽象、封装\n\n利用继承，可以讲公共的代码抽取到父类，子类复用父类的属性和方法。利用多态，可以动态的替换一段代码的部分逻辑，让这段代码可复用。抽象和封装，越抽象越不依赖具体的实现，越容易复用。代码封装成模块，隐藏可变的细节、暴露不变的接口，越容易复用。\n\n7.应用模版等设计模式\n\n一些设计模式也能提高代码的复用性，模版模式利用了多态来实现，可以灵活地替换其中的部分代码，整个流程模版可复用。\n\n## 迪米特法则\n\n最小知识原则，The Least Knowledge Principle。不应该有直接依赖关系的类之间，不要有依赖。有依赖关系的类之间，尽量只依赖必要的接口。\n\n\n\n### 实战思考\n\n1.业务系统的开发\n\n学会借鉴，可以通过线框图和用户用例来细化业务流程，挖掘一些比较细节的、不容易想到的功能点。面向对象设计主要聚焦在代码层面（主要针对类），系统设计就是聚焦在架构层面（主要针对模块）。类比面向对象设计，系统设计就是把合适的功能放到合适的模块中。合理地划分模块也可以做到模块层面的高内聚、低耦合，架构整洁清晰。类设计好之后，我们需要设计类之间的交互关系。类比到系统设计，系统职责划分好之后，接下来就是设计系统之间的交互。\n\n2.非业务的通用框架开发\n\n在做非业务通用框架的开发，在做需求分析的时候，除了功能性需求分析之外，还需要考虑框架的非功能性需求。比如框架的易用性、性能、扩展性、容错性、通用性等。\n\n在设计时，可以通过画产品线框图，聚焦简单应用场景，设计实现最小原型，画系统设计图来让问题简化、具体、明确，提供一个迭代设计开发的基础，逐步推进。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"设计原则与思想-设计原则","published":1,"updated":"2021-05-29T05:26:10.000Z","comments":1,"photos":[],"link":"","_id":"cm1m304xf000x31b4h8ep846d","content":"<h2 id=\"单一职责原则\"><a href=\"#单一职责原则\" class=\"headerlink\" title=\"单一职责原则\"></a>单一职责原则</h2><h3 id=\"理解\"><a href=\"#理解\" class=\"headerlink\" title=\"理解\"></a>理解</h3><p>一个类只负责完成一个职责或者功能。不要设计大而全的类，要设计粒度小、功能单一的类。</p>\n<h3 id=\"如何判断是否足够单一\"><a href=\"#如何判断是否足够单一\" class=\"headerlink\" title=\"如何判断是否足够单一\"></a>如何判断是否足够单一</h3><p>结合具体的应用场景。可以先写一个粗力度的类，满足业务需求。随着业务发展，如果粗力度的类越来越庞大，代码越来越多，就可以把这个粗粒度的类拆分成几个更细粒度的类。这就是所谓的持续重构。</p>\n<p>总结了几条判断原则：</p>\n<ul>\n<li>类中的代码行数、函数或属性过多，会影响代码的可读性和可维护性，我们就需要考虑对类进行拆分</li>\n<li>类依赖的其他类过多，或者依赖类的其他类过多，不符合高内聚、低耦合的设计思想，我们就需要考虑对类进行拆分</li>\n<li>私有方法过多，我们就要考虑是否能将私有方法独立到新的类中，设置为public方法，供更多的类使用，从而提高代码的复用性</li>\n<li>比较难给类起一个合适的名字，很难用一个业务名词概括，或者只能用一些笼统的Manager、Context之类的词语来命名，这就说明类的职责定义得可能不够清晰</li>\n<li>类中大量的方法都是集中操作类中的某几个属性，就可以考虑将这几个属性和对应的方法拆分出来。</li>\n</ul>\n<h3 id=\"类的职责是否设计得越单一越好\"><a href=\"#类的职责是否设计得越单一越好\" class=\"headerlink\" title=\"类的职责是否设计得越单一越好\"></a>类的职责是否设计得越单一越好</h3><p>如果拆分的过细，实际上会适得其反，会降低内聚性，也会影响代码的可维护性。</p>\n<h2 id=\"开闭原则\"><a href=\"#开闭原则\" class=\"headerlink\" title=\"开闭原则\"></a>开闭原则</h2><p><strong>理解</strong></p>\n<p>添加一个新的功能是在已有代码基础上扩展代码（新增模块、类、方法等）而非修改已有代码（修改模块、类、方法等）。开闭原则并不是说完全杜绝修改，而是以最小的修改代码的代价来完成新功能的开发。同样的代码改动，修改和扩展在不同代码粒度下可能为修改和扩展，不必太过纠结。</p>\n<p><strong>完全不修改？</strong></p>\n<p>添加一个新功能，不可能任何模块、类、方法的代码都不“修改”，这个是做不到的。类需要创建、组装、做一些初始化操作，才能构建成可运行的程序，这部分代码的修改是在所难免的。我们要做的是尽量让修改操作更集中、更少、更上层，尽量让最核心、最复杂的那部分逻辑代码满足开闭原则。</p>\n<p><strong>如何做到对扩展开放，对修改关闭</strong></p>\n<p>思想，为了尽量写出扩展性好的代码，要时刻具备扩展意识、抽象意识、封装意识。这些“潜意识”可能比任何开发技巧都重要。</p>\n<p>写代码的时候，多花时间往前多思考一下，这段代码未来可能有哪些需求变更、如何设计代码结构，实现留好扩展点，以便在需求变更的时候，不需要改动代码整体结构、做到最小代码改动的情况下，新的代码能够很灵活的插入到扩展点上。在识别出代码可变部分和不可变部分后，将可变部分封装起来，隔离变化，提供抽象化的不可变接口，给上层系统使用。当具体的实现发生变化的时候，我们呢只需要基于相同的抽象接口，扩展一个新的实现，替换掉老的实现即可，上游系统的代码几乎不需要修改。</p>\n<p>常用来提高代码扩展性的方法有：多态、依赖注入、基于接口而非实现编程</p>\n<p><strong>项目中如何应用开闭原则</strong></p>\n<p>对于一些确定的、短期内可能就会扩展，或者需求改动对代码结构影响比较大的情况，或者实现成本不高的扩展点，在编写代码的时候，我们就可以实现做些扩展性设计。但对于一些不确定未来是否要支持的需求，或者实现起来比较复杂的扩展点，我们可以等到有需求驱动的时候，在通过重构代码的方式来支持扩展的需求。</p>\n<h2 id=\"里氏替换原则\"><a href=\"#里氏替换原则\" class=\"headerlink\" title=\"里氏替换原则\"></a>里氏替换原则</h2><p><strong>如何理解</strong></p>\n<p>子类对象能够替换程序中父类对象出现的任何地方，并且保证原来程序的逻辑行为不变及正确性不被破坏。</p>\n<p><strong>与多态的区别</strong></p>\n<p>多态是面向对象的一大特性，也是面向对象编程语言的一种语法。</p>\n<p>里氏替换原则是一种设计原则，是用来指导继承关系中子类该如何设计，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑以及不破坏程序的正确性。</p>\n<p><strong>不符合里氏替换原则的例子</strong></p>\n<p>1.子类违背父类声明要实现的功能</p>\n<p>2.子类违背父类对输入、输出、异常的约定</p>\n<p>3.子类违背父类注释中所罗列的任何特殊说明</p>\n<h2 id=\"接口隔离原则\"><a href=\"#接口隔离原则\" class=\"headerlink\" title=\"接口隔离原则\"></a>接口隔离原则</h2><p><strong>理解</strong></p>\n<p>调用者不应该被强迫依赖它不需要的接口。</p>\n<p><strong>一组API接口集合</strong></p>\n<p>可以是某个微服务的接口，也可以是某个类库的接口。在设计微服务或者类库接口的时候，如果部分接口只被部分调用者使用，那就需要将这部分接口隔离出来，单独给对应的调用者使用，而不是强迫其他调用者也依赖这部分不会用到的接口。</p>\n<p><strong>单个接口或函数</strong></p>\n<p>其实这样理解和单一职责有点相似，但是单一职责针对类、模块、接口的设计。接口隔离原则通过调用者如何使用接口来间接的判定，如果调用者只使用部分功能，那接口的设计就不够职责单一。</p>\n<p><strong>OOP中的接口</strong></p>\n<p>就是面向对象编程语言中的接口。接口设计要尽量单一，不要让接口的实现类和调用者，依赖不需要的接口函数。</p>\n<h2 id=\"提高代码的复用性\"><a href=\"#提高代码的复用性\" class=\"headerlink\" title=\"提高代码的复用性\"></a>提高代码的复用性</h2><p>1.减少代码耦合</p>\n<p>对于高度耦合的代码，当我们想复用其中一个功能，想把这个功能的代码抽取出来成为一个独立的模块、类或者函数的时候，往往会发现牵一发而动全身。所以，高耦合的代码会影响到代码的复用性，我们要尽量减少代码耦合。</p>\n<p>2.满足单一职责</p>\n<p>职责不够单一，模块、类设计得大而全，那依赖它的代码或者它依赖的代码会比较多，进而增加了代码的耦合。细粒度的代码，代码的通用型会越好，越容易被复用。</p>\n<p>3.模块化</p>\n<p>模块不单指一组类构成的模块，还可以理解为单个类，函数。要善于将功能独立的代码，封装成模块。独立的模块就像一块一块的积木，更加容易复用，可以直接拿来搭建更加复杂的系统。</p>\n<p>4.业务与非业务分离</p>\n<p>越是和业务无关的代码越容易复用，越是针对特定业务的代码越难复用。所以为了复用和业务无关的代码，我们将业务和非业务逻辑代码分离，抽取成一些通用的框架、类库、组件等。</p>\n<p>5.通用代码下沉</p>\n<p>从分层的角度看，越底层的代码越通用、会被越多的模块调用，越应该设计的足够可复用。进行代码分层后，为了避免交叉调用导致关系混乱，我们只允许上层调用下层代码以及用层之间的调用，杜绝下层调用上层代码，所以通用代码我们尽量下沉到更下层。</p>\n<p>6.封装、多态、抽象、封装</p>\n<p>利用继承，可以讲公共的代码抽取到父类，子类复用父类的属性和方法。利用多态，可以动态的替换一段代码的部分逻辑，让这段代码可复用。抽象和封装，越抽象越不依赖具体的实现，越容易复用。代码封装成模块，隐藏可变的细节、暴露不变的接口，越容易复用。</p>\n<p>7.应用模版等设计模式</p>\n<p>一些设计模式也能提高代码的复用性，模版模式利用了多态来实现，可以灵活地替换其中的部分代码，整个流程模版可复用。</p>\n<h2 id=\"迪米特法则\"><a href=\"#迪米特法则\" class=\"headerlink\" title=\"迪米特法则\"></a>迪米特法则</h2><p>最小知识原则，The Least Knowledge Principle。不应该有直接依赖关系的类之间，不要有依赖。有依赖关系的类之间，尽量只依赖必要的接口。</p>\n<h3 id=\"实战思考\"><a href=\"#实战思考\" class=\"headerlink\" title=\"实战思考\"></a>实战思考</h3><p>1.业务系统的开发</p>\n<p>学会借鉴，可以通过线框图和用户用例来细化业务流程，挖掘一些比较细节的、不容易想到的功能点。面向对象设计主要聚焦在代码层面（主要针对类），系统设计就是聚焦在架构层面（主要针对模块）。类比面向对象设计，系统设计就是把合适的功能放到合适的模块中。合理地划分模块也可以做到模块层面的高内聚、低耦合，架构整洁清晰。类设计好之后，我们需要设计类之间的交互关系。类比到系统设计，系统职责划分好之后，接下来就是设计系统之间的交互。</p>\n<p>2.非业务的通用框架开发</p>\n<p>在做非业务通用框架的开发，在做需求分析的时候，除了功能性需求分析之外，还需要考虑框架的非功能性需求。比如框架的易用性、性能、扩展性、容错性、通用性等。</p>\n<p>在设计时，可以通过画产品线框图，聚焦简单应用场景，设计实现最小原型，画系统设计图来让问题简化、具体、明确，提供一个迭代设计开发的基础，逐步推进。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"单一职责原则\"><a href=\"#单一职责原则\" class=\"headerlink\" title=\"单一职责原则\"></a>单一职责原则</h2><h3 id=\"理解\"><a href=\"#理解\" class=\"headerlink\" title=\"理解\"></a>理解</h3><p>一个类只负责完成一个职责或者功能。不要设计大而全的类，要设计粒度小、功能单一的类。</p>\n<h3 id=\"如何判断是否足够单一\"><a href=\"#如何判断是否足够单一\" class=\"headerlink\" title=\"如何判断是否足够单一\"></a>如何判断是否足够单一</h3><p>结合具体的应用场景。可以先写一个粗力度的类，满足业务需求。随着业务发展，如果粗力度的类越来越庞大，代码越来越多，就可以把这个粗粒度的类拆分成几个更细粒度的类。这就是所谓的持续重构。</p>\n<p>总结了几条判断原则：</p>\n<ul>\n<li>类中的代码行数、函数或属性过多，会影响代码的可读性和可维护性，我们就需要考虑对类进行拆分</li>\n<li>类依赖的其他类过多，或者依赖类的其他类过多，不符合高内聚、低耦合的设计思想，我们就需要考虑对类进行拆分</li>\n<li>私有方法过多，我们就要考虑是否能将私有方法独立到新的类中，设置为public方法，供更多的类使用，从而提高代码的复用性</li>\n<li>比较难给类起一个合适的名字，很难用一个业务名词概括，或者只能用一些笼统的Manager、Context之类的词语来命名，这就说明类的职责定义得可能不够清晰</li>\n<li>类中大量的方法都是集中操作类中的某几个属性，就可以考虑将这几个属性和对应的方法拆分出来。</li>\n</ul>\n<h3 id=\"类的职责是否设计得越单一越好\"><a href=\"#类的职责是否设计得越单一越好\" class=\"headerlink\" title=\"类的职责是否设计得越单一越好\"></a>类的职责是否设计得越单一越好</h3><p>如果拆分的过细，实际上会适得其反，会降低内聚性，也会影响代码的可维护性。</p>\n<h2 id=\"开闭原则\"><a href=\"#开闭原则\" class=\"headerlink\" title=\"开闭原则\"></a>开闭原则</h2><p><strong>理解</strong></p>\n<p>添加一个新的功能是在已有代码基础上扩展代码（新增模块、类、方法等）而非修改已有代码（修改模块、类、方法等）。开闭原则并不是说完全杜绝修改，而是以最小的修改代码的代价来完成新功能的开发。同样的代码改动，修改和扩展在不同代码粒度下可能为修改和扩展，不必太过纠结。</p>\n<p><strong>完全不修改？</strong></p>\n<p>添加一个新功能，不可能任何模块、类、方法的代码都不“修改”，这个是做不到的。类需要创建、组装、做一些初始化操作，才能构建成可运行的程序，这部分代码的修改是在所难免的。我们要做的是尽量让修改操作更集中、更少、更上层，尽量让最核心、最复杂的那部分逻辑代码满足开闭原则。</p>\n<p><strong>如何做到对扩展开放，对修改关闭</strong></p>\n<p>思想，为了尽量写出扩展性好的代码，要时刻具备扩展意识、抽象意识、封装意识。这些“潜意识”可能比任何开发技巧都重要。</p>\n<p>写代码的时候，多花时间往前多思考一下，这段代码未来可能有哪些需求变更、如何设计代码结构，实现留好扩展点，以便在需求变更的时候，不需要改动代码整体结构、做到最小代码改动的情况下，新的代码能够很灵活的插入到扩展点上。在识别出代码可变部分和不可变部分后，将可变部分封装起来，隔离变化，提供抽象化的不可变接口，给上层系统使用。当具体的实现发生变化的时候，我们呢只需要基于相同的抽象接口，扩展一个新的实现，替换掉老的实现即可，上游系统的代码几乎不需要修改。</p>\n<p>常用来提高代码扩展性的方法有：多态、依赖注入、基于接口而非实现编程</p>\n<p><strong>项目中如何应用开闭原则</strong></p>\n<p>对于一些确定的、短期内可能就会扩展，或者需求改动对代码结构影响比较大的情况，或者实现成本不高的扩展点，在编写代码的时候，我们就可以实现做些扩展性设计。但对于一些不确定未来是否要支持的需求，或者实现起来比较复杂的扩展点，我们可以等到有需求驱动的时候，在通过重构代码的方式来支持扩展的需求。</p>\n<h2 id=\"里氏替换原则\"><a href=\"#里氏替换原则\" class=\"headerlink\" title=\"里氏替换原则\"></a>里氏替换原则</h2><p><strong>如何理解</strong></p>\n<p>子类对象能够替换程序中父类对象出现的任何地方，并且保证原来程序的逻辑行为不变及正确性不被破坏。</p>\n<p><strong>与多态的区别</strong></p>\n<p>多态是面向对象的一大特性，也是面向对象编程语言的一种语法。</p>\n<p>里氏替换原则是一种设计原则，是用来指导继承关系中子类该如何设计，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑以及不破坏程序的正确性。</p>\n<p><strong>不符合里氏替换原则的例子</strong></p>\n<p>1.子类违背父类声明要实现的功能</p>\n<p>2.子类违背父类对输入、输出、异常的约定</p>\n<p>3.子类违背父类注释中所罗列的任何特殊说明</p>\n<h2 id=\"接口隔离原则\"><a href=\"#接口隔离原则\" class=\"headerlink\" title=\"接口隔离原则\"></a>接口隔离原则</h2><p><strong>理解</strong></p>\n<p>调用者不应该被强迫依赖它不需要的接口。</p>\n<p><strong>一组API接口集合</strong></p>\n<p>可以是某个微服务的接口，也可以是某个类库的接口。在设计微服务或者类库接口的时候，如果部分接口只被部分调用者使用，那就需要将这部分接口隔离出来，单独给对应的调用者使用，而不是强迫其他调用者也依赖这部分不会用到的接口。</p>\n<p><strong>单个接口或函数</strong></p>\n<p>其实这样理解和单一职责有点相似，但是单一职责针对类、模块、接口的设计。接口隔离原则通过调用者如何使用接口来间接的判定，如果调用者只使用部分功能，那接口的设计就不够职责单一。</p>\n<p><strong>OOP中的接口</strong></p>\n<p>就是面向对象编程语言中的接口。接口设计要尽量单一，不要让接口的实现类和调用者，依赖不需要的接口函数。</p>\n<h2 id=\"提高代码的复用性\"><a href=\"#提高代码的复用性\" class=\"headerlink\" title=\"提高代码的复用性\"></a>提高代码的复用性</h2><p>1.减少代码耦合</p>\n<p>对于高度耦合的代码，当我们想复用其中一个功能，想把这个功能的代码抽取出来成为一个独立的模块、类或者函数的时候，往往会发现牵一发而动全身。所以，高耦合的代码会影响到代码的复用性，我们要尽量减少代码耦合。</p>\n<p>2.满足单一职责</p>\n<p>职责不够单一，模块、类设计得大而全，那依赖它的代码或者它依赖的代码会比较多，进而增加了代码的耦合。细粒度的代码，代码的通用型会越好，越容易被复用。</p>\n<p>3.模块化</p>\n<p>模块不单指一组类构成的模块，还可以理解为单个类，函数。要善于将功能独立的代码，封装成模块。独立的模块就像一块一块的积木，更加容易复用，可以直接拿来搭建更加复杂的系统。</p>\n<p>4.业务与非业务分离</p>\n<p>越是和业务无关的代码越容易复用，越是针对特定业务的代码越难复用。所以为了复用和业务无关的代码，我们将业务和非业务逻辑代码分离，抽取成一些通用的框架、类库、组件等。</p>\n<p>5.通用代码下沉</p>\n<p>从分层的角度看，越底层的代码越通用、会被越多的模块调用，越应该设计的足够可复用。进行代码分层后，为了避免交叉调用导致关系混乱，我们只允许上层调用下层代码以及用层之间的调用，杜绝下层调用上层代码，所以通用代码我们尽量下沉到更下层。</p>\n<p>6.封装、多态、抽象、封装</p>\n<p>利用继承，可以讲公共的代码抽取到父类，子类复用父类的属性和方法。利用多态，可以动态的替换一段代码的部分逻辑，让这段代码可复用。抽象和封装，越抽象越不依赖具体的实现，越容易复用。代码封装成模块，隐藏可变的细节、暴露不变的接口，越容易复用。</p>\n<p>7.应用模版等设计模式</p>\n<p>一些设计模式也能提高代码的复用性，模版模式利用了多态来实现，可以灵活地替换其中的部分代码，整个流程模版可复用。</p>\n<h2 id=\"迪米特法则\"><a href=\"#迪米特法则\" class=\"headerlink\" title=\"迪米特法则\"></a>迪米特法则</h2><p>最小知识原则，The Least Knowledge Principle。不应该有直接依赖关系的类之间，不要有依赖。有依赖关系的类之间，尽量只依赖必要的接口。</p>\n<h3 id=\"实战思考\"><a href=\"#实战思考\" class=\"headerlink\" title=\"实战思考\"></a>实战思考</h3><p>1.业务系统的开发</p>\n<p>学会借鉴，可以通过线框图和用户用例来细化业务流程，挖掘一些比较细节的、不容易想到的功能点。面向对象设计主要聚焦在代码层面（主要针对类），系统设计就是聚焦在架构层面（主要针对模块）。类比面向对象设计，系统设计就是把合适的功能放到合适的模块中。合理地划分模块也可以做到模块层面的高内聚、低耦合，架构整洁清晰。类设计好之后，我们需要设计类之间的交互关系。类比到系统设计，系统职责划分好之后，接下来就是设计系统之间的交互。</p>\n<p>2.非业务的通用框架开发</p>\n<p>在做非业务通用框架的开发，在做需求分析的时候，除了功能性需求分析之外，还需要考虑框架的非功能性需求。比如框架的易用性、性能、扩展性、容错性、通用性等。</p>\n<p>在设计时，可以通过画产品线框图，聚焦简单应用场景，设计实现最小原型，画系统设计图来让问题简化、具体、明确，提供一个迭代设计开发的基础，逐步推进。</p>\n"},{"layout":"post","title":"设计原则与思想-面向对象","description":"设计原则与思想之面向对象","date":"2020-10-22T06:25:10.000Z","_content":"\n## 设计模式之美\n\n**封装**\n\n封装也叫信息隐藏或数据访问保护。类通过暴露有限的访问接口，授权外部仅能通过类提供的方式来访问内部信息或者数据。\n\n如果将类的属性都暴露给调用者，调用者想要正确的操作这些属性，就需要对业务细节有足够的了解。而这对于调用者来说也是一种负担。相反如果我们把属性封装起来，暴露少许的几个必要的方法给调用者使用，调用者就不需要了解太多背后的业务细节，用错的概率就会减少很多。封装存在的意义，一方面为了保护数据不被随意修改，提高代码的可维护性，另一方面仅暴露有限的必要接口，提高类的易用性\n\n**抽象**\n\n抽象主要是隐藏方法的具体实现，让调用者只需要关心方法提供了哪些功能，并不需要知道这些功能如何实现。\n\n抽象可以通过接口类或者抽象类实现，但也并不需要特殊的语法机制来支持。抽象存在的意义，一方面是提高代码的可扩展性、维护性，修改实现不需要改变定义，减少代码的改动范围。是处理复杂系统的有效手段，能有效过滤掉不必要关注的信息。\n\n**继承**\n\n用来表示类之间 is-a 的关系，比如猫是一种哺乳动物。继承可以实现代码复用，比如两个类有相同的方法和属性。不过，过度使用继承，继承层次过深过复杂，就会导致代码可读性、可维护性变差。\n\n子类和父类高度耦合，修改父类的代码，会直接影响到子类。\n\n**多态**\n\n多态指子类可以替换父类，在实际的代码运行过程中，调用子类的方法实现。\n\n多态可以提高代码的可扩展性和复用性\n\n**面向对象的思考方式**\n\n思考如何给业务建模，如何将需求翻译为类，如何给类之间建立交互关系，而完成这些工作完全不需要考虑错综复杂的处理流程。当有了类的设计之后，然后再像搭积木一样，按照处理流程，将类组装起来形成整个程序。这种开发模式、思考问题的方式，能让我们在应对复杂程序开发的时候，思路更加清晰。\n\n**抽象类存在的意义**\n\n抽象类也是为代码复用而生的。可以优雅的实现多态。抽象类可以保证类不会被实例化，如果强行为了多态，父类创建了空的方法，那么会有误调用的风险。抽象类也可以强制子类重写需要的方法，否则就会编译错误。\n\n**接口存在的意义**\n\n接口存在的意义是为了解耦。接口实现了方法的定义和实现分离，可以降低代码的耦合性，提高代码的扩展性。\n\n**抽象类VS接口**\n\n如果要表示is-a的关系，并且是为了解决代码复用的问题，那就使用抽象类。如果要是表示一种has-a的关系，并且是为了解决抽象而非代码复用的问题，那就使用接口。\n\n从类的继承层次上看，抽象类是一种自下而上的设计思路，现有子类的代码重复，再抽象成上层的父类(抽象类)。接口是自上而下的设计思路，先设计接口，再去考虑具体的实现。\n\n**基于接口而非实现编程**\n\n应用这条原则，可以将接口与实现分离，封装不稳定的实现，暴露稳定的接口。上游系统面向接口而非实现编程，不依赖不稳定的实现细节，这样当实现发生变化的时候，上游系统代码基本上不需要改动，以此来降低耦合性，提高扩展性。越抽象，越顶层，越脱离具体某一实现的设计，越能提高代码的灵活性，越能应对未来的需求变化。好的代码设计，不仅能应对当下需求，而且在未来需求发生变化的时候，仍能够在不破坏原有代码设计的情况下灵活应对。\n\n**组合VS继承**\n\n鼓励多用组合少用继承，但是组合也并不是完美的，继承也并发一无是处。类之间的继承结构稳定（不会轻易改变），继承层次较浅，继承关系不复杂，就可以大胆的使用继承。系统不稳定，继承层次很深，继承关系复杂，就尽量使用组合来替代继承。\n\n如果不能修改一个函数的入参类型，而入参又非接口，为了支持多态，只能采用继承来实现。比如FeignClient类，要修改encode()函数，只能通过继承来实现。\n\n### 类之间交互关系\n\n**泛化**\n\n其实就是继承\n\n**实现**\n\n实现类实现接口\n\n**聚合**\n\n包含关系，A类对象包含B类对象，B类对象的生命周期可以不依赖A类对象的生命周期，也就是说单独销毁A类对象而不影响B对象。比如课程与学生之间的关系。\n\n```java\npublic class A {\n  private B b;\n  public A(B b){\n    this.b = b;\n  }\n}\n```\n\n**组合**\n\n也是一种包含关系。A类对象包含B类对象，B类对象的生命周期依赖A类对象的生命周期，B类对象不可单独存在，比如鸟与翅膀之间的关系。\n\n```java\npublic class A {\n  private B b;\n  publci A() {\n    this.b = new B();\n  }\n}\n```\n\n**关联**\n\n是一种非常弱的关系，包含聚合、组合两种关系。如果B类对象是A类的成员变量，那B类和A类就是关联关系。\n\n```java\npublic class A {\n  private B b;\n  //通过构造器注入B对象 或者在构造器中new B对象\n}\n```\n\n**依赖**\n\n是一种比关联关系更加弱的关系，包含关联关系。不管是B类对象是A类对象的成员变量，还是A类的方法实用B类对象作为参数或者返回值、局部变量，只要B类对象和A类对象有任何使用关系，就都是依赖关系。\n\n```java\npublic class A {\n  public void func(B b) {...}\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/设计原则与思想-面向对象.md","raw":"---\nlayout:    post\ntitle:     设计原则与思想-面向对象\ncategory:  设计模式之美\ndescription: 设计原则与思想之面向对象\ntags: 设计模式之美\ndate: 2020/10/22 14:25:10\n---\n\n## 设计模式之美\n\n**封装**\n\n封装也叫信息隐藏或数据访问保护。类通过暴露有限的访问接口，授权外部仅能通过类提供的方式来访问内部信息或者数据。\n\n如果将类的属性都暴露给调用者，调用者想要正确的操作这些属性，就需要对业务细节有足够的了解。而这对于调用者来说也是一种负担。相反如果我们把属性封装起来，暴露少许的几个必要的方法给调用者使用，调用者就不需要了解太多背后的业务细节，用错的概率就会减少很多。封装存在的意义，一方面为了保护数据不被随意修改，提高代码的可维护性，另一方面仅暴露有限的必要接口，提高类的易用性\n\n**抽象**\n\n抽象主要是隐藏方法的具体实现，让调用者只需要关心方法提供了哪些功能，并不需要知道这些功能如何实现。\n\n抽象可以通过接口类或者抽象类实现，但也并不需要特殊的语法机制来支持。抽象存在的意义，一方面是提高代码的可扩展性、维护性，修改实现不需要改变定义，减少代码的改动范围。是处理复杂系统的有效手段，能有效过滤掉不必要关注的信息。\n\n**继承**\n\n用来表示类之间 is-a 的关系，比如猫是一种哺乳动物。继承可以实现代码复用，比如两个类有相同的方法和属性。不过，过度使用继承，继承层次过深过复杂，就会导致代码可读性、可维护性变差。\n\n子类和父类高度耦合，修改父类的代码，会直接影响到子类。\n\n**多态**\n\n多态指子类可以替换父类，在实际的代码运行过程中，调用子类的方法实现。\n\n多态可以提高代码的可扩展性和复用性\n\n**面向对象的思考方式**\n\n思考如何给业务建模，如何将需求翻译为类，如何给类之间建立交互关系，而完成这些工作完全不需要考虑错综复杂的处理流程。当有了类的设计之后，然后再像搭积木一样，按照处理流程，将类组装起来形成整个程序。这种开发模式、思考问题的方式，能让我们在应对复杂程序开发的时候，思路更加清晰。\n\n**抽象类存在的意义**\n\n抽象类也是为代码复用而生的。可以优雅的实现多态。抽象类可以保证类不会被实例化，如果强行为了多态，父类创建了空的方法，那么会有误调用的风险。抽象类也可以强制子类重写需要的方法，否则就会编译错误。\n\n**接口存在的意义**\n\n接口存在的意义是为了解耦。接口实现了方法的定义和实现分离，可以降低代码的耦合性，提高代码的扩展性。\n\n**抽象类VS接口**\n\n如果要表示is-a的关系，并且是为了解决代码复用的问题，那就使用抽象类。如果要是表示一种has-a的关系，并且是为了解决抽象而非代码复用的问题，那就使用接口。\n\n从类的继承层次上看，抽象类是一种自下而上的设计思路，现有子类的代码重复，再抽象成上层的父类(抽象类)。接口是自上而下的设计思路，先设计接口，再去考虑具体的实现。\n\n**基于接口而非实现编程**\n\n应用这条原则，可以将接口与实现分离，封装不稳定的实现，暴露稳定的接口。上游系统面向接口而非实现编程，不依赖不稳定的实现细节，这样当实现发生变化的时候，上游系统代码基本上不需要改动，以此来降低耦合性，提高扩展性。越抽象，越顶层，越脱离具体某一实现的设计，越能提高代码的灵活性，越能应对未来的需求变化。好的代码设计，不仅能应对当下需求，而且在未来需求发生变化的时候，仍能够在不破坏原有代码设计的情况下灵活应对。\n\n**组合VS继承**\n\n鼓励多用组合少用继承，但是组合也并不是完美的，继承也并发一无是处。类之间的继承结构稳定（不会轻易改变），继承层次较浅，继承关系不复杂，就可以大胆的使用继承。系统不稳定，继承层次很深，继承关系复杂，就尽量使用组合来替代继承。\n\n如果不能修改一个函数的入参类型，而入参又非接口，为了支持多态，只能采用继承来实现。比如FeignClient类，要修改encode()函数，只能通过继承来实现。\n\n### 类之间交互关系\n\n**泛化**\n\n其实就是继承\n\n**实现**\n\n实现类实现接口\n\n**聚合**\n\n包含关系，A类对象包含B类对象，B类对象的生命周期可以不依赖A类对象的生命周期，也就是说单独销毁A类对象而不影响B对象。比如课程与学生之间的关系。\n\n```java\npublic class A {\n  private B b;\n  public A(B b){\n    this.b = b;\n  }\n}\n```\n\n**组合**\n\n也是一种包含关系。A类对象包含B类对象，B类对象的生命周期依赖A类对象的生命周期，B类对象不可单独存在，比如鸟与翅膀之间的关系。\n\n```java\npublic class A {\n  private B b;\n  publci A() {\n    this.b = new B();\n  }\n}\n```\n\n**关联**\n\n是一种非常弱的关系，包含聚合、组合两种关系。如果B类对象是A类的成员变量，那B类和A类就是关联关系。\n\n```java\npublic class A {\n  private B b;\n  //通过构造器注入B对象 或者在构造器中new B对象\n}\n```\n\n**依赖**\n\n是一种比关联关系更加弱的关系，包含关联关系。不管是B类对象是A类对象的成员变量，还是A类的方法实用B类对象作为参数或者返回值、局部变量，只要B类对象和A类对象有任何使用关系，就都是依赖关系。\n\n```java\npublic class A {\n  public void func(B b) {...}\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"设计原则与思想-面向对象","published":1,"updated":"2020-10-22T06:25:10.000Z","comments":1,"photos":[],"link":"","_id":"cm1m304xg001231b4disr86p9","content":"<h2 id=\"设计模式之美\"><a href=\"#设计模式之美\" class=\"headerlink\" title=\"设计模式之美\"></a>设计模式之美</h2><p><strong>封装</strong></p>\n<p>封装也叫信息隐藏或数据访问保护。类通过暴露有限的访问接口，授权外部仅能通过类提供的方式来访问内部信息或者数据。</p>\n<p>如果将类的属性都暴露给调用者，调用者想要正确的操作这些属性，就需要对业务细节有足够的了解。而这对于调用者来说也是一种负担。相反如果我们把属性封装起来，暴露少许的几个必要的方法给调用者使用，调用者就不需要了解太多背后的业务细节，用错的概率就会减少很多。封装存在的意义，一方面为了保护数据不被随意修改，提高代码的可维护性，另一方面仅暴露有限的必要接口，提高类的易用性</p>\n<p><strong>抽象</strong></p>\n<p>抽象主要是隐藏方法的具体实现，让调用者只需要关心方法提供了哪些功能，并不需要知道这些功能如何实现。</p>\n<p>抽象可以通过接口类或者抽象类实现，但也并不需要特殊的语法机制来支持。抽象存在的意义，一方面是提高代码的可扩展性、维护性，修改实现不需要改变定义，减少代码的改动范围。是处理复杂系统的有效手段，能有效过滤掉不必要关注的信息。</p>\n<p><strong>继承</strong></p>\n<p>用来表示类之间 is-a 的关系，比如猫是一种哺乳动物。继承可以实现代码复用，比如两个类有相同的方法和属性。不过，过度使用继承，继承层次过深过复杂，就会导致代码可读性、可维护性变差。</p>\n<p>子类和父类高度耦合，修改父类的代码，会直接影响到子类。</p>\n<p><strong>多态</strong></p>\n<p>多态指子类可以替换父类，在实际的代码运行过程中，调用子类的方法实现。</p>\n<p>多态可以提高代码的可扩展性和复用性</p>\n<p><strong>面向对象的思考方式</strong></p>\n<p>思考如何给业务建模，如何将需求翻译为类，如何给类之间建立交互关系，而完成这些工作完全不需要考虑错综复杂的处理流程。当有了类的设计之后，然后再像搭积木一样，按照处理流程，将类组装起来形成整个程序。这种开发模式、思考问题的方式，能让我们在应对复杂程序开发的时候，思路更加清晰。</p>\n<p><strong>抽象类存在的意义</strong></p>\n<p>抽象类也是为代码复用而生的。可以优雅的实现多态。抽象类可以保证类不会被实例化，如果强行为了多态，父类创建了空的方法，那么会有误调用的风险。抽象类也可以强制子类重写需要的方法，否则就会编译错误。</p>\n<p><strong>接口存在的意义</strong></p>\n<p>接口存在的意义是为了解耦。接口实现了方法的定义和实现分离，可以降低代码的耦合性，提高代码的扩展性。</p>\n<p><strong>抽象类VS接口</strong></p>\n<p>如果要表示is-a的关系，并且是为了解决代码复用的问题，那就使用抽象类。如果要是表示一种has-a的关系，并且是为了解决抽象而非代码复用的问题，那就使用接口。</p>\n<p>从类的继承层次上看，抽象类是一种自下而上的设计思路，现有子类的代码重复，再抽象成上层的父类(抽象类)。接口是自上而下的设计思路，先设计接口，再去考虑具体的实现。</p>\n<p><strong>基于接口而非实现编程</strong></p>\n<p>应用这条原则，可以将接口与实现分离，封装不稳定的实现，暴露稳定的接口。上游系统面向接口而非实现编程，不依赖不稳定的实现细节，这样当实现发生变化的时候，上游系统代码基本上不需要改动，以此来降低耦合性，提高扩展性。越抽象，越顶层，越脱离具体某一实现的设计，越能提高代码的灵活性，越能应对未来的需求变化。好的代码设计，不仅能应对当下需求，而且在未来需求发生变化的时候，仍能够在不破坏原有代码设计的情况下灵活应对。</p>\n<p><strong>组合VS继承</strong></p>\n<p>鼓励多用组合少用继承，但是组合也并不是完美的，继承也并发一无是处。类之间的继承结构稳定（不会轻易改变），继承层次较浅，继承关系不复杂，就可以大胆的使用继承。系统不稳定，继承层次很深，继承关系复杂，就尽量使用组合来替代继承。</p>\n<p>如果不能修改一个函数的入参类型，而入参又非接口，为了支持多态，只能采用继承来实现。比如FeignClient类，要修改encode()函数，只能通过继承来实现。</p>\n<h3 id=\"类之间交互关系\"><a href=\"#类之间交互关系\" class=\"headerlink\" title=\"类之间交互关系\"></a>类之间交互关系</h3><p><strong>泛化</strong></p>\n<p>其实就是继承</p>\n<p><strong>实现</strong></p>\n<p>实现类实现接口</p>\n<p><strong>聚合</strong></p>\n<p>包含关系，A类对象包含B类对象，B类对象的生命周期可以不依赖A类对象的生命周期，也就是说单独销毁A类对象而不影响B对象。比如课程与学生之间的关系。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> B b;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">A</span><span class=\"params\">(B b)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.b = b;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>组合</strong></p>\n<p>也是一种包含关系。A类对象包含B类对象，B类对象的生命周期依赖A类对象的生命周期，B类对象不可单独存在，比如鸟与翅膀之间的关系。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> B b;</span><br><span class=\"line\">  <span class=\"function\">publci <span class=\"title\">A</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.b = <span class=\"keyword\">new</span> B();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>关联</strong></p>\n<p>是一种非常弱的关系，包含聚合、组合两种关系。如果B类对象是A类的成员变量，那B类和A类就是关联关系。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> B b;</span><br><span class=\"line\">  <span class=\"comment\">//通过构造器注入B对象 或者在构造器中new B对象</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>依赖</strong></p>\n<p>是一种比关联关系更加弱的关系，包含关联关系。不管是B类对象是A类对象的成员变量，还是A类的方法实用B类对象作为参数或者返回值、局部变量，只要B类对象和A类对象有任何使用关系，就都是依赖关系。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">(B b)</span> </span>&#123;...&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"设计模式之美\"><a href=\"#设计模式之美\" class=\"headerlink\" title=\"设计模式之美\"></a>设计模式之美</h2><p><strong>封装</strong></p>\n<p>封装也叫信息隐藏或数据访问保护。类通过暴露有限的访问接口，授权外部仅能通过类提供的方式来访问内部信息或者数据。</p>\n<p>如果将类的属性都暴露给调用者，调用者想要正确的操作这些属性，就需要对业务细节有足够的了解。而这对于调用者来说也是一种负担。相反如果我们把属性封装起来，暴露少许的几个必要的方法给调用者使用，调用者就不需要了解太多背后的业务细节，用错的概率就会减少很多。封装存在的意义，一方面为了保护数据不被随意修改，提高代码的可维护性，另一方面仅暴露有限的必要接口，提高类的易用性</p>\n<p><strong>抽象</strong></p>\n<p>抽象主要是隐藏方法的具体实现，让调用者只需要关心方法提供了哪些功能，并不需要知道这些功能如何实现。</p>\n<p>抽象可以通过接口类或者抽象类实现，但也并不需要特殊的语法机制来支持。抽象存在的意义，一方面是提高代码的可扩展性、维护性，修改实现不需要改变定义，减少代码的改动范围。是处理复杂系统的有效手段，能有效过滤掉不必要关注的信息。</p>\n<p><strong>继承</strong></p>\n<p>用来表示类之间 is-a 的关系，比如猫是一种哺乳动物。继承可以实现代码复用，比如两个类有相同的方法和属性。不过，过度使用继承，继承层次过深过复杂，就会导致代码可读性、可维护性变差。</p>\n<p>子类和父类高度耦合，修改父类的代码，会直接影响到子类。</p>\n<p><strong>多态</strong></p>\n<p>多态指子类可以替换父类，在实际的代码运行过程中，调用子类的方法实现。</p>\n<p>多态可以提高代码的可扩展性和复用性</p>\n<p><strong>面向对象的思考方式</strong></p>\n<p>思考如何给业务建模，如何将需求翻译为类，如何给类之间建立交互关系，而完成这些工作完全不需要考虑错综复杂的处理流程。当有了类的设计之后，然后再像搭积木一样，按照处理流程，将类组装起来形成整个程序。这种开发模式、思考问题的方式，能让我们在应对复杂程序开发的时候，思路更加清晰。</p>\n<p><strong>抽象类存在的意义</strong></p>\n<p>抽象类也是为代码复用而生的。可以优雅的实现多态。抽象类可以保证类不会被实例化，如果强行为了多态，父类创建了空的方法，那么会有误调用的风险。抽象类也可以强制子类重写需要的方法，否则就会编译错误。</p>\n<p><strong>接口存在的意义</strong></p>\n<p>接口存在的意义是为了解耦。接口实现了方法的定义和实现分离，可以降低代码的耦合性，提高代码的扩展性。</p>\n<p><strong>抽象类VS接口</strong></p>\n<p>如果要表示is-a的关系，并且是为了解决代码复用的问题，那就使用抽象类。如果要是表示一种has-a的关系，并且是为了解决抽象而非代码复用的问题，那就使用接口。</p>\n<p>从类的继承层次上看，抽象类是一种自下而上的设计思路，现有子类的代码重复，再抽象成上层的父类(抽象类)。接口是自上而下的设计思路，先设计接口，再去考虑具体的实现。</p>\n<p><strong>基于接口而非实现编程</strong></p>\n<p>应用这条原则，可以将接口与实现分离，封装不稳定的实现，暴露稳定的接口。上游系统面向接口而非实现编程，不依赖不稳定的实现细节，这样当实现发生变化的时候，上游系统代码基本上不需要改动，以此来降低耦合性，提高扩展性。越抽象，越顶层，越脱离具体某一实现的设计，越能提高代码的灵活性，越能应对未来的需求变化。好的代码设计，不仅能应对当下需求，而且在未来需求发生变化的时候，仍能够在不破坏原有代码设计的情况下灵活应对。</p>\n<p><strong>组合VS继承</strong></p>\n<p>鼓励多用组合少用继承，但是组合也并不是完美的，继承也并发一无是处。类之间的继承结构稳定（不会轻易改变），继承层次较浅，继承关系不复杂，就可以大胆的使用继承。系统不稳定，继承层次很深，继承关系复杂，就尽量使用组合来替代继承。</p>\n<p>如果不能修改一个函数的入参类型，而入参又非接口，为了支持多态，只能采用继承来实现。比如FeignClient类，要修改encode()函数，只能通过继承来实现。</p>\n<h3 id=\"类之间交互关系\"><a href=\"#类之间交互关系\" class=\"headerlink\" title=\"类之间交互关系\"></a>类之间交互关系</h3><p><strong>泛化</strong></p>\n<p>其实就是继承</p>\n<p><strong>实现</strong></p>\n<p>实现类实现接口</p>\n<p><strong>聚合</strong></p>\n<p>包含关系，A类对象包含B类对象，B类对象的生命周期可以不依赖A类对象的生命周期，也就是说单独销毁A类对象而不影响B对象。比如课程与学生之间的关系。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> B b;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">A</span><span class=\"params\">(B b)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.b = b;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>组合</strong></p>\n<p>也是一种包含关系。A类对象包含B类对象，B类对象的生命周期依赖A类对象的生命周期，B类对象不可单独存在，比如鸟与翅膀之间的关系。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> B b;</span><br><span class=\"line\">  <span class=\"function\">publci <span class=\"title\">A</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.b = <span class=\"keyword\">new</span> B();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>关联</strong></p>\n<p>是一种非常弱的关系，包含聚合、组合两种关系。如果B类对象是A类的成员变量，那B类和A类就是关联关系。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> B b;</span><br><span class=\"line\">  <span class=\"comment\">//通过构造器注入B对象 或者在构造器中new B对象</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>依赖</strong></p>\n<p>是一种比关联关系更加弱的关系，包含关联关系。不管是B类对象是A类对象的成员变量，还是A类的方法实用B类对象作为参数或者返回值、局部变量，只要B类对象和A类对象有任何使用关系，就都是依赖关系。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">(B b)</span> </span>&#123;...&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"layout":"post","title":"设计模式之中介模式","description":"设计模式之中介模式","date":"2021-06-29T03:15:10.000Z","_content":"中介模式的英文翻译是Mediator Design Pattern。在GoF的《设计模式》中，是这样定义的：\n\n> Mediator pattern defines a separate (mediator) object that encapsulates the interaction between a set of objects and the objects delegate their interaction to a mediator object instead of interacting with each other directly.\n\n翻译成中文就是：中介模式定义了一个单独的（中介）对象，来封装一组对象直接的交互。将这组对象之间的交互委派给中介对象交互，来避免对象之间的直接交互。\n\n还记得如何给代码解耦吗？其中一个方法就是引入中间层。\n\n中介模式的设计思想根中间层很像，通过引入中介这个中间层，将一组对象之间的交互关系（或者说依赖关系）从多对多（网状关系）转换为一对多（星状关系）。原来一个对象要和n个对象交互，现在只需要跟一个中介对象交互，从而最小化对象之间的交互关系，降低了代码的复杂度，提高了代码的可读性和可维护性。\n\n<img src=\"https://static001.geekbang.org/resource/image/43/9f/4376d541bf17a029f37aa76009ef3a9f.jpg\" alt=\"img\" style=\"zoom:30%;\" />\n\n提到中介模式，有个经典的例子，就是航空管制。\n\n为了让飞机在飞行的时候互不干扰，每架飞机都需要知道其他飞机每时每刻的位置，这就需要时刻跟其他飞机通信。飞机通信形成的通信网络就会无比复杂。这个时候，我们通过引入“塔台”这样一个中介，让每架飞机只跟塔台来通信，发送自己的位置给塔台，由塔台来复杂每架飞机的航线调度。这样就大大简化了通信网络。\n\n假设有一个比较复杂的对话框，对话框中有很多控件，比如按钮、文本框、下拉框等。当我们对某个控件进行操作的时候，其他控件就会做出相应的反应，比如，我们在下拉框中选择“注册”，注册相关的控件就会显示在对话框中。如果我们在下拉框中选择“登陆”，登陆相关的控件就会显示在对话框中。\n\n按照通常我们习惯的UI界面的开发方式，我们将刚刚的需求用代码实现出来，就是下面这样。在这种实现中，控件和控件之间互相操作、互相依赖。\n\n```java\npublic class UIControl {\n  private static final String LOGIN_BTN_ID = \"login_btn\";\n  private static final String REG_BTN_ID = \"reg_btn\";\n  private static final String USERNAME_INPUT_ID = \"username_input\";\n  private static final String PASSWORD_INPUT_ID = \"pswd_input\";\n  private static final String REPEATED_PASSWORD_INPUT_ID = \"repeated_pswd_input\";\n  private static final String HINT_TEXT_ID = \"hint_text\";\n  private static final String SELECTION_ID = \"selection\";\n\n  public static void main(String[] args) {\n    Button loginButton = (Button)findViewById(LOGIN_BTN_ID);\n    Button regButton = (Button)findViewById(REG_BTN_ID);\n    Input usernameInput = (Input)findViewById(USERNAME_INPUT_ID);\n    Input passwordInput = (Input)findViewById(PASSWORD_INPUT_ID);\n    Input repeatedPswdInput = (Input)findViewById(REPEATED_PASSWORD_INPUT_ID);\n    Text hintText = (Text)findViewById(HINT_TEXT_ID);\n    Selection selection = (Selection)findViewById(SELECTION_ID);\n\n    loginButton.setOnClickListener(new OnClickListener() {\n      @Override\n      public void onClick(View v) {\n        String username = usernameInput.text();\n        String password = passwordInput.text();\n        //校验数据...\n        //做业务处理...\n      }\n    });\n\n    regButton.setOnClickListener(new OnClickListener() {\n      @Override\n      public void onClick(View v) {\n      //获取usernameInput、passwordInput、repeatedPswdInput数据...\n      //校验数据...\n      //做业务处理...\n      }\n    });\n\n    //...省略selection下拉选择框相关代码....\n  }\n}\n```\n\n再按照中介模式，将上面的代码重新实现一下。在新的代码中，各个空间只跟中介对象交互，中介对象负责所有业务逻辑的处理。\n\n```java\npublic interface Mediator {\n  void handleEvent(Component component, String event);\n}\n\npublic class LandingPageDialog implements Mediator {\n  private Button loginButton;\n  private Button regButton;\n  private Selection selection;\n  private Input usernameInput;\n  private Input passwordInput;\n  private Input repeatedPswdInput;\n  private Text hintText;\n\n  @Override\n  public void handleEvent(Component component, String event) {\n    if (component.equals(loginButton)) {\n      String username = usernameInput.text();\n      String password = passwordInput.text();\n      //校验数据...\n      //做业务处理...\n    } else if (component.equals(regButton)) {\n      //获取usernameInput、passwordInput、repeatedPswdInput数据...\n      //校验数据...\n      //做业务处理...\n    } else if (component.equals(selection)) {\n      String selectedItem = selection.select();\n      if (selectedItem.equals(\"login\")) {\n        usernameInput.show();\n        passwordInput.show();\n        repeatedPswdInput.hide();\n        hintText.hide();\n        //...省略其他代码\n      } else if (selectedItem.equals(\"register\")) {\n        //....\n      }\n    }\n  }\n}\n\npublic class UIControl {\n  private static final String LOGIN_BTN_ID = \"login_btn\";\n  private static final String REG_BTN_ID = \"reg_btn\";\n  private static final String USERNAME_INPUT_ID = \"username_input\";\n  private static final String PASSWORD_INPUT_ID = \"pswd_input\";\n  private static final String REPEATED_PASSWORD_INPUT_ID = \"repeated_pswd_input\";\n  private static final String HINT_TEXT_ID = \"hint_text\";\n  private static final String SELECTION_ID = \"selection\";\n\n  public static void main(String[] args) {\n    Button loginButton = (Button)findViewById(LOGIN_BTN_ID);\n    Button regButton = (Button)findViewById(REG_BTN_ID);\n    Input usernameInput = (Input)findViewById(USERNAME_INPUT_ID);\n    Input passwordInput = (Input)findViewById(PASSWORD_INPUT_ID);\n    Input repeatedPswdInput = (Input)findViewById(REPEATED_PASSWORD_INPUT_ID);\n    Text hintText = (Text)findViewById(HINT_TEXT_ID);\n    Selection selection = (Selection)findViewById(SELECTION_ID);\n\n    Mediator dialog = new LandingPageDialog();\n    dialog.setLoginButton(loginButton);\n    dialog.setRegButton(regButton);\n    dialog.setUsernameInput(usernameInput);\n    dialog.setPasswordInput(passwordInput);\n    dialog.setRepeatedPswdInput(repeatedPswdInput);\n    dialog.setHintText(hintText);\n    dialog.setSelection(selection);\n\n    loginButton.setOnClickListener(new OnClickListener() {\n      @Override\n      public void onClick(View v) {\n        dialog.handleEvent(loginButton, \"click\");\n      }\n    });\n\n    regButton.setOnClickListener(new OnClickListener() {\n      @Override\n      public void onClick(View v) {\n        dialog.handleEvent(regButton, \"click\");\n      }\n    });\n\n    //....\n  }\n}\n```\n\n原本业务逻辑分散到各个控件中，现在都集中到了中介类中。这样做有好处也有坏处，好处是简化了控件之间的交互，坏处是中介类可能变成大而复杂的上帝类（God Class）。所以，在使用中介模式的时候，要根据实际情况，平衡对象之间交互的复杂度和中介类本身的复杂度。其实就是要看取舍，我觉得还可以把中介类做一个中间层，别的处理方式拆分成功能单一的小类也可以。只不过中介类用来做统一的调度处理，就类似于塔台，塔台中也会有多个工作人员去协调调度飞机。\n\n##### 中介模式VS观察者模式\n\n观察者模式有多种实现方式。虽然经典的实现方式没法彻底解耦观察者和被观察者，观察者需要注册到被观察者中，被观察者状态更新需要调用观察者的update()方法。但是，在跨进程的实现方式中，我们可以利用消息队列实现彻底解耦，观察者和被观察者都只需要跟消息队列交互，观察者完全不知道被观察者的存在，被观察者也完全不知道观察者的存在。\n\n中介模式也是为了解耦对象之间的交互，所有的参与者都只与中介进行交互。而观察者模式中的消息队列，就有点类似中介模式中的“中介”，观察者模式中的观察者和被观察者，就有点类似中介模式中的“参与者”。问题来了：中介模式和观察者模式的区别在哪里呢？什么时候选择使用中介模式？什么时候选择使用观察者模式呢？\n\n在观察者模式中，尽管一个参与者既可以是观察者，同时也可以是被观察者，但是，大部分情况下，交互关系往往都是单向的，一个参与者要么是观察者，要么是被观察者，不会兼具两种身份。也就是说，观察者模式的应用场景中，参与者之间的交互关系比较有条理。\n\n中介模式正好相反。只有当参与者之间的交互关系错综复杂，维护成本很高的时候，我们才考虑使用中介模式。毕竟，中介模式的应用会带来一定的副作用，前面也将到，它有可能会产生大而复杂的上帝类。除此之外，如果一个参与者状态的改变，其他参与者执行的操作有一定先后顺序的要求，这个时候，中介模式就可以利用中介类，通过先后调用不同参与者的方法，来实现顺序的控制，而观察者模式是无法实现这样的顺序要求的。\n\n","source":"_posts/设计模式之中介模式.md","raw":"---\nlayout:    post\ntitle:     设计模式之中介模式\ncategory:  设计模式之美\ndescription: 设计模式之中介模式\ntags: 设计模式之美\ndate: 2021/06/29 11:15:10\n---\n中介模式的英文翻译是Mediator Design Pattern。在GoF的《设计模式》中，是这样定义的：\n\n> Mediator pattern defines a separate (mediator) object that encapsulates the interaction between a set of objects and the objects delegate their interaction to a mediator object instead of interacting with each other directly.\n\n翻译成中文就是：中介模式定义了一个单独的（中介）对象，来封装一组对象直接的交互。将这组对象之间的交互委派给中介对象交互，来避免对象之间的直接交互。\n\n还记得如何给代码解耦吗？其中一个方法就是引入中间层。\n\n中介模式的设计思想根中间层很像，通过引入中介这个中间层，将一组对象之间的交互关系（或者说依赖关系）从多对多（网状关系）转换为一对多（星状关系）。原来一个对象要和n个对象交互，现在只需要跟一个中介对象交互，从而最小化对象之间的交互关系，降低了代码的复杂度，提高了代码的可读性和可维护性。\n\n<img src=\"https://static001.geekbang.org/resource/image/43/9f/4376d541bf17a029f37aa76009ef3a9f.jpg\" alt=\"img\" style=\"zoom:30%;\" />\n\n提到中介模式，有个经典的例子，就是航空管制。\n\n为了让飞机在飞行的时候互不干扰，每架飞机都需要知道其他飞机每时每刻的位置，这就需要时刻跟其他飞机通信。飞机通信形成的通信网络就会无比复杂。这个时候，我们通过引入“塔台”这样一个中介，让每架飞机只跟塔台来通信，发送自己的位置给塔台，由塔台来复杂每架飞机的航线调度。这样就大大简化了通信网络。\n\n假设有一个比较复杂的对话框，对话框中有很多控件，比如按钮、文本框、下拉框等。当我们对某个控件进行操作的时候，其他控件就会做出相应的反应，比如，我们在下拉框中选择“注册”，注册相关的控件就会显示在对话框中。如果我们在下拉框中选择“登陆”，登陆相关的控件就会显示在对话框中。\n\n按照通常我们习惯的UI界面的开发方式，我们将刚刚的需求用代码实现出来，就是下面这样。在这种实现中，控件和控件之间互相操作、互相依赖。\n\n```java\npublic class UIControl {\n  private static final String LOGIN_BTN_ID = \"login_btn\";\n  private static final String REG_BTN_ID = \"reg_btn\";\n  private static final String USERNAME_INPUT_ID = \"username_input\";\n  private static final String PASSWORD_INPUT_ID = \"pswd_input\";\n  private static final String REPEATED_PASSWORD_INPUT_ID = \"repeated_pswd_input\";\n  private static final String HINT_TEXT_ID = \"hint_text\";\n  private static final String SELECTION_ID = \"selection\";\n\n  public static void main(String[] args) {\n    Button loginButton = (Button)findViewById(LOGIN_BTN_ID);\n    Button regButton = (Button)findViewById(REG_BTN_ID);\n    Input usernameInput = (Input)findViewById(USERNAME_INPUT_ID);\n    Input passwordInput = (Input)findViewById(PASSWORD_INPUT_ID);\n    Input repeatedPswdInput = (Input)findViewById(REPEATED_PASSWORD_INPUT_ID);\n    Text hintText = (Text)findViewById(HINT_TEXT_ID);\n    Selection selection = (Selection)findViewById(SELECTION_ID);\n\n    loginButton.setOnClickListener(new OnClickListener() {\n      @Override\n      public void onClick(View v) {\n        String username = usernameInput.text();\n        String password = passwordInput.text();\n        //校验数据...\n        //做业务处理...\n      }\n    });\n\n    regButton.setOnClickListener(new OnClickListener() {\n      @Override\n      public void onClick(View v) {\n      //获取usernameInput、passwordInput、repeatedPswdInput数据...\n      //校验数据...\n      //做业务处理...\n      }\n    });\n\n    //...省略selection下拉选择框相关代码....\n  }\n}\n```\n\n再按照中介模式，将上面的代码重新实现一下。在新的代码中，各个空间只跟中介对象交互，中介对象负责所有业务逻辑的处理。\n\n```java\npublic interface Mediator {\n  void handleEvent(Component component, String event);\n}\n\npublic class LandingPageDialog implements Mediator {\n  private Button loginButton;\n  private Button regButton;\n  private Selection selection;\n  private Input usernameInput;\n  private Input passwordInput;\n  private Input repeatedPswdInput;\n  private Text hintText;\n\n  @Override\n  public void handleEvent(Component component, String event) {\n    if (component.equals(loginButton)) {\n      String username = usernameInput.text();\n      String password = passwordInput.text();\n      //校验数据...\n      //做业务处理...\n    } else if (component.equals(regButton)) {\n      //获取usernameInput、passwordInput、repeatedPswdInput数据...\n      //校验数据...\n      //做业务处理...\n    } else if (component.equals(selection)) {\n      String selectedItem = selection.select();\n      if (selectedItem.equals(\"login\")) {\n        usernameInput.show();\n        passwordInput.show();\n        repeatedPswdInput.hide();\n        hintText.hide();\n        //...省略其他代码\n      } else if (selectedItem.equals(\"register\")) {\n        //....\n      }\n    }\n  }\n}\n\npublic class UIControl {\n  private static final String LOGIN_BTN_ID = \"login_btn\";\n  private static final String REG_BTN_ID = \"reg_btn\";\n  private static final String USERNAME_INPUT_ID = \"username_input\";\n  private static final String PASSWORD_INPUT_ID = \"pswd_input\";\n  private static final String REPEATED_PASSWORD_INPUT_ID = \"repeated_pswd_input\";\n  private static final String HINT_TEXT_ID = \"hint_text\";\n  private static final String SELECTION_ID = \"selection\";\n\n  public static void main(String[] args) {\n    Button loginButton = (Button)findViewById(LOGIN_BTN_ID);\n    Button regButton = (Button)findViewById(REG_BTN_ID);\n    Input usernameInput = (Input)findViewById(USERNAME_INPUT_ID);\n    Input passwordInput = (Input)findViewById(PASSWORD_INPUT_ID);\n    Input repeatedPswdInput = (Input)findViewById(REPEATED_PASSWORD_INPUT_ID);\n    Text hintText = (Text)findViewById(HINT_TEXT_ID);\n    Selection selection = (Selection)findViewById(SELECTION_ID);\n\n    Mediator dialog = new LandingPageDialog();\n    dialog.setLoginButton(loginButton);\n    dialog.setRegButton(regButton);\n    dialog.setUsernameInput(usernameInput);\n    dialog.setPasswordInput(passwordInput);\n    dialog.setRepeatedPswdInput(repeatedPswdInput);\n    dialog.setHintText(hintText);\n    dialog.setSelection(selection);\n\n    loginButton.setOnClickListener(new OnClickListener() {\n      @Override\n      public void onClick(View v) {\n        dialog.handleEvent(loginButton, \"click\");\n      }\n    });\n\n    regButton.setOnClickListener(new OnClickListener() {\n      @Override\n      public void onClick(View v) {\n        dialog.handleEvent(regButton, \"click\");\n      }\n    });\n\n    //....\n  }\n}\n```\n\n原本业务逻辑分散到各个控件中，现在都集中到了中介类中。这样做有好处也有坏处，好处是简化了控件之间的交互，坏处是中介类可能变成大而复杂的上帝类（God Class）。所以，在使用中介模式的时候，要根据实际情况，平衡对象之间交互的复杂度和中介类本身的复杂度。其实就是要看取舍，我觉得还可以把中介类做一个中间层，别的处理方式拆分成功能单一的小类也可以。只不过中介类用来做统一的调度处理，就类似于塔台，塔台中也会有多个工作人员去协调调度飞机。\n\n##### 中介模式VS观察者模式\n\n观察者模式有多种实现方式。虽然经典的实现方式没法彻底解耦观察者和被观察者，观察者需要注册到被观察者中，被观察者状态更新需要调用观察者的update()方法。但是，在跨进程的实现方式中，我们可以利用消息队列实现彻底解耦，观察者和被观察者都只需要跟消息队列交互，观察者完全不知道被观察者的存在，被观察者也完全不知道观察者的存在。\n\n中介模式也是为了解耦对象之间的交互，所有的参与者都只与中介进行交互。而观察者模式中的消息队列，就有点类似中介模式中的“中介”，观察者模式中的观察者和被观察者，就有点类似中介模式中的“参与者”。问题来了：中介模式和观察者模式的区别在哪里呢？什么时候选择使用中介模式？什么时候选择使用观察者模式呢？\n\n在观察者模式中，尽管一个参与者既可以是观察者，同时也可以是被观察者，但是，大部分情况下，交互关系往往都是单向的，一个参与者要么是观察者，要么是被观察者，不会兼具两种身份。也就是说，观察者模式的应用场景中，参与者之间的交互关系比较有条理。\n\n中介模式正好相反。只有当参与者之间的交互关系错综复杂，维护成本很高的时候，我们才考虑使用中介模式。毕竟，中介模式的应用会带来一定的副作用，前面也将到，它有可能会产生大而复杂的上帝类。除此之外，如果一个参与者状态的改变，其他参与者执行的操作有一定先后顺序的要求，这个时候，中介模式就可以利用中介类，通过先后调用不同参与者的方法，来实现顺序的控制，而观察者模式是无法实现这样的顺序要求的。\n\n","slug":"设计模式之中介模式","published":1,"updated":"2021-06-29T03:15:10.000Z","comments":1,"photos":[],"link":"","_id":"cm1m304xh001431b43ncne0zc","content":"<p>中介模式的英文翻译是Mediator Design Pattern。在GoF的《设计模式》中，是这样定义的：</p>\n<blockquote>\n<p>Mediator pattern defines a separate (mediator) object that encapsulates the interaction between a set of objects and the objects delegate their interaction to a mediator object instead of interacting with each other directly.</p>\n</blockquote>\n<p>翻译成中文就是：中介模式定义了一个单独的（中介）对象，来封装一组对象直接的交互。将这组对象之间的交互委派给中介对象交互，来避免对象之间的直接交互。</p>\n<p>还记得如何给代码解耦吗？其中一个方法就是引入中间层。</p>\n<p>中介模式的设计思想根中间层很像，通过引入中介这个中间层，将一组对象之间的交互关系（或者说依赖关系）从多对多（网状关系）转换为一对多（星状关系）。原来一个对象要和n个对象交互，现在只需要跟一个中介对象交互，从而最小化对象之间的交互关系，降低了代码的复杂度，提高了代码的可读性和可维护性。</p>\n<img src=\"https://static001.geekbang.org/resource/image/43/9f/4376d541bf17a029f37aa76009ef3a9f.jpg\" alt=\"img\" style=\"zoom:30%;\" />\n\n<p>提到中介模式，有个经典的例子，就是航空管制。</p>\n<p>为了让飞机在飞行的时候互不干扰，每架飞机都需要知道其他飞机每时每刻的位置，这就需要时刻跟其他飞机通信。飞机通信形成的通信网络就会无比复杂。这个时候，我们通过引入“塔台”这样一个中介，让每架飞机只跟塔台来通信，发送自己的位置给塔台，由塔台来复杂每架飞机的航线调度。这样就大大简化了通信网络。</p>\n<p>假设有一个比较复杂的对话框，对话框中有很多控件，比如按钮、文本框、下拉框等。当我们对某个控件进行操作的时候，其他控件就会做出相应的反应，比如，我们在下拉框中选择“注册”，注册相关的控件就会显示在对话框中。如果我们在下拉框中选择“登陆”，登陆相关的控件就会显示在对话框中。</p>\n<p>按照通常我们习惯的UI界面的开发方式，我们将刚刚的需求用代码实现出来，就是下面这样。在这种实现中，控件和控件之间互相操作、互相依赖。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UIControl</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String LOGIN_BTN_ID = <span class=\"string\">&quot;login_btn&quot;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String REG_BTN_ID = <span class=\"string\">&quot;reg_btn&quot;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String USERNAME_INPUT_ID = <span class=\"string\">&quot;username_input&quot;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String PASSWORD_INPUT_ID = <span class=\"string\">&quot;pswd_input&quot;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String REPEATED_PASSWORD_INPUT_ID = <span class=\"string\">&quot;repeated_pswd_input&quot;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String HINT_TEXT_ID = <span class=\"string\">&quot;hint_text&quot;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String SELECTION_ID = <span class=\"string\">&quot;selection&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    Button loginButton = (Button)findViewById(LOGIN_BTN_ID);</span><br><span class=\"line\">    Button regButton = (Button)findViewById(REG_BTN_ID);</span><br><span class=\"line\">    Input usernameInput = (Input)findViewById(USERNAME_INPUT_ID);</span><br><span class=\"line\">    Input passwordInput = (Input)findViewById(PASSWORD_INPUT_ID);</span><br><span class=\"line\">    Input repeatedPswdInput = (Input)findViewById(REPEATED_PASSWORD_INPUT_ID);</span><br><span class=\"line\">    Text hintText = (Text)findViewById(HINT_TEXT_ID);</span><br><span class=\"line\">    Selection selection = (Selection)findViewById(SELECTION_ID);</span><br><span class=\"line\"></span><br><span class=\"line\">    loginButton.setOnClickListener(<span class=\"keyword\">new</span> OnClickListener() &#123;</span><br><span class=\"line\">      <span class=\"meta\">@Override</span></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onClick</span><span class=\"params\">(View v)</span> </span>&#123;</span><br><span class=\"line\">        String username = usernameInput.text();</span><br><span class=\"line\">        String password = passwordInput.text();</span><br><span class=\"line\">        <span class=\"comment\">//校验数据...</span></span><br><span class=\"line\">        <span class=\"comment\">//做业务处理...</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    regButton.setOnClickListener(<span class=\"keyword\">new</span> OnClickListener() &#123;</span><br><span class=\"line\">      <span class=\"meta\">@Override</span></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onClick</span><span class=\"params\">(View v)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">//获取usernameInput、passwordInput、repeatedPswdInput数据...</span></span><br><span class=\"line\">      <span class=\"comment\">//校验数据...</span></span><br><span class=\"line\">      <span class=\"comment\">//做业务处理...</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//...省略selection下拉选择框相关代码....</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>再按照中介模式，将上面的代码重新实现一下。在新的代码中，各个空间只跟中介对象交互，中介对象负责所有业务逻辑的处理。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Mediator</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">handleEvent</span><span class=\"params\">(Component component, String event)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LandingPageDialog</span> <span class=\"keyword\">implements</span> <span class=\"title\">Mediator</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Button loginButton;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Button regButton;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Selection selection;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Input usernameInput;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Input passwordInput;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Input repeatedPswdInput;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Text hintText;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleEvent</span><span class=\"params\">(Component component, String event)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (component.equals(loginButton)) &#123;</span><br><span class=\"line\">      String username = usernameInput.text();</span><br><span class=\"line\">      String password = passwordInput.text();</span><br><span class=\"line\">      <span class=\"comment\">//校验数据...</span></span><br><span class=\"line\">      <span class=\"comment\">//做业务处理...</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (component.equals(regButton)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//获取usernameInput、passwordInput、repeatedPswdInput数据...</span></span><br><span class=\"line\">      <span class=\"comment\">//校验数据...</span></span><br><span class=\"line\">      <span class=\"comment\">//做业务处理...</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (component.equals(selection)) &#123;</span><br><span class=\"line\">      String selectedItem = selection.select();</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (selectedItem.equals(<span class=\"string\">&quot;login&quot;</span>)) &#123;</span><br><span class=\"line\">        usernameInput.show();</span><br><span class=\"line\">        passwordInput.show();</span><br><span class=\"line\">        repeatedPswdInput.hide();</span><br><span class=\"line\">        hintText.hide();</span><br><span class=\"line\">        <span class=\"comment\">//...省略其他代码</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (selectedItem.equals(<span class=\"string\">&quot;register&quot;</span>)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//....</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UIControl</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String LOGIN_BTN_ID = <span class=\"string\">&quot;login_btn&quot;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String REG_BTN_ID = <span class=\"string\">&quot;reg_btn&quot;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String USERNAME_INPUT_ID = <span class=\"string\">&quot;username_input&quot;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String PASSWORD_INPUT_ID = <span class=\"string\">&quot;pswd_input&quot;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String REPEATED_PASSWORD_INPUT_ID = <span class=\"string\">&quot;repeated_pswd_input&quot;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String HINT_TEXT_ID = <span class=\"string\">&quot;hint_text&quot;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String SELECTION_ID = <span class=\"string\">&quot;selection&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    Button loginButton = (Button)findViewById(LOGIN_BTN_ID);</span><br><span class=\"line\">    Button regButton = (Button)findViewById(REG_BTN_ID);</span><br><span class=\"line\">    Input usernameInput = (Input)findViewById(USERNAME_INPUT_ID);</span><br><span class=\"line\">    Input passwordInput = (Input)findViewById(PASSWORD_INPUT_ID);</span><br><span class=\"line\">    Input repeatedPswdInput = (Input)findViewById(REPEATED_PASSWORD_INPUT_ID);</span><br><span class=\"line\">    Text hintText = (Text)findViewById(HINT_TEXT_ID);</span><br><span class=\"line\">    Selection selection = (Selection)findViewById(SELECTION_ID);</span><br><span class=\"line\"></span><br><span class=\"line\">    Mediator dialog = <span class=\"keyword\">new</span> LandingPageDialog();</span><br><span class=\"line\">    dialog.setLoginButton(loginButton);</span><br><span class=\"line\">    dialog.setRegButton(regButton);</span><br><span class=\"line\">    dialog.setUsernameInput(usernameInput);</span><br><span class=\"line\">    dialog.setPasswordInput(passwordInput);</span><br><span class=\"line\">    dialog.setRepeatedPswdInput(repeatedPswdInput);</span><br><span class=\"line\">    dialog.setHintText(hintText);</span><br><span class=\"line\">    dialog.setSelection(selection);</span><br><span class=\"line\"></span><br><span class=\"line\">    loginButton.setOnClickListener(<span class=\"keyword\">new</span> OnClickListener() &#123;</span><br><span class=\"line\">      <span class=\"meta\">@Override</span></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onClick</span><span class=\"params\">(View v)</span> </span>&#123;</span><br><span class=\"line\">        dialog.handleEvent(loginButton, <span class=\"string\">&quot;click&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    regButton.setOnClickListener(<span class=\"keyword\">new</span> OnClickListener() &#123;</span><br><span class=\"line\">      <span class=\"meta\">@Override</span></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onClick</span><span class=\"params\">(View v)</span> </span>&#123;</span><br><span class=\"line\">        dialog.handleEvent(regButton, <span class=\"string\">&quot;click&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//....</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>原本业务逻辑分散到各个控件中，现在都集中到了中介类中。这样做有好处也有坏处，好处是简化了控件之间的交互，坏处是中介类可能变成大而复杂的上帝类（God Class）。所以，在使用中介模式的时候，要根据实际情况，平衡对象之间交互的复杂度和中介类本身的复杂度。其实就是要看取舍，我觉得还可以把中介类做一个中间层，别的处理方式拆分成功能单一的小类也可以。只不过中介类用来做统一的调度处理，就类似于塔台，塔台中也会有多个工作人员去协调调度飞机。</p>\n<h5 id=\"中介模式VS观察者模式\"><a href=\"#中介模式VS观察者模式\" class=\"headerlink\" title=\"中介模式VS观察者模式\"></a>中介模式VS观察者模式</h5><p>观察者模式有多种实现方式。虽然经典的实现方式没法彻底解耦观察者和被观察者，观察者需要注册到被观察者中，被观察者状态更新需要调用观察者的update()方法。但是，在跨进程的实现方式中，我们可以利用消息队列实现彻底解耦，观察者和被观察者都只需要跟消息队列交互，观察者完全不知道被观察者的存在，被观察者也完全不知道观察者的存在。</p>\n<p>中介模式也是为了解耦对象之间的交互，所有的参与者都只与中介进行交互。而观察者模式中的消息队列，就有点类似中介模式中的“中介”，观察者模式中的观察者和被观察者，就有点类似中介模式中的“参与者”。问题来了：中介模式和观察者模式的区别在哪里呢？什么时候选择使用中介模式？什么时候选择使用观察者模式呢？</p>\n<p>在观察者模式中，尽管一个参与者既可以是观察者，同时也可以是被观察者，但是，大部分情况下，交互关系往往都是单向的，一个参与者要么是观察者，要么是被观察者，不会兼具两种身份。也就是说，观察者模式的应用场景中，参与者之间的交互关系比较有条理。</p>\n<p>中介模式正好相反。只有当参与者之间的交互关系错综复杂，维护成本很高的时候，我们才考虑使用中介模式。毕竟，中介模式的应用会带来一定的副作用，前面也将到，它有可能会产生大而复杂的上帝类。除此之外，如果一个参与者状态的改变，其他参与者执行的操作有一定先后顺序的要求，这个时候，中介模式就可以利用中介类，通过先后调用不同参与者的方法，来实现顺序的控制，而观察者模式是无法实现这样的顺序要求的。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>中介模式的英文翻译是Mediator Design Pattern。在GoF的《设计模式》中，是这样定义的：</p>\n<blockquote>\n<p>Mediator pattern defines a separate (mediator) object that encapsulates the interaction between a set of objects and the objects delegate their interaction to a mediator object instead of interacting with each other directly.</p>\n</blockquote>\n<p>翻译成中文就是：中介模式定义了一个单独的（中介）对象，来封装一组对象直接的交互。将这组对象之间的交互委派给中介对象交互，来避免对象之间的直接交互。</p>\n<p>还记得如何给代码解耦吗？其中一个方法就是引入中间层。</p>\n<p>中介模式的设计思想根中间层很像，通过引入中介这个中间层，将一组对象之间的交互关系（或者说依赖关系）从多对多（网状关系）转换为一对多（星状关系）。原来一个对象要和n个对象交互，现在只需要跟一个中介对象交互，从而最小化对象之间的交互关系，降低了代码的复杂度，提高了代码的可读性和可维护性。</p>\n<img src=\"https://static001.geekbang.org/resource/image/43/9f/4376d541bf17a029f37aa76009ef3a9f.jpg\" alt=\"img\" style=\"zoom:30%;\" />\n\n<p>提到中介模式，有个经典的例子，就是航空管制。</p>\n<p>为了让飞机在飞行的时候互不干扰，每架飞机都需要知道其他飞机每时每刻的位置，这就需要时刻跟其他飞机通信。飞机通信形成的通信网络就会无比复杂。这个时候，我们通过引入“塔台”这样一个中介，让每架飞机只跟塔台来通信，发送自己的位置给塔台，由塔台来复杂每架飞机的航线调度。这样就大大简化了通信网络。</p>\n<p>假设有一个比较复杂的对话框，对话框中有很多控件，比如按钮、文本框、下拉框等。当我们对某个控件进行操作的时候，其他控件就会做出相应的反应，比如，我们在下拉框中选择“注册”，注册相关的控件就会显示在对话框中。如果我们在下拉框中选择“登陆”，登陆相关的控件就会显示在对话框中。</p>\n<p>按照通常我们习惯的UI界面的开发方式，我们将刚刚的需求用代码实现出来，就是下面这样。在这种实现中，控件和控件之间互相操作、互相依赖。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UIControl</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String LOGIN_BTN_ID = <span class=\"string\">&quot;login_btn&quot;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String REG_BTN_ID = <span class=\"string\">&quot;reg_btn&quot;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String USERNAME_INPUT_ID = <span class=\"string\">&quot;username_input&quot;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String PASSWORD_INPUT_ID = <span class=\"string\">&quot;pswd_input&quot;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String REPEATED_PASSWORD_INPUT_ID = <span class=\"string\">&quot;repeated_pswd_input&quot;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String HINT_TEXT_ID = <span class=\"string\">&quot;hint_text&quot;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String SELECTION_ID = <span class=\"string\">&quot;selection&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    Button loginButton = (Button)findViewById(LOGIN_BTN_ID);</span><br><span class=\"line\">    Button regButton = (Button)findViewById(REG_BTN_ID);</span><br><span class=\"line\">    Input usernameInput = (Input)findViewById(USERNAME_INPUT_ID);</span><br><span class=\"line\">    Input passwordInput = (Input)findViewById(PASSWORD_INPUT_ID);</span><br><span class=\"line\">    Input repeatedPswdInput = (Input)findViewById(REPEATED_PASSWORD_INPUT_ID);</span><br><span class=\"line\">    Text hintText = (Text)findViewById(HINT_TEXT_ID);</span><br><span class=\"line\">    Selection selection = (Selection)findViewById(SELECTION_ID);</span><br><span class=\"line\"></span><br><span class=\"line\">    loginButton.setOnClickListener(<span class=\"keyword\">new</span> OnClickListener() &#123;</span><br><span class=\"line\">      <span class=\"meta\">@Override</span></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onClick</span><span class=\"params\">(View v)</span> </span>&#123;</span><br><span class=\"line\">        String username = usernameInput.text();</span><br><span class=\"line\">        String password = passwordInput.text();</span><br><span class=\"line\">        <span class=\"comment\">//校验数据...</span></span><br><span class=\"line\">        <span class=\"comment\">//做业务处理...</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    regButton.setOnClickListener(<span class=\"keyword\">new</span> OnClickListener() &#123;</span><br><span class=\"line\">      <span class=\"meta\">@Override</span></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onClick</span><span class=\"params\">(View v)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">//获取usernameInput、passwordInput、repeatedPswdInput数据...</span></span><br><span class=\"line\">      <span class=\"comment\">//校验数据...</span></span><br><span class=\"line\">      <span class=\"comment\">//做业务处理...</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//...省略selection下拉选择框相关代码....</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>再按照中介模式，将上面的代码重新实现一下。在新的代码中，各个空间只跟中介对象交互，中介对象负责所有业务逻辑的处理。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Mediator</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">handleEvent</span><span class=\"params\">(Component component, String event)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LandingPageDialog</span> <span class=\"keyword\">implements</span> <span class=\"title\">Mediator</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Button loginButton;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Button regButton;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Selection selection;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Input usernameInput;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Input passwordInput;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Input repeatedPswdInput;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Text hintText;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleEvent</span><span class=\"params\">(Component component, String event)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (component.equals(loginButton)) &#123;</span><br><span class=\"line\">      String username = usernameInput.text();</span><br><span class=\"line\">      String password = passwordInput.text();</span><br><span class=\"line\">      <span class=\"comment\">//校验数据...</span></span><br><span class=\"line\">      <span class=\"comment\">//做业务处理...</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (component.equals(regButton)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//获取usernameInput、passwordInput、repeatedPswdInput数据...</span></span><br><span class=\"line\">      <span class=\"comment\">//校验数据...</span></span><br><span class=\"line\">      <span class=\"comment\">//做业务处理...</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (component.equals(selection)) &#123;</span><br><span class=\"line\">      String selectedItem = selection.select();</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (selectedItem.equals(<span class=\"string\">&quot;login&quot;</span>)) &#123;</span><br><span class=\"line\">        usernameInput.show();</span><br><span class=\"line\">        passwordInput.show();</span><br><span class=\"line\">        repeatedPswdInput.hide();</span><br><span class=\"line\">        hintText.hide();</span><br><span class=\"line\">        <span class=\"comment\">//...省略其他代码</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (selectedItem.equals(<span class=\"string\">&quot;register&quot;</span>)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//....</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UIControl</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String LOGIN_BTN_ID = <span class=\"string\">&quot;login_btn&quot;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String REG_BTN_ID = <span class=\"string\">&quot;reg_btn&quot;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String USERNAME_INPUT_ID = <span class=\"string\">&quot;username_input&quot;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String PASSWORD_INPUT_ID = <span class=\"string\">&quot;pswd_input&quot;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String REPEATED_PASSWORD_INPUT_ID = <span class=\"string\">&quot;repeated_pswd_input&quot;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String HINT_TEXT_ID = <span class=\"string\">&quot;hint_text&quot;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String SELECTION_ID = <span class=\"string\">&quot;selection&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    Button loginButton = (Button)findViewById(LOGIN_BTN_ID);</span><br><span class=\"line\">    Button regButton = (Button)findViewById(REG_BTN_ID);</span><br><span class=\"line\">    Input usernameInput = (Input)findViewById(USERNAME_INPUT_ID);</span><br><span class=\"line\">    Input passwordInput = (Input)findViewById(PASSWORD_INPUT_ID);</span><br><span class=\"line\">    Input repeatedPswdInput = (Input)findViewById(REPEATED_PASSWORD_INPUT_ID);</span><br><span class=\"line\">    Text hintText = (Text)findViewById(HINT_TEXT_ID);</span><br><span class=\"line\">    Selection selection = (Selection)findViewById(SELECTION_ID);</span><br><span class=\"line\"></span><br><span class=\"line\">    Mediator dialog = <span class=\"keyword\">new</span> LandingPageDialog();</span><br><span class=\"line\">    dialog.setLoginButton(loginButton);</span><br><span class=\"line\">    dialog.setRegButton(regButton);</span><br><span class=\"line\">    dialog.setUsernameInput(usernameInput);</span><br><span class=\"line\">    dialog.setPasswordInput(passwordInput);</span><br><span class=\"line\">    dialog.setRepeatedPswdInput(repeatedPswdInput);</span><br><span class=\"line\">    dialog.setHintText(hintText);</span><br><span class=\"line\">    dialog.setSelection(selection);</span><br><span class=\"line\"></span><br><span class=\"line\">    loginButton.setOnClickListener(<span class=\"keyword\">new</span> OnClickListener() &#123;</span><br><span class=\"line\">      <span class=\"meta\">@Override</span></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onClick</span><span class=\"params\">(View v)</span> </span>&#123;</span><br><span class=\"line\">        dialog.handleEvent(loginButton, <span class=\"string\">&quot;click&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    regButton.setOnClickListener(<span class=\"keyword\">new</span> OnClickListener() &#123;</span><br><span class=\"line\">      <span class=\"meta\">@Override</span></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onClick</span><span class=\"params\">(View v)</span> </span>&#123;</span><br><span class=\"line\">        dialog.handleEvent(regButton, <span class=\"string\">&quot;click&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//....</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>原本业务逻辑分散到各个控件中，现在都集中到了中介类中。这样做有好处也有坏处，好处是简化了控件之间的交互，坏处是中介类可能变成大而复杂的上帝类（God Class）。所以，在使用中介模式的时候，要根据实际情况，平衡对象之间交互的复杂度和中介类本身的复杂度。其实就是要看取舍，我觉得还可以把中介类做一个中间层，别的处理方式拆分成功能单一的小类也可以。只不过中介类用来做统一的调度处理，就类似于塔台，塔台中也会有多个工作人员去协调调度飞机。</p>\n<h5 id=\"中介模式VS观察者模式\"><a href=\"#中介模式VS观察者模式\" class=\"headerlink\" title=\"中介模式VS观察者模式\"></a>中介模式VS观察者模式</h5><p>观察者模式有多种实现方式。虽然经典的实现方式没法彻底解耦观察者和被观察者，观察者需要注册到被观察者中，被观察者状态更新需要调用观察者的update()方法。但是，在跨进程的实现方式中，我们可以利用消息队列实现彻底解耦，观察者和被观察者都只需要跟消息队列交互，观察者完全不知道被观察者的存在，被观察者也完全不知道观察者的存在。</p>\n<p>中介模式也是为了解耦对象之间的交互，所有的参与者都只与中介进行交互。而观察者模式中的消息队列，就有点类似中介模式中的“中介”，观察者模式中的观察者和被观察者，就有点类似中介模式中的“参与者”。问题来了：中介模式和观察者模式的区别在哪里呢？什么时候选择使用中介模式？什么时候选择使用观察者模式呢？</p>\n<p>在观察者模式中，尽管一个参与者既可以是观察者，同时也可以是被观察者，但是，大部分情况下，交互关系往往都是单向的，一个参与者要么是观察者，要么是被观察者，不会兼具两种身份。也就是说，观察者模式的应用场景中，参与者之间的交互关系比较有条理。</p>\n<p>中介模式正好相反。只有当参与者之间的交互关系错综复杂，维护成本很高的时候，我们才考虑使用中介模式。毕竟，中介模式的应用会带来一定的副作用，前面也将到，它有可能会产生大而复杂的上帝类。除此之外，如果一个参与者状态的改变，其他参与者执行的操作有一定先后顺序的要求，这个时候，中介模式就可以利用中介类，通过先后调用不同参与者的方法，来实现顺序的控制，而观察者模式是无法实现这样的顺序要求的。</p>\n"},{"layout":"post","title":"设计模式之代理模式","description":"设计模式之代理模式","date":"2021-05-13T05:26:10.000Z","_content":"\n代理模式在不改变原始类（被代理类）代码的情况下，通过引入代理类来给原始类附加功能。\n\n代理类负责在业务代码前后附加其他逻辑代码，并通过委托的方式调用原始类来执行业务代码。\n\n```java\n\npublic interface IUserController {\n  UserVo login(String telephone, String password);\n  UserVo register(String telephone, String password);\n}\n\npublic class UserController implements IUserController {\n  //...省略其他属性和方法...\n\n  @Override\n  public UserVo login(String telephone, String password) {\n    //...省略login逻辑...\n    //...返回UserVo数据...\n  }\n\n  @Override\n  public UserVo register(String telephone, String password) {\n    //...省略register逻辑...\n    //...返回UserVo数据...\n  }\n}\n\npublic class UserControllerProxy implements IUserController {\n  private MetricsCollector metricsCollector;\n  private UserController userController;\n\n  public UserControllerProxy(UserController userController) {\n    this.userController = userController;\n    this.metricsCollector = new MetricsCollector();\n  }\n\n  @Override\n  public UserVo login(String telephone, String password) {\n    long startTimestamp = System.currentTimeMillis();\n\n    // 委托\n    UserVo userVo = userController.login(telephone, password);\n\n    long endTimeStamp = System.currentTimeMillis();\n    long responseTime = endTimeStamp - startTimestamp;\n    RequestInfo requestInfo = new RequestInfo(\"login\", responseTime, startTimestamp);\n    metricsCollector.recordRequest(requestInfo);\n\n    return userVo;\n  }\n\n  @Override\n  public UserVo register(String telephone, String password) {\n    long startTimestamp = System.currentTimeMillis();\n\n    UserVo userVo = userController.register(telephone, password);\n\n    long endTimeStamp = System.currentTimeMillis();\n    long responseTime = endTimeStamp - startTimestamp;\n    RequestInfo requestInfo = new RequestInfo(\"register\", responseTime, startTimestamp);\n    metricsCollector.recordRequest(requestInfo);\n\n    return userVo;\n  }\n}\n\n//UserControllerProxy使用举例\n//因为原始类和代理类实现相同的接口，是基于接口而非实现编程\n//将UserController类对象替换为UserControllerProxy类对象，不需要改动太多代码\nIUserController userController = new UserControllerProxy(new UserController());\n```\n\n如果原始类没有定义接口，并且原始类不是我们开发维护的（来自第三方类库），我们也没有办法直接修改原始类，给它重新定义一个接口，对于这种外部类的扩展，我们一般采用集成的方式。\n\n```java\n\npublic class UserControllerProxy extends UserController {\n  private MetricsCollector metricsCollector;\n\n  public UserControllerProxy() {\n    this.metricsCollector = new MetricsCollector();\n  }\n\n  public UserVo login(String telephone, String password) {\n    long startTimestamp = System.currentTimeMillis();\n\n    UserVo userVo = super.login(telephone, password);\n\n    long endTimeStamp = System.currentTimeMillis();\n    long responseTime = endTimeStamp - startTimestamp;\n    RequestInfo requestInfo = new RequestInfo(\"login\", responseTime, startTimestamp);\n    metricsCollector.recordRequest(requestInfo);\n\n    return userVo;\n  }\n\n  public UserVo register(String telephone, String password) {\n    long startTimestamp = System.currentTimeMillis();\n\n    UserVo userVo = super.register(telephone, password);\n\n    long endTimeStamp = System.currentTimeMillis();\n    long responseTime = endTimeStamp - startTimestamp;\n    RequestInfo requestInfo = new RequestInfo(\"register\", responseTime, startTimestamp);\n    metricsCollector.recordRequest(requestInfo);\n\n    return userVo;\n  }\n}\n//UserControllerProxy使用举例\nUserController userController = new UserControllerProxy();\n```\n\n动态代理\n\n刚刚的代码存在一些问题，一方面，我们需要在代理类中，将原始类中的所有的方法，都重新实现一遍，并且为每个方法都附加相似的代码逻辑。另一方面，如果要添加的附加功能的类不止一个，我们需要针对每个类都创建一个代理类。如果有很多要添加附加功能的原始类，需要创建很多的代理类，这样项目中的类的个数就成倍增加，并且每个代理类中的代码都有点像模版式的重复代码，增加了不必要的开发成本。\n\n可以用动态代理来解决这个问题，动态代理，就是不事先为每个原始类编写代理类，而是在运行的时候，动态地创建原始类对应的代理类，然后在系统中用代理类替换掉原始类。\n\n```java\n\npublic class MetricsCollectorProxy {\n  private MetricsCollector metricsCollector;\n\n  public MetricsCollectorProxy() {\n    this.metricsCollector = new MetricsCollector();\n  }\n\n  public Object createProxy(Object proxiedObject) {\n    Class<?>[] interfaces = proxiedObject.getClass().getInterfaces();\n    DynamicProxyHandler handler = new DynamicProxyHandler(proxiedObject);\n    return Proxy.newProxyInstance(proxiedObject.getClass().getClassLoader(), interfaces, handler);\n  }\n\n  private class DynamicProxyHandler implements InvocationHandler {\n    private Object proxiedObject;\n\n    public DynamicProxyHandler(Object proxiedObject) {\n      this.proxiedObject = proxiedObject;\n    }\n\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n      long startTimestamp = System.currentTimeMillis();\n      Object result = method.invoke(proxiedObject, args);\n      long endTimeStamp = System.currentTimeMillis();\n      long responseTime = endTimeStamp - startTimestamp;\n      String apiName = proxiedObject.getClass().getName() + \":\" + method.getName();\n      RequestInfo requestInfo = new RequestInfo(apiName, responseTime, startTimestamp);\n      metricsCollector.recordRequest(requestInfo);\n      return result;\n    }\n  }\n}\n\n//MetricsCollectorProxy使用举例\nMetricsCollectorProxy proxy = new MetricsCollectorProxy();\nIUserController userController = (IUserController) proxy.createProxy(new UserController());\n```\n\nSpring AOP底层的实现原理就是基于动态代理。用户配置好需要给哪些类创建代理，并定义好在执行原始类的业务代码前后执行哪些附加功能。Spring为这些类创建动态代理对象，并在JVM中替代原始类对象。原本在代码中执行的原始类的方法，被换作执行代理类的方法，也就实现了给原始类添加附加功能的目的。\n\n##### 代理模式应用场景\n\n1.业务系统的非功能性需求开发\n\n代理模式最常用的应用场景，在业务系统中开发一些非功能性需求，监控、统计、鉴权、限流、事务、幂等、日志。将这些附加功能和业务功能解耦，放到代理类中统一处理。\n\nrpc的demo https://github.com/wangzheng0822/codedesign/tree/master/com/xzg/cd/rpc\n\n2.代理模式在RPC、缓存中的应用\n\n实际上，RPC框架也可以看作一种代理模式，《设计模式》中把它叫做远程代理，通过远程代理，将网络通信、数据编解码等细节隐藏起来。客户端在使用RPC服务的时候，就像使用本地函数一样，无需了解跟服务器交互的细节。\n\n缓存中的应用。假设我们要开发一个接口请求的缓存功能，对于某些接口请求，如果入参相同，在设定的过期内，直接返回缓存结果，而不用重新进行逻辑处理。比如，针对获取用户个人信息，我们可以开发两个接口，一个支持缓存，一个支持实时查询。动态代理模式可以很好的解决这个问题，如果基于spring开发的话，可以在AOP切面中完成接口缓存的功能。应用启动的时候，从配置文件加载需要支持缓存的接口，以及相应的缓存策略（比如过期时间）等，当请求到来的时候，我们在AOP切面中拦截请求，如果满足策略，便从缓存中获取数据直接返回。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/设计模式之代理模式.md","raw":"---\nlayout:    post\ntitle:     设计模式之代理模式\ncategory:  设计模式之美\ndescription: 设计模式之代理模式\ntags: 设计模式之美\ndate: 2021/05/13 13:26:10\n---\n\n代理模式在不改变原始类（被代理类）代码的情况下，通过引入代理类来给原始类附加功能。\n\n代理类负责在业务代码前后附加其他逻辑代码，并通过委托的方式调用原始类来执行业务代码。\n\n```java\n\npublic interface IUserController {\n  UserVo login(String telephone, String password);\n  UserVo register(String telephone, String password);\n}\n\npublic class UserController implements IUserController {\n  //...省略其他属性和方法...\n\n  @Override\n  public UserVo login(String telephone, String password) {\n    //...省略login逻辑...\n    //...返回UserVo数据...\n  }\n\n  @Override\n  public UserVo register(String telephone, String password) {\n    //...省略register逻辑...\n    //...返回UserVo数据...\n  }\n}\n\npublic class UserControllerProxy implements IUserController {\n  private MetricsCollector metricsCollector;\n  private UserController userController;\n\n  public UserControllerProxy(UserController userController) {\n    this.userController = userController;\n    this.metricsCollector = new MetricsCollector();\n  }\n\n  @Override\n  public UserVo login(String telephone, String password) {\n    long startTimestamp = System.currentTimeMillis();\n\n    // 委托\n    UserVo userVo = userController.login(telephone, password);\n\n    long endTimeStamp = System.currentTimeMillis();\n    long responseTime = endTimeStamp - startTimestamp;\n    RequestInfo requestInfo = new RequestInfo(\"login\", responseTime, startTimestamp);\n    metricsCollector.recordRequest(requestInfo);\n\n    return userVo;\n  }\n\n  @Override\n  public UserVo register(String telephone, String password) {\n    long startTimestamp = System.currentTimeMillis();\n\n    UserVo userVo = userController.register(telephone, password);\n\n    long endTimeStamp = System.currentTimeMillis();\n    long responseTime = endTimeStamp - startTimestamp;\n    RequestInfo requestInfo = new RequestInfo(\"register\", responseTime, startTimestamp);\n    metricsCollector.recordRequest(requestInfo);\n\n    return userVo;\n  }\n}\n\n//UserControllerProxy使用举例\n//因为原始类和代理类实现相同的接口，是基于接口而非实现编程\n//将UserController类对象替换为UserControllerProxy类对象，不需要改动太多代码\nIUserController userController = new UserControllerProxy(new UserController());\n```\n\n如果原始类没有定义接口，并且原始类不是我们开发维护的（来自第三方类库），我们也没有办法直接修改原始类，给它重新定义一个接口，对于这种外部类的扩展，我们一般采用集成的方式。\n\n```java\n\npublic class UserControllerProxy extends UserController {\n  private MetricsCollector metricsCollector;\n\n  public UserControllerProxy() {\n    this.metricsCollector = new MetricsCollector();\n  }\n\n  public UserVo login(String telephone, String password) {\n    long startTimestamp = System.currentTimeMillis();\n\n    UserVo userVo = super.login(telephone, password);\n\n    long endTimeStamp = System.currentTimeMillis();\n    long responseTime = endTimeStamp - startTimestamp;\n    RequestInfo requestInfo = new RequestInfo(\"login\", responseTime, startTimestamp);\n    metricsCollector.recordRequest(requestInfo);\n\n    return userVo;\n  }\n\n  public UserVo register(String telephone, String password) {\n    long startTimestamp = System.currentTimeMillis();\n\n    UserVo userVo = super.register(telephone, password);\n\n    long endTimeStamp = System.currentTimeMillis();\n    long responseTime = endTimeStamp - startTimestamp;\n    RequestInfo requestInfo = new RequestInfo(\"register\", responseTime, startTimestamp);\n    metricsCollector.recordRequest(requestInfo);\n\n    return userVo;\n  }\n}\n//UserControllerProxy使用举例\nUserController userController = new UserControllerProxy();\n```\n\n动态代理\n\n刚刚的代码存在一些问题，一方面，我们需要在代理类中，将原始类中的所有的方法，都重新实现一遍，并且为每个方法都附加相似的代码逻辑。另一方面，如果要添加的附加功能的类不止一个，我们需要针对每个类都创建一个代理类。如果有很多要添加附加功能的原始类，需要创建很多的代理类，这样项目中的类的个数就成倍增加，并且每个代理类中的代码都有点像模版式的重复代码，增加了不必要的开发成本。\n\n可以用动态代理来解决这个问题，动态代理，就是不事先为每个原始类编写代理类，而是在运行的时候，动态地创建原始类对应的代理类，然后在系统中用代理类替换掉原始类。\n\n```java\n\npublic class MetricsCollectorProxy {\n  private MetricsCollector metricsCollector;\n\n  public MetricsCollectorProxy() {\n    this.metricsCollector = new MetricsCollector();\n  }\n\n  public Object createProxy(Object proxiedObject) {\n    Class<?>[] interfaces = proxiedObject.getClass().getInterfaces();\n    DynamicProxyHandler handler = new DynamicProxyHandler(proxiedObject);\n    return Proxy.newProxyInstance(proxiedObject.getClass().getClassLoader(), interfaces, handler);\n  }\n\n  private class DynamicProxyHandler implements InvocationHandler {\n    private Object proxiedObject;\n\n    public DynamicProxyHandler(Object proxiedObject) {\n      this.proxiedObject = proxiedObject;\n    }\n\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n      long startTimestamp = System.currentTimeMillis();\n      Object result = method.invoke(proxiedObject, args);\n      long endTimeStamp = System.currentTimeMillis();\n      long responseTime = endTimeStamp - startTimestamp;\n      String apiName = proxiedObject.getClass().getName() + \":\" + method.getName();\n      RequestInfo requestInfo = new RequestInfo(apiName, responseTime, startTimestamp);\n      metricsCollector.recordRequest(requestInfo);\n      return result;\n    }\n  }\n}\n\n//MetricsCollectorProxy使用举例\nMetricsCollectorProxy proxy = new MetricsCollectorProxy();\nIUserController userController = (IUserController) proxy.createProxy(new UserController());\n```\n\nSpring AOP底层的实现原理就是基于动态代理。用户配置好需要给哪些类创建代理，并定义好在执行原始类的业务代码前后执行哪些附加功能。Spring为这些类创建动态代理对象，并在JVM中替代原始类对象。原本在代码中执行的原始类的方法，被换作执行代理类的方法，也就实现了给原始类添加附加功能的目的。\n\n##### 代理模式应用场景\n\n1.业务系统的非功能性需求开发\n\n代理模式最常用的应用场景，在业务系统中开发一些非功能性需求，监控、统计、鉴权、限流、事务、幂等、日志。将这些附加功能和业务功能解耦，放到代理类中统一处理。\n\nrpc的demo https://github.com/wangzheng0822/codedesign/tree/master/com/xzg/cd/rpc\n\n2.代理模式在RPC、缓存中的应用\n\n实际上，RPC框架也可以看作一种代理模式，《设计模式》中把它叫做远程代理，通过远程代理，将网络通信、数据编解码等细节隐藏起来。客户端在使用RPC服务的时候，就像使用本地函数一样，无需了解跟服务器交互的细节。\n\n缓存中的应用。假设我们要开发一个接口请求的缓存功能，对于某些接口请求，如果入参相同，在设定的过期内，直接返回缓存结果，而不用重新进行逻辑处理。比如，针对获取用户个人信息，我们可以开发两个接口，一个支持缓存，一个支持实时查询。动态代理模式可以很好的解决这个问题，如果基于spring开发的话，可以在AOP切面中完成接口缓存的功能。应用启动的时候，从配置文件加载需要支持缓存的接口，以及相应的缓存策略（比如过期时间）等，当请求到来的时候，我们在AOP切面中拦截请求，如果满足策略，便从缓存中获取数据直接返回。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"设计模式之代理模式","published":1,"updated":"2021-05-13T05:26:10.000Z","comments":1,"photos":[],"link":"","_id":"cm1m304xk001931b44zdm7dru","content":"<p>代理模式在不改变原始类（被代理类）代码的情况下，通过引入代理类来给原始类附加功能。</p>\n<p>代理类负责在业务代码前后附加其他逻辑代码，并通过委托的方式调用原始类来执行业务代码。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">IUserController</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\">UserVo <span class=\"title\">login</span><span class=\"params\">(String telephone, String password)</span></span>;</span><br><span class=\"line\">  <span class=\"function\">UserVo <span class=\"title\">register</span><span class=\"params\">(String telephone, String password)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserController</span> <span class=\"keyword\">implements</span> <span class=\"title\">IUserController</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//...省略其他属性和方法...</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> UserVo <span class=\"title\">login</span><span class=\"params\">(String telephone, String password)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...省略login逻辑...</span></span><br><span class=\"line\">    <span class=\"comment\">//...返回UserVo数据...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> UserVo <span class=\"title\">register</span><span class=\"params\">(String telephone, String password)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...省略register逻辑...</span></span><br><span class=\"line\">    <span class=\"comment\">//...返回UserVo数据...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserControllerProxy</span> <span class=\"keyword\">implements</span> <span class=\"title\">IUserController</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> MetricsCollector metricsCollector;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> UserController userController;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">UserControllerProxy</span><span class=\"params\">(UserController userController)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.userController = userController;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.metricsCollector = <span class=\"keyword\">new</span> MetricsCollector();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> UserVo <span class=\"title\">login</span><span class=\"params\">(String telephone, String password)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> startTimestamp = System.currentTimeMillis();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 委托</span></span><br><span class=\"line\">    UserVo userVo = userController.login(telephone, password);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">long</span> endTimeStamp = System.currentTimeMillis();</span><br><span class=\"line\">    <span class=\"keyword\">long</span> responseTime = endTimeStamp - startTimestamp;</span><br><span class=\"line\">    RequestInfo requestInfo = <span class=\"keyword\">new</span> RequestInfo(<span class=\"string\">&quot;login&quot;</span>, responseTime, startTimestamp);</span><br><span class=\"line\">    metricsCollector.recordRequest(requestInfo);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> userVo;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> UserVo <span class=\"title\">register</span><span class=\"params\">(String telephone, String password)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> startTimestamp = System.currentTimeMillis();</span><br><span class=\"line\"></span><br><span class=\"line\">    UserVo userVo = userController.register(telephone, password);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">long</span> endTimeStamp = System.currentTimeMillis();</span><br><span class=\"line\">    <span class=\"keyword\">long</span> responseTime = endTimeStamp - startTimestamp;</span><br><span class=\"line\">    RequestInfo requestInfo = <span class=\"keyword\">new</span> RequestInfo(<span class=\"string\">&quot;register&quot;</span>, responseTime, startTimestamp);</span><br><span class=\"line\">    metricsCollector.recordRequest(requestInfo);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> userVo;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//UserControllerProxy使用举例</span></span><br><span class=\"line\"><span class=\"comment\">//因为原始类和代理类实现相同的接口，是基于接口而非实现编程</span></span><br><span class=\"line\"><span class=\"comment\">//将UserController类对象替换为UserControllerProxy类对象，不需要改动太多代码</span></span><br><span class=\"line\">IUserController userController = <span class=\"keyword\">new</span> UserControllerProxy(<span class=\"keyword\">new</span> UserController());</span><br></pre></td></tr></table></figure>\n\n<p>如果原始类没有定义接口，并且原始类不是我们开发维护的（来自第三方类库），我们也没有办法直接修改原始类，给它重新定义一个接口，对于这种外部类的扩展，我们一般采用集成的方式。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserControllerProxy</span> <span class=\"keyword\">extends</span> <span class=\"title\">UserController</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> MetricsCollector metricsCollector;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">UserControllerProxy</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.metricsCollector = <span class=\"keyword\">new</span> MetricsCollector();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> UserVo <span class=\"title\">login</span><span class=\"params\">(String telephone, String password)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> startTimestamp = System.currentTimeMillis();</span><br><span class=\"line\"></span><br><span class=\"line\">    UserVo userVo = <span class=\"keyword\">super</span>.login(telephone, password);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">long</span> endTimeStamp = System.currentTimeMillis();</span><br><span class=\"line\">    <span class=\"keyword\">long</span> responseTime = endTimeStamp - startTimestamp;</span><br><span class=\"line\">    RequestInfo requestInfo = <span class=\"keyword\">new</span> RequestInfo(<span class=\"string\">&quot;login&quot;</span>, responseTime, startTimestamp);</span><br><span class=\"line\">    metricsCollector.recordRequest(requestInfo);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> userVo;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> UserVo <span class=\"title\">register</span><span class=\"params\">(String telephone, String password)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> startTimestamp = System.currentTimeMillis();</span><br><span class=\"line\"></span><br><span class=\"line\">    UserVo userVo = <span class=\"keyword\">super</span>.register(telephone, password);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">long</span> endTimeStamp = System.currentTimeMillis();</span><br><span class=\"line\">    <span class=\"keyword\">long</span> responseTime = endTimeStamp - startTimestamp;</span><br><span class=\"line\">    RequestInfo requestInfo = <span class=\"keyword\">new</span> RequestInfo(<span class=\"string\">&quot;register&quot;</span>, responseTime, startTimestamp);</span><br><span class=\"line\">    metricsCollector.recordRequest(requestInfo);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> userVo;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//UserControllerProxy使用举例</span></span><br><span class=\"line\">UserController userController = <span class=\"keyword\">new</span> UserControllerProxy();</span><br></pre></td></tr></table></figure>\n\n<p>动态代理</p>\n<p>刚刚的代码存在一些问题，一方面，我们需要在代理类中，将原始类中的所有的方法，都重新实现一遍，并且为每个方法都附加相似的代码逻辑。另一方面，如果要添加的附加功能的类不止一个，我们需要针对每个类都创建一个代理类。如果有很多要添加附加功能的原始类，需要创建很多的代理类，这样项目中的类的个数就成倍增加，并且每个代理类中的代码都有点像模版式的重复代码，增加了不必要的开发成本。</p>\n<p>可以用动态代理来解决这个问题，动态代理，就是不事先为每个原始类编写代理类，而是在运行的时候，动态地创建原始类对应的代理类，然后在系统中用代理类替换掉原始类。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MetricsCollectorProxy</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> MetricsCollector metricsCollector;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MetricsCollectorProxy</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.metricsCollector = <span class=\"keyword\">new</span> MetricsCollector();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">createProxy</span><span class=\"params\">(Object proxiedObject)</span> </span>&#123;</span><br><span class=\"line\">    Class&lt;?&gt;[] interfaces = proxiedObject.getClass().getInterfaces();</span><br><span class=\"line\">    DynamicProxyHandler handler = <span class=\"keyword\">new</span> DynamicProxyHandler(proxiedObject);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Proxy.newProxyInstance(proxiedObject.getClass().getClassLoader(), interfaces, handler);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DynamicProxyHandler</span> <span class=\"keyword\">implements</span> <span class=\"title\">InvocationHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object proxiedObject;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DynamicProxyHandler</span><span class=\"params\">(Object proxiedObject)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.proxiedObject = proxiedObject;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">long</span> startTimestamp = System.currentTimeMillis();</span><br><span class=\"line\">      Object result = method.invoke(proxiedObject, args);</span><br><span class=\"line\">      <span class=\"keyword\">long</span> endTimeStamp = System.currentTimeMillis();</span><br><span class=\"line\">      <span class=\"keyword\">long</span> responseTime = endTimeStamp - startTimestamp;</span><br><span class=\"line\">      String apiName = proxiedObject.getClass().getName() + <span class=\"string\">&quot;:&quot;</span> + method.getName();</span><br><span class=\"line\">      RequestInfo requestInfo = <span class=\"keyword\">new</span> RequestInfo(apiName, responseTime, startTimestamp);</span><br><span class=\"line\">      metricsCollector.recordRequest(requestInfo);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//MetricsCollectorProxy使用举例</span></span><br><span class=\"line\">MetricsCollectorProxy proxy = <span class=\"keyword\">new</span> MetricsCollectorProxy();</span><br><span class=\"line\">IUserController userController = (IUserController) proxy.createProxy(<span class=\"keyword\">new</span> UserController());</span><br></pre></td></tr></table></figure>\n\n<p>Spring AOP底层的实现原理就是基于动态代理。用户配置好需要给哪些类创建代理，并定义好在执行原始类的业务代码前后执行哪些附加功能。Spring为这些类创建动态代理对象，并在JVM中替代原始类对象。原本在代码中执行的原始类的方法，被换作执行代理类的方法，也就实现了给原始类添加附加功能的目的。</p>\n<h5 id=\"代理模式应用场景\"><a href=\"#代理模式应用场景\" class=\"headerlink\" title=\"代理模式应用场景\"></a>代理模式应用场景</h5><p>1.业务系统的非功能性需求开发</p>\n<p>代理模式最常用的应用场景，在业务系统中开发一些非功能性需求，监控、统计、鉴权、限流、事务、幂等、日志。将这些附加功能和业务功能解耦，放到代理类中统一处理。</p>\n<p>rpc的demo <a href=\"https://github.com/wangzheng0822/codedesign/tree/master/com/xzg/cd/rpc\">https://github.com/wangzheng0822/codedesign/tree/master/com/xzg/cd/rpc</a></p>\n<p>2.代理模式在RPC、缓存中的应用</p>\n<p>实际上，RPC框架也可以看作一种代理模式，《设计模式》中把它叫做远程代理，通过远程代理，将网络通信、数据编解码等细节隐藏起来。客户端在使用RPC服务的时候，就像使用本地函数一样，无需了解跟服务器交互的细节。</p>\n<p>缓存中的应用。假设我们要开发一个接口请求的缓存功能，对于某些接口请求，如果入参相同，在设定的过期内，直接返回缓存结果，而不用重新进行逻辑处理。比如，针对获取用户个人信息，我们可以开发两个接口，一个支持缓存，一个支持实时查询。动态代理模式可以很好的解决这个问题，如果基于spring开发的话，可以在AOP切面中完成接口缓存的功能。应用启动的时候，从配置文件加载需要支持缓存的接口，以及相应的缓存策略（比如过期时间）等，当请求到来的时候，我们在AOP切面中拦截请求，如果满足策略，便从缓存中获取数据直接返回。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>代理模式在不改变原始类（被代理类）代码的情况下，通过引入代理类来给原始类附加功能。</p>\n<p>代理类负责在业务代码前后附加其他逻辑代码，并通过委托的方式调用原始类来执行业务代码。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">IUserController</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\">UserVo <span class=\"title\">login</span><span class=\"params\">(String telephone, String password)</span></span>;</span><br><span class=\"line\">  <span class=\"function\">UserVo <span class=\"title\">register</span><span class=\"params\">(String telephone, String password)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserController</span> <span class=\"keyword\">implements</span> <span class=\"title\">IUserController</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//...省略其他属性和方法...</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> UserVo <span class=\"title\">login</span><span class=\"params\">(String telephone, String password)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...省略login逻辑...</span></span><br><span class=\"line\">    <span class=\"comment\">//...返回UserVo数据...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> UserVo <span class=\"title\">register</span><span class=\"params\">(String telephone, String password)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...省略register逻辑...</span></span><br><span class=\"line\">    <span class=\"comment\">//...返回UserVo数据...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserControllerProxy</span> <span class=\"keyword\">implements</span> <span class=\"title\">IUserController</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> MetricsCollector metricsCollector;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> UserController userController;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">UserControllerProxy</span><span class=\"params\">(UserController userController)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.userController = userController;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.metricsCollector = <span class=\"keyword\">new</span> MetricsCollector();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> UserVo <span class=\"title\">login</span><span class=\"params\">(String telephone, String password)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> startTimestamp = System.currentTimeMillis();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 委托</span></span><br><span class=\"line\">    UserVo userVo = userController.login(telephone, password);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">long</span> endTimeStamp = System.currentTimeMillis();</span><br><span class=\"line\">    <span class=\"keyword\">long</span> responseTime = endTimeStamp - startTimestamp;</span><br><span class=\"line\">    RequestInfo requestInfo = <span class=\"keyword\">new</span> RequestInfo(<span class=\"string\">&quot;login&quot;</span>, responseTime, startTimestamp);</span><br><span class=\"line\">    metricsCollector.recordRequest(requestInfo);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> userVo;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> UserVo <span class=\"title\">register</span><span class=\"params\">(String telephone, String password)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> startTimestamp = System.currentTimeMillis();</span><br><span class=\"line\"></span><br><span class=\"line\">    UserVo userVo = userController.register(telephone, password);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">long</span> endTimeStamp = System.currentTimeMillis();</span><br><span class=\"line\">    <span class=\"keyword\">long</span> responseTime = endTimeStamp - startTimestamp;</span><br><span class=\"line\">    RequestInfo requestInfo = <span class=\"keyword\">new</span> RequestInfo(<span class=\"string\">&quot;register&quot;</span>, responseTime, startTimestamp);</span><br><span class=\"line\">    metricsCollector.recordRequest(requestInfo);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> userVo;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//UserControllerProxy使用举例</span></span><br><span class=\"line\"><span class=\"comment\">//因为原始类和代理类实现相同的接口，是基于接口而非实现编程</span></span><br><span class=\"line\"><span class=\"comment\">//将UserController类对象替换为UserControllerProxy类对象，不需要改动太多代码</span></span><br><span class=\"line\">IUserController userController = <span class=\"keyword\">new</span> UserControllerProxy(<span class=\"keyword\">new</span> UserController());</span><br></pre></td></tr></table></figure>\n\n<p>如果原始类没有定义接口，并且原始类不是我们开发维护的（来自第三方类库），我们也没有办法直接修改原始类，给它重新定义一个接口，对于这种外部类的扩展，我们一般采用集成的方式。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserControllerProxy</span> <span class=\"keyword\">extends</span> <span class=\"title\">UserController</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> MetricsCollector metricsCollector;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">UserControllerProxy</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.metricsCollector = <span class=\"keyword\">new</span> MetricsCollector();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> UserVo <span class=\"title\">login</span><span class=\"params\">(String telephone, String password)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> startTimestamp = System.currentTimeMillis();</span><br><span class=\"line\"></span><br><span class=\"line\">    UserVo userVo = <span class=\"keyword\">super</span>.login(telephone, password);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">long</span> endTimeStamp = System.currentTimeMillis();</span><br><span class=\"line\">    <span class=\"keyword\">long</span> responseTime = endTimeStamp - startTimestamp;</span><br><span class=\"line\">    RequestInfo requestInfo = <span class=\"keyword\">new</span> RequestInfo(<span class=\"string\">&quot;login&quot;</span>, responseTime, startTimestamp);</span><br><span class=\"line\">    metricsCollector.recordRequest(requestInfo);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> userVo;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> UserVo <span class=\"title\">register</span><span class=\"params\">(String telephone, String password)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> startTimestamp = System.currentTimeMillis();</span><br><span class=\"line\"></span><br><span class=\"line\">    UserVo userVo = <span class=\"keyword\">super</span>.register(telephone, password);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">long</span> endTimeStamp = System.currentTimeMillis();</span><br><span class=\"line\">    <span class=\"keyword\">long</span> responseTime = endTimeStamp - startTimestamp;</span><br><span class=\"line\">    RequestInfo requestInfo = <span class=\"keyword\">new</span> RequestInfo(<span class=\"string\">&quot;register&quot;</span>, responseTime, startTimestamp);</span><br><span class=\"line\">    metricsCollector.recordRequest(requestInfo);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> userVo;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//UserControllerProxy使用举例</span></span><br><span class=\"line\">UserController userController = <span class=\"keyword\">new</span> UserControllerProxy();</span><br></pre></td></tr></table></figure>\n\n<p>动态代理</p>\n<p>刚刚的代码存在一些问题，一方面，我们需要在代理类中，将原始类中的所有的方法，都重新实现一遍，并且为每个方法都附加相似的代码逻辑。另一方面，如果要添加的附加功能的类不止一个，我们需要针对每个类都创建一个代理类。如果有很多要添加附加功能的原始类，需要创建很多的代理类，这样项目中的类的个数就成倍增加，并且每个代理类中的代码都有点像模版式的重复代码，增加了不必要的开发成本。</p>\n<p>可以用动态代理来解决这个问题，动态代理，就是不事先为每个原始类编写代理类，而是在运行的时候，动态地创建原始类对应的代理类，然后在系统中用代理类替换掉原始类。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MetricsCollectorProxy</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> MetricsCollector metricsCollector;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MetricsCollectorProxy</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.metricsCollector = <span class=\"keyword\">new</span> MetricsCollector();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">createProxy</span><span class=\"params\">(Object proxiedObject)</span> </span>&#123;</span><br><span class=\"line\">    Class&lt;?&gt;[] interfaces = proxiedObject.getClass().getInterfaces();</span><br><span class=\"line\">    DynamicProxyHandler handler = <span class=\"keyword\">new</span> DynamicProxyHandler(proxiedObject);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Proxy.newProxyInstance(proxiedObject.getClass().getClassLoader(), interfaces, handler);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DynamicProxyHandler</span> <span class=\"keyword\">implements</span> <span class=\"title\">InvocationHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object proxiedObject;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DynamicProxyHandler</span><span class=\"params\">(Object proxiedObject)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.proxiedObject = proxiedObject;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">long</span> startTimestamp = System.currentTimeMillis();</span><br><span class=\"line\">      Object result = method.invoke(proxiedObject, args);</span><br><span class=\"line\">      <span class=\"keyword\">long</span> endTimeStamp = System.currentTimeMillis();</span><br><span class=\"line\">      <span class=\"keyword\">long</span> responseTime = endTimeStamp - startTimestamp;</span><br><span class=\"line\">      String apiName = proxiedObject.getClass().getName() + <span class=\"string\">&quot;:&quot;</span> + method.getName();</span><br><span class=\"line\">      RequestInfo requestInfo = <span class=\"keyword\">new</span> RequestInfo(apiName, responseTime, startTimestamp);</span><br><span class=\"line\">      metricsCollector.recordRequest(requestInfo);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//MetricsCollectorProxy使用举例</span></span><br><span class=\"line\">MetricsCollectorProxy proxy = <span class=\"keyword\">new</span> MetricsCollectorProxy();</span><br><span class=\"line\">IUserController userController = (IUserController) proxy.createProxy(<span class=\"keyword\">new</span> UserController());</span><br></pre></td></tr></table></figure>\n\n<p>Spring AOP底层的实现原理就是基于动态代理。用户配置好需要给哪些类创建代理，并定义好在执行原始类的业务代码前后执行哪些附加功能。Spring为这些类创建动态代理对象，并在JVM中替代原始类对象。原本在代码中执行的原始类的方法，被换作执行代理类的方法，也就实现了给原始类添加附加功能的目的。</p>\n<h5 id=\"代理模式应用场景\"><a href=\"#代理模式应用场景\" class=\"headerlink\" title=\"代理模式应用场景\"></a>代理模式应用场景</h5><p>1.业务系统的非功能性需求开发</p>\n<p>代理模式最常用的应用场景，在业务系统中开发一些非功能性需求，监控、统计、鉴权、限流、事务、幂等、日志。将这些附加功能和业务功能解耦，放到代理类中统一处理。</p>\n<p>rpc的demo <a href=\"https://github.com/wangzheng0822/codedesign/tree/master/com/xzg/cd/rpc\">https://github.com/wangzheng0822/codedesign/tree/master/com/xzg/cd/rpc</a></p>\n<p>2.代理模式在RPC、缓存中的应用</p>\n<p>实际上，RPC框架也可以看作一种代理模式，《设计模式》中把它叫做远程代理，通过远程代理，将网络通信、数据编解码等细节隐藏起来。客户端在使用RPC服务的时候，就像使用本地函数一样，无需了解跟服务器交互的细节。</p>\n<p>缓存中的应用。假设我们要开发一个接口请求的缓存功能，对于某些接口请求，如果入参相同，在设定的过期内，直接返回缓存结果，而不用重新进行逻辑处理。比如，针对获取用户个人信息，我们可以开发两个接口，一个支持缓存，一个支持实时查询。动态代理模式可以很好的解决这个问题，如果基于spring开发的话，可以在AOP切面中完成接口缓存的功能。应用启动的时候，从配置文件加载需要支持缓存的接口，以及相应的缓存策略（比如过期时间）等，当请求到来的时候，我们在AOP切面中拦截请求，如果满足策略，便从缓存中获取数据直接返回。</p>\n"},{"layout":"post","title":"设计模式之享元模式","description":"设计模式之享元模式","date":"2021-06-01T05:26:10.000Z","_content":"\n所谓“享元”，顾名思义就是被共享的单元。享元模式的意图是复用对象，节省内存，前提是享元对象是不可变对象。\n\n具体来讲，当一个系统中存在大量重复对象的时候，如果这些重复的对象是不可变对象，我们就可以利用享元模式将对象设计成享元，在内存中只保留一份实例，供多处代码引用。这样可以减少内存中对象的数量，起到节省内存的目的。实际上，不仅仅相同对象可以设计成享元，对于相似对象，可以将这些对象中相同的部分（字段）提取出来，设计成享元，让这些大量对象引用这些享元。\n\n不可变对象指的是，一旦通过构造函数初始化完成之后，它的状态（对象的成员变量或者属性）就不会再被修改了。不可变对象不能暴露任何set()等修改内部状态的方法。之所以要求享元是不可变对象，是因为它被多处代码共享使用，避免一处代码对享元进行了修改，影响到其他使用它的代码。\n\n假设我们在开发一个棋牌游戏（比如象棋）。一个游戏厅中有成千上万个“房间”，每个房间对应一个棋局。棋局要保存每个棋子的数据，比如：棋子类型（将、相、士、炮等）、棋子颜色（红方、黑方）、棋子在棋局中的位置。利用这些数据，我们就能显示一个完整的棋盘给玩家。ChessPiece类表示棋子，ChessBoard类表示一个棋局，里面保存了象棋中30个棋子的信息。\n\n```java\npublic class ChessPiece { //棋子\n  private int id;\n  private String text;\n  private Color color;\n  private int positionX;\n  private int positionY;\n  \n  public ChessPiece(int id, String text, Color color, int positionX, int positionY) {\n    this.id = id; \n    this.text = text; \n    this.color = color; \n    this.positionX = positionX; this.positionY = positionX; \n  }\n  \n  public static enum Color {\n    RED,BLACK;\n  }\n  // ... 省略其他属性和getter/setter方法...\n}\n\npublic class ChessBoard { //棋局\n  private Map<Integer,ChessPiece> chessPieces = new HashMap<>();\n  \n  public ChessBoard(){\n    init();\n  }\n  \n  private void init() {\n    chessPirces.put(1,new ChessPiece(1,\"車\",ChessPiece.Color.BLACK,0,0));\n    chessPirces.put(2,new ChessPiece(2,\"馬\",ChessPiece.Color.BLACK,0,1));\n    //...省略摆放其他棋子的代码...\n  }\n  \n  public void move(int chessPieceId,int toPositionX,int toPositionY){\n    //...\n  }\n}\n```\n\n为了记录每个房间当前的棋局情况，我们需要给每个房间都创建一个ChessBoard棋局对象。因为游戏大厅中有成千上万的房间，那保存着么多棋局对象就会消耗大量的内存。有没有办法来节省内存呢？\n\n这个时候，就可以考虑享元模式了。刚才的实现中，内存中存在大量的相似对象，这些对象的id、text、color都是相同的，只有positionX、positionY不同。我们可以将棋子的id、text、color属性拆分出来，设计成独立的类，并且作为享元供多个棋盘复用。\n\n```java\n//享元类\npublic class ChessPieceUnit {\n  private int id;\n  private String text;\n  private Color color;\n  public ChessPieceUnit(int id, String text, Color color) {\n    this.id = id;\n    this.text = text;\n    this.color = color;\n  }\n  \n  public static enum Color {\n    RED,BLACK;\n  }\n  // ...省略其他属性和getter方法...\n}\n\npublic class ChessPieceUnitFactory {\n  private static final Map<Integer,ChessPieceUnit> pieces = new HashMap<>();\n  \n  static {\n    pieces.put(1,new ChessPieceUnit(1,\"車\"，ChessPieceUnit.Color.BLACK));\n    pieces.put(2,new ChessPieceUnit(2,\"馬\"，ChessPieceUnit.Color.BLACK));\n    //...省略其他棋子...\n  }\n  \n  public static ChessPieceUnit getChessPiece(int chessPieceId) {\n    return pieces.get(chessPieceId);\n  }\n}\n\npublic class ChessPiece {\n  private ChessPieceUnit chessPieceUnit;\n  private int positionX;\n  private int positionY;\n  \n  public ChessPiece(ChessPieceUnit unit,int positionX,int positionY) {\n    this.chessPieceUnit = unit;\n    this.positionX = positionX;\n    this.positionY = positionY;\n  }\n  //省略 getter、setter方法\n}\n\npublic class ChessBoard {\n  private Map<Integer,ChessPiece> chessPieces = new HashMap<>();\n  \n  public ChessBoard() {\n    init();\n  }\n  \n  private void init() {\n    chessPieces.put(1,new ChessPiece(ChessPieceUnitFactory.getChessPiece(1),0,0));\n    chessPieces.put(2,new ChessPiece(ChessPieceUnitFactory.getChessPiece(2),1,0));\n    //...省略摆放其他棋子代码...\n  }\n  \n  public void move(int chessPieceId,int toPositionX,int toPositionY){\n    //...\n  }\n}\n```\n\n通过利用工厂类来缓存ChesspieceUnit信息（id、text、color）。通过工厂类获取到的ChessPieceUnit就是享元。所有的ChessBoard对象共享30个ChessPieceUnit对象（象棋中的30个棋子）。在使用享元模式之前，一万个棋局需要30万个棋子对象（拥有同样的id、text、color）。使用享元模式后，30万个棋子对象都使用了共享30个基本棋子信息（id、text、color），大大节省了内存。\n\n总结一下享元模式的代码结构，主要是通过工厂模式，在工厂类中，通过一个Map来缓存已经创建过的享元对象，来达到复用的目的。\n\n##### 享元模式 vs 单例、缓存、对象池\n\n享元模式跟单例的区别\n\n单例模式中，一个类只能创建一个对象，每个对象被多处代码引用共享。区别两种设计模式，不能光看代码实现，而是要看设计意图，也就是看要解决的问题。尽管从代码实现上来看，享元模式和多例有很多相似之处，但从设计意图上来看，它们是完全不同的。应用享元模式是为了对象复用，节省内存，而应用多例模式是为了限制对象的个数。\n\n享元模式跟缓存的区别\n\n享元模式的实现中，通过工厂类来“缓存”已经创建好的对象。这里的缓存是存储的意思，跟平时所说的“数据库缓存”“CPU缓存”“MemCache缓存”是两回事。我们平时讲的缓存，主要是为了提高访问效率，而非复用。\n\n享元模式跟对象池的区别\n\n对象池、连接池（数据库连接池）、线程池等也是为了复用，那么跟享元模式有什么区别呢？\n\n像C++这样的编程语言，内存管理是程序员负责的。为了避免频繁地进行对象创建和释放导致内存碎片，我们可以预先申请一片连续的内存空间，也就是这里说的对象池。每次创建对象时，我们从对象池中直接取出一个空闲对象来使用，对象使用完成之后，再放回到对象池中以供后续复用，而非直接释放掉。\n\n池化技术中的“复用”可以理解为“重复使用”，主要目的是节省时间（比如从数据库连接池中取一个连接，不需要重新创建）。在任意时刻，每一个对象、连接、线程，并不会被多处使用，而是被一个使用者独占，当使用完成之后，放回到池中，再由其他使用者重复利用。享元模式中的“复用”可以理解为“共享使用”，在真个生命周期中，都是被所有使用者共享的，主要目的是节省空间。\n\n##### 享元模式在Java Integer中的应用\n\n```java\nInteger i1 = 56;\nInteger i2 = 56;\nInteger i3 = 129;\nInteger i4 = 129;\nSystem.out.println(i1 == i2);\nSystem.out.println(i3 == i4);\n```\n\n使用“==”来判定两个对象是否相等的时候，实际上是在判断两个局部变量存储的地址是否相同，也就是在判断两个局部变量是否指向相同的对象。上面的答案是一个true，一个false。因为Integer用到了享元模式来复用对象，所以导致了这样的结果。当通过自动装箱，调用valueOf()来创建Integer对象的时候，如果Integer对象的值在-128到127之间，会从IntegerCache类中直接返回，否则才调用new方法创建。Integer类的valueOf()函数的具体代码如下：\n\n```java\npublic static Integer valueOf(int i) {\n  if(i >= IntegerCache.low && i <= IntegerCache.high) \n    return IntegerCache.cache[i + (-IntegerCache.low)];\n  return new Integer(i);\n}\n```\n\n这里的IntegerCache相当于生成享元对象的工厂类。这个类是Integer的内部类\n\n```java\n/**\n * Cache to support the object identity semantics of autoboxing for values between\n * -128 and 127 (inclusive) as required by JLS.\n *\n * The cache is initialized on first usage.  The size of the cache\n * may be controlled by the {@code -XX:AutoBoxCacheMax=<size>} option.\n * During VM initialization, java.lang.Integer.IntegerCache.high property\n * may be set and saved in the private system properties in the\n * sun.misc.VM class.\n */\nprivate static class IntegerCache {\n    static final int low = -128;\n    static final int high;\n    static final Integer cache[];\n\n    static {\n        // high value may be configured by property\n        int h = 127;\n        String integerCacheHighPropValue =\n            sun.misc.VM.getSavedProperty(\"java.lang.Integer.IntegerCache.high\");\n        if (integerCacheHighPropValue != null) {\n            try {\n                int i = parseInt(integerCacheHighPropValue);\n                i = Math.max(i, 127);\n                // Maximum array size is Integer.MAX_VALUE\n                h = Math.min(i, Integer.MAX_VALUE - (-low) -1);\n            } catch( NumberFormatException nfe) {\n                // If the property cannot be parsed into an int, ignore it.\n            }\n        }\n        high = h;\n\n        cache = new Integer[(high - low) + 1];\n        int j = low;\n        for(int k = 0; k < cache.length; k++)\n            cache[k] = new Integer(j++);\n\n        // range [-128, 127] must be interned (JLS7 5.1.7)\n        assert IntegerCache.high >= 127;\n    }\n\n    private IntegerCache() {}\n}\n```\n\n为什么IntegerCache只缓存-128到127之间的整型值呢？\n\n在IntegerCache的代码实现中，这个类被加载的时候，缓存的享元对象会被一次性创建好。但是整型值太多了，不可能在IntegerCache类中预先创建好所有的整形值，这样既占用很多内存，也使加载IntegerCache类的时间过长。所以只能选择缓存大部分应用最常用的整型值，也就是一个字节的大小(-128到127之间的数据)。\n\nJDK也提供了可以自定义缓存的最大值的方式。如果应用使用-128到255之间的数据占用的内存比较多，可以将缓存的最大值从127调整到255。不过JDK并没有提供设置最小值的方法。\n\n```\n//方法一\n-Djava.lang.Integer.IntegerCache.high=255\n//方法二\n-XX:AutoBoxCacheMax=255\n```\n\n除了Integer类型之外，其他保障器类型，Long、Short、Byte等，也都利用享元模式来缓存-128到127之间的数据。\n\nLongCache享元工厂类以及valueOf函数代码如下：\n\n```java\nprivate static class LongCache {\n    private LongCache(){}\n\n    static final Long cache[] = new Long[-(-128) + 127 + 1];\n\n    static {\n        for(int i = 0; i < cache.length; i++)\n            cache[i] = new Long(i - 128);\n    }\n}\n\npublic static Long valueOf(long l) {\n    final int offset = 128;\n    if (l >= -128 && l <= 127) { // will cache\n        return LongCache.cache[(int)l + offset];\n    }\n    return new Long(l);\n}\n```\n\n平时开发中，对于三种创建整型对象的方式，优先使用后两种。\n\n```java\nInteger a = new Integer(123);\nInteger a = 123;\nInteger a = Integer.valueOf(123);\n```\n\n第一种创建方式不会使用到IntegerCache，后两种都可以利用IntegerCache缓存，返回共享的对象，以达到节省内存的目的。举个极端的例子，假设程序需要插棍见一万个-128到127之间的Integer对象，使用第一种方式，需要分配1万个Integer对象的内存空间，使用后两种创建方式，最多只需要256个Integer对象的内存空间。\n\n##### 享元模式在Java String中的应用\n\n```java\nString s1 = \"小争哥\";\nString s2 = \"小争哥\";\nString s3 = new String(\"小争哥\");\n\nSystem.out.println(s1 == s2);\nSystem.out.println(s1 == s3);\n```\n\n上面的结果，一个true，一个false。跟Integer类的设计思路相似。String类利用享元模式来复用相同的字符串常量（也就是代码中的“小争哥”）。JVM会专门开辟一块存储区来存储字符串常量，这块存储区叫做“字符串常量池”。\n\n不过，String类的享元模式的设计，跟Integer类稍微有些不同。Integer要共享的对象，是在类加载的时候，集中一次性创建好，但是对于字符串来说，没办法事先知道要共享哪些字符串常量，所以没办法事先创建好，只能在某个字符串常量第一次被用到的时候，存储到常量池中，当之后再用到的时候，直接引用常量池中已经存在的即可，就不需要再重新创建了。\n\n但是享元模式对JVM的垃圾回收并不友好。因为享元工厂类一致保存了对享元对象的引用，这就导致享元对象在没有任何代码使用的情况下，也不会被JVM垃圾回收机制自动回收掉。因此，在某些情况下，如果对象的生命周期很短，也不会被密集使用，利用享元模式反而会浪费更多内存。\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/设计模式之享元模式.md","raw":"---\nlayout:    post\ntitle:     设计模式之享元模式\ncategory:  设计模式之美\ndescription: 设计模式之享元模式\ntags: 设计模式之美\ndate: 2021/06/01 13:26:10\n---\n\n所谓“享元”，顾名思义就是被共享的单元。享元模式的意图是复用对象，节省内存，前提是享元对象是不可变对象。\n\n具体来讲，当一个系统中存在大量重复对象的时候，如果这些重复的对象是不可变对象，我们就可以利用享元模式将对象设计成享元，在内存中只保留一份实例，供多处代码引用。这样可以减少内存中对象的数量，起到节省内存的目的。实际上，不仅仅相同对象可以设计成享元，对于相似对象，可以将这些对象中相同的部分（字段）提取出来，设计成享元，让这些大量对象引用这些享元。\n\n不可变对象指的是，一旦通过构造函数初始化完成之后，它的状态（对象的成员变量或者属性）就不会再被修改了。不可变对象不能暴露任何set()等修改内部状态的方法。之所以要求享元是不可变对象，是因为它被多处代码共享使用，避免一处代码对享元进行了修改，影响到其他使用它的代码。\n\n假设我们在开发一个棋牌游戏（比如象棋）。一个游戏厅中有成千上万个“房间”，每个房间对应一个棋局。棋局要保存每个棋子的数据，比如：棋子类型（将、相、士、炮等）、棋子颜色（红方、黑方）、棋子在棋局中的位置。利用这些数据，我们就能显示一个完整的棋盘给玩家。ChessPiece类表示棋子，ChessBoard类表示一个棋局，里面保存了象棋中30个棋子的信息。\n\n```java\npublic class ChessPiece { //棋子\n  private int id;\n  private String text;\n  private Color color;\n  private int positionX;\n  private int positionY;\n  \n  public ChessPiece(int id, String text, Color color, int positionX, int positionY) {\n    this.id = id; \n    this.text = text; \n    this.color = color; \n    this.positionX = positionX; this.positionY = positionX; \n  }\n  \n  public static enum Color {\n    RED,BLACK;\n  }\n  // ... 省略其他属性和getter/setter方法...\n}\n\npublic class ChessBoard { //棋局\n  private Map<Integer,ChessPiece> chessPieces = new HashMap<>();\n  \n  public ChessBoard(){\n    init();\n  }\n  \n  private void init() {\n    chessPirces.put(1,new ChessPiece(1,\"車\",ChessPiece.Color.BLACK,0,0));\n    chessPirces.put(2,new ChessPiece(2,\"馬\",ChessPiece.Color.BLACK,0,1));\n    //...省略摆放其他棋子的代码...\n  }\n  \n  public void move(int chessPieceId,int toPositionX,int toPositionY){\n    //...\n  }\n}\n```\n\n为了记录每个房间当前的棋局情况，我们需要给每个房间都创建一个ChessBoard棋局对象。因为游戏大厅中有成千上万的房间，那保存着么多棋局对象就会消耗大量的内存。有没有办法来节省内存呢？\n\n这个时候，就可以考虑享元模式了。刚才的实现中，内存中存在大量的相似对象，这些对象的id、text、color都是相同的，只有positionX、positionY不同。我们可以将棋子的id、text、color属性拆分出来，设计成独立的类，并且作为享元供多个棋盘复用。\n\n```java\n//享元类\npublic class ChessPieceUnit {\n  private int id;\n  private String text;\n  private Color color;\n  public ChessPieceUnit(int id, String text, Color color) {\n    this.id = id;\n    this.text = text;\n    this.color = color;\n  }\n  \n  public static enum Color {\n    RED,BLACK;\n  }\n  // ...省略其他属性和getter方法...\n}\n\npublic class ChessPieceUnitFactory {\n  private static final Map<Integer,ChessPieceUnit> pieces = new HashMap<>();\n  \n  static {\n    pieces.put(1,new ChessPieceUnit(1,\"車\"，ChessPieceUnit.Color.BLACK));\n    pieces.put(2,new ChessPieceUnit(2,\"馬\"，ChessPieceUnit.Color.BLACK));\n    //...省略其他棋子...\n  }\n  \n  public static ChessPieceUnit getChessPiece(int chessPieceId) {\n    return pieces.get(chessPieceId);\n  }\n}\n\npublic class ChessPiece {\n  private ChessPieceUnit chessPieceUnit;\n  private int positionX;\n  private int positionY;\n  \n  public ChessPiece(ChessPieceUnit unit,int positionX,int positionY) {\n    this.chessPieceUnit = unit;\n    this.positionX = positionX;\n    this.positionY = positionY;\n  }\n  //省略 getter、setter方法\n}\n\npublic class ChessBoard {\n  private Map<Integer,ChessPiece> chessPieces = new HashMap<>();\n  \n  public ChessBoard() {\n    init();\n  }\n  \n  private void init() {\n    chessPieces.put(1,new ChessPiece(ChessPieceUnitFactory.getChessPiece(1),0,0));\n    chessPieces.put(2,new ChessPiece(ChessPieceUnitFactory.getChessPiece(2),1,0));\n    //...省略摆放其他棋子代码...\n  }\n  \n  public void move(int chessPieceId,int toPositionX,int toPositionY){\n    //...\n  }\n}\n```\n\n通过利用工厂类来缓存ChesspieceUnit信息（id、text、color）。通过工厂类获取到的ChessPieceUnit就是享元。所有的ChessBoard对象共享30个ChessPieceUnit对象（象棋中的30个棋子）。在使用享元模式之前，一万个棋局需要30万个棋子对象（拥有同样的id、text、color）。使用享元模式后，30万个棋子对象都使用了共享30个基本棋子信息（id、text、color），大大节省了内存。\n\n总结一下享元模式的代码结构，主要是通过工厂模式，在工厂类中，通过一个Map来缓存已经创建过的享元对象，来达到复用的目的。\n\n##### 享元模式 vs 单例、缓存、对象池\n\n享元模式跟单例的区别\n\n单例模式中，一个类只能创建一个对象，每个对象被多处代码引用共享。区别两种设计模式，不能光看代码实现，而是要看设计意图，也就是看要解决的问题。尽管从代码实现上来看，享元模式和多例有很多相似之处，但从设计意图上来看，它们是完全不同的。应用享元模式是为了对象复用，节省内存，而应用多例模式是为了限制对象的个数。\n\n享元模式跟缓存的区别\n\n享元模式的实现中，通过工厂类来“缓存”已经创建好的对象。这里的缓存是存储的意思，跟平时所说的“数据库缓存”“CPU缓存”“MemCache缓存”是两回事。我们平时讲的缓存，主要是为了提高访问效率，而非复用。\n\n享元模式跟对象池的区别\n\n对象池、连接池（数据库连接池）、线程池等也是为了复用，那么跟享元模式有什么区别呢？\n\n像C++这样的编程语言，内存管理是程序员负责的。为了避免频繁地进行对象创建和释放导致内存碎片，我们可以预先申请一片连续的内存空间，也就是这里说的对象池。每次创建对象时，我们从对象池中直接取出一个空闲对象来使用，对象使用完成之后，再放回到对象池中以供后续复用，而非直接释放掉。\n\n池化技术中的“复用”可以理解为“重复使用”，主要目的是节省时间（比如从数据库连接池中取一个连接，不需要重新创建）。在任意时刻，每一个对象、连接、线程，并不会被多处使用，而是被一个使用者独占，当使用完成之后，放回到池中，再由其他使用者重复利用。享元模式中的“复用”可以理解为“共享使用”，在真个生命周期中，都是被所有使用者共享的，主要目的是节省空间。\n\n##### 享元模式在Java Integer中的应用\n\n```java\nInteger i1 = 56;\nInteger i2 = 56;\nInteger i3 = 129;\nInteger i4 = 129;\nSystem.out.println(i1 == i2);\nSystem.out.println(i3 == i4);\n```\n\n使用“==”来判定两个对象是否相等的时候，实际上是在判断两个局部变量存储的地址是否相同，也就是在判断两个局部变量是否指向相同的对象。上面的答案是一个true，一个false。因为Integer用到了享元模式来复用对象，所以导致了这样的结果。当通过自动装箱，调用valueOf()来创建Integer对象的时候，如果Integer对象的值在-128到127之间，会从IntegerCache类中直接返回，否则才调用new方法创建。Integer类的valueOf()函数的具体代码如下：\n\n```java\npublic static Integer valueOf(int i) {\n  if(i >= IntegerCache.low && i <= IntegerCache.high) \n    return IntegerCache.cache[i + (-IntegerCache.low)];\n  return new Integer(i);\n}\n```\n\n这里的IntegerCache相当于生成享元对象的工厂类。这个类是Integer的内部类\n\n```java\n/**\n * Cache to support the object identity semantics of autoboxing for values between\n * -128 and 127 (inclusive) as required by JLS.\n *\n * The cache is initialized on first usage.  The size of the cache\n * may be controlled by the {@code -XX:AutoBoxCacheMax=<size>} option.\n * During VM initialization, java.lang.Integer.IntegerCache.high property\n * may be set and saved in the private system properties in the\n * sun.misc.VM class.\n */\nprivate static class IntegerCache {\n    static final int low = -128;\n    static final int high;\n    static final Integer cache[];\n\n    static {\n        // high value may be configured by property\n        int h = 127;\n        String integerCacheHighPropValue =\n            sun.misc.VM.getSavedProperty(\"java.lang.Integer.IntegerCache.high\");\n        if (integerCacheHighPropValue != null) {\n            try {\n                int i = parseInt(integerCacheHighPropValue);\n                i = Math.max(i, 127);\n                // Maximum array size is Integer.MAX_VALUE\n                h = Math.min(i, Integer.MAX_VALUE - (-low) -1);\n            } catch( NumberFormatException nfe) {\n                // If the property cannot be parsed into an int, ignore it.\n            }\n        }\n        high = h;\n\n        cache = new Integer[(high - low) + 1];\n        int j = low;\n        for(int k = 0; k < cache.length; k++)\n            cache[k] = new Integer(j++);\n\n        // range [-128, 127] must be interned (JLS7 5.1.7)\n        assert IntegerCache.high >= 127;\n    }\n\n    private IntegerCache() {}\n}\n```\n\n为什么IntegerCache只缓存-128到127之间的整型值呢？\n\n在IntegerCache的代码实现中，这个类被加载的时候，缓存的享元对象会被一次性创建好。但是整型值太多了，不可能在IntegerCache类中预先创建好所有的整形值，这样既占用很多内存，也使加载IntegerCache类的时间过长。所以只能选择缓存大部分应用最常用的整型值，也就是一个字节的大小(-128到127之间的数据)。\n\nJDK也提供了可以自定义缓存的最大值的方式。如果应用使用-128到255之间的数据占用的内存比较多，可以将缓存的最大值从127调整到255。不过JDK并没有提供设置最小值的方法。\n\n```\n//方法一\n-Djava.lang.Integer.IntegerCache.high=255\n//方法二\n-XX:AutoBoxCacheMax=255\n```\n\n除了Integer类型之外，其他保障器类型，Long、Short、Byte等，也都利用享元模式来缓存-128到127之间的数据。\n\nLongCache享元工厂类以及valueOf函数代码如下：\n\n```java\nprivate static class LongCache {\n    private LongCache(){}\n\n    static final Long cache[] = new Long[-(-128) + 127 + 1];\n\n    static {\n        for(int i = 0; i < cache.length; i++)\n            cache[i] = new Long(i - 128);\n    }\n}\n\npublic static Long valueOf(long l) {\n    final int offset = 128;\n    if (l >= -128 && l <= 127) { // will cache\n        return LongCache.cache[(int)l + offset];\n    }\n    return new Long(l);\n}\n```\n\n平时开发中，对于三种创建整型对象的方式，优先使用后两种。\n\n```java\nInteger a = new Integer(123);\nInteger a = 123;\nInteger a = Integer.valueOf(123);\n```\n\n第一种创建方式不会使用到IntegerCache，后两种都可以利用IntegerCache缓存，返回共享的对象，以达到节省内存的目的。举个极端的例子，假设程序需要插棍见一万个-128到127之间的Integer对象，使用第一种方式，需要分配1万个Integer对象的内存空间，使用后两种创建方式，最多只需要256个Integer对象的内存空间。\n\n##### 享元模式在Java String中的应用\n\n```java\nString s1 = \"小争哥\";\nString s2 = \"小争哥\";\nString s3 = new String(\"小争哥\");\n\nSystem.out.println(s1 == s2);\nSystem.out.println(s1 == s3);\n```\n\n上面的结果，一个true，一个false。跟Integer类的设计思路相似。String类利用享元模式来复用相同的字符串常量（也就是代码中的“小争哥”）。JVM会专门开辟一块存储区来存储字符串常量，这块存储区叫做“字符串常量池”。\n\n不过，String类的享元模式的设计，跟Integer类稍微有些不同。Integer要共享的对象，是在类加载的时候，集中一次性创建好，但是对于字符串来说，没办法事先知道要共享哪些字符串常量，所以没办法事先创建好，只能在某个字符串常量第一次被用到的时候，存储到常量池中，当之后再用到的时候，直接引用常量池中已经存在的即可，就不需要再重新创建了。\n\n但是享元模式对JVM的垃圾回收并不友好。因为享元工厂类一致保存了对享元对象的引用，这就导致享元对象在没有任何代码使用的情况下，也不会被JVM垃圾回收机制自动回收掉。因此，在某些情况下，如果对象的生命周期很短，也不会被密集使用，利用享元模式反而会浪费更多内存。\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"设计模式之享元模式","published":1,"updated":"2021-06-01T05:26:10.000Z","comments":1,"photos":[],"link":"","_id":"cm1m304xk001b31b4hrzcgurc","content":"<p>所谓“享元”，顾名思义就是被共享的单元。享元模式的意图是复用对象，节省内存，前提是享元对象是不可变对象。</p>\n<p>具体来讲，当一个系统中存在大量重复对象的时候，如果这些重复的对象是不可变对象，我们就可以利用享元模式将对象设计成享元，在内存中只保留一份实例，供多处代码引用。这样可以减少内存中对象的数量，起到节省内存的目的。实际上，不仅仅相同对象可以设计成享元，对于相似对象，可以将这些对象中相同的部分（字段）提取出来，设计成享元，让这些大量对象引用这些享元。</p>\n<p>不可变对象指的是，一旦通过构造函数初始化完成之后，它的状态（对象的成员变量或者属性）就不会再被修改了。不可变对象不能暴露任何set()等修改内部状态的方法。之所以要求享元是不可变对象，是因为它被多处代码共享使用，避免一处代码对享元进行了修改，影响到其他使用它的代码。</p>\n<p>假设我们在开发一个棋牌游戏（比如象棋）。一个游戏厅中有成千上万个“房间”，每个房间对应一个棋局。棋局要保存每个棋子的数据，比如：棋子类型（将、相、士、炮等）、棋子颜色（红方、黑方）、棋子在棋局中的位置。利用这些数据，我们就能显示一个完整的棋盘给玩家。ChessPiece类表示棋子，ChessBoard类表示一个棋局，里面保存了象棋中30个棋子的信息。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ChessPiece</span> </span>&#123; <span class=\"comment\">//棋子</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> id;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> String text;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Color color;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> positionX;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> positionY;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ChessPiece</span><span class=\"params\">(<span class=\"keyword\">int</span> id, String text, Color color, <span class=\"keyword\">int</span> positionX, <span class=\"keyword\">int</span> positionY)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.id = id; </span><br><span class=\"line\">    <span class=\"keyword\">this</span>.text = text; </span><br><span class=\"line\">    <span class=\"keyword\">this</span>.color = color; </span><br><span class=\"line\">    <span class=\"keyword\">this</span>.positionX = positionX; <span class=\"keyword\">this</span>.positionY = positionX; </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">Color</span> </span>&#123;</span><br><span class=\"line\">    RED,BLACK;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// ... 省略其他属性和getter/setter方法...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ChessBoard</span> </span>&#123; <span class=\"comment\">//棋局</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> Map&lt;Integer,ChessPiece&gt; chessPieces = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ChessBoard</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    init();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    chessPirces.put(<span class=\"number\">1</span>,<span class=\"keyword\">new</span> ChessPiece(<span class=\"number\">1</span>,<span class=\"string\">&quot;車&quot;</span>,ChessPiece.Color.BLACK,<span class=\"number\">0</span>,<span class=\"number\">0</span>));</span><br><span class=\"line\">    chessPirces.put(<span class=\"number\">2</span>,<span class=\"keyword\">new</span> ChessPiece(<span class=\"number\">2</span>,<span class=\"string\">&quot;馬&quot;</span>,ChessPiece.Color.BLACK,<span class=\"number\">0</span>,<span class=\"number\">1</span>));</span><br><span class=\"line\">    <span class=\"comment\">//...省略摆放其他棋子的代码...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">move</span><span class=\"params\">(<span class=\"keyword\">int</span> chessPieceId,<span class=\"keyword\">int</span> toPositionX,<span class=\"keyword\">int</span> toPositionY)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>为了记录每个房间当前的棋局情况，我们需要给每个房间都创建一个ChessBoard棋局对象。因为游戏大厅中有成千上万的房间，那保存着么多棋局对象就会消耗大量的内存。有没有办法来节省内存呢？</p>\n<p>这个时候，就可以考虑享元模式了。刚才的实现中，内存中存在大量的相似对象，这些对象的id、text、color都是相同的，只有positionX、positionY不同。我们可以将棋子的id、text、color属性拆分出来，设计成独立的类，并且作为享元供多个棋盘复用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//享元类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ChessPieceUnit</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> id;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> String text;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Color color;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ChessPieceUnit</span><span class=\"params\">(<span class=\"keyword\">int</span> id, String text, Color color)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.id = id;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.text = text;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.color = color;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">Color</span> </span>&#123;</span><br><span class=\"line\">    RED,BLACK;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// ...省略其他属性和getter方法...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ChessPieceUnitFactory</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Map&lt;Integer,ChessPieceUnit&gt; pieces = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">    pieces.put(<span class=\"number\">1</span>,<span class=\"keyword\">new</span> ChessPieceUnit(<span class=\"number\">1</span>,<span class=\"string\">&quot;車&quot;</span>，ChessPieceUnit.Color.BLACK));</span><br><span class=\"line\">    pieces.put(<span class=\"number\">2</span>,<span class=\"keyword\">new</span> ChessPieceUnit(<span class=\"number\">2</span>,<span class=\"string\">&quot;馬&quot;</span>，ChessPieceUnit.Color.BLACK));</span><br><span class=\"line\">    <span class=\"comment\">//...省略其他棋子...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ChessPieceUnit <span class=\"title\">getChessPiece</span><span class=\"params\">(<span class=\"keyword\">int</span> chessPieceId)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pieces.get(chessPieceId);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ChessPiece</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> ChessPieceUnit chessPieceUnit;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> positionX;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> positionY;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ChessPiece</span><span class=\"params\">(ChessPieceUnit unit,<span class=\"keyword\">int</span> positionX,<span class=\"keyword\">int</span> positionY)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.chessPieceUnit = unit;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.positionX = positionX;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.positionY = positionY;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//省略 getter、setter方法</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ChessBoard</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Map&lt;Integer,ChessPiece&gt; chessPieces = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ChessBoard</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    init();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    chessPieces.put(<span class=\"number\">1</span>,<span class=\"keyword\">new</span> ChessPiece(ChessPieceUnitFactory.getChessPiece(<span class=\"number\">1</span>),<span class=\"number\">0</span>,<span class=\"number\">0</span>));</span><br><span class=\"line\">    chessPieces.put(<span class=\"number\">2</span>,<span class=\"keyword\">new</span> ChessPiece(ChessPieceUnitFactory.getChessPiece(<span class=\"number\">2</span>),<span class=\"number\">1</span>,<span class=\"number\">0</span>));</span><br><span class=\"line\">    <span class=\"comment\">//...省略摆放其他棋子代码...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">move</span><span class=\"params\">(<span class=\"keyword\">int</span> chessPieceId,<span class=\"keyword\">int</span> toPositionX,<span class=\"keyword\">int</span> toPositionY)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过利用工厂类来缓存ChesspieceUnit信息（id、text、color）。通过工厂类获取到的ChessPieceUnit就是享元。所有的ChessBoard对象共享30个ChessPieceUnit对象（象棋中的30个棋子）。在使用享元模式之前，一万个棋局需要30万个棋子对象（拥有同样的id、text、color）。使用享元模式后，30万个棋子对象都使用了共享30个基本棋子信息（id、text、color），大大节省了内存。</p>\n<p>总结一下享元模式的代码结构，主要是通过工厂模式，在工厂类中，通过一个Map来缓存已经创建过的享元对象，来达到复用的目的。</p>\n<h5 id=\"享元模式-vs-单例、缓存、对象池\"><a href=\"#享元模式-vs-单例、缓存、对象池\" class=\"headerlink\" title=\"享元模式 vs 单例、缓存、对象池\"></a>享元模式 vs 单例、缓存、对象池</h5><p>享元模式跟单例的区别</p>\n<p>单例模式中，一个类只能创建一个对象，每个对象被多处代码引用共享。区别两种设计模式，不能光看代码实现，而是要看设计意图，也就是看要解决的问题。尽管从代码实现上来看，享元模式和多例有很多相似之处，但从设计意图上来看，它们是完全不同的。应用享元模式是为了对象复用，节省内存，而应用多例模式是为了限制对象的个数。</p>\n<p>享元模式跟缓存的区别</p>\n<p>享元模式的实现中，通过工厂类来“缓存”已经创建好的对象。这里的缓存是存储的意思，跟平时所说的“数据库缓存”“CPU缓存”“MemCache缓存”是两回事。我们平时讲的缓存，主要是为了提高访问效率，而非复用。</p>\n<p>享元模式跟对象池的区别</p>\n<p>对象池、连接池（数据库连接池）、线程池等也是为了复用，那么跟享元模式有什么区别呢？</p>\n<p>像C++这样的编程语言，内存管理是程序员负责的。为了避免频繁地进行对象创建和释放导致内存碎片，我们可以预先申请一片连续的内存空间，也就是这里说的对象池。每次创建对象时，我们从对象池中直接取出一个空闲对象来使用，对象使用完成之后，再放回到对象池中以供后续复用，而非直接释放掉。</p>\n<p>池化技术中的“复用”可以理解为“重复使用”，主要目的是节省时间（比如从数据库连接池中取一个连接，不需要重新创建）。在任意时刻，每一个对象、连接、线程，并不会被多处使用，而是被一个使用者独占，当使用完成之后，放回到池中，再由其他使用者重复利用。享元模式中的“复用”可以理解为“共享使用”，在真个生命周期中，都是被所有使用者共享的，主要目的是节省空间。</p>\n<h5 id=\"享元模式在Java-Integer中的应用\"><a href=\"#享元模式在Java-Integer中的应用\" class=\"headerlink\" title=\"享元模式在Java Integer中的应用\"></a>享元模式在Java Integer中的应用</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer i1 = <span class=\"number\">56</span>;</span><br><span class=\"line\">Integer i2 = <span class=\"number\">56</span>;</span><br><span class=\"line\">Integer i3 = <span class=\"number\">129</span>;</span><br><span class=\"line\">Integer i4 = <span class=\"number\">129</span>;</span><br><span class=\"line\">System.out.println(i1 == i2);</span><br><span class=\"line\">System.out.println(i3 == i4);</span><br></pre></td></tr></table></figure>\n\n<p>使用“==”来判定两个对象是否相等的时候，实际上是在判断两个局部变量存储的地址是否相同，也就是在判断两个局部变量是否指向相同的对象。上面的答案是一个true，一个false。因为Integer用到了享元模式来复用对象，所以导致了这样的结果。当通过自动装箱，调用valueOf()来创建Integer对象的时候，如果Integer对象的值在-128到127之间，会从IntegerCache类中直接返回，否则才调用new方法创建。Integer类的valueOf()函数的具体代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Integer <span class=\"title\">valueOf</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) </span><br><span class=\"line\">    <span class=\"keyword\">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Integer(i);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里的IntegerCache相当于生成享元对象的工厂类。这个类是Integer的内部类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Cache to support the object identity semantics of autoboxing for values between</span></span><br><span class=\"line\"><span class=\"comment\"> * -128 and 127 (inclusive) as required by JLS.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * The cache is initialized on first usage.  The size of the cache</span></span><br><span class=\"line\"><span class=\"comment\"> * may be controlled by the &#123;<span class=\"doctag\">@code</span> -XX:AutoBoxCacheMax=&lt;size&gt;&#125; option.</span></span><br><span class=\"line\"><span class=\"comment\"> * During VM initialization, java.lang.Integer.IntegerCache.high property</span></span><br><span class=\"line\"><span class=\"comment\"> * may be set and saved in the private system properties in the</span></span><br><span class=\"line\"><span class=\"comment\"> * sun.misc.VM class.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IntegerCache</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> low = -<span class=\"number\">128</span>;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> high;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Integer cache[];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// high value may be configured by property</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> h = <span class=\"number\">127</span>;</span><br><span class=\"line\">        String integerCacheHighPropValue =</span><br><span class=\"line\">            sun.misc.VM.getSavedProperty(<span class=\"string\">&quot;java.lang.Integer.IntegerCache.high&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (integerCacheHighPropValue != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class=\"line\">                i = Math.max(i, <span class=\"number\">127</span>);</span><br><span class=\"line\">                <span class=\"comment\">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class=\"line\">                h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span>( NumberFormatException nfe) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        high = h;</span><br><span class=\"line\"></span><br><span class=\"line\">        cache = <span class=\"keyword\">new</span> Integer[(high - low) + <span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> j = low;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k &lt; cache.length; k++)</span><br><span class=\"line\">            cache[k] = <span class=\"keyword\">new</span> Integer(j++);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class=\"line\">        <span class=\"keyword\">assert</span> IntegerCache.high &gt;= <span class=\"number\">127</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">IntegerCache</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>为什么IntegerCache只缓存-128到127之间的整型值呢？</p>\n<p>在IntegerCache的代码实现中，这个类被加载的时候，缓存的享元对象会被一次性创建好。但是整型值太多了，不可能在IntegerCache类中预先创建好所有的整形值，这样既占用很多内存，也使加载IntegerCache类的时间过长。所以只能选择缓存大部分应用最常用的整型值，也就是一个字节的大小(-128到127之间的数据)。</p>\n<p>JDK也提供了可以自定义缓存的最大值的方式。如果应用使用-128到255之间的数据占用的内存比较多，可以将缓存的最大值从127调整到255。不过JDK并没有提供设置最小值的方法。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//方法一</span><br><span class=\"line\">-Djava.lang.Integer.IntegerCache.high=255</span><br><span class=\"line\">//方法二</span><br><span class=\"line\">-XX:AutoBoxCacheMax=255</span><br></pre></td></tr></table></figure>\n\n<p>除了Integer类型之外，其他保障器类型，Long、Short、Byte等，也都利用享元模式来缓存-128到127之间的数据。</p>\n<p>LongCache享元工厂类以及valueOf函数代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LongCache</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">LongCache</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Long cache[] = <span class=\"keyword\">new</span> Long[-(-<span class=\"number\">128</span>) + <span class=\"number\">127</span> + <span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; cache.length; i++)</span><br><span class=\"line\">            cache[i] = <span class=\"keyword\">new</span> Long(i - <span class=\"number\">128</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Long <span class=\"title\">valueOf</span><span class=\"params\">(<span class=\"keyword\">long</span> l)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> offset = <span class=\"number\">128</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (l &gt;= -<span class=\"number\">128</span> &amp;&amp; l &lt;= <span class=\"number\">127</span>) &#123; <span class=\"comment\">// will cache</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> LongCache.cache[(<span class=\"keyword\">int</span>)l + offset];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Long(l);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>平时开发中，对于三种创建整型对象的方式，优先使用后两种。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer a = <span class=\"keyword\">new</span> Integer(<span class=\"number\">123</span>);</span><br><span class=\"line\">Integer a = <span class=\"number\">123</span>;</span><br><span class=\"line\">Integer a = Integer.valueOf(<span class=\"number\">123</span>);</span><br></pre></td></tr></table></figure>\n\n<p>第一种创建方式不会使用到IntegerCache，后两种都可以利用IntegerCache缓存，返回共享的对象，以达到节省内存的目的。举个极端的例子，假设程序需要插棍见一万个-128到127之间的Integer对象，使用第一种方式，需要分配1万个Integer对象的内存空间，使用后两种创建方式，最多只需要256个Integer对象的内存空间。</p>\n<h5 id=\"享元模式在Java-String中的应用\"><a href=\"#享元模式在Java-String中的应用\" class=\"headerlink\" title=\"享元模式在Java String中的应用\"></a>享元模式在Java String中的应用</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String s1 = <span class=\"string\">&quot;小争哥&quot;</span>;</span><br><span class=\"line\">String s2 = <span class=\"string\">&quot;小争哥&quot;</span>;</span><br><span class=\"line\">String s3 = <span class=\"keyword\">new</span> String(<span class=\"string\">&quot;小争哥&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(s1 == s2);</span><br><span class=\"line\">System.out.println(s1 == s3);</span><br></pre></td></tr></table></figure>\n\n<p>上面的结果，一个true，一个false。跟Integer类的设计思路相似。String类利用享元模式来复用相同的字符串常量（也就是代码中的“小争哥”）。JVM会专门开辟一块存储区来存储字符串常量，这块存储区叫做“字符串常量池”。</p>\n<p>不过，String类的享元模式的设计，跟Integer类稍微有些不同。Integer要共享的对象，是在类加载的时候，集中一次性创建好，但是对于字符串来说，没办法事先知道要共享哪些字符串常量，所以没办法事先创建好，只能在某个字符串常量第一次被用到的时候，存储到常量池中，当之后再用到的时候，直接引用常量池中已经存在的即可，就不需要再重新创建了。</p>\n<p>但是享元模式对JVM的垃圾回收并不友好。因为享元工厂类一致保存了对享元对象的引用，这就导致享元对象在没有任何代码使用的情况下，也不会被JVM垃圾回收机制自动回收掉。因此，在某些情况下，如果对象的生命周期很短，也不会被密集使用，利用享元模式反而会浪费更多内存。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>所谓“享元”，顾名思义就是被共享的单元。享元模式的意图是复用对象，节省内存，前提是享元对象是不可变对象。</p>\n<p>具体来讲，当一个系统中存在大量重复对象的时候，如果这些重复的对象是不可变对象，我们就可以利用享元模式将对象设计成享元，在内存中只保留一份实例，供多处代码引用。这样可以减少内存中对象的数量，起到节省内存的目的。实际上，不仅仅相同对象可以设计成享元，对于相似对象，可以将这些对象中相同的部分（字段）提取出来，设计成享元，让这些大量对象引用这些享元。</p>\n<p>不可变对象指的是，一旦通过构造函数初始化完成之后，它的状态（对象的成员变量或者属性）就不会再被修改了。不可变对象不能暴露任何set()等修改内部状态的方法。之所以要求享元是不可变对象，是因为它被多处代码共享使用，避免一处代码对享元进行了修改，影响到其他使用它的代码。</p>\n<p>假设我们在开发一个棋牌游戏（比如象棋）。一个游戏厅中有成千上万个“房间”，每个房间对应一个棋局。棋局要保存每个棋子的数据，比如：棋子类型（将、相、士、炮等）、棋子颜色（红方、黑方）、棋子在棋局中的位置。利用这些数据，我们就能显示一个完整的棋盘给玩家。ChessPiece类表示棋子，ChessBoard类表示一个棋局，里面保存了象棋中30个棋子的信息。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ChessPiece</span> </span>&#123; <span class=\"comment\">//棋子</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> id;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> String text;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Color color;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> positionX;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> positionY;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ChessPiece</span><span class=\"params\">(<span class=\"keyword\">int</span> id, String text, Color color, <span class=\"keyword\">int</span> positionX, <span class=\"keyword\">int</span> positionY)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.id = id; </span><br><span class=\"line\">    <span class=\"keyword\">this</span>.text = text; </span><br><span class=\"line\">    <span class=\"keyword\">this</span>.color = color; </span><br><span class=\"line\">    <span class=\"keyword\">this</span>.positionX = positionX; <span class=\"keyword\">this</span>.positionY = positionX; </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">Color</span> </span>&#123;</span><br><span class=\"line\">    RED,BLACK;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// ... 省略其他属性和getter/setter方法...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ChessBoard</span> </span>&#123; <span class=\"comment\">//棋局</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> Map&lt;Integer,ChessPiece&gt; chessPieces = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ChessBoard</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    init();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    chessPirces.put(<span class=\"number\">1</span>,<span class=\"keyword\">new</span> ChessPiece(<span class=\"number\">1</span>,<span class=\"string\">&quot;車&quot;</span>,ChessPiece.Color.BLACK,<span class=\"number\">0</span>,<span class=\"number\">0</span>));</span><br><span class=\"line\">    chessPirces.put(<span class=\"number\">2</span>,<span class=\"keyword\">new</span> ChessPiece(<span class=\"number\">2</span>,<span class=\"string\">&quot;馬&quot;</span>,ChessPiece.Color.BLACK,<span class=\"number\">0</span>,<span class=\"number\">1</span>));</span><br><span class=\"line\">    <span class=\"comment\">//...省略摆放其他棋子的代码...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">move</span><span class=\"params\">(<span class=\"keyword\">int</span> chessPieceId,<span class=\"keyword\">int</span> toPositionX,<span class=\"keyword\">int</span> toPositionY)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>为了记录每个房间当前的棋局情况，我们需要给每个房间都创建一个ChessBoard棋局对象。因为游戏大厅中有成千上万的房间，那保存着么多棋局对象就会消耗大量的内存。有没有办法来节省内存呢？</p>\n<p>这个时候，就可以考虑享元模式了。刚才的实现中，内存中存在大量的相似对象，这些对象的id、text、color都是相同的，只有positionX、positionY不同。我们可以将棋子的id、text、color属性拆分出来，设计成独立的类，并且作为享元供多个棋盘复用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//享元类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ChessPieceUnit</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> id;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> String text;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Color color;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ChessPieceUnit</span><span class=\"params\">(<span class=\"keyword\">int</span> id, String text, Color color)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.id = id;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.text = text;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.color = color;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">Color</span> </span>&#123;</span><br><span class=\"line\">    RED,BLACK;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// ...省略其他属性和getter方法...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ChessPieceUnitFactory</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Map&lt;Integer,ChessPieceUnit&gt; pieces = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">    pieces.put(<span class=\"number\">1</span>,<span class=\"keyword\">new</span> ChessPieceUnit(<span class=\"number\">1</span>,<span class=\"string\">&quot;車&quot;</span>，ChessPieceUnit.Color.BLACK));</span><br><span class=\"line\">    pieces.put(<span class=\"number\">2</span>,<span class=\"keyword\">new</span> ChessPieceUnit(<span class=\"number\">2</span>,<span class=\"string\">&quot;馬&quot;</span>，ChessPieceUnit.Color.BLACK));</span><br><span class=\"line\">    <span class=\"comment\">//...省略其他棋子...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ChessPieceUnit <span class=\"title\">getChessPiece</span><span class=\"params\">(<span class=\"keyword\">int</span> chessPieceId)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pieces.get(chessPieceId);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ChessPiece</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> ChessPieceUnit chessPieceUnit;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> positionX;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> positionY;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ChessPiece</span><span class=\"params\">(ChessPieceUnit unit,<span class=\"keyword\">int</span> positionX,<span class=\"keyword\">int</span> positionY)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.chessPieceUnit = unit;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.positionX = positionX;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.positionY = positionY;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//省略 getter、setter方法</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ChessBoard</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Map&lt;Integer,ChessPiece&gt; chessPieces = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ChessBoard</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    init();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    chessPieces.put(<span class=\"number\">1</span>,<span class=\"keyword\">new</span> ChessPiece(ChessPieceUnitFactory.getChessPiece(<span class=\"number\">1</span>),<span class=\"number\">0</span>,<span class=\"number\">0</span>));</span><br><span class=\"line\">    chessPieces.put(<span class=\"number\">2</span>,<span class=\"keyword\">new</span> ChessPiece(ChessPieceUnitFactory.getChessPiece(<span class=\"number\">2</span>),<span class=\"number\">1</span>,<span class=\"number\">0</span>));</span><br><span class=\"line\">    <span class=\"comment\">//...省略摆放其他棋子代码...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">move</span><span class=\"params\">(<span class=\"keyword\">int</span> chessPieceId,<span class=\"keyword\">int</span> toPositionX,<span class=\"keyword\">int</span> toPositionY)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过利用工厂类来缓存ChesspieceUnit信息（id、text、color）。通过工厂类获取到的ChessPieceUnit就是享元。所有的ChessBoard对象共享30个ChessPieceUnit对象（象棋中的30个棋子）。在使用享元模式之前，一万个棋局需要30万个棋子对象（拥有同样的id、text、color）。使用享元模式后，30万个棋子对象都使用了共享30个基本棋子信息（id、text、color），大大节省了内存。</p>\n<p>总结一下享元模式的代码结构，主要是通过工厂模式，在工厂类中，通过一个Map来缓存已经创建过的享元对象，来达到复用的目的。</p>\n<h5 id=\"享元模式-vs-单例、缓存、对象池\"><a href=\"#享元模式-vs-单例、缓存、对象池\" class=\"headerlink\" title=\"享元模式 vs 单例、缓存、对象池\"></a>享元模式 vs 单例、缓存、对象池</h5><p>享元模式跟单例的区别</p>\n<p>单例模式中，一个类只能创建一个对象，每个对象被多处代码引用共享。区别两种设计模式，不能光看代码实现，而是要看设计意图，也就是看要解决的问题。尽管从代码实现上来看，享元模式和多例有很多相似之处，但从设计意图上来看，它们是完全不同的。应用享元模式是为了对象复用，节省内存，而应用多例模式是为了限制对象的个数。</p>\n<p>享元模式跟缓存的区别</p>\n<p>享元模式的实现中，通过工厂类来“缓存”已经创建好的对象。这里的缓存是存储的意思，跟平时所说的“数据库缓存”“CPU缓存”“MemCache缓存”是两回事。我们平时讲的缓存，主要是为了提高访问效率，而非复用。</p>\n<p>享元模式跟对象池的区别</p>\n<p>对象池、连接池（数据库连接池）、线程池等也是为了复用，那么跟享元模式有什么区别呢？</p>\n<p>像C++这样的编程语言，内存管理是程序员负责的。为了避免频繁地进行对象创建和释放导致内存碎片，我们可以预先申请一片连续的内存空间，也就是这里说的对象池。每次创建对象时，我们从对象池中直接取出一个空闲对象来使用，对象使用完成之后，再放回到对象池中以供后续复用，而非直接释放掉。</p>\n<p>池化技术中的“复用”可以理解为“重复使用”，主要目的是节省时间（比如从数据库连接池中取一个连接，不需要重新创建）。在任意时刻，每一个对象、连接、线程，并不会被多处使用，而是被一个使用者独占，当使用完成之后，放回到池中，再由其他使用者重复利用。享元模式中的“复用”可以理解为“共享使用”，在真个生命周期中，都是被所有使用者共享的，主要目的是节省空间。</p>\n<h5 id=\"享元模式在Java-Integer中的应用\"><a href=\"#享元模式在Java-Integer中的应用\" class=\"headerlink\" title=\"享元模式在Java Integer中的应用\"></a>享元模式在Java Integer中的应用</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer i1 = <span class=\"number\">56</span>;</span><br><span class=\"line\">Integer i2 = <span class=\"number\">56</span>;</span><br><span class=\"line\">Integer i3 = <span class=\"number\">129</span>;</span><br><span class=\"line\">Integer i4 = <span class=\"number\">129</span>;</span><br><span class=\"line\">System.out.println(i1 == i2);</span><br><span class=\"line\">System.out.println(i3 == i4);</span><br></pre></td></tr></table></figure>\n\n<p>使用“==”来判定两个对象是否相等的时候，实际上是在判断两个局部变量存储的地址是否相同，也就是在判断两个局部变量是否指向相同的对象。上面的答案是一个true，一个false。因为Integer用到了享元模式来复用对象，所以导致了这样的结果。当通过自动装箱，调用valueOf()来创建Integer对象的时候，如果Integer对象的值在-128到127之间，会从IntegerCache类中直接返回，否则才调用new方法创建。Integer类的valueOf()函数的具体代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Integer <span class=\"title\">valueOf</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) </span><br><span class=\"line\">    <span class=\"keyword\">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Integer(i);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里的IntegerCache相当于生成享元对象的工厂类。这个类是Integer的内部类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Cache to support the object identity semantics of autoboxing for values between</span></span><br><span class=\"line\"><span class=\"comment\"> * -128 and 127 (inclusive) as required by JLS.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * The cache is initialized on first usage.  The size of the cache</span></span><br><span class=\"line\"><span class=\"comment\"> * may be controlled by the &#123;<span class=\"doctag\">@code</span> -XX:AutoBoxCacheMax=&lt;size&gt;&#125; option.</span></span><br><span class=\"line\"><span class=\"comment\"> * During VM initialization, java.lang.Integer.IntegerCache.high property</span></span><br><span class=\"line\"><span class=\"comment\"> * may be set and saved in the private system properties in the</span></span><br><span class=\"line\"><span class=\"comment\"> * sun.misc.VM class.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IntegerCache</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> low = -<span class=\"number\">128</span>;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> high;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Integer cache[];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// high value may be configured by property</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> h = <span class=\"number\">127</span>;</span><br><span class=\"line\">        String integerCacheHighPropValue =</span><br><span class=\"line\">            sun.misc.VM.getSavedProperty(<span class=\"string\">&quot;java.lang.Integer.IntegerCache.high&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (integerCacheHighPropValue != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class=\"line\">                i = Math.max(i, <span class=\"number\">127</span>);</span><br><span class=\"line\">                <span class=\"comment\">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class=\"line\">                h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span>( NumberFormatException nfe) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        high = h;</span><br><span class=\"line\"></span><br><span class=\"line\">        cache = <span class=\"keyword\">new</span> Integer[(high - low) + <span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> j = low;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k &lt; cache.length; k++)</span><br><span class=\"line\">            cache[k] = <span class=\"keyword\">new</span> Integer(j++);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class=\"line\">        <span class=\"keyword\">assert</span> IntegerCache.high &gt;= <span class=\"number\">127</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">IntegerCache</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>为什么IntegerCache只缓存-128到127之间的整型值呢？</p>\n<p>在IntegerCache的代码实现中，这个类被加载的时候，缓存的享元对象会被一次性创建好。但是整型值太多了，不可能在IntegerCache类中预先创建好所有的整形值，这样既占用很多内存，也使加载IntegerCache类的时间过长。所以只能选择缓存大部分应用最常用的整型值，也就是一个字节的大小(-128到127之间的数据)。</p>\n<p>JDK也提供了可以自定义缓存的最大值的方式。如果应用使用-128到255之间的数据占用的内存比较多，可以将缓存的最大值从127调整到255。不过JDK并没有提供设置最小值的方法。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//方法一</span><br><span class=\"line\">-Djava.lang.Integer.IntegerCache.high=255</span><br><span class=\"line\">//方法二</span><br><span class=\"line\">-XX:AutoBoxCacheMax=255</span><br></pre></td></tr></table></figure>\n\n<p>除了Integer类型之外，其他保障器类型，Long、Short、Byte等，也都利用享元模式来缓存-128到127之间的数据。</p>\n<p>LongCache享元工厂类以及valueOf函数代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LongCache</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">LongCache</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Long cache[] = <span class=\"keyword\">new</span> Long[-(-<span class=\"number\">128</span>) + <span class=\"number\">127</span> + <span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; cache.length; i++)</span><br><span class=\"line\">            cache[i] = <span class=\"keyword\">new</span> Long(i - <span class=\"number\">128</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Long <span class=\"title\">valueOf</span><span class=\"params\">(<span class=\"keyword\">long</span> l)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> offset = <span class=\"number\">128</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (l &gt;= -<span class=\"number\">128</span> &amp;&amp; l &lt;= <span class=\"number\">127</span>) &#123; <span class=\"comment\">// will cache</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> LongCache.cache[(<span class=\"keyword\">int</span>)l + offset];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Long(l);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>平时开发中，对于三种创建整型对象的方式，优先使用后两种。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer a = <span class=\"keyword\">new</span> Integer(<span class=\"number\">123</span>);</span><br><span class=\"line\">Integer a = <span class=\"number\">123</span>;</span><br><span class=\"line\">Integer a = Integer.valueOf(<span class=\"number\">123</span>);</span><br></pre></td></tr></table></figure>\n\n<p>第一种创建方式不会使用到IntegerCache，后两种都可以利用IntegerCache缓存，返回共享的对象，以达到节省内存的目的。举个极端的例子，假设程序需要插棍见一万个-128到127之间的Integer对象，使用第一种方式，需要分配1万个Integer对象的内存空间，使用后两种创建方式，最多只需要256个Integer对象的内存空间。</p>\n<h5 id=\"享元模式在Java-String中的应用\"><a href=\"#享元模式在Java-String中的应用\" class=\"headerlink\" title=\"享元模式在Java String中的应用\"></a>享元模式在Java String中的应用</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String s1 = <span class=\"string\">&quot;小争哥&quot;</span>;</span><br><span class=\"line\">String s2 = <span class=\"string\">&quot;小争哥&quot;</span>;</span><br><span class=\"line\">String s3 = <span class=\"keyword\">new</span> String(<span class=\"string\">&quot;小争哥&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(s1 == s2);</span><br><span class=\"line\">System.out.println(s1 == s3);</span><br></pre></td></tr></table></figure>\n\n<p>上面的结果，一个true，一个false。跟Integer类的设计思路相似。String类利用享元模式来复用相同的字符串常量（也就是代码中的“小争哥”）。JVM会专门开辟一块存储区来存储字符串常量，这块存储区叫做“字符串常量池”。</p>\n<p>不过，String类的享元模式的设计，跟Integer类稍微有些不同。Integer要共享的对象，是在类加载的时候，集中一次性创建好，但是对于字符串来说，没办法事先知道要共享哪些字符串常量，所以没办法事先创建好，只能在某个字符串常量第一次被用到的时候，存储到常量池中，当之后再用到的时候，直接引用常量池中已经存在的即可，就不需要再重新创建了。</p>\n<p>但是享元模式对JVM的垃圾回收并不友好。因为享元工厂类一致保存了对享元对象的引用，这就导致享元对象在没有任何代码使用的情况下，也不会被JVM垃圾回收机制自动回收掉。因此，在某些情况下，如果对象的生命周期很短，也不会被密集使用，利用享元模式反而会浪费更多内存。</p>\n"},{"layout":"post","title":"设计模式之原型模式","description":"设计模式之原型模式","date":"2021-05-11T05:26:10.000Z","_content":"\n#### 原型模式的原理与应用\n\n如果对象的创建成本比较大，而同一个类的不同对象之间差别不大（大部分字段都相同），在这种情况下，我们可以利用已有对象（原型）进行复制（或者叫拷贝）的方式来创建新对象，以达到节省创建时间的目的。这种基于原型来创建对象的方式就叫做原型设计模式（Prototype Design Pattern），简称原型模式。\n\n##### 为何“对象的创建成本比较大”\n\n创建对象包含的申请内存、给成员变量赋值这一过程，本身并不会花费太多时间，或者说对于大部分业务系统来说，这点时间完全是可以忽略的。应用一个复杂的模式，只得到一点点的性能提升，这就是所谓的过度设计，得不偿失。\n\n但是，如果对象中的数据需要经过复杂的计算才能得到（比如排序、计算哈希值），或者需要从RPC、网络、数据库、文件系统等非常慢速的IO中读取，这种情况下，我们就可以利用原型模式，从其他已有对象中直接拷贝得到，而不用每次在创建新对象的时候，都重复执行这些耗时的操作。\n\n##### 场景\n\n假设数据库中存储了大约10万条“搜索关键词”信息，每条信息包含关键词、关键词被搜索的次数、信息最近被更新的时间等。系统A在启动的时候会加载这份数据到内存中，用于处理某些其他业务需求。为了方便快速地查找某个关键词对应的信息，我们给关键词简历一个散列表索引。还有另外一个系统B，专门用来分析搜索日志，定期批量更新数据库中的数据，并且标记为新的数据版本。为了保证系统A数据的实时行（不是强实时，但是数据不能太旧），系统A需要定期根据数据库中的数据，更新内存中的索引和数据。\n\n加一个特殊的要求，任何时刻系统A中的数据都必须是同一个版本，还要求在更新内存数据的时候，系统A不能处于不可用状态，也就是不能停机更新数据。\n\n我们把正在使用的数据的版本定义为“服务版本”，当我们需要更新内存中的数据的时候，我们并不是直接在服务版本上更新，而是重新创建另一个版本数据（假设是版本b数据），等新的版本数据建好之后，再一次性地将服务版本从版本a切换到版本b，这样既保证了数据一直可用，又避免了中间状态的存在。\n\n```java\n\npublic class Demo {\n  private HashMap<String, SearchWord> currentKeywords=new HashMap<>();\n\n  public void refresh() {\n    HashMap<String, SearchWord> newKeywords = new LinkedHashMap<>();\n\n    // 从数据库中取出所有的数据，放入到newKeywords中\n    List<SearchWord> toBeUpdatedSearchWords = getSearchWords();\n    for (SearchWord searchWord : toBeUpdatedSearchWords) {\n      newKeywords.put(searchWord.getKeyword(), searchWord);\n    }\n\n    currentKeywords = newKeywords;\n  }\n\n  private List<SearchWord> getSearchWords() {\n    // TODO: 从数据库中取出所有的数据\n    return null;\n  }\n}\n```\n\n上面的代码实现，newKeywords构建的成本比较高，我们需要将这10万条数据从数据库中读出，然后计算哈希值，构建newKeywords。这个过程比较耗时，为了提高效率，原型模式就派上用场了。\n\n```java\n\npublic class Demo {\n  private HashMap<String, SearchWord> currentKeywords=new HashMap<>();\n  private long lastUpdateTime = -1;\n\n  public void refresh() {\n    // 原型模式就这么简单，拷贝已有对象的数据，更新少量差值\n    HashMap<String, SearchWord> newKeywords = (HashMap<String, SearchWord>) currentKeywords.clone();\n\n    // 从数据库中取出更新时间>lastUpdateTime的数据，放入到newKeywords中\n    List<SearchWord> toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);\n    long maxNewUpdatedTime = lastUpdateTime;\n    for (SearchWord searchWord : toBeUpdatedSearchWords) {\n      if (searchWord.getLastUpdateTime() > maxNewUpdatedTime) {\n        maxNewUpdatedTime = searchWord.getLastUpdateTime();\n      }\n      if (newKeywords.containsKey(searchWord.getKeyword())) {\n        SearchWord oldSearchWord = newKeywords.get(searchWord.getKeyword());\n        oldSearchWord.setCount(searchWord.getCount());\n        oldSearchWord.setLastUpdateTime(searchWord.getLastUpdateTime());\n      } else {\n        newKeywords.put(searchWord.getKeyword(), searchWord);\n      }\n    }\n\n    lastUpdateTime = maxNewUpdatedTime;\n    currentKeywords = newKeywords;\n  }\n\n  private List<SearchWord> getSearchWords(long lastUpdateTime) {\n    // TODO: 从数据库中取出更新时间>lastUpdateTime的数据\n    return null;\n  }\n}\n```\n\n这里利用了Java中的clone()语法来复制一个对象。相对于数据库的IO操作来说，内存操作和CPU计算的耗时都是可以忽略的。不过这样的实现还存在问题（浅拷贝和深拷贝）\n\n##### 原型模式的实现方式：深拷贝和浅拷贝\n\n浅拷贝和深拷贝的区别在于，浅拷贝只会拷贝索引，不会复制数据（SearchWord对象）本身。深拷贝不仅仅会复制索引，还会复制数据本身。浅拷贝得到的对象（SearchWord对象）跟原始对象（currentKeywords）共享数据（SearchWord对象），而深拷贝得到的是一份完完全全独立的对象。\n\nJava语言中，Object类的clone()方法执行的就是我们刚刚说的浅拷贝。它只会拷贝对象中的基本数据类型的数据（比如int，long），以及引用对象（SearchWord）的内存地址，不会递归地拷贝引用对象本身。\n\n在上面的代码中，我们通过HashMap中的clone()浅拷贝方法来实现原型模式。当我们通过newKeywords更新SearchWord对象的时候，因为newKeywords和currentKeywords指向相同的一组SearchWord对象，就会导致currentKeywords中指向的SearchKeywords，有的事老版本的，有的是新版的，无法满足任何时刻都是同一版本的，不存在介于老版和新版之间的中间状态。\n\n实现深拷贝的方法\n\n第一种：递归拷贝对象、对象的引用对象以及引用对象的引用对象...直到要拷贝的对象只包含基本数据类型数据，没有引用对象为止。\n\n```java\n\npublic class Demo {\n  private HashMap<String, SearchWord> currentKeywords=new HashMap<>();\n  private long lastUpdateTime = -1;\n\n  public void refresh() {\n    // Deep copy\n    HashMap<String, SearchWord> newKeywords = new HashMap<>();\n    for (HashMap.Entry<String, SearchWord> e : currentKeywords.entrySet()) {\n      SearchWord searchWord = e.getValue();\n      SearchWord newSearchWord = new SearchWord(\n              searchWord.getKeyword(), searchWord.getCount(), searchWord.getLastUpdateTime());\n      newKeywords.put(e.getKey(), newSearchWord);\n    }\n\n    // 从数据库中取出更新时间>lastUpdateTime的数据，放入到newKeywords中\n    List<SearchWord> toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);\n    long maxNewUpdatedTime = lastUpdateTime;\n    for (SearchWord searchWord : toBeUpdatedSearchWords) {\n      if (searchWord.getLastUpdateTime() > maxNewUpdatedTime) {\n        maxNewUpdatedTime = searchWord.getLastUpdateTime();\n      }\n      if (newKeywords.containsKey(searchWord.getKeyword())) {\n        SearchWord oldSearchWord = newKeywords.get(searchWord.getKeyword());\n        oldSearchWord.setCount(searchWord.getCount());\n        oldSearchWord.setLastUpdateTime(searchWord.getLastUpdateTime());\n      } else {\n        newKeywords.put(searchWord.getKeyword(), searchWord);\n      }\n    }\n\n    lastUpdateTime = maxNewUpdatedTime;\n    currentKeywords = newKeywords;\n  }\n\n  private List<SearchWord> getSearchWords(long lastUpdateTime) {\n    // TODO: 从数据库中取出更新时间>lastUpdateTime的数据\n    return null;\n  }\n\n}\n```\n\n第二种方法：先将对象序列化，然后在反序列化成新的对象。\n\n```java\npublic Object deepCopy(Object object){\n  ByteArrayOutputStream bo = new ByteArrayOutputStream();\n  ObjectOutputStream oo = new ObjectOutputStream();\n  oo.writeObject(object);\n  ByteArrayInputStream bi = new ByteArrayInputStream(bo.toByteArray());\n  ObjectInputStream oi = new ObjectInputStream(bi);\n  return oi.readObject();\n}\n```\n\n以上两种方式，深拷贝都比浅拷贝耗时、耗内存空间。\n\n基于这种应用场景，更快、更省内存的实现方式。可以先浅拷贝的方式创建newKeywords。对于需要更新的SearchWord对象，我们再使用深度拷贝的方式创建一份新的对象，替换newKeywords中的老对象，毕竟需要更新的数据是很少的。这种方式即利用了浅拷贝节省时间、空间的优点，又能保证currentKeywords中的数据都是老版本的数据。\n\n```java\npublic class Demo {\n  private HashMap<String, SearchWord> currentKeywords=new HashMap<>();\n  private long lastUpdateTime = -1;\n  \n  public void refresh() {\n    //Shallow copy\n    HashMap<String,SearchWord> newKeywords = (HashMap) currentKeywords.clone();\n    // 从数据库中取出更新时间>lastUpdateTime的数据，放入到newKeywords中\n    List toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);\n    long maxNewUpdatedTime = lastUpdateTime;\n    for (SearchWord searchWord : toBeUpdatedSearchWords) {\n      if (searchWord.getLastUpdateTime() > maxNewUpdatedTime) {\n        maxNewUpdatedTime = searchWord.getLastUpdateTime();\n      }\n      if (newKeywords.containsKey(searchWord.getKeyword())) {\n        newKeywords.remove(searchWord.getKeyword());\n      }\n      newKeywords.put(searchWord.getKeyword(), searchWord);\n    }\n    lastUpdateTime = maxNewUpdatedTime;\n    currentKeywords = newKeywords;\n  }\n  \n  private List getSearchWords(long lastUpdateTime) {\n    // TODO: 从数据库中取出更新时间>lastUpdateTime的数据 \n    return null; \n  }\n}\n```\n\n","source":"_posts/设计模式之原型模式.md","raw":"---\nlayout:    post\ntitle:     设计模式之原型模式\ncategory:  设计模式之美\ndescription: 设计模式之原型模式\ntags: 设计模式之美\ndate: 2021/05/11 13:26:10\n---\n\n#### 原型模式的原理与应用\n\n如果对象的创建成本比较大，而同一个类的不同对象之间差别不大（大部分字段都相同），在这种情况下，我们可以利用已有对象（原型）进行复制（或者叫拷贝）的方式来创建新对象，以达到节省创建时间的目的。这种基于原型来创建对象的方式就叫做原型设计模式（Prototype Design Pattern），简称原型模式。\n\n##### 为何“对象的创建成本比较大”\n\n创建对象包含的申请内存、给成员变量赋值这一过程，本身并不会花费太多时间，或者说对于大部分业务系统来说，这点时间完全是可以忽略的。应用一个复杂的模式，只得到一点点的性能提升，这就是所谓的过度设计，得不偿失。\n\n但是，如果对象中的数据需要经过复杂的计算才能得到（比如排序、计算哈希值），或者需要从RPC、网络、数据库、文件系统等非常慢速的IO中读取，这种情况下，我们就可以利用原型模式，从其他已有对象中直接拷贝得到，而不用每次在创建新对象的时候，都重复执行这些耗时的操作。\n\n##### 场景\n\n假设数据库中存储了大约10万条“搜索关键词”信息，每条信息包含关键词、关键词被搜索的次数、信息最近被更新的时间等。系统A在启动的时候会加载这份数据到内存中，用于处理某些其他业务需求。为了方便快速地查找某个关键词对应的信息，我们给关键词简历一个散列表索引。还有另外一个系统B，专门用来分析搜索日志，定期批量更新数据库中的数据，并且标记为新的数据版本。为了保证系统A数据的实时行（不是强实时，但是数据不能太旧），系统A需要定期根据数据库中的数据，更新内存中的索引和数据。\n\n加一个特殊的要求，任何时刻系统A中的数据都必须是同一个版本，还要求在更新内存数据的时候，系统A不能处于不可用状态，也就是不能停机更新数据。\n\n我们把正在使用的数据的版本定义为“服务版本”，当我们需要更新内存中的数据的时候，我们并不是直接在服务版本上更新，而是重新创建另一个版本数据（假设是版本b数据），等新的版本数据建好之后，再一次性地将服务版本从版本a切换到版本b，这样既保证了数据一直可用，又避免了中间状态的存在。\n\n```java\n\npublic class Demo {\n  private HashMap<String, SearchWord> currentKeywords=new HashMap<>();\n\n  public void refresh() {\n    HashMap<String, SearchWord> newKeywords = new LinkedHashMap<>();\n\n    // 从数据库中取出所有的数据，放入到newKeywords中\n    List<SearchWord> toBeUpdatedSearchWords = getSearchWords();\n    for (SearchWord searchWord : toBeUpdatedSearchWords) {\n      newKeywords.put(searchWord.getKeyword(), searchWord);\n    }\n\n    currentKeywords = newKeywords;\n  }\n\n  private List<SearchWord> getSearchWords() {\n    // TODO: 从数据库中取出所有的数据\n    return null;\n  }\n}\n```\n\n上面的代码实现，newKeywords构建的成本比较高，我们需要将这10万条数据从数据库中读出，然后计算哈希值，构建newKeywords。这个过程比较耗时，为了提高效率，原型模式就派上用场了。\n\n```java\n\npublic class Demo {\n  private HashMap<String, SearchWord> currentKeywords=new HashMap<>();\n  private long lastUpdateTime = -1;\n\n  public void refresh() {\n    // 原型模式就这么简单，拷贝已有对象的数据，更新少量差值\n    HashMap<String, SearchWord> newKeywords = (HashMap<String, SearchWord>) currentKeywords.clone();\n\n    // 从数据库中取出更新时间>lastUpdateTime的数据，放入到newKeywords中\n    List<SearchWord> toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);\n    long maxNewUpdatedTime = lastUpdateTime;\n    for (SearchWord searchWord : toBeUpdatedSearchWords) {\n      if (searchWord.getLastUpdateTime() > maxNewUpdatedTime) {\n        maxNewUpdatedTime = searchWord.getLastUpdateTime();\n      }\n      if (newKeywords.containsKey(searchWord.getKeyword())) {\n        SearchWord oldSearchWord = newKeywords.get(searchWord.getKeyword());\n        oldSearchWord.setCount(searchWord.getCount());\n        oldSearchWord.setLastUpdateTime(searchWord.getLastUpdateTime());\n      } else {\n        newKeywords.put(searchWord.getKeyword(), searchWord);\n      }\n    }\n\n    lastUpdateTime = maxNewUpdatedTime;\n    currentKeywords = newKeywords;\n  }\n\n  private List<SearchWord> getSearchWords(long lastUpdateTime) {\n    // TODO: 从数据库中取出更新时间>lastUpdateTime的数据\n    return null;\n  }\n}\n```\n\n这里利用了Java中的clone()语法来复制一个对象。相对于数据库的IO操作来说，内存操作和CPU计算的耗时都是可以忽略的。不过这样的实现还存在问题（浅拷贝和深拷贝）\n\n##### 原型模式的实现方式：深拷贝和浅拷贝\n\n浅拷贝和深拷贝的区别在于，浅拷贝只会拷贝索引，不会复制数据（SearchWord对象）本身。深拷贝不仅仅会复制索引，还会复制数据本身。浅拷贝得到的对象（SearchWord对象）跟原始对象（currentKeywords）共享数据（SearchWord对象），而深拷贝得到的是一份完完全全独立的对象。\n\nJava语言中，Object类的clone()方法执行的就是我们刚刚说的浅拷贝。它只会拷贝对象中的基本数据类型的数据（比如int，long），以及引用对象（SearchWord）的内存地址，不会递归地拷贝引用对象本身。\n\n在上面的代码中，我们通过HashMap中的clone()浅拷贝方法来实现原型模式。当我们通过newKeywords更新SearchWord对象的时候，因为newKeywords和currentKeywords指向相同的一组SearchWord对象，就会导致currentKeywords中指向的SearchKeywords，有的事老版本的，有的是新版的，无法满足任何时刻都是同一版本的，不存在介于老版和新版之间的中间状态。\n\n实现深拷贝的方法\n\n第一种：递归拷贝对象、对象的引用对象以及引用对象的引用对象...直到要拷贝的对象只包含基本数据类型数据，没有引用对象为止。\n\n```java\n\npublic class Demo {\n  private HashMap<String, SearchWord> currentKeywords=new HashMap<>();\n  private long lastUpdateTime = -1;\n\n  public void refresh() {\n    // Deep copy\n    HashMap<String, SearchWord> newKeywords = new HashMap<>();\n    for (HashMap.Entry<String, SearchWord> e : currentKeywords.entrySet()) {\n      SearchWord searchWord = e.getValue();\n      SearchWord newSearchWord = new SearchWord(\n              searchWord.getKeyword(), searchWord.getCount(), searchWord.getLastUpdateTime());\n      newKeywords.put(e.getKey(), newSearchWord);\n    }\n\n    // 从数据库中取出更新时间>lastUpdateTime的数据，放入到newKeywords中\n    List<SearchWord> toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);\n    long maxNewUpdatedTime = lastUpdateTime;\n    for (SearchWord searchWord : toBeUpdatedSearchWords) {\n      if (searchWord.getLastUpdateTime() > maxNewUpdatedTime) {\n        maxNewUpdatedTime = searchWord.getLastUpdateTime();\n      }\n      if (newKeywords.containsKey(searchWord.getKeyword())) {\n        SearchWord oldSearchWord = newKeywords.get(searchWord.getKeyword());\n        oldSearchWord.setCount(searchWord.getCount());\n        oldSearchWord.setLastUpdateTime(searchWord.getLastUpdateTime());\n      } else {\n        newKeywords.put(searchWord.getKeyword(), searchWord);\n      }\n    }\n\n    lastUpdateTime = maxNewUpdatedTime;\n    currentKeywords = newKeywords;\n  }\n\n  private List<SearchWord> getSearchWords(long lastUpdateTime) {\n    // TODO: 从数据库中取出更新时间>lastUpdateTime的数据\n    return null;\n  }\n\n}\n```\n\n第二种方法：先将对象序列化，然后在反序列化成新的对象。\n\n```java\npublic Object deepCopy(Object object){\n  ByteArrayOutputStream bo = new ByteArrayOutputStream();\n  ObjectOutputStream oo = new ObjectOutputStream();\n  oo.writeObject(object);\n  ByteArrayInputStream bi = new ByteArrayInputStream(bo.toByteArray());\n  ObjectInputStream oi = new ObjectInputStream(bi);\n  return oi.readObject();\n}\n```\n\n以上两种方式，深拷贝都比浅拷贝耗时、耗内存空间。\n\n基于这种应用场景，更快、更省内存的实现方式。可以先浅拷贝的方式创建newKeywords。对于需要更新的SearchWord对象，我们再使用深度拷贝的方式创建一份新的对象，替换newKeywords中的老对象，毕竟需要更新的数据是很少的。这种方式即利用了浅拷贝节省时间、空间的优点，又能保证currentKeywords中的数据都是老版本的数据。\n\n```java\npublic class Demo {\n  private HashMap<String, SearchWord> currentKeywords=new HashMap<>();\n  private long lastUpdateTime = -1;\n  \n  public void refresh() {\n    //Shallow copy\n    HashMap<String,SearchWord> newKeywords = (HashMap) currentKeywords.clone();\n    // 从数据库中取出更新时间>lastUpdateTime的数据，放入到newKeywords中\n    List toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);\n    long maxNewUpdatedTime = lastUpdateTime;\n    for (SearchWord searchWord : toBeUpdatedSearchWords) {\n      if (searchWord.getLastUpdateTime() > maxNewUpdatedTime) {\n        maxNewUpdatedTime = searchWord.getLastUpdateTime();\n      }\n      if (newKeywords.containsKey(searchWord.getKeyword())) {\n        newKeywords.remove(searchWord.getKeyword());\n      }\n      newKeywords.put(searchWord.getKeyword(), searchWord);\n    }\n    lastUpdateTime = maxNewUpdatedTime;\n    currentKeywords = newKeywords;\n  }\n  \n  private List getSearchWords(long lastUpdateTime) {\n    // TODO: 从数据库中取出更新时间>lastUpdateTime的数据 \n    return null; \n  }\n}\n```\n\n","slug":"设计模式之原型模式","published":1,"updated":"2021-05-11T05:26:10.000Z","comments":1,"photos":[],"link":"","_id":"cm1m304xl001e31b4coou3bub","content":"<h4 id=\"原型模式的原理与应用\"><a href=\"#原型模式的原理与应用\" class=\"headerlink\" title=\"原型模式的原理与应用\"></a>原型模式的原理与应用</h4><p>如果对象的创建成本比较大，而同一个类的不同对象之间差别不大（大部分字段都相同），在这种情况下，我们可以利用已有对象（原型）进行复制（或者叫拷贝）的方式来创建新对象，以达到节省创建时间的目的。这种基于原型来创建对象的方式就叫做原型设计模式（Prototype Design Pattern），简称原型模式。</p>\n<h5 id=\"为何“对象的创建成本比较大”\"><a href=\"#为何“对象的创建成本比较大”\" class=\"headerlink\" title=\"为何“对象的创建成本比较大”\"></a>为何“对象的创建成本比较大”</h5><p>创建对象包含的申请内存、给成员变量赋值这一过程，本身并不会花费太多时间，或者说对于大部分业务系统来说，这点时间完全是可以忽略的。应用一个复杂的模式，只得到一点点的性能提升，这就是所谓的过度设计，得不偿失。</p>\n<p>但是，如果对象中的数据需要经过复杂的计算才能得到（比如排序、计算哈希值），或者需要从RPC、网络、数据库、文件系统等非常慢速的IO中读取，这种情况下，我们就可以利用原型模式，从其他已有对象中直接拷贝得到，而不用每次在创建新对象的时候，都重复执行这些耗时的操作。</p>\n<h5 id=\"场景\"><a href=\"#场景\" class=\"headerlink\" title=\"场景\"></a>场景</h5><p>假设数据库中存储了大约10万条“搜索关键词”信息，每条信息包含关键词、关键词被搜索的次数、信息最近被更新的时间等。系统A在启动的时候会加载这份数据到内存中，用于处理某些其他业务需求。为了方便快速地查找某个关键词对应的信息，我们给关键词简历一个散列表索引。还有另外一个系统B，专门用来分析搜索日志，定期批量更新数据库中的数据，并且标记为新的数据版本。为了保证系统A数据的实时行（不是强实时，但是数据不能太旧），系统A需要定期根据数据库中的数据，更新内存中的索引和数据。</p>\n<p>加一个特殊的要求，任何时刻系统A中的数据都必须是同一个版本，还要求在更新内存数据的时候，系统A不能处于不可用状态，也就是不能停机更新数据。</p>\n<p>我们把正在使用的数据的版本定义为“服务版本”，当我们需要更新内存中的数据的时候，我们并不是直接在服务版本上更新，而是重新创建另一个版本数据（假设是版本b数据），等新的版本数据建好之后，再一次性地将服务版本从版本a切换到版本b，这样既保证了数据一直可用，又避免了中间状态的存在。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> HashMap&lt;String, SearchWord&gt; currentKeywords=<span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">refresh</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    HashMap&lt;String, SearchWord&gt; newKeywords = <span class=\"keyword\">new</span> LinkedHashMap&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 从数据库中取出所有的数据，放入到newKeywords中</span></span><br><span class=\"line\">    List&lt;SearchWord&gt; toBeUpdatedSearchWords = getSearchWords();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (SearchWord searchWord : toBeUpdatedSearchWords) &#123;</span><br><span class=\"line\">      newKeywords.put(searchWord.getKeyword(), searchWord);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    currentKeywords = newKeywords;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> List&lt;SearchWord&gt; <span class=\"title\">getSearchWords</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span> 从数据库中取出所有的数据</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的代码实现，newKeywords构建的成本比较高，我们需要将这10万条数据从数据库中读出，然后计算哈希值，构建newKeywords。这个过程比较耗时，为了提高效率，原型模式就派上用场了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> HashMap&lt;String, SearchWord&gt; currentKeywords=<span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> lastUpdateTime = -<span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">refresh</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 原型模式就这么简单，拷贝已有对象的数据，更新少量差值</span></span><br><span class=\"line\">    HashMap&lt;String, SearchWord&gt; newKeywords = (HashMap&lt;String, SearchWord&gt;) currentKeywords.clone();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 从数据库中取出更新时间&gt;lastUpdateTime的数据，放入到newKeywords中</span></span><br><span class=\"line\">    List&lt;SearchWord&gt; toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);</span><br><span class=\"line\">    <span class=\"keyword\">long</span> maxNewUpdatedTime = lastUpdateTime;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (SearchWord searchWord : toBeUpdatedSearchWords) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (searchWord.getLastUpdateTime() &gt; maxNewUpdatedTime) &#123;</span><br><span class=\"line\">        maxNewUpdatedTime = searchWord.getLastUpdateTime();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (newKeywords.containsKey(searchWord.getKeyword())) &#123;</span><br><span class=\"line\">        SearchWord oldSearchWord = newKeywords.get(searchWord.getKeyword());</span><br><span class=\"line\">        oldSearchWord.setCount(searchWord.getCount());</span><br><span class=\"line\">        oldSearchWord.setLastUpdateTime(searchWord.getLastUpdateTime());</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        newKeywords.put(searchWord.getKeyword(), searchWord);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    lastUpdateTime = maxNewUpdatedTime;</span><br><span class=\"line\">    currentKeywords = newKeywords;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> List&lt;SearchWord&gt; <span class=\"title\">getSearchWords</span><span class=\"params\">(<span class=\"keyword\">long</span> lastUpdateTime)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span> 从数据库中取出更新时间&gt;lastUpdateTime的数据</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里利用了Java中的clone()语法来复制一个对象。相对于数据库的IO操作来说，内存操作和CPU计算的耗时都是可以忽略的。不过这样的实现还存在问题（浅拷贝和深拷贝）</p>\n<h5 id=\"原型模式的实现方式：深拷贝和浅拷贝\"><a href=\"#原型模式的实现方式：深拷贝和浅拷贝\" class=\"headerlink\" title=\"原型模式的实现方式：深拷贝和浅拷贝\"></a>原型模式的实现方式：深拷贝和浅拷贝</h5><p>浅拷贝和深拷贝的区别在于，浅拷贝只会拷贝索引，不会复制数据（SearchWord对象）本身。深拷贝不仅仅会复制索引，还会复制数据本身。浅拷贝得到的对象（SearchWord对象）跟原始对象（currentKeywords）共享数据（SearchWord对象），而深拷贝得到的是一份完完全全独立的对象。</p>\n<p>Java语言中，Object类的clone()方法执行的就是我们刚刚说的浅拷贝。它只会拷贝对象中的基本数据类型的数据（比如int，long），以及引用对象（SearchWord）的内存地址，不会递归地拷贝引用对象本身。</p>\n<p>在上面的代码中，我们通过HashMap中的clone()浅拷贝方法来实现原型模式。当我们通过newKeywords更新SearchWord对象的时候，因为newKeywords和currentKeywords指向相同的一组SearchWord对象，就会导致currentKeywords中指向的SearchKeywords，有的事老版本的，有的是新版的，无法满足任何时刻都是同一版本的，不存在介于老版和新版之间的中间状态。</p>\n<p>实现深拷贝的方法</p>\n<p>第一种：递归拷贝对象、对象的引用对象以及引用对象的引用对象…直到要拷贝的对象只包含基本数据类型数据，没有引用对象为止。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> HashMap&lt;String, SearchWord&gt; currentKeywords=<span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> lastUpdateTime = -<span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">refresh</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Deep copy</span></span><br><span class=\"line\">    HashMap&lt;String, SearchWord&gt; newKeywords = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (HashMap.Entry&lt;String, SearchWord&gt; e : currentKeywords.entrySet()) &#123;</span><br><span class=\"line\">      SearchWord searchWord = e.getValue();</span><br><span class=\"line\">      SearchWord newSearchWord = <span class=\"keyword\">new</span> SearchWord(</span><br><span class=\"line\">              searchWord.getKeyword(), searchWord.getCount(), searchWord.getLastUpdateTime());</span><br><span class=\"line\">      newKeywords.put(e.getKey(), newSearchWord);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 从数据库中取出更新时间&gt;lastUpdateTime的数据，放入到newKeywords中</span></span><br><span class=\"line\">    List&lt;SearchWord&gt; toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);</span><br><span class=\"line\">    <span class=\"keyword\">long</span> maxNewUpdatedTime = lastUpdateTime;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (SearchWord searchWord : toBeUpdatedSearchWords) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (searchWord.getLastUpdateTime() &gt; maxNewUpdatedTime) &#123;</span><br><span class=\"line\">        maxNewUpdatedTime = searchWord.getLastUpdateTime();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (newKeywords.containsKey(searchWord.getKeyword())) &#123;</span><br><span class=\"line\">        SearchWord oldSearchWord = newKeywords.get(searchWord.getKeyword());</span><br><span class=\"line\">        oldSearchWord.setCount(searchWord.getCount());</span><br><span class=\"line\">        oldSearchWord.setLastUpdateTime(searchWord.getLastUpdateTime());</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        newKeywords.put(searchWord.getKeyword(), searchWord);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    lastUpdateTime = maxNewUpdatedTime;</span><br><span class=\"line\">    currentKeywords = newKeywords;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> List&lt;SearchWord&gt; <span class=\"title\">getSearchWords</span><span class=\"params\">(<span class=\"keyword\">long</span> lastUpdateTime)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span> 从数据库中取出更新时间&gt;lastUpdateTime的数据</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>第二种方法：先将对象序列化，然后在反序列化成新的对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">deepCopy</span><span class=\"params\">(Object object)</span></span>&#123;</span><br><span class=\"line\">  ByteArrayOutputStream bo = <span class=\"keyword\">new</span> ByteArrayOutputStream();</span><br><span class=\"line\">  ObjectOutputStream oo = <span class=\"keyword\">new</span> ObjectOutputStream();</span><br><span class=\"line\">  oo.writeObject(object);</span><br><span class=\"line\">  ByteArrayInputStream bi = <span class=\"keyword\">new</span> ByteArrayInputStream(bo.toByteArray());</span><br><span class=\"line\">  ObjectInputStream oi = <span class=\"keyword\">new</span> ObjectInputStream(bi);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> oi.readObject();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以上两种方式，深拷贝都比浅拷贝耗时、耗内存空间。</p>\n<p>基于这种应用场景，更快、更省内存的实现方式。可以先浅拷贝的方式创建newKeywords。对于需要更新的SearchWord对象，我们再使用深度拷贝的方式创建一份新的对象，替换newKeywords中的老对象，毕竟需要更新的数据是很少的。这种方式即利用了浅拷贝节省时间、空间的优点，又能保证currentKeywords中的数据都是老版本的数据。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> HashMap&lt;String, SearchWord&gt; currentKeywords=<span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> lastUpdateTime = -<span class=\"number\">1</span>;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">refresh</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//Shallow copy</span></span><br><span class=\"line\">    HashMap&lt;String,SearchWord&gt; newKeywords = (HashMap) currentKeywords.clone();</span><br><span class=\"line\">    <span class=\"comment\">// 从数据库中取出更新时间&gt;lastUpdateTime的数据，放入到newKeywords中</span></span><br><span class=\"line\">    List toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);</span><br><span class=\"line\">    <span class=\"keyword\">long</span> maxNewUpdatedTime = lastUpdateTime;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (SearchWord searchWord : toBeUpdatedSearchWords) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (searchWord.getLastUpdateTime() &gt; maxNewUpdatedTime) &#123;</span><br><span class=\"line\">        maxNewUpdatedTime = searchWord.getLastUpdateTime();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (newKeywords.containsKey(searchWord.getKeyword())) &#123;</span><br><span class=\"line\">        newKeywords.remove(searchWord.getKeyword());</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      newKeywords.put(searchWord.getKeyword(), searchWord);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    lastUpdateTime = maxNewUpdatedTime;</span><br><span class=\"line\">    currentKeywords = newKeywords;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> List <span class=\"title\">getSearchWords</span><span class=\"params\">(<span class=\"keyword\">long</span> lastUpdateTime)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span> 从数据库中取出更新时间&gt;lastUpdateTime的数据 </span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>; </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"原型模式的原理与应用\"><a href=\"#原型模式的原理与应用\" class=\"headerlink\" title=\"原型模式的原理与应用\"></a>原型模式的原理与应用</h4><p>如果对象的创建成本比较大，而同一个类的不同对象之间差别不大（大部分字段都相同），在这种情况下，我们可以利用已有对象（原型）进行复制（或者叫拷贝）的方式来创建新对象，以达到节省创建时间的目的。这种基于原型来创建对象的方式就叫做原型设计模式（Prototype Design Pattern），简称原型模式。</p>\n<h5 id=\"为何“对象的创建成本比较大”\"><a href=\"#为何“对象的创建成本比较大”\" class=\"headerlink\" title=\"为何“对象的创建成本比较大”\"></a>为何“对象的创建成本比较大”</h5><p>创建对象包含的申请内存、给成员变量赋值这一过程，本身并不会花费太多时间，或者说对于大部分业务系统来说，这点时间完全是可以忽略的。应用一个复杂的模式，只得到一点点的性能提升，这就是所谓的过度设计，得不偿失。</p>\n<p>但是，如果对象中的数据需要经过复杂的计算才能得到（比如排序、计算哈希值），或者需要从RPC、网络、数据库、文件系统等非常慢速的IO中读取，这种情况下，我们就可以利用原型模式，从其他已有对象中直接拷贝得到，而不用每次在创建新对象的时候，都重复执行这些耗时的操作。</p>\n<h5 id=\"场景\"><a href=\"#场景\" class=\"headerlink\" title=\"场景\"></a>场景</h5><p>假设数据库中存储了大约10万条“搜索关键词”信息，每条信息包含关键词、关键词被搜索的次数、信息最近被更新的时间等。系统A在启动的时候会加载这份数据到内存中，用于处理某些其他业务需求。为了方便快速地查找某个关键词对应的信息，我们给关键词简历一个散列表索引。还有另外一个系统B，专门用来分析搜索日志，定期批量更新数据库中的数据，并且标记为新的数据版本。为了保证系统A数据的实时行（不是强实时，但是数据不能太旧），系统A需要定期根据数据库中的数据，更新内存中的索引和数据。</p>\n<p>加一个特殊的要求，任何时刻系统A中的数据都必须是同一个版本，还要求在更新内存数据的时候，系统A不能处于不可用状态，也就是不能停机更新数据。</p>\n<p>我们把正在使用的数据的版本定义为“服务版本”，当我们需要更新内存中的数据的时候，我们并不是直接在服务版本上更新，而是重新创建另一个版本数据（假设是版本b数据），等新的版本数据建好之后，再一次性地将服务版本从版本a切换到版本b，这样既保证了数据一直可用，又避免了中间状态的存在。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> HashMap&lt;String, SearchWord&gt; currentKeywords=<span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">refresh</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    HashMap&lt;String, SearchWord&gt; newKeywords = <span class=\"keyword\">new</span> LinkedHashMap&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 从数据库中取出所有的数据，放入到newKeywords中</span></span><br><span class=\"line\">    List&lt;SearchWord&gt; toBeUpdatedSearchWords = getSearchWords();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (SearchWord searchWord : toBeUpdatedSearchWords) &#123;</span><br><span class=\"line\">      newKeywords.put(searchWord.getKeyword(), searchWord);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    currentKeywords = newKeywords;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> List&lt;SearchWord&gt; <span class=\"title\">getSearchWords</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span> 从数据库中取出所有的数据</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的代码实现，newKeywords构建的成本比较高，我们需要将这10万条数据从数据库中读出，然后计算哈希值，构建newKeywords。这个过程比较耗时，为了提高效率，原型模式就派上用场了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> HashMap&lt;String, SearchWord&gt; currentKeywords=<span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> lastUpdateTime = -<span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">refresh</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 原型模式就这么简单，拷贝已有对象的数据，更新少量差值</span></span><br><span class=\"line\">    HashMap&lt;String, SearchWord&gt; newKeywords = (HashMap&lt;String, SearchWord&gt;) currentKeywords.clone();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 从数据库中取出更新时间&gt;lastUpdateTime的数据，放入到newKeywords中</span></span><br><span class=\"line\">    List&lt;SearchWord&gt; toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);</span><br><span class=\"line\">    <span class=\"keyword\">long</span> maxNewUpdatedTime = lastUpdateTime;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (SearchWord searchWord : toBeUpdatedSearchWords) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (searchWord.getLastUpdateTime() &gt; maxNewUpdatedTime) &#123;</span><br><span class=\"line\">        maxNewUpdatedTime = searchWord.getLastUpdateTime();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (newKeywords.containsKey(searchWord.getKeyword())) &#123;</span><br><span class=\"line\">        SearchWord oldSearchWord = newKeywords.get(searchWord.getKeyword());</span><br><span class=\"line\">        oldSearchWord.setCount(searchWord.getCount());</span><br><span class=\"line\">        oldSearchWord.setLastUpdateTime(searchWord.getLastUpdateTime());</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        newKeywords.put(searchWord.getKeyword(), searchWord);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    lastUpdateTime = maxNewUpdatedTime;</span><br><span class=\"line\">    currentKeywords = newKeywords;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> List&lt;SearchWord&gt; <span class=\"title\">getSearchWords</span><span class=\"params\">(<span class=\"keyword\">long</span> lastUpdateTime)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span> 从数据库中取出更新时间&gt;lastUpdateTime的数据</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里利用了Java中的clone()语法来复制一个对象。相对于数据库的IO操作来说，内存操作和CPU计算的耗时都是可以忽略的。不过这样的实现还存在问题（浅拷贝和深拷贝）</p>\n<h5 id=\"原型模式的实现方式：深拷贝和浅拷贝\"><a href=\"#原型模式的实现方式：深拷贝和浅拷贝\" class=\"headerlink\" title=\"原型模式的实现方式：深拷贝和浅拷贝\"></a>原型模式的实现方式：深拷贝和浅拷贝</h5><p>浅拷贝和深拷贝的区别在于，浅拷贝只会拷贝索引，不会复制数据（SearchWord对象）本身。深拷贝不仅仅会复制索引，还会复制数据本身。浅拷贝得到的对象（SearchWord对象）跟原始对象（currentKeywords）共享数据（SearchWord对象），而深拷贝得到的是一份完完全全独立的对象。</p>\n<p>Java语言中，Object类的clone()方法执行的就是我们刚刚说的浅拷贝。它只会拷贝对象中的基本数据类型的数据（比如int，long），以及引用对象（SearchWord）的内存地址，不会递归地拷贝引用对象本身。</p>\n<p>在上面的代码中，我们通过HashMap中的clone()浅拷贝方法来实现原型模式。当我们通过newKeywords更新SearchWord对象的时候，因为newKeywords和currentKeywords指向相同的一组SearchWord对象，就会导致currentKeywords中指向的SearchKeywords，有的事老版本的，有的是新版的，无法满足任何时刻都是同一版本的，不存在介于老版和新版之间的中间状态。</p>\n<p>实现深拷贝的方法</p>\n<p>第一种：递归拷贝对象、对象的引用对象以及引用对象的引用对象…直到要拷贝的对象只包含基本数据类型数据，没有引用对象为止。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> HashMap&lt;String, SearchWord&gt; currentKeywords=<span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> lastUpdateTime = -<span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">refresh</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Deep copy</span></span><br><span class=\"line\">    HashMap&lt;String, SearchWord&gt; newKeywords = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (HashMap.Entry&lt;String, SearchWord&gt; e : currentKeywords.entrySet()) &#123;</span><br><span class=\"line\">      SearchWord searchWord = e.getValue();</span><br><span class=\"line\">      SearchWord newSearchWord = <span class=\"keyword\">new</span> SearchWord(</span><br><span class=\"line\">              searchWord.getKeyword(), searchWord.getCount(), searchWord.getLastUpdateTime());</span><br><span class=\"line\">      newKeywords.put(e.getKey(), newSearchWord);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 从数据库中取出更新时间&gt;lastUpdateTime的数据，放入到newKeywords中</span></span><br><span class=\"line\">    List&lt;SearchWord&gt; toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);</span><br><span class=\"line\">    <span class=\"keyword\">long</span> maxNewUpdatedTime = lastUpdateTime;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (SearchWord searchWord : toBeUpdatedSearchWords) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (searchWord.getLastUpdateTime() &gt; maxNewUpdatedTime) &#123;</span><br><span class=\"line\">        maxNewUpdatedTime = searchWord.getLastUpdateTime();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (newKeywords.containsKey(searchWord.getKeyword())) &#123;</span><br><span class=\"line\">        SearchWord oldSearchWord = newKeywords.get(searchWord.getKeyword());</span><br><span class=\"line\">        oldSearchWord.setCount(searchWord.getCount());</span><br><span class=\"line\">        oldSearchWord.setLastUpdateTime(searchWord.getLastUpdateTime());</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        newKeywords.put(searchWord.getKeyword(), searchWord);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    lastUpdateTime = maxNewUpdatedTime;</span><br><span class=\"line\">    currentKeywords = newKeywords;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> List&lt;SearchWord&gt; <span class=\"title\">getSearchWords</span><span class=\"params\">(<span class=\"keyword\">long</span> lastUpdateTime)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span> 从数据库中取出更新时间&gt;lastUpdateTime的数据</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>第二种方法：先将对象序列化，然后在反序列化成新的对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">deepCopy</span><span class=\"params\">(Object object)</span></span>&#123;</span><br><span class=\"line\">  ByteArrayOutputStream bo = <span class=\"keyword\">new</span> ByteArrayOutputStream();</span><br><span class=\"line\">  ObjectOutputStream oo = <span class=\"keyword\">new</span> ObjectOutputStream();</span><br><span class=\"line\">  oo.writeObject(object);</span><br><span class=\"line\">  ByteArrayInputStream bi = <span class=\"keyword\">new</span> ByteArrayInputStream(bo.toByteArray());</span><br><span class=\"line\">  ObjectInputStream oi = <span class=\"keyword\">new</span> ObjectInputStream(bi);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> oi.readObject();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以上两种方式，深拷贝都比浅拷贝耗时、耗内存空间。</p>\n<p>基于这种应用场景，更快、更省内存的实现方式。可以先浅拷贝的方式创建newKeywords。对于需要更新的SearchWord对象，我们再使用深度拷贝的方式创建一份新的对象，替换newKeywords中的老对象，毕竟需要更新的数据是很少的。这种方式即利用了浅拷贝节省时间、空间的优点，又能保证currentKeywords中的数据都是老版本的数据。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> HashMap&lt;String, SearchWord&gt; currentKeywords=<span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> lastUpdateTime = -<span class=\"number\">1</span>;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">refresh</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//Shallow copy</span></span><br><span class=\"line\">    HashMap&lt;String,SearchWord&gt; newKeywords = (HashMap) currentKeywords.clone();</span><br><span class=\"line\">    <span class=\"comment\">// 从数据库中取出更新时间&gt;lastUpdateTime的数据，放入到newKeywords中</span></span><br><span class=\"line\">    List toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);</span><br><span class=\"line\">    <span class=\"keyword\">long</span> maxNewUpdatedTime = lastUpdateTime;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (SearchWord searchWord : toBeUpdatedSearchWords) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (searchWord.getLastUpdateTime() &gt; maxNewUpdatedTime) &#123;</span><br><span class=\"line\">        maxNewUpdatedTime = searchWord.getLastUpdateTime();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (newKeywords.containsKey(searchWord.getKeyword())) &#123;</span><br><span class=\"line\">        newKeywords.remove(searchWord.getKeyword());</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      newKeywords.put(searchWord.getKeyword(), searchWord);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    lastUpdateTime = maxNewUpdatedTime;</span><br><span class=\"line\">    currentKeywords = newKeywords;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> List <span class=\"title\">getSearchWords</span><span class=\"params\">(<span class=\"keyword\">long</span> lastUpdateTime)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span> 从数据库中取出更新时间&gt;lastUpdateTime的数据 </span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>; </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"},{"layout":"post","title":"设计模式之单例模式","description":"设计模式之单例模式","date":"2021-04-16T05:26:10.000Z","_content":"\n### **单例模式**\n\n一个类只允许创建一个对象（或者实例），那这个类就是一个单例类，这种设计模式就叫单例模式。\n\n### **为什么使用单例**\n\n1.处理资源访问冲突\n\n日志去操作日志文件，多线程环境下，两个线程同时写日志，就可能存在覆盖的情况。解决这个问题一般都是想到通过加锁的方式，给函数加互斥锁（synchronized），但是synchronized(this) 是对象级别的锁，一个对象在不同线程下同时调用log()函数，会被强制要求顺序执行。但是不同的对象并不是共享一把锁。在不同的线程下，通过不同的对象调用执行log()函数，锁并不会起作用，仍然可能存在日志覆盖的情况。那么如何解决呢，我们只要把对象级别的锁换成类级别的锁就可以了。synchronized(Logger.class) 这样就避免了不同对象之间同时调用log函数，导致的日志覆盖问题。除此之外，并发队列也可以解决这个问题（BlockingQueue），多个线程同时并发往队列中写日志，一个单独的线程负责将队列中的日志写入到日志文件中。相比这两种方案，单例模式的思路就简单很多了。而且单例对于类级别锁的好处是，不需要创建很多的Logger对象，一方面节省内存空间，另一方面节省系统文件句柄（对于操作系统来说，文件句柄也是一种资源，不能随便浪费）\n\n2.表示全局唯一类\n\n在业务概念上，如果有些数据在系统中只应保存一份，那就比较适合设计为单例类。比如配置信息类。还有全局的唯一ID生成器。\n\n### 如何实现单例\n\n- 构造函数私有，避免外部通过new创建实例\n\n- 考虑对象创建时的线程安全问题\n\n- 考虑是否支持延迟加载\n\n- 考虑getInstance()性能是否高(是否加锁)\n\n  #### 1.饿汉式\n\n  饿汉式实现比较简单。在类加载的时候，instance静态实例就已经创建并初始化好了，所以，instance实例的创建过程是线程安全的。不过这样的方式不支持延迟加载(在真正用到的时候，再创建实例)\n\n  ```java\n  public class IdGenerator{\n    private AtomicLong id = new AtomicLong(0);\n    private static final IdGenerator instance = new IdGenerator();\n    private IdGenerator(){}\n    public static IdGenerator getInstance(){\n      return instance;\n    }\n    public long getId(){\n      return id.incrementAndGet();\n    }\n  }\n  ```\n\n  采用饿汉的实现方式，将耗时的初始化操作提前到程序启动的时候完成，这样能避免在程序运行的时候，再去初始化导致的性能问题。如果实例占用资源多，按照fail-fase的设计原则(有问题及早暴露)，我们也希望在程序启动时就将这个实例初始化好。如果资源不够，就会在启动的时候出发报错，我们可以立即去修复，这样也能避免在程序运行一段时间后，突然因为初始化这个实例占用资源过多，导致系统崩溃，影响系统的可用性。\n\n  #### 2.懒汉式\n\n  懒汉式的优势是支持延迟加载\n\n  ```java\n  public class IdGenerator { \n    private AtomicLong id = new AtomicLong(0);\n    private static IdGenerator instance;\n    private IdGenerator() {}\n    public static synchronized IdGenerator getInstance() {\n      if (instance == null) {\n        instance = new IdGenerator();\n      }\n      return instance;\n    }\n    public long getId() { \n      return id.incrementAndGet();\n    }\n  }\n  ```\n\n  懒汉式的缺点也很明显，我们给getInstance()这个方法加了一把大锁，导致这个函数的并发度很低。量化一下的话，并发度是1，就是想当于穿行操作了。而这个函数在单例使用期间，一直会被调用。如果频繁地用到，那频繁加锁、释放锁及并发度低等问题，会导致性能瓶颈，这种实现方式就不可取了。\n\n  #### 3.双重检测\n\n  饿汉式不支持延迟记载，懒汉式有性能问题，不支持高并发。在这种实现方式中，只要instance被创建之后，即便再调用getInstance()函数也不会再进入到加锁逻辑中了。\n\n  ```java\n  public class IdGenerator{\n    private AtomicLong id = new AtomicLong();\n    private static IdGenerator instance;\n    private IdGenerator(){}\n    public static IdGenerator getInstance(){\n      if(instance == null) {\n        synchronized(IdGenerator.class){ //此处为类级别的锁\n          if(instance == null){\n            instance = new IdGenerator();\n          }\n        }\n      }\n      return instance;\n    }\n    public long getId(){\n      return id.incrementAndGet();\n    }\n  }\n  ```\n\n  网上有人说，这种实现方式有问题，因为指令重排序，可能会导致IdGenerator对象被new出来，并且赋值给instance之后，还没来得及初始化(执行构造函数中的代码逻辑)，就被另一个线程使用了。\n\n  要解决这个问题，需要给instance成员变量加上volatile关键字，禁止指令重排序才行。实际上，只有很低版本的Java才会有这个问题。我们在用的高版本的Jave已经在JDK内部实现中解决了这个问题。(解决的办法很简单，只要把对象new操作和初始化操作设计为原子操作，就自然能禁止重排序)\n\n  #### 4.静态内部类\n\n  利用Java的静态内部类。既有点饿汉式，有做到了延迟加载。\n\n  ```java\n  public class IdGenerator{\n    private AtomicLong id = new AtomicLong(0); \n    private IdGenerator() {}\n    private static class SingletonHolder{\n      private static final IdGenerator instance = new IdGenerator();\n    }\n    public static IdGenerator getInstance() {\n      return SingletonHolder.instance;\n    }\n    public long getId(){\n      return id.incrementAndGet();\n    }\n  }\n  ```\n\n  SingletonHolder是一个静态内部类，当外部类IdGenerator被加载的时候，并不会创建SingletonHolder实例对象。只有当调用getInstance()方法时，SingletonHolder才会被加载，这个时候才会创建instance。instance的唯一性、创建过程的线程安全性，都由JVM来保证。所以这种实现方法即保证了线程安全，又能做到延迟加载。\n\n  #### 5.枚举\n\n  基于枚举类型的单例实现。这种实现方式通过Java枚举类型本身的特性，保证了实例创建的线程安全性和实例的唯一性。\n\n  ```java\n  public enum IdGenerator{\n    INSTANCE;\n    private AtomicLong id = new AtomicLong(0);\n    \n    public long getId(){\n      return id.incrementAndGet();\n    }\n  }\n  ```\n\n### 单例存在哪些问题\n\n1.单例对OOP特性支持不友好\n\nIdGenerator的使用方式违背了基于接口而非实现的设计原则，也就违背了OOP的抽象特性。如果未来希望针对不同业务采用不用的ID生成算法，为了应对这个需求变化，需要修改所有用到IdGenerator类的地方。单例对继承、多态的支持也不友好。因为单例类也可以被继承、也可以实现多态，只是实现起来会非常奇怪。所以一旦某个类被设计成单例类，也就意味着放弃了继承和多态这两个面向对象的特性，也就相当于损失了可以应对未来需求变化的扩展性。\n\n2.单例会隐藏类之间的依赖关系\n\n单例类不需要显示创建、不需要依赖参数传递，在函数直接调用就可以了。如果代码比较复杂，调用关系就会非常隐蔽。阅读代码的时候，需要仔细看每个函数的代码实现，才能知道这个类到底依赖了哪些类。\n\n3.单例对代码的扩展性不友好\n\n设计初期我们觉得系统中应该有一个数据库连接池，这样能方便控制对数据库连接资源的消耗。但是有些SQL语句运行得非常慢，为了解决这个问题，我们将慢SQL与其他SQL隔离执行，为了实现这样的目的，可以在系统中创建两个数据库连接池，慢SQL独享一个数据库连接池，其他SQL独享另一个数据库连接池，慢SQL就不会影响其他SQL的执行。单例类无法适应这样的需求变更，在某些情况下会影响代码的扩展性、灵活性。所以，数据库连接池、线程池这类的资源池还是不要设计成单例类。\n\n4.单例对代码的可测试性不友好\n\n单例模式的使用会影响到代码的可测试性。如果单例类以来比较重的外部资源，比如DB，写单元测试的时候，无法实现mock替换。如果单例类持有成员变量，就相当于一种全局变量，被所有的代码共享，那成员变量是可以被修改的，在编写单元测试的时候，还需要注意不用测试用例之间，修改单例类中的同一个成员变量的值，导致测试结果互相影响的问题。\n\n5.单例不支持有参数的构造函数\n\n单例不支持有参数的构造函数，比如创建一个连接池的单例对象，没法通过参数来指定连接池的大小。\n\n第一种解决思路：创建完实例后，再调用init()函数传递参数。但是在使用单例类的时候，要先调用init()方法，然后才能调用getInstance()方法，否则代码会抛出异常。\n\n```java\npublic class Singleton {\n  private static Singleton instance = null;\n  private final int paramA;\n  private final int paramB;\n  private Singleton(int paramA,int paramB) {\n    this.paramA = paramA;\n    this.paramB = paramB;\n  }\n  public static Singleton getInstance() {\n    if(instance == null) {\n      throw new RuntimeException(\"Run init() first.\");\n    }\n    return instance;\n  }\n  public synchronized static Singleton init(int paramA,int paramB) {\n    if(instance != null){\n      throw new RuntimeException(\"Singleton has bean created!\");\n    }\n    instance = new Singleton(paramA,paramB);\n    return instance;\n  }\n}\n```\n\n第二种解决思路是：将参数放到getInstance()方法中\n\n```java\npublic class Singleton {\n  private static Singleton instance = null;\n  private final int paramA;\n  private final int paramB;\n  private Singleton(int paramA,int paramB) {\n    this.paramA = paramA; \n    this.paramB = paramB;\n  }\n  public synchronized static Singleton getInstance(int paramA, int paramB) { \n    if (instance == null) { \n      instance = new Singleton(paramA, paramB); \n    } \n    return instance; \n  }\n}\n```\n\n但是执行两次getInstance()方法，第二次的参数不会起作用，构建的过程也没有给提示。因为是单例的，在getInstance()方法中加两个参数感觉并不合适。\n\n第三种解决思路是：将参数放到另外一个全局变量中。就是值即可以通过静态常量来定义，也可以从配置文件中加载得到。这种方法是最值得推荐的。\n\n```java\n\npublic class Config {\n  public static final int PARAM_A = 123;\n  public static final int PARAM_B = 245;\n}\n\npublic class Singleton {\n  private static Singleton instance = null;\n  private final int paramA;\n  private final int paramB;\n\n  private Singleton() {\n    this.paramA = Config.PARAM_A;\n    this.paramB = Config.PARAM_B;\n  }\n\n  public synchronized static Singleton getInstance() {\n    if (instance == null) {\n      instance = new Singleton();\n    }\n    return instance;\n  }\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/设计模式之单例模式.md","raw":"---\nlayout:    post\ntitle:     设计模式之单例模式\ncategory:  设计模式之美\ndescription: 设计模式之单例模式\ntags: 设计模式之美\ndate: 2021/04/16 13:26:10\n---\n\n### **单例模式**\n\n一个类只允许创建一个对象（或者实例），那这个类就是一个单例类，这种设计模式就叫单例模式。\n\n### **为什么使用单例**\n\n1.处理资源访问冲突\n\n日志去操作日志文件，多线程环境下，两个线程同时写日志，就可能存在覆盖的情况。解决这个问题一般都是想到通过加锁的方式，给函数加互斥锁（synchronized），但是synchronized(this) 是对象级别的锁，一个对象在不同线程下同时调用log()函数，会被强制要求顺序执行。但是不同的对象并不是共享一把锁。在不同的线程下，通过不同的对象调用执行log()函数，锁并不会起作用，仍然可能存在日志覆盖的情况。那么如何解决呢，我们只要把对象级别的锁换成类级别的锁就可以了。synchronized(Logger.class) 这样就避免了不同对象之间同时调用log函数，导致的日志覆盖问题。除此之外，并发队列也可以解决这个问题（BlockingQueue），多个线程同时并发往队列中写日志，一个单独的线程负责将队列中的日志写入到日志文件中。相比这两种方案，单例模式的思路就简单很多了。而且单例对于类级别锁的好处是，不需要创建很多的Logger对象，一方面节省内存空间，另一方面节省系统文件句柄（对于操作系统来说，文件句柄也是一种资源，不能随便浪费）\n\n2.表示全局唯一类\n\n在业务概念上，如果有些数据在系统中只应保存一份，那就比较适合设计为单例类。比如配置信息类。还有全局的唯一ID生成器。\n\n### 如何实现单例\n\n- 构造函数私有，避免外部通过new创建实例\n\n- 考虑对象创建时的线程安全问题\n\n- 考虑是否支持延迟加载\n\n- 考虑getInstance()性能是否高(是否加锁)\n\n  #### 1.饿汉式\n\n  饿汉式实现比较简单。在类加载的时候，instance静态实例就已经创建并初始化好了，所以，instance实例的创建过程是线程安全的。不过这样的方式不支持延迟加载(在真正用到的时候，再创建实例)\n\n  ```java\n  public class IdGenerator{\n    private AtomicLong id = new AtomicLong(0);\n    private static final IdGenerator instance = new IdGenerator();\n    private IdGenerator(){}\n    public static IdGenerator getInstance(){\n      return instance;\n    }\n    public long getId(){\n      return id.incrementAndGet();\n    }\n  }\n  ```\n\n  采用饿汉的实现方式，将耗时的初始化操作提前到程序启动的时候完成，这样能避免在程序运行的时候，再去初始化导致的性能问题。如果实例占用资源多，按照fail-fase的设计原则(有问题及早暴露)，我们也希望在程序启动时就将这个实例初始化好。如果资源不够，就会在启动的时候出发报错，我们可以立即去修复，这样也能避免在程序运行一段时间后，突然因为初始化这个实例占用资源过多，导致系统崩溃，影响系统的可用性。\n\n  #### 2.懒汉式\n\n  懒汉式的优势是支持延迟加载\n\n  ```java\n  public class IdGenerator { \n    private AtomicLong id = new AtomicLong(0);\n    private static IdGenerator instance;\n    private IdGenerator() {}\n    public static synchronized IdGenerator getInstance() {\n      if (instance == null) {\n        instance = new IdGenerator();\n      }\n      return instance;\n    }\n    public long getId() { \n      return id.incrementAndGet();\n    }\n  }\n  ```\n\n  懒汉式的缺点也很明显，我们给getInstance()这个方法加了一把大锁，导致这个函数的并发度很低。量化一下的话，并发度是1，就是想当于穿行操作了。而这个函数在单例使用期间，一直会被调用。如果频繁地用到，那频繁加锁、释放锁及并发度低等问题，会导致性能瓶颈，这种实现方式就不可取了。\n\n  #### 3.双重检测\n\n  饿汉式不支持延迟记载，懒汉式有性能问题，不支持高并发。在这种实现方式中，只要instance被创建之后，即便再调用getInstance()函数也不会再进入到加锁逻辑中了。\n\n  ```java\n  public class IdGenerator{\n    private AtomicLong id = new AtomicLong();\n    private static IdGenerator instance;\n    private IdGenerator(){}\n    public static IdGenerator getInstance(){\n      if(instance == null) {\n        synchronized(IdGenerator.class){ //此处为类级别的锁\n          if(instance == null){\n            instance = new IdGenerator();\n          }\n        }\n      }\n      return instance;\n    }\n    public long getId(){\n      return id.incrementAndGet();\n    }\n  }\n  ```\n\n  网上有人说，这种实现方式有问题，因为指令重排序，可能会导致IdGenerator对象被new出来，并且赋值给instance之后，还没来得及初始化(执行构造函数中的代码逻辑)，就被另一个线程使用了。\n\n  要解决这个问题，需要给instance成员变量加上volatile关键字，禁止指令重排序才行。实际上，只有很低版本的Java才会有这个问题。我们在用的高版本的Jave已经在JDK内部实现中解决了这个问题。(解决的办法很简单，只要把对象new操作和初始化操作设计为原子操作，就自然能禁止重排序)\n\n  #### 4.静态内部类\n\n  利用Java的静态内部类。既有点饿汉式，有做到了延迟加载。\n\n  ```java\n  public class IdGenerator{\n    private AtomicLong id = new AtomicLong(0); \n    private IdGenerator() {}\n    private static class SingletonHolder{\n      private static final IdGenerator instance = new IdGenerator();\n    }\n    public static IdGenerator getInstance() {\n      return SingletonHolder.instance;\n    }\n    public long getId(){\n      return id.incrementAndGet();\n    }\n  }\n  ```\n\n  SingletonHolder是一个静态内部类，当外部类IdGenerator被加载的时候，并不会创建SingletonHolder实例对象。只有当调用getInstance()方法时，SingletonHolder才会被加载，这个时候才会创建instance。instance的唯一性、创建过程的线程安全性，都由JVM来保证。所以这种实现方法即保证了线程安全，又能做到延迟加载。\n\n  #### 5.枚举\n\n  基于枚举类型的单例实现。这种实现方式通过Java枚举类型本身的特性，保证了实例创建的线程安全性和实例的唯一性。\n\n  ```java\n  public enum IdGenerator{\n    INSTANCE;\n    private AtomicLong id = new AtomicLong(0);\n    \n    public long getId(){\n      return id.incrementAndGet();\n    }\n  }\n  ```\n\n### 单例存在哪些问题\n\n1.单例对OOP特性支持不友好\n\nIdGenerator的使用方式违背了基于接口而非实现的设计原则，也就违背了OOP的抽象特性。如果未来希望针对不同业务采用不用的ID生成算法，为了应对这个需求变化，需要修改所有用到IdGenerator类的地方。单例对继承、多态的支持也不友好。因为单例类也可以被继承、也可以实现多态，只是实现起来会非常奇怪。所以一旦某个类被设计成单例类，也就意味着放弃了继承和多态这两个面向对象的特性，也就相当于损失了可以应对未来需求变化的扩展性。\n\n2.单例会隐藏类之间的依赖关系\n\n单例类不需要显示创建、不需要依赖参数传递，在函数直接调用就可以了。如果代码比较复杂，调用关系就会非常隐蔽。阅读代码的时候，需要仔细看每个函数的代码实现，才能知道这个类到底依赖了哪些类。\n\n3.单例对代码的扩展性不友好\n\n设计初期我们觉得系统中应该有一个数据库连接池，这样能方便控制对数据库连接资源的消耗。但是有些SQL语句运行得非常慢，为了解决这个问题，我们将慢SQL与其他SQL隔离执行，为了实现这样的目的，可以在系统中创建两个数据库连接池，慢SQL独享一个数据库连接池，其他SQL独享另一个数据库连接池，慢SQL就不会影响其他SQL的执行。单例类无法适应这样的需求变更，在某些情况下会影响代码的扩展性、灵活性。所以，数据库连接池、线程池这类的资源池还是不要设计成单例类。\n\n4.单例对代码的可测试性不友好\n\n单例模式的使用会影响到代码的可测试性。如果单例类以来比较重的外部资源，比如DB，写单元测试的时候，无法实现mock替换。如果单例类持有成员变量，就相当于一种全局变量，被所有的代码共享，那成员变量是可以被修改的，在编写单元测试的时候，还需要注意不用测试用例之间，修改单例类中的同一个成员变量的值，导致测试结果互相影响的问题。\n\n5.单例不支持有参数的构造函数\n\n单例不支持有参数的构造函数，比如创建一个连接池的单例对象，没法通过参数来指定连接池的大小。\n\n第一种解决思路：创建完实例后，再调用init()函数传递参数。但是在使用单例类的时候，要先调用init()方法，然后才能调用getInstance()方法，否则代码会抛出异常。\n\n```java\npublic class Singleton {\n  private static Singleton instance = null;\n  private final int paramA;\n  private final int paramB;\n  private Singleton(int paramA,int paramB) {\n    this.paramA = paramA;\n    this.paramB = paramB;\n  }\n  public static Singleton getInstance() {\n    if(instance == null) {\n      throw new RuntimeException(\"Run init() first.\");\n    }\n    return instance;\n  }\n  public synchronized static Singleton init(int paramA,int paramB) {\n    if(instance != null){\n      throw new RuntimeException(\"Singleton has bean created!\");\n    }\n    instance = new Singleton(paramA,paramB);\n    return instance;\n  }\n}\n```\n\n第二种解决思路是：将参数放到getInstance()方法中\n\n```java\npublic class Singleton {\n  private static Singleton instance = null;\n  private final int paramA;\n  private final int paramB;\n  private Singleton(int paramA,int paramB) {\n    this.paramA = paramA; \n    this.paramB = paramB;\n  }\n  public synchronized static Singleton getInstance(int paramA, int paramB) { \n    if (instance == null) { \n      instance = new Singleton(paramA, paramB); \n    } \n    return instance; \n  }\n}\n```\n\n但是执行两次getInstance()方法，第二次的参数不会起作用，构建的过程也没有给提示。因为是单例的，在getInstance()方法中加两个参数感觉并不合适。\n\n第三种解决思路是：将参数放到另外一个全局变量中。就是值即可以通过静态常量来定义，也可以从配置文件中加载得到。这种方法是最值得推荐的。\n\n```java\n\npublic class Config {\n  public static final int PARAM_A = 123;\n  public static final int PARAM_B = 245;\n}\n\npublic class Singleton {\n  private static Singleton instance = null;\n  private final int paramA;\n  private final int paramB;\n\n  private Singleton() {\n    this.paramA = Config.PARAM_A;\n    this.paramB = Config.PARAM_B;\n  }\n\n  public synchronized static Singleton getInstance() {\n    if (instance == null) {\n      instance = new Singleton();\n    }\n    return instance;\n  }\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"设计模式之单例模式","published":1,"updated":"2021-04-16T05:26:10.000Z","comments":1,"photos":[],"link":"","_id":"cm1m304xm001h31b4aqu086up","content":"<h3 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a><strong>单例模式</strong></h3><p>一个类只允许创建一个对象（或者实例），那这个类就是一个单例类，这种设计模式就叫单例模式。</p>\n<h3 id=\"为什么使用单例\"><a href=\"#为什么使用单例\" class=\"headerlink\" title=\"为什么使用单例\"></a><strong>为什么使用单例</strong></h3><p>1.处理资源访问冲突</p>\n<p>日志去操作日志文件，多线程环境下，两个线程同时写日志，就可能存在覆盖的情况。解决这个问题一般都是想到通过加锁的方式，给函数加互斥锁（synchronized），但是synchronized(this) 是对象级别的锁，一个对象在不同线程下同时调用log()函数，会被强制要求顺序执行。但是不同的对象并不是共享一把锁。在不同的线程下，通过不同的对象调用执行log()函数，锁并不会起作用，仍然可能存在日志覆盖的情况。那么如何解决呢，我们只要把对象级别的锁换成类级别的锁就可以了。synchronized(Logger.class) 这样就避免了不同对象之间同时调用log函数，导致的日志覆盖问题。除此之外，并发队列也可以解决这个问题（BlockingQueue），多个线程同时并发往队列中写日志，一个单独的线程负责将队列中的日志写入到日志文件中。相比这两种方案，单例模式的思路就简单很多了。而且单例对于类级别锁的好处是，不需要创建很多的Logger对象，一方面节省内存空间，另一方面节省系统文件句柄（对于操作系统来说，文件句柄也是一种资源，不能随便浪费）</p>\n<p>2.表示全局唯一类</p>\n<p>在业务概念上，如果有些数据在系统中只应保存一份，那就比较适合设计为单例类。比如配置信息类。还有全局的唯一ID生成器。</p>\n<h3 id=\"如何实现单例\"><a href=\"#如何实现单例\" class=\"headerlink\" title=\"如何实现单例\"></a>如何实现单例</h3><ul>\n<li><p>构造函数私有，避免外部通过new创建实例</p>\n</li>\n<li><p>考虑对象创建时的线程安全问题</p>\n</li>\n<li><p>考虑是否支持延迟加载</p>\n</li>\n<li><p>考虑getInstance()性能是否高(是否加锁)</p>\n<h4 id=\"1-饿汉式\"><a href=\"#1-饿汉式\" class=\"headerlink\" title=\"1.饿汉式\"></a>1.饿汉式</h4><p>饿汉式实现比较简单。在类加载的时候，instance静态实例就已经创建并初始化好了，所以，instance实例的创建过程是线程安全的。不过这样的方式不支持延迟加载(在真正用到的时候，再创建实例)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IdGenerator</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> AtomicLong id = <span class=\"keyword\">new</span> AtomicLong(<span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> IdGenerator instance = <span class=\"keyword\">new</span> IdGenerator();</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">IdGenerator</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> IdGenerator <span class=\"title\">getInstance</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">getId</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> id.incrementAndGet();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>采用饿汉的实现方式，将耗时的初始化操作提前到程序启动的时候完成，这样能避免在程序运行的时候，再去初始化导致的性能问题。如果实例占用资源多，按照fail-fase的设计原则(有问题及早暴露)，我们也希望在程序启动时就将这个实例初始化好。如果资源不够，就会在启动的时候出发报错，我们可以立即去修复，这样也能避免在程序运行一段时间后，突然因为初始化这个实例占用资源过多，导致系统崩溃，影响系统的可用性。</p>\n<h4 id=\"2-懒汉式\"><a href=\"#2-懒汉式\" class=\"headerlink\" title=\"2.懒汉式\"></a>2.懒汉式</h4><p>懒汉式的优势是支持延迟加载</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IdGenerator</span> </span>&#123; </span><br><span class=\"line\">  <span class=\"keyword\">private</span> AtomicLong id = <span class=\"keyword\">new</span> AtomicLong(<span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> IdGenerator instance;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">IdGenerator</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> IdGenerator <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      instance = <span class=\"keyword\">new</span> IdGenerator();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">getId</span><span class=\"params\">()</span> </span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> id.incrementAndGet();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>懒汉式的缺点也很明显，我们给getInstance()这个方法加了一把大锁，导致这个函数的并发度很低。量化一下的话，并发度是1，就是想当于穿行操作了。而这个函数在单例使用期间，一直会被调用。如果频繁地用到，那频繁加锁、释放锁及并发度低等问题，会导致性能瓶颈，这种实现方式就不可取了。</p>\n<h4 id=\"3-双重检测\"><a href=\"#3-双重检测\" class=\"headerlink\" title=\"3.双重检测\"></a>3.双重检测</h4><p>饿汉式不支持延迟记载，懒汉式有性能问题，不支持高并发。在这种实现方式中，只要instance被创建之后，即便再调用getInstance()函数也不会再进入到加锁逻辑中了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IdGenerator</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> AtomicLong id = <span class=\"keyword\">new</span> AtomicLong();</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> IdGenerator instance;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">IdGenerator</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> IdGenerator <span class=\"title\">getInstance</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(instance == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">synchronized</span>(IdGenerator.class)&#123; <span class=\"comment\">//此处为类级别的锁</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(instance == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">          instance = <span class=\"keyword\">new</span> IdGenerator();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">getId</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> id.incrementAndGet();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>网上有人说，这种实现方式有问题，因为指令重排序，可能会导致IdGenerator对象被new出来，并且赋值给instance之后，还没来得及初始化(执行构造函数中的代码逻辑)，就被另一个线程使用了。</p>\n<p>要解决这个问题，需要给instance成员变量加上volatile关键字，禁止指令重排序才行。实际上，只有很低版本的Java才会有这个问题。我们在用的高版本的Jave已经在JDK内部实现中解决了这个问题。(解决的办法很简单，只要把对象new操作和初始化操作设计为原子操作，就自然能禁止重排序)</p>\n<h4 id=\"4-静态内部类\"><a href=\"#4-静态内部类\" class=\"headerlink\" title=\"4.静态内部类\"></a>4.静态内部类</h4><p>利用Java的静态内部类。既有点饿汉式，有做到了延迟加载。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IdGenerator</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> AtomicLong id = <span class=\"keyword\">new</span> AtomicLong(<span class=\"number\">0</span>); </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">IdGenerator</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SingletonHolder</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> IdGenerator instance = <span class=\"keyword\">new</span> IdGenerator();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> IdGenerator <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> SingletonHolder.instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">getId</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> id.incrementAndGet();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>SingletonHolder是一个静态内部类，当外部类IdGenerator被加载的时候，并不会创建SingletonHolder实例对象。只有当调用getInstance()方法时，SingletonHolder才会被加载，这个时候才会创建instance。instance的唯一性、创建过程的线程安全性，都由JVM来保证。所以这种实现方法即保证了线程安全，又能做到延迟加载。</p>\n<h4 id=\"5-枚举\"><a href=\"#5-枚举\" class=\"headerlink\" title=\"5.枚举\"></a>5.枚举</h4><p>基于枚举类型的单例实现。这种实现方式通过Java枚举类型本身的特性，保证了实例创建的线程安全性和实例的唯一性。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">IdGenerator</span></span>&#123;</span><br><span class=\"line\">  INSTANCE;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> AtomicLong id = <span class=\"keyword\">new</span> AtomicLong(<span class=\"number\">0</span>);</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">getId</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> id.incrementAndGet();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"单例存在哪些问题\"><a href=\"#单例存在哪些问题\" class=\"headerlink\" title=\"单例存在哪些问题\"></a>单例存在哪些问题</h3><p>1.单例对OOP特性支持不友好</p>\n<p>IdGenerator的使用方式违背了基于接口而非实现的设计原则，也就违背了OOP的抽象特性。如果未来希望针对不同业务采用不用的ID生成算法，为了应对这个需求变化，需要修改所有用到IdGenerator类的地方。单例对继承、多态的支持也不友好。因为单例类也可以被继承、也可以实现多态，只是实现起来会非常奇怪。所以一旦某个类被设计成单例类，也就意味着放弃了继承和多态这两个面向对象的特性，也就相当于损失了可以应对未来需求变化的扩展性。</p>\n<p>2.单例会隐藏类之间的依赖关系</p>\n<p>单例类不需要显示创建、不需要依赖参数传递，在函数直接调用就可以了。如果代码比较复杂，调用关系就会非常隐蔽。阅读代码的时候，需要仔细看每个函数的代码实现，才能知道这个类到底依赖了哪些类。</p>\n<p>3.单例对代码的扩展性不友好</p>\n<p>设计初期我们觉得系统中应该有一个数据库连接池，这样能方便控制对数据库连接资源的消耗。但是有些SQL语句运行得非常慢，为了解决这个问题，我们将慢SQL与其他SQL隔离执行，为了实现这样的目的，可以在系统中创建两个数据库连接池，慢SQL独享一个数据库连接池，其他SQL独享另一个数据库连接池，慢SQL就不会影响其他SQL的执行。单例类无法适应这样的需求变更，在某些情况下会影响代码的扩展性、灵活性。所以，数据库连接池、线程池这类的资源池还是不要设计成单例类。</p>\n<p>4.单例对代码的可测试性不友好</p>\n<p>单例模式的使用会影响到代码的可测试性。如果单例类以来比较重的外部资源，比如DB，写单元测试的时候，无法实现mock替换。如果单例类持有成员变量，就相当于一种全局变量，被所有的代码共享，那成员变量是可以被修改的，在编写单元测试的时候，还需要注意不用测试用例之间，修改单例类中的同一个成员变量的值，导致测试结果互相影响的问题。</p>\n<p>5.单例不支持有参数的构造函数</p>\n<p>单例不支持有参数的构造函数，比如创建一个连接池的单例对象，没法通过参数来指定连接池的大小。</p>\n<p>第一种解决思路：创建完实例后，再调用init()函数传递参数。但是在使用单例类的时候，要先调用init()方法，然后才能调用getInstance()方法，否则代码会抛出异常。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> paramA;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> paramB;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">(<span class=\"keyword\">int</span> paramA,<span class=\"keyword\">int</span> paramB)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.paramA = paramA;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.paramB = paramB;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(instance == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">&quot;Run init() first.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">init</span><span class=\"params\">(<span class=\"keyword\">int</span> paramA,<span class=\"keyword\">int</span> paramB)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(instance != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">&quot;Singleton has bean created!&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    instance = <span class=\"keyword\">new</span> Singleton(paramA,paramB);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>第二种解决思路是：将参数放到getInstance()方法中</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> paramA;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> paramB;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">(<span class=\"keyword\">int</span> paramA,<span class=\"keyword\">int</span> paramB)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.paramA = paramA; </span><br><span class=\"line\">    <span class=\"keyword\">this</span>.paramB = paramB;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">(<span class=\"keyword\">int</span> paramA, <span class=\"keyword\">int</span> paramB)</span> </span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123; </span><br><span class=\"line\">      instance = <span class=\"keyword\">new</span> Singleton(paramA, paramB); </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance; </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是执行两次getInstance()方法，第二次的参数不会起作用，构建的过程也没有给提示。因为是单例的，在getInstance()方法中加两个参数感觉并不合适。</p>\n<p>第三种解决思路是：将参数放到另外一个全局变量中。就是值即可以通过静态常量来定义，也可以从配置文件中加载得到。这种方法是最值得推荐的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Config</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> PARAM_A = <span class=\"number\">123</span>;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> PARAM_B = <span class=\"number\">245</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> paramA;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> paramB;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.paramA = Config.PARAM_A;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.paramB = Config.PARAM_B;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      instance = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a><strong>单例模式</strong></h3><p>一个类只允许创建一个对象（或者实例），那这个类就是一个单例类，这种设计模式就叫单例模式。</p>\n<h3 id=\"为什么使用单例\"><a href=\"#为什么使用单例\" class=\"headerlink\" title=\"为什么使用单例\"></a><strong>为什么使用单例</strong></h3><p>1.处理资源访问冲突</p>\n<p>日志去操作日志文件，多线程环境下，两个线程同时写日志，就可能存在覆盖的情况。解决这个问题一般都是想到通过加锁的方式，给函数加互斥锁（synchronized），但是synchronized(this) 是对象级别的锁，一个对象在不同线程下同时调用log()函数，会被强制要求顺序执行。但是不同的对象并不是共享一把锁。在不同的线程下，通过不同的对象调用执行log()函数，锁并不会起作用，仍然可能存在日志覆盖的情况。那么如何解决呢，我们只要把对象级别的锁换成类级别的锁就可以了。synchronized(Logger.class) 这样就避免了不同对象之间同时调用log函数，导致的日志覆盖问题。除此之外，并发队列也可以解决这个问题（BlockingQueue），多个线程同时并发往队列中写日志，一个单独的线程负责将队列中的日志写入到日志文件中。相比这两种方案，单例模式的思路就简单很多了。而且单例对于类级别锁的好处是，不需要创建很多的Logger对象，一方面节省内存空间，另一方面节省系统文件句柄（对于操作系统来说，文件句柄也是一种资源，不能随便浪费）</p>\n<p>2.表示全局唯一类</p>\n<p>在业务概念上，如果有些数据在系统中只应保存一份，那就比较适合设计为单例类。比如配置信息类。还有全局的唯一ID生成器。</p>\n<h3 id=\"如何实现单例\"><a href=\"#如何实现单例\" class=\"headerlink\" title=\"如何实现单例\"></a>如何实现单例</h3><ul>\n<li><p>构造函数私有，避免外部通过new创建实例</p>\n</li>\n<li><p>考虑对象创建时的线程安全问题</p>\n</li>\n<li><p>考虑是否支持延迟加载</p>\n</li>\n<li><p>考虑getInstance()性能是否高(是否加锁)</p>\n<h4 id=\"1-饿汉式\"><a href=\"#1-饿汉式\" class=\"headerlink\" title=\"1.饿汉式\"></a>1.饿汉式</h4><p>饿汉式实现比较简单。在类加载的时候，instance静态实例就已经创建并初始化好了，所以，instance实例的创建过程是线程安全的。不过这样的方式不支持延迟加载(在真正用到的时候，再创建实例)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IdGenerator</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> AtomicLong id = <span class=\"keyword\">new</span> AtomicLong(<span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> IdGenerator instance = <span class=\"keyword\">new</span> IdGenerator();</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">IdGenerator</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> IdGenerator <span class=\"title\">getInstance</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">getId</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> id.incrementAndGet();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>采用饿汉的实现方式，将耗时的初始化操作提前到程序启动的时候完成，这样能避免在程序运行的时候，再去初始化导致的性能问题。如果实例占用资源多，按照fail-fase的设计原则(有问题及早暴露)，我们也希望在程序启动时就将这个实例初始化好。如果资源不够，就会在启动的时候出发报错，我们可以立即去修复，这样也能避免在程序运行一段时间后，突然因为初始化这个实例占用资源过多，导致系统崩溃，影响系统的可用性。</p>\n<h4 id=\"2-懒汉式\"><a href=\"#2-懒汉式\" class=\"headerlink\" title=\"2.懒汉式\"></a>2.懒汉式</h4><p>懒汉式的优势是支持延迟加载</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IdGenerator</span> </span>&#123; </span><br><span class=\"line\">  <span class=\"keyword\">private</span> AtomicLong id = <span class=\"keyword\">new</span> AtomicLong(<span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> IdGenerator instance;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">IdGenerator</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> IdGenerator <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      instance = <span class=\"keyword\">new</span> IdGenerator();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">getId</span><span class=\"params\">()</span> </span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> id.incrementAndGet();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>懒汉式的缺点也很明显，我们给getInstance()这个方法加了一把大锁，导致这个函数的并发度很低。量化一下的话，并发度是1，就是想当于穿行操作了。而这个函数在单例使用期间，一直会被调用。如果频繁地用到，那频繁加锁、释放锁及并发度低等问题，会导致性能瓶颈，这种实现方式就不可取了。</p>\n<h4 id=\"3-双重检测\"><a href=\"#3-双重检测\" class=\"headerlink\" title=\"3.双重检测\"></a>3.双重检测</h4><p>饿汉式不支持延迟记载，懒汉式有性能问题，不支持高并发。在这种实现方式中，只要instance被创建之后，即便再调用getInstance()函数也不会再进入到加锁逻辑中了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IdGenerator</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> AtomicLong id = <span class=\"keyword\">new</span> AtomicLong();</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> IdGenerator instance;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">IdGenerator</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> IdGenerator <span class=\"title\">getInstance</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(instance == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">synchronized</span>(IdGenerator.class)&#123; <span class=\"comment\">//此处为类级别的锁</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(instance == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">          instance = <span class=\"keyword\">new</span> IdGenerator();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">getId</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> id.incrementAndGet();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>网上有人说，这种实现方式有问题，因为指令重排序，可能会导致IdGenerator对象被new出来，并且赋值给instance之后，还没来得及初始化(执行构造函数中的代码逻辑)，就被另一个线程使用了。</p>\n<p>要解决这个问题，需要给instance成员变量加上volatile关键字，禁止指令重排序才行。实际上，只有很低版本的Java才会有这个问题。我们在用的高版本的Jave已经在JDK内部实现中解决了这个问题。(解决的办法很简单，只要把对象new操作和初始化操作设计为原子操作，就自然能禁止重排序)</p>\n<h4 id=\"4-静态内部类\"><a href=\"#4-静态内部类\" class=\"headerlink\" title=\"4.静态内部类\"></a>4.静态内部类</h4><p>利用Java的静态内部类。既有点饿汉式，有做到了延迟加载。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IdGenerator</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> AtomicLong id = <span class=\"keyword\">new</span> AtomicLong(<span class=\"number\">0</span>); </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">IdGenerator</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SingletonHolder</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> IdGenerator instance = <span class=\"keyword\">new</span> IdGenerator();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> IdGenerator <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> SingletonHolder.instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">getId</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> id.incrementAndGet();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>SingletonHolder是一个静态内部类，当外部类IdGenerator被加载的时候，并不会创建SingletonHolder实例对象。只有当调用getInstance()方法时，SingletonHolder才会被加载，这个时候才会创建instance。instance的唯一性、创建过程的线程安全性，都由JVM来保证。所以这种实现方法即保证了线程安全，又能做到延迟加载。</p>\n<h4 id=\"5-枚举\"><a href=\"#5-枚举\" class=\"headerlink\" title=\"5.枚举\"></a>5.枚举</h4><p>基于枚举类型的单例实现。这种实现方式通过Java枚举类型本身的特性，保证了实例创建的线程安全性和实例的唯一性。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">IdGenerator</span></span>&#123;</span><br><span class=\"line\">  INSTANCE;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> AtomicLong id = <span class=\"keyword\">new</span> AtomicLong(<span class=\"number\">0</span>);</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">getId</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> id.incrementAndGet();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"单例存在哪些问题\"><a href=\"#单例存在哪些问题\" class=\"headerlink\" title=\"单例存在哪些问题\"></a>单例存在哪些问题</h3><p>1.单例对OOP特性支持不友好</p>\n<p>IdGenerator的使用方式违背了基于接口而非实现的设计原则，也就违背了OOP的抽象特性。如果未来希望针对不同业务采用不用的ID生成算法，为了应对这个需求变化，需要修改所有用到IdGenerator类的地方。单例对继承、多态的支持也不友好。因为单例类也可以被继承、也可以实现多态，只是实现起来会非常奇怪。所以一旦某个类被设计成单例类，也就意味着放弃了继承和多态这两个面向对象的特性，也就相当于损失了可以应对未来需求变化的扩展性。</p>\n<p>2.单例会隐藏类之间的依赖关系</p>\n<p>单例类不需要显示创建、不需要依赖参数传递，在函数直接调用就可以了。如果代码比较复杂，调用关系就会非常隐蔽。阅读代码的时候，需要仔细看每个函数的代码实现，才能知道这个类到底依赖了哪些类。</p>\n<p>3.单例对代码的扩展性不友好</p>\n<p>设计初期我们觉得系统中应该有一个数据库连接池，这样能方便控制对数据库连接资源的消耗。但是有些SQL语句运行得非常慢，为了解决这个问题，我们将慢SQL与其他SQL隔离执行，为了实现这样的目的，可以在系统中创建两个数据库连接池，慢SQL独享一个数据库连接池，其他SQL独享另一个数据库连接池，慢SQL就不会影响其他SQL的执行。单例类无法适应这样的需求变更，在某些情况下会影响代码的扩展性、灵活性。所以，数据库连接池、线程池这类的资源池还是不要设计成单例类。</p>\n<p>4.单例对代码的可测试性不友好</p>\n<p>单例模式的使用会影响到代码的可测试性。如果单例类以来比较重的外部资源，比如DB，写单元测试的时候，无法实现mock替换。如果单例类持有成员变量，就相当于一种全局变量，被所有的代码共享，那成员变量是可以被修改的，在编写单元测试的时候，还需要注意不用测试用例之间，修改单例类中的同一个成员变量的值，导致测试结果互相影响的问题。</p>\n<p>5.单例不支持有参数的构造函数</p>\n<p>单例不支持有参数的构造函数，比如创建一个连接池的单例对象，没法通过参数来指定连接池的大小。</p>\n<p>第一种解决思路：创建完实例后，再调用init()函数传递参数。但是在使用单例类的时候，要先调用init()方法，然后才能调用getInstance()方法，否则代码会抛出异常。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> paramA;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> paramB;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">(<span class=\"keyword\">int</span> paramA,<span class=\"keyword\">int</span> paramB)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.paramA = paramA;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.paramB = paramB;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(instance == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">&quot;Run init() first.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">init</span><span class=\"params\">(<span class=\"keyword\">int</span> paramA,<span class=\"keyword\">int</span> paramB)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(instance != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">&quot;Singleton has bean created!&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    instance = <span class=\"keyword\">new</span> Singleton(paramA,paramB);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>第二种解决思路是：将参数放到getInstance()方法中</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> paramA;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> paramB;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">(<span class=\"keyword\">int</span> paramA,<span class=\"keyword\">int</span> paramB)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.paramA = paramA; </span><br><span class=\"line\">    <span class=\"keyword\">this</span>.paramB = paramB;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">(<span class=\"keyword\">int</span> paramA, <span class=\"keyword\">int</span> paramB)</span> </span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123; </span><br><span class=\"line\">      instance = <span class=\"keyword\">new</span> Singleton(paramA, paramB); </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance; </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是执行两次getInstance()方法，第二次的参数不会起作用，构建的过程也没有给提示。因为是单例的，在getInstance()方法中加两个参数感觉并不合适。</p>\n<p>第三种解决思路是：将参数放到另外一个全局变量中。就是值即可以通过静态常量来定义，也可以从配置文件中加载得到。这种方法是最值得推荐的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Config</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> PARAM_A = <span class=\"number\">123</span>;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> PARAM_B = <span class=\"number\">245</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> paramA;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> paramB;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.paramA = Config.PARAM_A;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.paramB = Config.PARAM_B;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      instance = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"layout":"post","title":"设计模式之备忘录模式","description":"设计模式之备忘录模式","date":"2021-06-23T05:26:10.000Z","_content":"备忘录模式理解、掌握都不难，代码实现比较灵活，应用场景也比较明确和有限，主要用来防丢失、撤销、恢复等。\n\n备忘录模式，也叫快照（Snapshot）模式，英文翻译是Memento Design Pattern。在GoF的《设计模式》一书中，备忘录模式是这么定义的：\n\n> Captures and externalizes an object’s internal state so that it can be restored later, all without violating encapsulation.\n\n翻译成中文就是：在不违背封装原则的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便之后恢复对象为先前的状态。\n\n这个模式的定义主要表达了两部分内容。一部分是，存储副本以便后期恢复。另一部分是，要在不违背封装原则的前提下，进行对象的备份和恢复。这部分不太好理解。我们结合一个例子来解释一下，搞清楚这两个问题：\n\n- 为什么存储和恢复副本会违背封装原则？\n- 备忘录模式是如何做到不违背封装原则的？\n\n假设有这样一道面试题，希望你编写一个小程序，可以接受命令行输入。用户输入文本时，程序将追加存储在内存文本中；用户输入“:list”，程序在命令行中输出内存文本的内容；用户输入“:undo”，程序会撤销上一次输入的文本，也就是从内存文本中将上次输入的文本删除掉。\n\n```shell\n>hello\n>:list\nhello\n>world\n>:list\nhelloworld\n>:undo\n>:list\nhello\n```\n\n怎么实现呢？\n\n```java\npublic class InputText {\n  private StringBuilder text = new StringBuilder();\n\n  public String getText() {\n    return text.toString();\n  }\n\n  public void append(String input) {\n    text.append(input);\n  }\n\n  public void setText(String text) {\n    this.text.replace(0, this.text.length(), text);\n  }\n}\n\npublic class SnapshotHolder {\n  private Stack<InputText> snapshots = new Stack<>();\n\n  public InputText popSnapshot() {\n    return snapshots.pop();\n  }\n\n  public void pushSnapshot(InputText inputText) {\n    InputText deepClonedInputText = new InputText();\n    deepClonedInputText.setText(inputText.getText());\n    snapshots.push(deepClonedInputText);\n  }\n}\n\npublic class ApplicationMain {\n  public static void main(String[] args) {\n    InputText inputText = new InputText();\n    SnapshotHolder snapshotsHolder = new SnapshotHolder();\n    Scanner scanner = new Scanner(System.in);\n    while (scanner.hasNext()) {\n      String input = scanner.next();\n      if (input.equals(\":list\")) {\n        System.out.println(inputText.getText());\n      } else if (input.equals(\":undo\")) {\n        InputText snapshot = snapshotsHolder.popSnapshot();\n        inputText.setText(snapshot.getText());\n      } else {\n        snapshotsHolder.pushSnapshot(inputText);\n        inputText.append(input);\n      }\n    }\n  }\n}\n```\n\n备忘录模式的实现很灵活，没有固定的实现方式，在不同的业务需求、不同编程语言下，代码实现可能都不大一样。上面的代码基本上已经实现了最基本的备忘录的功能。但是还有一些问题没有解决，就是要在不违背封装原则的前提下，进行对象的备份和恢复。而上面的代码并不满足这一点，主要体现在下面两方面：\n\n- 第一，为了能用快照恢复InputText对象，我们在InputText类中定义了setText()函数，但这个函数有可能会被其他业务使用，所以，暴露不应该暴露的函数违背了封装原则。\n- 第二，快照本身是不可变的。理论上讲，不应该包含任何set()等修饰内部状态的函数。但在上面的代码实现中，“快照”这个业务模型复用了InputText类的定义，而InputText类本身有一系列修改内部状态的函数，所以，用InputText类来表示快照违背了封装原则。\n\n针对以上问题，我们对代码做两点修改。第一，定义一个独立的类（Snapshot类）来表示快照，而不是复用InputText类。这个类只暴露get()方法，没有set()等任何修改内部状态的方法。第二，在InputText类中，我们把setText()方法重命名为restoreSnapshot()方法，用意更加明确，只用来恢复对象。\n\n按照这个思路，对上面的代码进行重构，重构后的代码如下：\n\n```java\npublic class InputText {\n  private StringBuilder text = new StringBuilder();\n\n  public String getText() {\n    return text.toString();\n  }\n\n  public void append(String input) {\n    text.append(input);\n  }\n\n  public Snapshot createSnapshot() {\n    return new Snapshot(text.toString());\n  }\n\n  public void restoreSnapshot(Snapshot snapshot) {\n    this.text.replace(0, this.text.length(), snapshot.getText());\n  }\n}\n\npublic class Snapshot {\n  private String text;\n\n  public Snapshot(String text) {\n    this.text = text;\n  }\n\n  public String getText() {\n    return this.text;\n  }\n}\n\npublic class SnapshotHolder {\n  private Stack<Snapshot> snapshots = new Stack<>();\n\n  public Snapshot popSnapshot() {\n    return snapshots.pop();\n  }\n\n  public void pushSnapshot(Snapshot snapshot) {\n    snapshots.push(snapshot);\n  }\n}\n\npublic class ApplicationMain {\n  public static void main(String[] args) {\n    InputText inputText = new InputText();\n    SnapshotHolder snapshotsHolder = new SnapshotHolder();\n    Scanner scanner = new Scanner(System.in);\n    while (scanner.hasNext()) {\n      String input = scanner.next();\n      if (input.equals(\":list\")) {\n        System.out.println(inputText.toString());\n      } else if (input.equals(\":undo\")) {\n        Snapshot snapshot = snapshotsHolder.popSnapshot();\n        inputText.restoreSnapshot(snapshot);\n      } else {\n        snapshotsHolder.pushSnapshot(inputText.createSnapshot());\n        inputText.append(input);\n      }\n    }\n  }\n}\n```\n\n上面的代码实现就是典型的备忘录模式的代码实现，也是很多书籍中给出的实现方法。\n\n除了备忘录模式，还有一个和它很类似的概念，“备份”，它在我们平时的开发中更常听到。那备忘录模式跟“备份”有什么区别和联系呢？实际上，这两者的应用场景很类似，都应用在放丢失、恢复、撤销等场景中。它们的区别在于，备忘录模式更侧重于代码的设计和实现，备份更侧重架构设计或产品设计。\n\n##### 如何优化内存和时间消耗？\n\n如果要备份的数据比较大，备份频率又比较高，那快照占用的内存会比较大，备份和恢复的耗时会比较长。这个问题如何解决呢？\n\n不同的场景下有不同的解决方法。比如前面的例子，应用场景是利用备忘录来实现撤销操作，而且仅仅支持顺序撤销，也就是说，每次操作只能撤销上一次的输入，不能跳过上次撤销之前的输入。在具有这样的应用场景下，为了节省内存，我们不需要在快照中存储完整的文本，只需要记录少许信息，比如在获取快照当下的文本长度，用这个值结合InputText类对象存储的文本来做撤销操作。\n\n假设每当有数据改动，都需要生成一个备份，以备之后恢复。如果需要备份的数据很大，这样高频的备份，不管是对存储（内存或者硬盘）的消耗，还是对时间的消耗，都是对时间的消耗，都可能是无法接受的。要解决这个问题，一般会采用“低频率全量备份”和“高频率增量备份”相结合的方法。\n\n全量备份就是把所有的数据“拍个快照”保存下来，“增量备份”记录每次操作或数据变动。\n\n当我们需要恢复到某一时间点的备份的时候，如果这一时间点有做全量备份，我们直接拿来恢复就可以了。如果这一时间点没有对应的全量备份，我们就先找到最近的一次全量备份，然后用它来恢复，之后执行此次全量备份跟这一时间点之间的所有增量备份，也就是对应的操作或者数据变动。这样就能减少全量备份的数量和频率，减少对时间、内存的消耗。\n\n\n\n","source":"_posts/设计模式之备忘录模式.md","raw":"---\nlayout:    post\ntitle:     设计模式之备忘录模式\ncategory:  设计模式之美\ndescription: 设计模式之备忘录模式\ntags: 设计模式之美\ndate: 2021/06/23 13:26:10\n---\n备忘录模式理解、掌握都不难，代码实现比较灵活，应用场景也比较明确和有限，主要用来防丢失、撤销、恢复等。\n\n备忘录模式，也叫快照（Snapshot）模式，英文翻译是Memento Design Pattern。在GoF的《设计模式》一书中，备忘录模式是这么定义的：\n\n> Captures and externalizes an object’s internal state so that it can be restored later, all without violating encapsulation.\n\n翻译成中文就是：在不违背封装原则的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便之后恢复对象为先前的状态。\n\n这个模式的定义主要表达了两部分内容。一部分是，存储副本以便后期恢复。另一部分是，要在不违背封装原则的前提下，进行对象的备份和恢复。这部分不太好理解。我们结合一个例子来解释一下，搞清楚这两个问题：\n\n- 为什么存储和恢复副本会违背封装原则？\n- 备忘录模式是如何做到不违背封装原则的？\n\n假设有这样一道面试题，希望你编写一个小程序，可以接受命令行输入。用户输入文本时，程序将追加存储在内存文本中；用户输入“:list”，程序在命令行中输出内存文本的内容；用户输入“:undo”，程序会撤销上一次输入的文本，也就是从内存文本中将上次输入的文本删除掉。\n\n```shell\n>hello\n>:list\nhello\n>world\n>:list\nhelloworld\n>:undo\n>:list\nhello\n```\n\n怎么实现呢？\n\n```java\npublic class InputText {\n  private StringBuilder text = new StringBuilder();\n\n  public String getText() {\n    return text.toString();\n  }\n\n  public void append(String input) {\n    text.append(input);\n  }\n\n  public void setText(String text) {\n    this.text.replace(0, this.text.length(), text);\n  }\n}\n\npublic class SnapshotHolder {\n  private Stack<InputText> snapshots = new Stack<>();\n\n  public InputText popSnapshot() {\n    return snapshots.pop();\n  }\n\n  public void pushSnapshot(InputText inputText) {\n    InputText deepClonedInputText = new InputText();\n    deepClonedInputText.setText(inputText.getText());\n    snapshots.push(deepClonedInputText);\n  }\n}\n\npublic class ApplicationMain {\n  public static void main(String[] args) {\n    InputText inputText = new InputText();\n    SnapshotHolder snapshotsHolder = new SnapshotHolder();\n    Scanner scanner = new Scanner(System.in);\n    while (scanner.hasNext()) {\n      String input = scanner.next();\n      if (input.equals(\":list\")) {\n        System.out.println(inputText.getText());\n      } else if (input.equals(\":undo\")) {\n        InputText snapshot = snapshotsHolder.popSnapshot();\n        inputText.setText(snapshot.getText());\n      } else {\n        snapshotsHolder.pushSnapshot(inputText);\n        inputText.append(input);\n      }\n    }\n  }\n}\n```\n\n备忘录模式的实现很灵活，没有固定的实现方式，在不同的业务需求、不同编程语言下，代码实现可能都不大一样。上面的代码基本上已经实现了最基本的备忘录的功能。但是还有一些问题没有解决，就是要在不违背封装原则的前提下，进行对象的备份和恢复。而上面的代码并不满足这一点，主要体现在下面两方面：\n\n- 第一，为了能用快照恢复InputText对象，我们在InputText类中定义了setText()函数，但这个函数有可能会被其他业务使用，所以，暴露不应该暴露的函数违背了封装原则。\n- 第二，快照本身是不可变的。理论上讲，不应该包含任何set()等修饰内部状态的函数。但在上面的代码实现中，“快照”这个业务模型复用了InputText类的定义，而InputText类本身有一系列修改内部状态的函数，所以，用InputText类来表示快照违背了封装原则。\n\n针对以上问题，我们对代码做两点修改。第一，定义一个独立的类（Snapshot类）来表示快照，而不是复用InputText类。这个类只暴露get()方法，没有set()等任何修改内部状态的方法。第二，在InputText类中，我们把setText()方法重命名为restoreSnapshot()方法，用意更加明确，只用来恢复对象。\n\n按照这个思路，对上面的代码进行重构，重构后的代码如下：\n\n```java\npublic class InputText {\n  private StringBuilder text = new StringBuilder();\n\n  public String getText() {\n    return text.toString();\n  }\n\n  public void append(String input) {\n    text.append(input);\n  }\n\n  public Snapshot createSnapshot() {\n    return new Snapshot(text.toString());\n  }\n\n  public void restoreSnapshot(Snapshot snapshot) {\n    this.text.replace(0, this.text.length(), snapshot.getText());\n  }\n}\n\npublic class Snapshot {\n  private String text;\n\n  public Snapshot(String text) {\n    this.text = text;\n  }\n\n  public String getText() {\n    return this.text;\n  }\n}\n\npublic class SnapshotHolder {\n  private Stack<Snapshot> snapshots = new Stack<>();\n\n  public Snapshot popSnapshot() {\n    return snapshots.pop();\n  }\n\n  public void pushSnapshot(Snapshot snapshot) {\n    snapshots.push(snapshot);\n  }\n}\n\npublic class ApplicationMain {\n  public static void main(String[] args) {\n    InputText inputText = new InputText();\n    SnapshotHolder snapshotsHolder = new SnapshotHolder();\n    Scanner scanner = new Scanner(System.in);\n    while (scanner.hasNext()) {\n      String input = scanner.next();\n      if (input.equals(\":list\")) {\n        System.out.println(inputText.toString());\n      } else if (input.equals(\":undo\")) {\n        Snapshot snapshot = snapshotsHolder.popSnapshot();\n        inputText.restoreSnapshot(snapshot);\n      } else {\n        snapshotsHolder.pushSnapshot(inputText.createSnapshot());\n        inputText.append(input);\n      }\n    }\n  }\n}\n```\n\n上面的代码实现就是典型的备忘录模式的代码实现，也是很多书籍中给出的实现方法。\n\n除了备忘录模式，还有一个和它很类似的概念，“备份”，它在我们平时的开发中更常听到。那备忘录模式跟“备份”有什么区别和联系呢？实际上，这两者的应用场景很类似，都应用在放丢失、恢复、撤销等场景中。它们的区别在于，备忘录模式更侧重于代码的设计和实现，备份更侧重架构设计或产品设计。\n\n##### 如何优化内存和时间消耗？\n\n如果要备份的数据比较大，备份频率又比较高，那快照占用的内存会比较大，备份和恢复的耗时会比较长。这个问题如何解决呢？\n\n不同的场景下有不同的解决方法。比如前面的例子，应用场景是利用备忘录来实现撤销操作，而且仅仅支持顺序撤销，也就是说，每次操作只能撤销上一次的输入，不能跳过上次撤销之前的输入。在具有这样的应用场景下，为了节省内存，我们不需要在快照中存储完整的文本，只需要记录少许信息，比如在获取快照当下的文本长度，用这个值结合InputText类对象存储的文本来做撤销操作。\n\n假设每当有数据改动，都需要生成一个备份，以备之后恢复。如果需要备份的数据很大，这样高频的备份，不管是对存储（内存或者硬盘）的消耗，还是对时间的消耗，都是对时间的消耗，都可能是无法接受的。要解决这个问题，一般会采用“低频率全量备份”和“高频率增量备份”相结合的方法。\n\n全量备份就是把所有的数据“拍个快照”保存下来，“增量备份”记录每次操作或数据变动。\n\n当我们需要恢复到某一时间点的备份的时候，如果这一时间点有做全量备份，我们直接拿来恢复就可以了。如果这一时间点没有对应的全量备份，我们就先找到最近的一次全量备份，然后用它来恢复，之后执行此次全量备份跟这一时间点之间的所有增量备份，也就是对应的操作或者数据变动。这样就能减少全量备份的数量和频率，减少对时间、内存的消耗。\n\n\n\n","slug":"设计模式之备忘录模式","published":1,"updated":"2021-06-23T05:26:10.000Z","comments":1,"photos":[],"link":"","_id":"cm1m304xn001k31b47cnwe93g","content":"<p>备忘录模式理解、掌握都不难，代码实现比较灵活，应用场景也比较明确和有限，主要用来防丢失、撤销、恢复等。</p>\n<p>备忘录模式，也叫快照（Snapshot）模式，英文翻译是Memento Design Pattern。在GoF的《设计模式》一书中，备忘录模式是这么定义的：</p>\n<blockquote>\n<p>Captures and externalizes an object’s internal state so that it can be restored later, all without violating encapsulation.</p>\n</blockquote>\n<p>翻译成中文就是：在不违背封装原则的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便之后恢复对象为先前的状态。</p>\n<p>这个模式的定义主要表达了两部分内容。一部分是，存储副本以便后期恢复。另一部分是，要在不违背封装原则的前提下，进行对象的备份和恢复。这部分不太好理解。我们结合一个例子来解释一下，搞清楚这两个问题：</p>\n<ul>\n<li>为什么存储和恢复副本会违背封装原则？</li>\n<li>备忘录模式是如何做到不违背封装原则的？</li>\n</ul>\n<p>假设有这样一道面试题，希望你编写一个小程序，可以接受命令行输入。用户输入文本时，程序将追加存储在内存文本中；用户输入“:list”，程序在命令行中输出内存文本的内容；用户输入“:undo”，程序会撤销上一次输入的文本，也就是从内存文本中将上次输入的文本删除掉。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\">hello</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\">:list</span></span><br><span class=\"line\">hello</span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\">world</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\">:list</span></span><br><span class=\"line\">helloworld</span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\">:undo</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\">:list</span></span><br><span class=\"line\">hello</span><br></pre></td></tr></table></figure>\n\n<p>怎么实现呢？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InputText</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> StringBuilder text = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getText</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> text.toString();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">append</span><span class=\"params\">(String input)</span> </span>&#123;</span><br><span class=\"line\">    text.append(input);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setText</span><span class=\"params\">(String text)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.text.replace(<span class=\"number\">0</span>, <span class=\"keyword\">this</span>.text.length(), text);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SnapshotHolder</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Stack&lt;InputText&gt; snapshots = <span class=\"keyword\">new</span> Stack&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> InputText <span class=\"title\">popSnapshot</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> snapshots.pop();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">pushSnapshot</span><span class=\"params\">(InputText inputText)</span> </span>&#123;</span><br><span class=\"line\">    InputText deepClonedInputText = <span class=\"keyword\">new</span> InputText();</span><br><span class=\"line\">    deepClonedInputText.setText(inputText.getText());</span><br><span class=\"line\">    snapshots.push(deepClonedInputText);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ApplicationMain</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    InputText inputText = <span class=\"keyword\">new</span> InputText();</span><br><span class=\"line\">    SnapshotHolder snapshotsHolder = <span class=\"keyword\">new</span> SnapshotHolder();</span><br><span class=\"line\">    Scanner scanner = <span class=\"keyword\">new</span> Scanner(System.in);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (scanner.hasNext()) &#123;</span><br><span class=\"line\">      String input = scanner.next();</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (input.equals(<span class=\"string\">&quot;:list&quot;</span>)) &#123;</span><br><span class=\"line\">        System.out.println(inputText.getText());</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (input.equals(<span class=\"string\">&quot;:undo&quot;</span>)) &#123;</span><br><span class=\"line\">        InputText snapshot = snapshotsHolder.popSnapshot();</span><br><span class=\"line\">        inputText.setText(snapshot.getText());</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        snapshotsHolder.pushSnapshot(inputText);</span><br><span class=\"line\">        inputText.append(input);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>备忘录模式的实现很灵活，没有固定的实现方式，在不同的业务需求、不同编程语言下，代码实现可能都不大一样。上面的代码基本上已经实现了最基本的备忘录的功能。但是还有一些问题没有解决，就是要在不违背封装原则的前提下，进行对象的备份和恢复。而上面的代码并不满足这一点，主要体现在下面两方面：</p>\n<ul>\n<li>第一，为了能用快照恢复InputText对象，我们在InputText类中定义了setText()函数，但这个函数有可能会被其他业务使用，所以，暴露不应该暴露的函数违背了封装原则。</li>\n<li>第二，快照本身是不可变的。理论上讲，不应该包含任何set()等修饰内部状态的函数。但在上面的代码实现中，“快照”这个业务模型复用了InputText类的定义，而InputText类本身有一系列修改内部状态的函数，所以，用InputText类来表示快照违背了封装原则。</li>\n</ul>\n<p>针对以上问题，我们对代码做两点修改。第一，定义一个独立的类（Snapshot类）来表示快照，而不是复用InputText类。这个类只暴露get()方法，没有set()等任何修改内部状态的方法。第二，在InputText类中，我们把setText()方法重命名为restoreSnapshot()方法，用意更加明确，只用来恢复对象。</p>\n<p>按照这个思路，对上面的代码进行重构，重构后的代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InputText</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> StringBuilder text = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getText</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> text.toString();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">append</span><span class=\"params\">(String input)</span> </span>&#123;</span><br><span class=\"line\">    text.append(input);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> Snapshot <span class=\"title\">createSnapshot</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Snapshot(text.toString());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">restoreSnapshot</span><span class=\"params\">(Snapshot snapshot)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.text.replace(<span class=\"number\">0</span>, <span class=\"keyword\">this</span>.text.length(), snapshot.getText());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Snapshot</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> String text;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Snapshot</span><span class=\"params\">(String text)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.text = text;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getText</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.text;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SnapshotHolder</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Stack&lt;Snapshot&gt; snapshots = <span class=\"keyword\">new</span> Stack&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> Snapshot <span class=\"title\">popSnapshot</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> snapshots.pop();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">pushSnapshot</span><span class=\"params\">(Snapshot snapshot)</span> </span>&#123;</span><br><span class=\"line\">    snapshots.push(snapshot);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ApplicationMain</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    InputText inputText = <span class=\"keyword\">new</span> InputText();</span><br><span class=\"line\">    SnapshotHolder snapshotsHolder = <span class=\"keyword\">new</span> SnapshotHolder();</span><br><span class=\"line\">    Scanner scanner = <span class=\"keyword\">new</span> Scanner(System.in);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (scanner.hasNext()) &#123;</span><br><span class=\"line\">      String input = scanner.next();</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (input.equals(<span class=\"string\">&quot;:list&quot;</span>)) &#123;</span><br><span class=\"line\">        System.out.println(inputText.toString());</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (input.equals(<span class=\"string\">&quot;:undo&quot;</span>)) &#123;</span><br><span class=\"line\">        Snapshot snapshot = snapshotsHolder.popSnapshot();</span><br><span class=\"line\">        inputText.restoreSnapshot(snapshot);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        snapshotsHolder.pushSnapshot(inputText.createSnapshot());</span><br><span class=\"line\">        inputText.append(input);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的代码实现就是典型的备忘录模式的代码实现，也是很多书籍中给出的实现方法。</p>\n<p>除了备忘录模式，还有一个和它很类似的概念，“备份”，它在我们平时的开发中更常听到。那备忘录模式跟“备份”有什么区别和联系呢？实际上，这两者的应用场景很类似，都应用在放丢失、恢复、撤销等场景中。它们的区别在于，备忘录模式更侧重于代码的设计和实现，备份更侧重架构设计或产品设计。</p>\n<h5 id=\"如何优化内存和时间消耗？\"><a href=\"#如何优化内存和时间消耗？\" class=\"headerlink\" title=\"如何优化内存和时间消耗？\"></a>如何优化内存和时间消耗？</h5><p>如果要备份的数据比较大，备份频率又比较高，那快照占用的内存会比较大，备份和恢复的耗时会比较长。这个问题如何解决呢？</p>\n<p>不同的场景下有不同的解决方法。比如前面的例子，应用场景是利用备忘录来实现撤销操作，而且仅仅支持顺序撤销，也就是说，每次操作只能撤销上一次的输入，不能跳过上次撤销之前的输入。在具有这样的应用场景下，为了节省内存，我们不需要在快照中存储完整的文本，只需要记录少许信息，比如在获取快照当下的文本长度，用这个值结合InputText类对象存储的文本来做撤销操作。</p>\n<p>假设每当有数据改动，都需要生成一个备份，以备之后恢复。如果需要备份的数据很大，这样高频的备份，不管是对存储（内存或者硬盘）的消耗，还是对时间的消耗，都是对时间的消耗，都可能是无法接受的。要解决这个问题，一般会采用“低频率全量备份”和“高频率增量备份”相结合的方法。</p>\n<p>全量备份就是把所有的数据“拍个快照”保存下来，“增量备份”记录每次操作或数据变动。</p>\n<p>当我们需要恢复到某一时间点的备份的时候，如果这一时间点有做全量备份，我们直接拿来恢复就可以了。如果这一时间点没有对应的全量备份，我们就先找到最近的一次全量备份，然后用它来恢复，之后执行此次全量备份跟这一时间点之间的所有增量备份，也就是对应的操作或者数据变动。这样就能减少全量备份的数量和频率，减少对时间、内存的消耗。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>备忘录模式理解、掌握都不难，代码实现比较灵活，应用场景也比较明确和有限，主要用来防丢失、撤销、恢复等。</p>\n<p>备忘录模式，也叫快照（Snapshot）模式，英文翻译是Memento Design Pattern。在GoF的《设计模式》一书中，备忘录模式是这么定义的：</p>\n<blockquote>\n<p>Captures and externalizes an object’s internal state so that it can be restored later, all without violating encapsulation.</p>\n</blockquote>\n<p>翻译成中文就是：在不违背封装原则的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便之后恢复对象为先前的状态。</p>\n<p>这个模式的定义主要表达了两部分内容。一部分是，存储副本以便后期恢复。另一部分是，要在不违背封装原则的前提下，进行对象的备份和恢复。这部分不太好理解。我们结合一个例子来解释一下，搞清楚这两个问题：</p>\n<ul>\n<li>为什么存储和恢复副本会违背封装原则？</li>\n<li>备忘录模式是如何做到不违背封装原则的？</li>\n</ul>\n<p>假设有这样一道面试题，希望你编写一个小程序，可以接受命令行输入。用户输入文本时，程序将追加存储在内存文本中；用户输入“:list”，程序在命令行中输出内存文本的内容；用户输入“:undo”，程序会撤销上一次输入的文本，也就是从内存文本中将上次输入的文本删除掉。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\">hello</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\">:list</span></span><br><span class=\"line\">hello</span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\">world</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\">:list</span></span><br><span class=\"line\">helloworld</span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\">:undo</span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\">:list</span></span><br><span class=\"line\">hello</span><br></pre></td></tr></table></figure>\n\n<p>怎么实现呢？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InputText</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> StringBuilder text = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getText</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> text.toString();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">append</span><span class=\"params\">(String input)</span> </span>&#123;</span><br><span class=\"line\">    text.append(input);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setText</span><span class=\"params\">(String text)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.text.replace(<span class=\"number\">0</span>, <span class=\"keyword\">this</span>.text.length(), text);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SnapshotHolder</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Stack&lt;InputText&gt; snapshots = <span class=\"keyword\">new</span> Stack&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> InputText <span class=\"title\">popSnapshot</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> snapshots.pop();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">pushSnapshot</span><span class=\"params\">(InputText inputText)</span> </span>&#123;</span><br><span class=\"line\">    InputText deepClonedInputText = <span class=\"keyword\">new</span> InputText();</span><br><span class=\"line\">    deepClonedInputText.setText(inputText.getText());</span><br><span class=\"line\">    snapshots.push(deepClonedInputText);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ApplicationMain</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    InputText inputText = <span class=\"keyword\">new</span> InputText();</span><br><span class=\"line\">    SnapshotHolder snapshotsHolder = <span class=\"keyword\">new</span> SnapshotHolder();</span><br><span class=\"line\">    Scanner scanner = <span class=\"keyword\">new</span> Scanner(System.in);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (scanner.hasNext()) &#123;</span><br><span class=\"line\">      String input = scanner.next();</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (input.equals(<span class=\"string\">&quot;:list&quot;</span>)) &#123;</span><br><span class=\"line\">        System.out.println(inputText.getText());</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (input.equals(<span class=\"string\">&quot;:undo&quot;</span>)) &#123;</span><br><span class=\"line\">        InputText snapshot = snapshotsHolder.popSnapshot();</span><br><span class=\"line\">        inputText.setText(snapshot.getText());</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        snapshotsHolder.pushSnapshot(inputText);</span><br><span class=\"line\">        inputText.append(input);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>备忘录模式的实现很灵活，没有固定的实现方式，在不同的业务需求、不同编程语言下，代码实现可能都不大一样。上面的代码基本上已经实现了最基本的备忘录的功能。但是还有一些问题没有解决，就是要在不违背封装原则的前提下，进行对象的备份和恢复。而上面的代码并不满足这一点，主要体现在下面两方面：</p>\n<ul>\n<li>第一，为了能用快照恢复InputText对象，我们在InputText类中定义了setText()函数，但这个函数有可能会被其他业务使用，所以，暴露不应该暴露的函数违背了封装原则。</li>\n<li>第二，快照本身是不可变的。理论上讲，不应该包含任何set()等修饰内部状态的函数。但在上面的代码实现中，“快照”这个业务模型复用了InputText类的定义，而InputText类本身有一系列修改内部状态的函数，所以，用InputText类来表示快照违背了封装原则。</li>\n</ul>\n<p>针对以上问题，我们对代码做两点修改。第一，定义一个独立的类（Snapshot类）来表示快照，而不是复用InputText类。这个类只暴露get()方法，没有set()等任何修改内部状态的方法。第二，在InputText类中，我们把setText()方法重命名为restoreSnapshot()方法，用意更加明确，只用来恢复对象。</p>\n<p>按照这个思路，对上面的代码进行重构，重构后的代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InputText</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> StringBuilder text = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getText</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> text.toString();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">append</span><span class=\"params\">(String input)</span> </span>&#123;</span><br><span class=\"line\">    text.append(input);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> Snapshot <span class=\"title\">createSnapshot</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Snapshot(text.toString());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">restoreSnapshot</span><span class=\"params\">(Snapshot snapshot)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.text.replace(<span class=\"number\">0</span>, <span class=\"keyword\">this</span>.text.length(), snapshot.getText());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Snapshot</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> String text;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Snapshot</span><span class=\"params\">(String text)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.text = text;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getText</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.text;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SnapshotHolder</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Stack&lt;Snapshot&gt; snapshots = <span class=\"keyword\">new</span> Stack&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> Snapshot <span class=\"title\">popSnapshot</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> snapshots.pop();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">pushSnapshot</span><span class=\"params\">(Snapshot snapshot)</span> </span>&#123;</span><br><span class=\"line\">    snapshots.push(snapshot);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ApplicationMain</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    InputText inputText = <span class=\"keyword\">new</span> InputText();</span><br><span class=\"line\">    SnapshotHolder snapshotsHolder = <span class=\"keyword\">new</span> SnapshotHolder();</span><br><span class=\"line\">    Scanner scanner = <span class=\"keyword\">new</span> Scanner(System.in);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (scanner.hasNext()) &#123;</span><br><span class=\"line\">      String input = scanner.next();</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (input.equals(<span class=\"string\">&quot;:list&quot;</span>)) &#123;</span><br><span class=\"line\">        System.out.println(inputText.toString());</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (input.equals(<span class=\"string\">&quot;:undo&quot;</span>)) &#123;</span><br><span class=\"line\">        Snapshot snapshot = snapshotsHolder.popSnapshot();</span><br><span class=\"line\">        inputText.restoreSnapshot(snapshot);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        snapshotsHolder.pushSnapshot(inputText.createSnapshot());</span><br><span class=\"line\">        inputText.append(input);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的代码实现就是典型的备忘录模式的代码实现，也是很多书籍中给出的实现方法。</p>\n<p>除了备忘录模式，还有一个和它很类似的概念，“备份”，它在我们平时的开发中更常听到。那备忘录模式跟“备份”有什么区别和联系呢？实际上，这两者的应用场景很类似，都应用在放丢失、恢复、撤销等场景中。它们的区别在于，备忘录模式更侧重于代码的设计和实现，备份更侧重架构设计或产品设计。</p>\n<h5 id=\"如何优化内存和时间消耗？\"><a href=\"#如何优化内存和时间消耗？\" class=\"headerlink\" title=\"如何优化内存和时间消耗？\"></a>如何优化内存和时间消耗？</h5><p>如果要备份的数据比较大，备份频率又比较高，那快照占用的内存会比较大，备份和恢复的耗时会比较长。这个问题如何解决呢？</p>\n<p>不同的场景下有不同的解决方法。比如前面的例子，应用场景是利用备忘录来实现撤销操作，而且仅仅支持顺序撤销，也就是说，每次操作只能撤销上一次的输入，不能跳过上次撤销之前的输入。在具有这样的应用场景下，为了节省内存，我们不需要在快照中存储完整的文本，只需要记录少许信息，比如在获取快照当下的文本长度，用这个值结合InputText类对象存储的文本来做撤销操作。</p>\n<p>假设每当有数据改动，都需要生成一个备份，以备之后恢复。如果需要备份的数据很大，这样高频的备份，不管是对存储（内存或者硬盘）的消耗，还是对时间的消耗，都是对时间的消耗，都可能是无法接受的。要解决这个问题，一般会采用“低频率全量备份”和“高频率增量备份”相结合的方法。</p>\n<p>全量备份就是把所有的数据“拍个快照”保存下来，“增量备份”记录每次操作或数据变动。</p>\n<p>当我们需要恢复到某一时间点的备份的时候，如果这一时间点有做全量备份，我们直接拿来恢复就可以了。如果这一时间点没有对应的全量备份，我们就先找到最近的一次全量备份，然后用它来恢复，之后执行此次全量备份跟这一时间点之间的所有增量备份，也就是对应的操作或者数据变动。这样就能减少全量备份的数量和频率，减少对时间、内存的消耗。</p>\n"},{"layout":"post","title":"设计模式之命令模式","description":"设计模式之命令模式","date":"2021-06-25T03:07:54.000Z","_content":"命令模式英文Command Design Pattern。GoF的《设计模式》中，它是这么定义的：\n\n> The command pattern encapsulates a request as an object, thereby letting us parameterize other objects with different requests, queue or log requests, and support undoable operations.\n\n翻译成中文就是：\n\n命令模式将请求（命令）封装成一个对象，这样可以使用不同的请求参数化其他对象（将不同请求依赖注入到其他对象），并且能够支持请求（命令）的排队执行、记录日志、撤销等（附加控制）功能。\n\n落实到编码实现，命令模式用的最核心的实现手段，是将函数封装成对象。C语言支持函数指针，可以把函数当作变量传来传去。但是在大部分编程语言中，函数没法儿作为参数传递给其他函数，也没法儿赋值给变量。借助命令模式，可以将函数封装成对象。具体来说，设计一个包含这个函数的类，实例化一个对象传来传去，这样就可以实现把函数像对象一样使用。从实现的角度来说，类似于回调。\n\n当把函数封装成对象之后，对象就可以存储下来，方便控制执行。命令模式的主要作用和应用场景，是用来控制命令的执行，比如，异步、延迟、排队执行命令、撤销重做命令、存储命令、给命令记录日志等等，这才是命令模式能发挥独一无二作用的地方。\n\n##### 命令模式的实战讲解\n\n假设正在开发一个类似《天天酷跑》或者《QQ卡丁车》这样的手游。这种游戏本身的复杂度集中在客户端。后端基本上只负责数据（积分、生命值、装备）的更新和查询，所以后端逻辑相对于客户端来说，要简单很多。\n\n为了提高性能，我们会把游戏中玩家的信息保存在内存中。在游戏运行的过程中，只更新内存中的数据，游戏结束之后，再将内存中的数据存档，也就是持久化到数据库中。为了降低实现的难度，一般来说，同一个游戏场景里的玩家，会被分配到同一台服务器上。这样，一个玩家拉取同一个游戏场景中的其他玩家的信息，就不需要跨服务器取查找了，实现起来就简单了很多。\n\n一般来说，游戏客户端和服务器之间的数据交互是比较频繁的，所以，为了节省网络连接建立的开销，客户端和服务器之间一般采取长连接的方式来通信。通信的格式有多种，比如Protocol Buffer、JSON、XML，甚至可以自定义格式。不管是什么格式，客户端发送给服务器的请求，一般都包括两部分内容：指令和数据。其中，指令我们也可以叫做事件，数据是执行这个指令所需的数据。\n\n服务器在接受到客户端的请求之后，会解析处指令和数据，并且根据指令的不同，执行不同的处理逻辑。对于这样的一个业务场景，一般会有两种架构实现思路。\n\n常用的一种实现就是利用多线程。一个线程接受请求，接收到请求后，启动一个新的线程来处理请求。具体点说，一般是通过一个主线程来接收客户端发来的请求。每当接收到一个请求之后，就从一个抓门用来处理请求的线程池中，捞出一个空闲线程来处理。\n\n另一种实现思路是在一个线程内轮询接受请求和处理请求。这种处理方式不太常见。尽管它无法利用多线程多核处理的优势，但是对于IO密集型的业务来说，它避免了多线程不停切换对性能的损耗，并且克服了多线程编程Bug比较难调试的缺点，也算是手游后端服务器开发中比较常见的架构模式了。\n\n重点来看下第二种实现方式。\n\n整个手游后端服务器轮训获取客户端发来的请求，获取到请求后，借助命令模式，把请求包含的数据和处理逻辑封装成命令对象，并存储在内存队列中。然后，再从队列中取出一定数量的命令来执行。执行完成之后，再开始新的一轮轮询。具体的示例代码如下。\n\n```java\npublic interface Command {\n  void execute();\n}\n\npublic class GotDiamondCommand implements Command {\n  // 省略成员变量\n\n  public GotDiamondCommand(/*数据*/) {\n    //...\n  }\n\n  @Override\n  public void execute() {\n    // 执行相应的逻辑\n  }\n}\n//GotStartCommand/HitObstacleCommand/ArchiveCommand类省略\n\npublic class GameApplication {\n  private static final int MAX_HANDLED_REQ_COUNT_PER_LOOP = 100;\n  private Queue<Command> queue = new LinkedList<>();\n\n  public void mainloop() {\n    while (true) {\n      List<Request> requests = new ArrayList<>();\n      \n      //省略从epoll或者select中获取数据，并封装成Request的逻辑，\n      //注意设置超时时间，如果很长时间没有接收到请求，就继续下面的逻辑处理。\n      \n      for (Request request : requests) {\n        Event event = request.getEvent();\n        Command command = null;\n        if (event.equals(Event.GOT_DIAMOND)) {\n          command = new GotDiamondCommand(/*数据*/);\n        } else if (event.equals(Event.GOT_STAR)) {\n          command = new GotStartCommand(/*数据*/);\n        } else if (event.equals(Event.HIT_OBSTACLE)) {\n          command = new HitObstacleCommand(/*数据*/);\n        } else if (event.equals(Event.ARCHIVE)) {\n          command = new ArchiveCommand(/*数据*/);\n        } // ...一堆else if...\n\n        queue.add(command);\n      }\n\n      int handledCount = 0;\n      while (handledCount < MAX_HANDLED_REQ_COUNT_PER_LOOP) {\n        if (queue.isEmpty()) {\n          break;\n        }\n        Command command = queue.poll();\n        command.execute();\n      }\n    }\n  }\n}\n```\n\n##### 命令模式VS策略模式\n\n每个设计模式都应该由两个部分组成：第一部分是应用场景，即这个模式可以解决哪类问题；第二部分是解决方案，即这个模式的设计思路和具体的代码实现。不过，代码实现并不是模式必须包含的。如果只是单纯的只关注解决方案这一部分，甚至只关注代码实现，就会产生大部分模式看起来都很相似的错觉。\n\n设计模式之间的主要区别还是在于设计意图，也就是应用场景。单纯地看设计思路或者代码实现，有些模式确实很相似，比如策略模式和工厂模式。\n\n策略模式包含策略的定义、创建和使用三部分，从代码结构上来，它非常像工厂模式。它们的区别在于，策略模式侧重“策略”或“算法”这个特定的应用场景，用来解决根据运行时状态从一组策略汇总选择不同策略的问题，而工厂模式侧重封装对象的创建过程，这里的对象没有任何业务场景的限定，可以是策略，但也可以是其他东西。从设计意图上来看，这两个模式完全是两回事。\n\n策略模式中，不同的策略具有相同的目的、不同的实现、相互之间可以替换。比如BubbleSort、SelectionSort都是为了实现排序的，只不过一个是用冒泡排序算法来实现的，另一个是用选择排序算法来实现的。而在命令模式中，不同的命令具有不同的目的，对应不同的处理逻辑，并且互相之间不可替换。","source":"_posts/设计模式之命令模式.md","raw":"---\nlayout:    post\ntitle:     设计模式之命令模式\ncategory:  设计模式之美\ndescription: 设计模式之命令模式\ntags: 设计模式之美\ndate: 2021/06/25 11:07:54\n---\n命令模式英文Command Design Pattern。GoF的《设计模式》中，它是这么定义的：\n\n> The command pattern encapsulates a request as an object, thereby letting us parameterize other objects with different requests, queue or log requests, and support undoable operations.\n\n翻译成中文就是：\n\n命令模式将请求（命令）封装成一个对象，这样可以使用不同的请求参数化其他对象（将不同请求依赖注入到其他对象），并且能够支持请求（命令）的排队执行、记录日志、撤销等（附加控制）功能。\n\n落实到编码实现，命令模式用的最核心的实现手段，是将函数封装成对象。C语言支持函数指针，可以把函数当作变量传来传去。但是在大部分编程语言中，函数没法儿作为参数传递给其他函数，也没法儿赋值给变量。借助命令模式，可以将函数封装成对象。具体来说，设计一个包含这个函数的类，实例化一个对象传来传去，这样就可以实现把函数像对象一样使用。从实现的角度来说，类似于回调。\n\n当把函数封装成对象之后，对象就可以存储下来，方便控制执行。命令模式的主要作用和应用场景，是用来控制命令的执行，比如，异步、延迟、排队执行命令、撤销重做命令、存储命令、给命令记录日志等等，这才是命令模式能发挥独一无二作用的地方。\n\n##### 命令模式的实战讲解\n\n假设正在开发一个类似《天天酷跑》或者《QQ卡丁车》这样的手游。这种游戏本身的复杂度集中在客户端。后端基本上只负责数据（积分、生命值、装备）的更新和查询，所以后端逻辑相对于客户端来说，要简单很多。\n\n为了提高性能，我们会把游戏中玩家的信息保存在内存中。在游戏运行的过程中，只更新内存中的数据，游戏结束之后，再将内存中的数据存档，也就是持久化到数据库中。为了降低实现的难度，一般来说，同一个游戏场景里的玩家，会被分配到同一台服务器上。这样，一个玩家拉取同一个游戏场景中的其他玩家的信息，就不需要跨服务器取查找了，实现起来就简单了很多。\n\n一般来说，游戏客户端和服务器之间的数据交互是比较频繁的，所以，为了节省网络连接建立的开销，客户端和服务器之间一般采取长连接的方式来通信。通信的格式有多种，比如Protocol Buffer、JSON、XML，甚至可以自定义格式。不管是什么格式，客户端发送给服务器的请求，一般都包括两部分内容：指令和数据。其中，指令我们也可以叫做事件，数据是执行这个指令所需的数据。\n\n服务器在接受到客户端的请求之后，会解析处指令和数据，并且根据指令的不同，执行不同的处理逻辑。对于这样的一个业务场景，一般会有两种架构实现思路。\n\n常用的一种实现就是利用多线程。一个线程接受请求，接收到请求后，启动一个新的线程来处理请求。具体点说，一般是通过一个主线程来接收客户端发来的请求。每当接收到一个请求之后，就从一个抓门用来处理请求的线程池中，捞出一个空闲线程来处理。\n\n另一种实现思路是在一个线程内轮询接受请求和处理请求。这种处理方式不太常见。尽管它无法利用多线程多核处理的优势，但是对于IO密集型的业务来说，它避免了多线程不停切换对性能的损耗，并且克服了多线程编程Bug比较难调试的缺点，也算是手游后端服务器开发中比较常见的架构模式了。\n\n重点来看下第二种实现方式。\n\n整个手游后端服务器轮训获取客户端发来的请求，获取到请求后，借助命令模式，把请求包含的数据和处理逻辑封装成命令对象，并存储在内存队列中。然后，再从队列中取出一定数量的命令来执行。执行完成之后，再开始新的一轮轮询。具体的示例代码如下。\n\n```java\npublic interface Command {\n  void execute();\n}\n\npublic class GotDiamondCommand implements Command {\n  // 省略成员变量\n\n  public GotDiamondCommand(/*数据*/) {\n    //...\n  }\n\n  @Override\n  public void execute() {\n    // 执行相应的逻辑\n  }\n}\n//GotStartCommand/HitObstacleCommand/ArchiveCommand类省略\n\npublic class GameApplication {\n  private static final int MAX_HANDLED_REQ_COUNT_PER_LOOP = 100;\n  private Queue<Command> queue = new LinkedList<>();\n\n  public void mainloop() {\n    while (true) {\n      List<Request> requests = new ArrayList<>();\n      \n      //省略从epoll或者select中获取数据，并封装成Request的逻辑，\n      //注意设置超时时间，如果很长时间没有接收到请求，就继续下面的逻辑处理。\n      \n      for (Request request : requests) {\n        Event event = request.getEvent();\n        Command command = null;\n        if (event.equals(Event.GOT_DIAMOND)) {\n          command = new GotDiamondCommand(/*数据*/);\n        } else if (event.equals(Event.GOT_STAR)) {\n          command = new GotStartCommand(/*数据*/);\n        } else if (event.equals(Event.HIT_OBSTACLE)) {\n          command = new HitObstacleCommand(/*数据*/);\n        } else if (event.equals(Event.ARCHIVE)) {\n          command = new ArchiveCommand(/*数据*/);\n        } // ...一堆else if...\n\n        queue.add(command);\n      }\n\n      int handledCount = 0;\n      while (handledCount < MAX_HANDLED_REQ_COUNT_PER_LOOP) {\n        if (queue.isEmpty()) {\n          break;\n        }\n        Command command = queue.poll();\n        command.execute();\n      }\n    }\n  }\n}\n```\n\n##### 命令模式VS策略模式\n\n每个设计模式都应该由两个部分组成：第一部分是应用场景，即这个模式可以解决哪类问题；第二部分是解决方案，即这个模式的设计思路和具体的代码实现。不过，代码实现并不是模式必须包含的。如果只是单纯的只关注解决方案这一部分，甚至只关注代码实现，就会产生大部分模式看起来都很相似的错觉。\n\n设计模式之间的主要区别还是在于设计意图，也就是应用场景。单纯地看设计思路或者代码实现，有些模式确实很相似，比如策略模式和工厂模式。\n\n策略模式包含策略的定义、创建和使用三部分，从代码结构上来，它非常像工厂模式。它们的区别在于，策略模式侧重“策略”或“算法”这个特定的应用场景，用来解决根据运行时状态从一组策略汇总选择不同策略的问题，而工厂模式侧重封装对象的创建过程，这里的对象没有任何业务场景的限定，可以是策略，但也可以是其他东西。从设计意图上来看，这两个模式完全是两回事。\n\n策略模式中，不同的策略具有相同的目的、不同的实现、相互之间可以替换。比如BubbleSort、SelectionSort都是为了实现排序的，只不过一个是用冒泡排序算法来实现的，另一个是用选择排序算法来实现的。而在命令模式中，不同的命令具有不同的目的，对应不同的处理逻辑，并且互相之间不可替换。","slug":"设计模式之命令模式","published":1,"updated":"2021-06-25T03:07:54.000Z","comments":1,"photos":[],"link":"","_id":"cm1m304xo001n31b47t9n2xnw","content":"<p>命令模式英文Command Design Pattern。GoF的《设计模式》中，它是这么定义的：</p>\n<blockquote>\n<p>The command pattern encapsulates a request as an object, thereby letting us parameterize other objects with different requests, queue or log requests, and support undoable operations.</p>\n</blockquote>\n<p>翻译成中文就是：</p>\n<p>命令模式将请求（命令）封装成一个对象，这样可以使用不同的请求参数化其他对象（将不同请求依赖注入到其他对象），并且能够支持请求（命令）的排队执行、记录日志、撤销等（附加控制）功能。</p>\n<p>落实到编码实现，命令模式用的最核心的实现手段，是将函数封装成对象。C语言支持函数指针，可以把函数当作变量传来传去。但是在大部分编程语言中，函数没法儿作为参数传递给其他函数，也没法儿赋值给变量。借助命令模式，可以将函数封装成对象。具体来说，设计一个包含这个函数的类，实例化一个对象传来传去，这样就可以实现把函数像对象一样使用。从实现的角度来说，类似于回调。</p>\n<p>当把函数封装成对象之后，对象就可以存储下来，方便控制执行。命令模式的主要作用和应用场景，是用来控制命令的执行，比如，异步、延迟、排队执行命令、撤销重做命令、存储命令、给命令记录日志等等，这才是命令模式能发挥独一无二作用的地方。</p>\n<h5 id=\"命令模式的实战讲解\"><a href=\"#命令模式的实战讲解\" class=\"headerlink\" title=\"命令模式的实战讲解\"></a>命令模式的实战讲解</h5><p>假设正在开发一个类似《天天酷跑》或者《QQ卡丁车》这样的手游。这种游戏本身的复杂度集中在客户端。后端基本上只负责数据（积分、生命值、装备）的更新和查询，所以后端逻辑相对于客户端来说，要简单很多。</p>\n<p>为了提高性能，我们会把游戏中玩家的信息保存在内存中。在游戏运行的过程中，只更新内存中的数据，游戏结束之后，再将内存中的数据存档，也就是持久化到数据库中。为了降低实现的难度，一般来说，同一个游戏场景里的玩家，会被分配到同一台服务器上。这样，一个玩家拉取同一个游戏场景中的其他玩家的信息，就不需要跨服务器取查找了，实现起来就简单了很多。</p>\n<p>一般来说，游戏客户端和服务器之间的数据交互是比较频繁的，所以，为了节省网络连接建立的开销，客户端和服务器之间一般采取长连接的方式来通信。通信的格式有多种，比如Protocol Buffer、JSON、XML，甚至可以自定义格式。不管是什么格式，客户端发送给服务器的请求，一般都包括两部分内容：指令和数据。其中，指令我们也可以叫做事件，数据是执行这个指令所需的数据。</p>\n<p>服务器在接受到客户端的请求之后，会解析处指令和数据，并且根据指令的不同，执行不同的处理逻辑。对于这样的一个业务场景，一般会有两种架构实现思路。</p>\n<p>常用的一种实现就是利用多线程。一个线程接受请求，接收到请求后，启动一个新的线程来处理请求。具体点说，一般是通过一个主线程来接收客户端发来的请求。每当接收到一个请求之后，就从一个抓门用来处理请求的线程池中，捞出一个空闲线程来处理。</p>\n<p>另一种实现思路是在一个线程内轮询接受请求和处理请求。这种处理方式不太常见。尽管它无法利用多线程多核处理的优势，但是对于IO密集型的业务来说，它避免了多线程不停切换对性能的损耗，并且克服了多线程编程Bug比较难调试的缺点，也算是手游后端服务器开发中比较常见的架构模式了。</p>\n<p>重点来看下第二种实现方式。</p>\n<p>整个手游后端服务器轮训获取客户端发来的请求，获取到请求后，借助命令模式，把请求包含的数据和处理逻辑封装成命令对象，并存储在内存队列中。然后，再从队列中取出一定数量的命令来执行。执行完成之后，再开始新的一轮轮询。具体的示例代码如下。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Command</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GotDiamondCommand</span> <span class=\"keyword\">implements</span> <span class=\"title\">Command</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 省略成员变量</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">GotDiamondCommand</span><span class=\"params\">(<span class=\"comment\">/*数据*/</span>)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 执行相应的逻辑</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//GotStartCommand/HitObstacleCommand/ArchiveCommand类省略</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GameApplication</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MAX_HANDLED_REQ_COUNT_PER_LOOP = <span class=\"number\">100</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Queue&lt;Command&gt; queue = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">mainloop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">      List&lt;Request&gt; requests = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"comment\">//省略从epoll或者select中获取数据，并封装成Request的逻辑，</span></span><br><span class=\"line\">      <span class=\"comment\">//注意设置超时时间，如果很长时间没有接收到请求，就继续下面的逻辑处理。</span></span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"keyword\">for</span> (Request request : requests) &#123;</span><br><span class=\"line\">        Event event = request.getEvent();</span><br><span class=\"line\">        Command command = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (event.equals(Event.GOT_DIAMOND)) &#123;</span><br><span class=\"line\">          command = <span class=\"keyword\">new</span> GotDiamondCommand(<span class=\"comment\">/*数据*/</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (event.equals(Event.GOT_STAR)) &#123;</span><br><span class=\"line\">          command = <span class=\"keyword\">new</span> GotStartCommand(<span class=\"comment\">/*数据*/</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (event.equals(Event.HIT_OBSTACLE)) &#123;</span><br><span class=\"line\">          command = <span class=\"keyword\">new</span> HitObstacleCommand(<span class=\"comment\">/*数据*/</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (event.equals(Event.ARCHIVE)) &#123;</span><br><span class=\"line\">          command = <span class=\"keyword\">new</span> ArchiveCommand(<span class=\"comment\">/*数据*/</span>);</span><br><span class=\"line\">        &#125; <span class=\"comment\">// ...一堆else if...</span></span><br><span class=\"line\"></span><br><span class=\"line\">        queue.add(command);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">int</span> handledCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">      <span class=\"keyword\">while</span> (handledCount &lt; MAX_HANDLED_REQ_COUNT_PER_LOOP) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (queue.isEmpty()) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Command command = queue.poll();</span><br><span class=\"line\">        command.execute();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"命令模式VS策略模式\"><a href=\"#命令模式VS策略模式\" class=\"headerlink\" title=\"命令模式VS策略模式\"></a>命令模式VS策略模式</h5><p>每个设计模式都应该由两个部分组成：第一部分是应用场景，即这个模式可以解决哪类问题；第二部分是解决方案，即这个模式的设计思路和具体的代码实现。不过，代码实现并不是模式必须包含的。如果只是单纯的只关注解决方案这一部分，甚至只关注代码实现，就会产生大部分模式看起来都很相似的错觉。</p>\n<p>设计模式之间的主要区别还是在于设计意图，也就是应用场景。单纯地看设计思路或者代码实现，有些模式确实很相似，比如策略模式和工厂模式。</p>\n<p>策略模式包含策略的定义、创建和使用三部分，从代码结构上来，它非常像工厂模式。它们的区别在于，策略模式侧重“策略”或“算法”这个特定的应用场景，用来解决根据运行时状态从一组策略汇总选择不同策略的问题，而工厂模式侧重封装对象的创建过程，这里的对象没有任何业务场景的限定，可以是策略，但也可以是其他东西。从设计意图上来看，这两个模式完全是两回事。</p>\n<p>策略模式中，不同的策略具有相同的目的、不同的实现、相互之间可以替换。比如BubbleSort、SelectionSort都是为了实现排序的，只不过一个是用冒泡排序算法来实现的，另一个是用选择排序算法来实现的。而在命令模式中，不同的命令具有不同的目的，对应不同的处理逻辑，并且互相之间不可替换。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>命令模式英文Command Design Pattern。GoF的《设计模式》中，它是这么定义的：</p>\n<blockquote>\n<p>The command pattern encapsulates a request as an object, thereby letting us parameterize other objects with different requests, queue or log requests, and support undoable operations.</p>\n</blockquote>\n<p>翻译成中文就是：</p>\n<p>命令模式将请求（命令）封装成一个对象，这样可以使用不同的请求参数化其他对象（将不同请求依赖注入到其他对象），并且能够支持请求（命令）的排队执行、记录日志、撤销等（附加控制）功能。</p>\n<p>落实到编码实现，命令模式用的最核心的实现手段，是将函数封装成对象。C语言支持函数指针，可以把函数当作变量传来传去。但是在大部分编程语言中，函数没法儿作为参数传递给其他函数，也没法儿赋值给变量。借助命令模式，可以将函数封装成对象。具体来说，设计一个包含这个函数的类，实例化一个对象传来传去，这样就可以实现把函数像对象一样使用。从实现的角度来说，类似于回调。</p>\n<p>当把函数封装成对象之后，对象就可以存储下来，方便控制执行。命令模式的主要作用和应用场景，是用来控制命令的执行，比如，异步、延迟、排队执行命令、撤销重做命令、存储命令、给命令记录日志等等，这才是命令模式能发挥独一无二作用的地方。</p>\n<h5 id=\"命令模式的实战讲解\"><a href=\"#命令模式的实战讲解\" class=\"headerlink\" title=\"命令模式的实战讲解\"></a>命令模式的实战讲解</h5><p>假设正在开发一个类似《天天酷跑》或者《QQ卡丁车》这样的手游。这种游戏本身的复杂度集中在客户端。后端基本上只负责数据（积分、生命值、装备）的更新和查询，所以后端逻辑相对于客户端来说，要简单很多。</p>\n<p>为了提高性能，我们会把游戏中玩家的信息保存在内存中。在游戏运行的过程中，只更新内存中的数据，游戏结束之后，再将内存中的数据存档，也就是持久化到数据库中。为了降低实现的难度，一般来说，同一个游戏场景里的玩家，会被分配到同一台服务器上。这样，一个玩家拉取同一个游戏场景中的其他玩家的信息，就不需要跨服务器取查找了，实现起来就简单了很多。</p>\n<p>一般来说，游戏客户端和服务器之间的数据交互是比较频繁的，所以，为了节省网络连接建立的开销，客户端和服务器之间一般采取长连接的方式来通信。通信的格式有多种，比如Protocol Buffer、JSON、XML，甚至可以自定义格式。不管是什么格式，客户端发送给服务器的请求，一般都包括两部分内容：指令和数据。其中，指令我们也可以叫做事件，数据是执行这个指令所需的数据。</p>\n<p>服务器在接受到客户端的请求之后，会解析处指令和数据，并且根据指令的不同，执行不同的处理逻辑。对于这样的一个业务场景，一般会有两种架构实现思路。</p>\n<p>常用的一种实现就是利用多线程。一个线程接受请求，接收到请求后，启动一个新的线程来处理请求。具体点说，一般是通过一个主线程来接收客户端发来的请求。每当接收到一个请求之后，就从一个抓门用来处理请求的线程池中，捞出一个空闲线程来处理。</p>\n<p>另一种实现思路是在一个线程内轮询接受请求和处理请求。这种处理方式不太常见。尽管它无法利用多线程多核处理的优势，但是对于IO密集型的业务来说，它避免了多线程不停切换对性能的损耗，并且克服了多线程编程Bug比较难调试的缺点，也算是手游后端服务器开发中比较常见的架构模式了。</p>\n<p>重点来看下第二种实现方式。</p>\n<p>整个手游后端服务器轮训获取客户端发来的请求，获取到请求后，借助命令模式，把请求包含的数据和处理逻辑封装成命令对象，并存储在内存队列中。然后，再从队列中取出一定数量的命令来执行。执行完成之后，再开始新的一轮轮询。具体的示例代码如下。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Command</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GotDiamondCommand</span> <span class=\"keyword\">implements</span> <span class=\"title\">Command</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 省略成员变量</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">GotDiamondCommand</span><span class=\"params\">(<span class=\"comment\">/*数据*/</span>)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 执行相应的逻辑</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//GotStartCommand/HitObstacleCommand/ArchiveCommand类省略</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GameApplication</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MAX_HANDLED_REQ_COUNT_PER_LOOP = <span class=\"number\">100</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Queue&lt;Command&gt; queue = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">mainloop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">      List&lt;Request&gt; requests = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"comment\">//省略从epoll或者select中获取数据，并封装成Request的逻辑，</span></span><br><span class=\"line\">      <span class=\"comment\">//注意设置超时时间，如果很长时间没有接收到请求，就继续下面的逻辑处理。</span></span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"keyword\">for</span> (Request request : requests) &#123;</span><br><span class=\"line\">        Event event = request.getEvent();</span><br><span class=\"line\">        Command command = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (event.equals(Event.GOT_DIAMOND)) &#123;</span><br><span class=\"line\">          command = <span class=\"keyword\">new</span> GotDiamondCommand(<span class=\"comment\">/*数据*/</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (event.equals(Event.GOT_STAR)) &#123;</span><br><span class=\"line\">          command = <span class=\"keyword\">new</span> GotStartCommand(<span class=\"comment\">/*数据*/</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (event.equals(Event.HIT_OBSTACLE)) &#123;</span><br><span class=\"line\">          command = <span class=\"keyword\">new</span> HitObstacleCommand(<span class=\"comment\">/*数据*/</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (event.equals(Event.ARCHIVE)) &#123;</span><br><span class=\"line\">          command = <span class=\"keyword\">new</span> ArchiveCommand(<span class=\"comment\">/*数据*/</span>);</span><br><span class=\"line\">        &#125; <span class=\"comment\">// ...一堆else if...</span></span><br><span class=\"line\"></span><br><span class=\"line\">        queue.add(command);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">int</span> handledCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">      <span class=\"keyword\">while</span> (handledCount &lt; MAX_HANDLED_REQ_COUNT_PER_LOOP) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (queue.isEmpty()) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Command command = queue.poll();</span><br><span class=\"line\">        command.execute();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"命令模式VS策略模式\"><a href=\"#命令模式VS策略模式\" class=\"headerlink\" title=\"命令模式VS策略模式\"></a>命令模式VS策略模式</h5><p>每个设计模式都应该由两个部分组成：第一部分是应用场景，即这个模式可以解决哪类问题；第二部分是解决方案，即这个模式的设计思路和具体的代码实现。不过，代码实现并不是模式必须包含的。如果只是单纯的只关注解决方案这一部分，甚至只关注代码实现，就会产生大部分模式看起来都很相似的错觉。</p>\n<p>设计模式之间的主要区别还是在于设计意图，也就是应用场景。单纯地看设计思路或者代码实现，有些模式确实很相似，比如策略模式和工厂模式。</p>\n<p>策略模式包含策略的定义、创建和使用三部分，从代码结构上来，它非常像工厂模式。它们的区别在于，策略模式侧重“策略”或“算法”这个特定的应用场景，用来解决根据运行时状态从一组策略汇总选择不同策略的问题，而工厂模式侧重封装对象的创建过程，这里的对象没有任何业务场景的限定，可以是策略，但也可以是其他东西。从设计意图上来看，这两个模式完全是两回事。</p>\n<p>策略模式中，不同的策略具有相同的目的、不同的实现、相互之间可以替换。比如BubbleSort、SelectionSort都是为了实现排序的，只不过一个是用冒泡排序算法来实现的，另一个是用选择排序算法来实现的。而在命令模式中，不同的命令具有不同的目的，对应不同的处理逻辑，并且互相之间不可替换。</p>\n"},{"layout":"post","title":"设计模式之工厂模式","description":"设计模式之工厂模式","date":"2021-05-06T05:26:10.000Z","_content":"### 简单工厂模式\n\n在下面的代码中，我们需要根据后缀（json、xml、yaml、properties）选择不同的解析器（JsonRuleConfigParser、XmlRuleConfigParser...），将存储在文件中的配置解析成内存对象RuleConfig。\n\n```java\npublic class RuleConfigSource {\n  public RuleConfig load(String ruleConfigFilePath) {\n    String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);\n    IRuleConfigParser parser = null;\n    if(\"json\".equalsIgnoreCase(ruleConfigFileExtension)){\n      parser = new JsonRuleConfigParser();\n    }else if (\"xml\".equalsIgnoreCase(ruleConfigFileExtension)) { \n      parser = new XmlRuleConfigParser(); \n    } else if (\"yaml\".equalsIgnoreCase(ruleConfigFileExtension)) { \n      parser = new YamlRuleConfigParser(); \n    } else if (\"properties\".equalsIgnoreCase(ruleConfigFileExtension)) { \n      parser = new PropertiesRuleConfigParser(); \n    } else { \n      throw new InvalidRuleConfigException( \"Rule config file format is not supported: \"+ruleConfigFilePath);\n    }\n    \n    Stirng configText = \"\";\n    //从ruleConfigFilePath文件中读取配置文本到configText中\n    RuleConfig ruleConfig = parser.parse(configText);\n    return ruleConfig;\n  }\n  \n  private String getFileExtension(String filePath) {\n    //...解析文件名获取扩展名\n    return \"json\";\n  }\n}\n```\n\n为了让代码逻辑更加清晰，可读性更好，我们可以给创建不同解析器封装成一个函数，createParser()函数。代码比较简单，就不写了。我们为了类的职责更加单一、代码更加清晰，可以创建这部分放到一个独立的类里，让这个类只负责对象的创建。这个类就是简单工厂模式类。\n\n```java\n//简单工厂模式的一种方法\npublic class RuleConfigParserFactory {\n  public static IruleConfigParser createParser(String configFormat) {\n    IRuleConfigParser parser = null;\n    if (\"json\".equalsIgnoreCase(configFormat)) {\n      parser = new JsonRuleConfigParser();    \n    } else if (\"xml\".equalsIgnoreCase(configFormat)) {\n      parser = new XmlRuleConfigParser();    \n    } else if (\"yaml\".equalsIgnoreCase(configFormat)) {\n      parser = new YamlRuleConfigParser();    \n    } else if (\"properties\".equalsIgnoreCase(configFormat)) {\n      parser = new PropertiesRuleConfigParser();    \n    }    \n    return parser;\n  }\n}\n```\n\n上面的代码实现中，我们每次调用createParser()都会创建一个新的parser，如果parser可以复用，我们可以将parser事先创建好缓存起来。获取实例的时候，直接从缓存中取出parser对象直接使用，有点类似于单例模式和简单工厂模式的结合。上面就是简单工厂模式的第一种实现方法。\n\n```java\n//另一种简单工厂模式的实现方法\npublic class RuleConfigParserFactory {\n  private static final Map<String,RuleConfigParser> cachedParsers = new HashMap<>();\n  static { \n    cachedParsers.put(\"json\", new JsonRuleConfigParser());\n    cachedParsers.put(\"xml\", new XmlRuleConfigParser());\n    cachedParsers.put(\"yaml\", new YamlRuleConfigParser());\n    cachedParsers.put(\"properties\", new PropertiesRuleConfigParser());\n  } \n  public static IRuleConfigParser createParser(String configFormat) {\n    if (configFormat == null || configFormat.isEmpty()) {\n      return null;//返回null还是IllegalArgumentException全凭你自己说了算 \n    } \n    IRuleConfigParser parser = cachedParsers.get(configFormat.toLowerCase()); \n    return parser; \n  }\n}\n```\n\n上面两种简单工厂模式的实现方法，如果要添加新的parser，势必要改动RuleConfigParserFactory的代码，这样就违反开闭原则。实际上，如果不是频繁的添加新的parser，只是偶尔修改一下，也是可以接受的，活学活用，灵活变通。尽管简单工厂模式的实现中，有多处if分支判断，违背了开闭原则，但是权衡扩展性和可读性，这样的代码实现在大多数情况下(不需要频繁添加parser，没有太多parser)是没有问题的。\n\n### 工厂方法\n\n如果非要去掉if，应该怎么处理呢？可以通过多态来实现。\n\n```java\npublic interface IRuleConfigParserFactory {\n  IRuleConfigParser createParser();\n}\n\npublic class JsonRuleConfigParserFactory implements IRuleConfigParserFactory {\n  @Override \n  public IRuleConfigParser createParser() {\n    return new JsonRuleConfigParser(); \n  }\n}\n\npublic class XmlRuleConfigParserFactory implements IRuleConfigParserFactory {\n  @Override\n  public IRuleConfigParser createParser() {\n    return new XmlRuleConfigParser(); \n  }\n}\n\npublic class YamlRuleConfigParserFactory implements IRuleConfigParserFactory {\n  @Override \n  public IRuleConfigParser createParser() {\n    return new YamlRuleConfigParser(); \n  }\n}\n\npublic class PropertiesRuleConfigParserFactory implements IRuleConfigParserFactory {\n  @Override\n  public IRuleConfigParser createParser() {\n    return new PropertiesRuleConfigParser(); \n  }\n}\n```\n\n这种实现的话，如果需要新增parser的时候，只需要新增一个实现接口的类就可以了。所以工厂方法模式比简单工厂模式更加符合开闭原则。但是存在挺大的问题，这些工厂类的使用。\n\n```java\npublic class RuleConfigSource {\n  public RuleConfig load(String ruleConfigFilePath) {\n    String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);\n    IRuleConfigParserFactory parserFactory = null;\n    if(\"json\".equalsIgnoreCase(ruleConfigFilePath)){\n      parseFactory = new JsonRuleConfigParserFactory();\n    }else if (\"xml\".equalsIgnoreCase(ruleConfigFileExtension)){\n      parserFactory = new XmlRuleConfigParserFactory();\n    }//...省略后续的\n    \n    IRuleConfigParser parser = parserFactory.createParser();\n    String configText = \"\"; \n    //从ruleConfigFilePath文件中读取配置文本到configText中 \n    RuleConfig ruleConfig = parser.parse(configText); \n    return ruleConfig;\n  }\n  \n  private String getFileExtension(String filePath) {\n    //...解析文件名获取扩展名，比如rule.json，返回json\n    return \"json\";\n  }\n}\n```\n\n工厂类的创建逻辑又耦合到了load()函数中，引入工厂方法不但没有解决问题，还让设计变得更加复杂了。这时候如果我们把工厂方法再创建一个简单工厂，用来创建对象，说白了就是工厂的工厂。\n\n```java\npublic class RuleConfigSource {\n  public RuleConfig load(String ruleConfigFilePath) {\n    String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);\n    IRuleConfigParserFactory parserFactory = RuleConfigParserFactoryMap.getParserFactory(ruleConfigFileExtension);\n    //其余逻辑不变\n  }\n}\n\n//因为工厂类只包含方法，不包含成员变量，完全可以复用\n//因为不需要每次都创建新的工厂类对象，所以第二种方式实现更合适\npublic class RuleConfigParserFactoryMap{\n  private static final Map cachedFactories = new HashMap<>();\n  static {\n    cachedFactories.put(\"json\", new JsonRuleConfigParserFactory());\n    cachedFactories.put(\"xml\", new XmlRuleConfigParserFactory());\n    cachedFactories.put(\"yaml\", new YamlRuleConfigParserFactory());\n    cachedFactories.put(\"properties\", new PropertiesRuleConfigParserFactory());\n  }\n  \n  public static IRuleConfigParserFactory getParserFactory(String type) {\n    if(type==null || type.isEmpty()){\n      return null;\n    }\n    IRuleConfigParserFactory parserFactory = cachedFactories.get(type.tolowerCase());\n    return parserFactory;\n  }\n}\n```\n\n这样需要添加新的规则配置解析器的时候，创建新的parser类和对应的工厂，并添加到map中即可。代码改动较少，基本符合开闭原则。\n\n实际上，对于规则配置文件解析场景来说，工厂模式需要额外创建很多工厂类，会增加代码的复杂性，而且每个工厂类功能比较单薄，只有一行代码，没必要设计成单独的类。所以这种场景下，简单工厂模式更合适。\n\n当对象的创建逻辑比较复杂，不只是简单的new一下就可以，而是要组合其他类的对象，做各种初始化操作的时候，我们推荐工厂方法模式，将复杂的逻辑拆分到多个工厂类中，让每个工厂类都不至于过于复杂。\n\n如果对象不可复用，还使用简单工厂模式来实现的话，就只能选择包含if分支逻辑的实现方式，如果想避免if分支的话，就要使用工厂方法模式。\n\n### 抽象工厂\n\n如果需要创建多个不同类型的对象，可以让一个工厂负责创建不同类型的对象，这样可以有效减少工厂类的个数。\n\n```java\npublic interface IConfigParserFactory { \n  IRuleConfigParser createRuleParser(); \n  ISystemConfigParser createSystemParser();\n  //此处可以扩展新的parser类型，比如IBizConfigParser\n}\n\npublic class JsonConfigParserFactory implements IConfigParserFactory {\n  @Override\n  public IRuleConfigParser createRuleParser() {\n    return new JsonRuleConfigParser(); \n  } \n  @Override \n  public ISystemConfigParser createSystemParser() {\n    return new JsonSystemConfigParser(); \n  }\n}\n```\n\n工厂模式的作用\n\n封装变化：创建逻辑有可能变化，封装成工厂类之后，创建逻辑的变更对调用者透明。\n\n代码复用：创建代码抽离到独立的工厂类之后可以复用。\n\n隔离复杂性：封装复杂的创建逻辑，调用者无需了解如何创建对象。\n\n控制复杂度：将创建代码抽离出来，让原本的函数或者类职责更单一，代码更简洁。\n\n","source":"_posts/设计模式之工厂模式.md","raw":"---\nlayout:    post\ntitle:     设计模式之工厂模式\ncategory:  设计模式之美\ndescription: 设计模式之工厂模式\ntags: 设计模式之美\ndate: 2021/05/06 13:26:10\n---\n### 简单工厂模式\n\n在下面的代码中，我们需要根据后缀（json、xml、yaml、properties）选择不同的解析器（JsonRuleConfigParser、XmlRuleConfigParser...），将存储在文件中的配置解析成内存对象RuleConfig。\n\n```java\npublic class RuleConfigSource {\n  public RuleConfig load(String ruleConfigFilePath) {\n    String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);\n    IRuleConfigParser parser = null;\n    if(\"json\".equalsIgnoreCase(ruleConfigFileExtension)){\n      parser = new JsonRuleConfigParser();\n    }else if (\"xml\".equalsIgnoreCase(ruleConfigFileExtension)) { \n      parser = new XmlRuleConfigParser(); \n    } else if (\"yaml\".equalsIgnoreCase(ruleConfigFileExtension)) { \n      parser = new YamlRuleConfigParser(); \n    } else if (\"properties\".equalsIgnoreCase(ruleConfigFileExtension)) { \n      parser = new PropertiesRuleConfigParser(); \n    } else { \n      throw new InvalidRuleConfigException( \"Rule config file format is not supported: \"+ruleConfigFilePath);\n    }\n    \n    Stirng configText = \"\";\n    //从ruleConfigFilePath文件中读取配置文本到configText中\n    RuleConfig ruleConfig = parser.parse(configText);\n    return ruleConfig;\n  }\n  \n  private String getFileExtension(String filePath) {\n    //...解析文件名获取扩展名\n    return \"json\";\n  }\n}\n```\n\n为了让代码逻辑更加清晰，可读性更好，我们可以给创建不同解析器封装成一个函数，createParser()函数。代码比较简单，就不写了。我们为了类的职责更加单一、代码更加清晰，可以创建这部分放到一个独立的类里，让这个类只负责对象的创建。这个类就是简单工厂模式类。\n\n```java\n//简单工厂模式的一种方法\npublic class RuleConfigParserFactory {\n  public static IruleConfigParser createParser(String configFormat) {\n    IRuleConfigParser parser = null;\n    if (\"json\".equalsIgnoreCase(configFormat)) {\n      parser = new JsonRuleConfigParser();    \n    } else if (\"xml\".equalsIgnoreCase(configFormat)) {\n      parser = new XmlRuleConfigParser();    \n    } else if (\"yaml\".equalsIgnoreCase(configFormat)) {\n      parser = new YamlRuleConfigParser();    \n    } else if (\"properties\".equalsIgnoreCase(configFormat)) {\n      parser = new PropertiesRuleConfigParser();    \n    }    \n    return parser;\n  }\n}\n```\n\n上面的代码实现中，我们每次调用createParser()都会创建一个新的parser，如果parser可以复用，我们可以将parser事先创建好缓存起来。获取实例的时候，直接从缓存中取出parser对象直接使用，有点类似于单例模式和简单工厂模式的结合。上面就是简单工厂模式的第一种实现方法。\n\n```java\n//另一种简单工厂模式的实现方法\npublic class RuleConfigParserFactory {\n  private static final Map<String,RuleConfigParser> cachedParsers = new HashMap<>();\n  static { \n    cachedParsers.put(\"json\", new JsonRuleConfigParser());\n    cachedParsers.put(\"xml\", new XmlRuleConfigParser());\n    cachedParsers.put(\"yaml\", new YamlRuleConfigParser());\n    cachedParsers.put(\"properties\", new PropertiesRuleConfigParser());\n  } \n  public static IRuleConfigParser createParser(String configFormat) {\n    if (configFormat == null || configFormat.isEmpty()) {\n      return null;//返回null还是IllegalArgumentException全凭你自己说了算 \n    } \n    IRuleConfigParser parser = cachedParsers.get(configFormat.toLowerCase()); \n    return parser; \n  }\n}\n```\n\n上面两种简单工厂模式的实现方法，如果要添加新的parser，势必要改动RuleConfigParserFactory的代码，这样就违反开闭原则。实际上，如果不是频繁的添加新的parser，只是偶尔修改一下，也是可以接受的，活学活用，灵活变通。尽管简单工厂模式的实现中，有多处if分支判断，违背了开闭原则，但是权衡扩展性和可读性，这样的代码实现在大多数情况下(不需要频繁添加parser，没有太多parser)是没有问题的。\n\n### 工厂方法\n\n如果非要去掉if，应该怎么处理呢？可以通过多态来实现。\n\n```java\npublic interface IRuleConfigParserFactory {\n  IRuleConfigParser createParser();\n}\n\npublic class JsonRuleConfigParserFactory implements IRuleConfigParserFactory {\n  @Override \n  public IRuleConfigParser createParser() {\n    return new JsonRuleConfigParser(); \n  }\n}\n\npublic class XmlRuleConfigParserFactory implements IRuleConfigParserFactory {\n  @Override\n  public IRuleConfigParser createParser() {\n    return new XmlRuleConfigParser(); \n  }\n}\n\npublic class YamlRuleConfigParserFactory implements IRuleConfigParserFactory {\n  @Override \n  public IRuleConfigParser createParser() {\n    return new YamlRuleConfigParser(); \n  }\n}\n\npublic class PropertiesRuleConfigParserFactory implements IRuleConfigParserFactory {\n  @Override\n  public IRuleConfigParser createParser() {\n    return new PropertiesRuleConfigParser(); \n  }\n}\n```\n\n这种实现的话，如果需要新增parser的时候，只需要新增一个实现接口的类就可以了。所以工厂方法模式比简单工厂模式更加符合开闭原则。但是存在挺大的问题，这些工厂类的使用。\n\n```java\npublic class RuleConfigSource {\n  public RuleConfig load(String ruleConfigFilePath) {\n    String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);\n    IRuleConfigParserFactory parserFactory = null;\n    if(\"json\".equalsIgnoreCase(ruleConfigFilePath)){\n      parseFactory = new JsonRuleConfigParserFactory();\n    }else if (\"xml\".equalsIgnoreCase(ruleConfigFileExtension)){\n      parserFactory = new XmlRuleConfigParserFactory();\n    }//...省略后续的\n    \n    IRuleConfigParser parser = parserFactory.createParser();\n    String configText = \"\"; \n    //从ruleConfigFilePath文件中读取配置文本到configText中 \n    RuleConfig ruleConfig = parser.parse(configText); \n    return ruleConfig;\n  }\n  \n  private String getFileExtension(String filePath) {\n    //...解析文件名获取扩展名，比如rule.json，返回json\n    return \"json\";\n  }\n}\n```\n\n工厂类的创建逻辑又耦合到了load()函数中，引入工厂方法不但没有解决问题，还让设计变得更加复杂了。这时候如果我们把工厂方法再创建一个简单工厂，用来创建对象，说白了就是工厂的工厂。\n\n```java\npublic class RuleConfigSource {\n  public RuleConfig load(String ruleConfigFilePath) {\n    String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);\n    IRuleConfigParserFactory parserFactory = RuleConfigParserFactoryMap.getParserFactory(ruleConfigFileExtension);\n    //其余逻辑不变\n  }\n}\n\n//因为工厂类只包含方法，不包含成员变量，完全可以复用\n//因为不需要每次都创建新的工厂类对象，所以第二种方式实现更合适\npublic class RuleConfigParserFactoryMap{\n  private static final Map cachedFactories = new HashMap<>();\n  static {\n    cachedFactories.put(\"json\", new JsonRuleConfigParserFactory());\n    cachedFactories.put(\"xml\", new XmlRuleConfigParserFactory());\n    cachedFactories.put(\"yaml\", new YamlRuleConfigParserFactory());\n    cachedFactories.put(\"properties\", new PropertiesRuleConfigParserFactory());\n  }\n  \n  public static IRuleConfigParserFactory getParserFactory(String type) {\n    if(type==null || type.isEmpty()){\n      return null;\n    }\n    IRuleConfigParserFactory parserFactory = cachedFactories.get(type.tolowerCase());\n    return parserFactory;\n  }\n}\n```\n\n这样需要添加新的规则配置解析器的时候，创建新的parser类和对应的工厂，并添加到map中即可。代码改动较少，基本符合开闭原则。\n\n实际上，对于规则配置文件解析场景来说，工厂模式需要额外创建很多工厂类，会增加代码的复杂性，而且每个工厂类功能比较单薄，只有一行代码，没必要设计成单独的类。所以这种场景下，简单工厂模式更合适。\n\n当对象的创建逻辑比较复杂，不只是简单的new一下就可以，而是要组合其他类的对象，做各种初始化操作的时候，我们推荐工厂方法模式，将复杂的逻辑拆分到多个工厂类中，让每个工厂类都不至于过于复杂。\n\n如果对象不可复用，还使用简单工厂模式来实现的话，就只能选择包含if分支逻辑的实现方式，如果想避免if分支的话，就要使用工厂方法模式。\n\n### 抽象工厂\n\n如果需要创建多个不同类型的对象，可以让一个工厂负责创建不同类型的对象，这样可以有效减少工厂类的个数。\n\n```java\npublic interface IConfigParserFactory { \n  IRuleConfigParser createRuleParser(); \n  ISystemConfigParser createSystemParser();\n  //此处可以扩展新的parser类型，比如IBizConfigParser\n}\n\npublic class JsonConfigParserFactory implements IConfigParserFactory {\n  @Override\n  public IRuleConfigParser createRuleParser() {\n    return new JsonRuleConfigParser(); \n  } \n  @Override \n  public ISystemConfigParser createSystemParser() {\n    return new JsonSystemConfigParser(); \n  }\n}\n```\n\n工厂模式的作用\n\n封装变化：创建逻辑有可能变化，封装成工厂类之后，创建逻辑的变更对调用者透明。\n\n代码复用：创建代码抽离到独立的工厂类之后可以复用。\n\n隔离复杂性：封装复杂的创建逻辑，调用者无需了解如何创建对象。\n\n控制复杂度：将创建代码抽离出来，让原本的函数或者类职责更单一，代码更简洁。\n\n","slug":"设计模式之工厂模式","published":1,"updated":"2021-05-06T05:26:10.000Z","comments":1,"photos":[],"link":"","_id":"cm1m304xp001r31b45h430wa0","content":"<h3 id=\"简单工厂模式\"><a href=\"#简单工厂模式\" class=\"headerlink\" title=\"简单工厂模式\"></a>简单工厂模式</h3><p>在下面的代码中，我们需要根据后缀（json、xml、yaml、properties）选择不同的解析器（JsonRuleConfigParser、XmlRuleConfigParser…），将存储在文件中的配置解析成内存对象RuleConfig。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RuleConfigSource</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> RuleConfig <span class=\"title\">load</span><span class=\"params\">(String ruleConfigFilePath)</span> </span>&#123;</span><br><span class=\"line\">    String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);</span><br><span class=\"line\">    IRuleConfigParser parser = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"string\">&quot;json&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension))&#123;</span><br><span class=\"line\">      parser = <span class=\"keyword\">new</span> JsonRuleConfigParser();</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">&quot;xml&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123; </span><br><span class=\"line\">      parser = <span class=\"keyword\">new</span> XmlRuleConfigParser(); </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">&quot;yaml&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123; </span><br><span class=\"line\">      parser = <span class=\"keyword\">new</span> YamlRuleConfigParser(); </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">&quot;properties&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123; </span><br><span class=\"line\">      parser = <span class=\"keyword\">new</span> PropertiesRuleConfigParser(); </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123; </span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> InvalidRuleConfigException( <span class=\"string\">&quot;Rule config file format is not supported: &quot;</span>+ruleConfigFilePath);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    Stirng configText = <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">    <span class=\"comment\">//从ruleConfigFilePath文件中读取配置文本到configText中</span></span><br><span class=\"line\">    RuleConfig ruleConfig = parser.parse(configText);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ruleConfig;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> String <span class=\"title\">getFileExtension</span><span class=\"params\">(String filePath)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...解析文件名获取扩展名</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;json&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>为了让代码逻辑更加清晰，可读性更好，我们可以给创建不同解析器封装成一个函数，createParser()函数。代码比较简单，就不写了。我们为了类的职责更加单一、代码更加清晰，可以创建这部分放到一个独立的类里，让这个类只负责对象的创建。这个类就是简单工厂模式类。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//简单工厂模式的一种方法</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RuleConfigParserFactory</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> IruleConfigParser <span class=\"title\">createParser</span><span class=\"params\">(String configFormat)</span> </span>&#123;</span><br><span class=\"line\">    IRuleConfigParser parser = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"string\">&quot;json&quot;</span>.equalsIgnoreCase(configFormat)) &#123;</span><br><span class=\"line\">      parser = <span class=\"keyword\">new</span> JsonRuleConfigParser();    </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">&quot;xml&quot;</span>.equalsIgnoreCase(configFormat)) &#123;</span><br><span class=\"line\">      parser = <span class=\"keyword\">new</span> XmlRuleConfigParser();    </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">&quot;yaml&quot;</span>.equalsIgnoreCase(configFormat)) &#123;</span><br><span class=\"line\">      parser = <span class=\"keyword\">new</span> YamlRuleConfigParser();    </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">&quot;properties&quot;</span>.equalsIgnoreCase(configFormat)) &#123;</span><br><span class=\"line\">      parser = <span class=\"keyword\">new</span> PropertiesRuleConfigParser();    </span><br><span class=\"line\">    &#125;    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> parser;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的代码实现中，我们每次调用createParser()都会创建一个新的parser，如果parser可以复用，我们可以将parser事先创建好缓存起来。获取实例的时候，直接从缓存中取出parser对象直接使用，有点类似于单例模式和简单工厂模式的结合。上面就是简单工厂模式的第一种实现方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//另一种简单工厂模式的实现方法</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RuleConfigParserFactory</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Map&lt;String,RuleConfigParser&gt; cachedParsers = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">  <span class=\"keyword\">static</span> &#123; </span><br><span class=\"line\">    cachedParsers.put(<span class=\"string\">&quot;json&quot;</span>, <span class=\"keyword\">new</span> JsonRuleConfigParser());</span><br><span class=\"line\">    cachedParsers.put(<span class=\"string\">&quot;xml&quot;</span>, <span class=\"keyword\">new</span> XmlRuleConfigParser());</span><br><span class=\"line\">    cachedParsers.put(<span class=\"string\">&quot;yaml&quot;</span>, <span class=\"keyword\">new</span> YamlRuleConfigParser());</span><br><span class=\"line\">    cachedParsers.put(<span class=\"string\">&quot;properties&quot;</span>, <span class=\"keyword\">new</span> PropertiesRuleConfigParser());</span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> IRuleConfigParser <span class=\"title\">createParser</span><span class=\"params\">(String configFormat)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (configFormat == <span class=\"keyword\">null</span> || configFormat.isEmpty()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;<span class=\"comment\">//返回null还是IllegalArgumentException全凭你自己说了算 </span></span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    IRuleConfigParser parser = cachedParsers.get(configFormat.toLowerCase()); </span><br><span class=\"line\">    <span class=\"keyword\">return</span> parser; </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面两种简单工厂模式的实现方法，如果要添加新的parser，势必要改动RuleConfigParserFactory的代码，这样就违反开闭原则。实际上，如果不是频繁的添加新的parser，只是偶尔修改一下，也是可以接受的，活学活用，灵活变通。尽管简单工厂模式的实现中，有多处if分支判断，违背了开闭原则，但是权衡扩展性和可读性，这样的代码实现在大多数情况下(不需要频繁添加parser，没有太多parser)是没有问题的。</p>\n<h3 id=\"工厂方法\"><a href=\"#工厂方法\" class=\"headerlink\" title=\"工厂方法\"></a>工厂方法</h3><p>如果非要去掉if，应该怎么处理呢？可以通过多态来实现。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">IRuleConfigParserFactory</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\">IRuleConfigParser <span class=\"title\">createParser</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JsonRuleConfigParserFactory</span> <span class=\"keyword\">implements</span> <span class=\"title\">IRuleConfigParserFactory</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span> </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> IRuleConfigParser <span class=\"title\">createParser</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> JsonRuleConfigParser(); </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">XmlRuleConfigParserFactory</span> <span class=\"keyword\">implements</span> <span class=\"title\">IRuleConfigParserFactory</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> IRuleConfigParser <span class=\"title\">createParser</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> XmlRuleConfigParser(); </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">YamlRuleConfigParserFactory</span> <span class=\"keyword\">implements</span> <span class=\"title\">IRuleConfigParserFactory</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span> </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> IRuleConfigParser <span class=\"title\">createParser</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> YamlRuleConfigParser(); </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PropertiesRuleConfigParserFactory</span> <span class=\"keyword\">implements</span> <span class=\"title\">IRuleConfigParserFactory</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> IRuleConfigParser <span class=\"title\">createParser</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> PropertiesRuleConfigParser(); </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这种实现的话，如果需要新增parser的时候，只需要新增一个实现接口的类就可以了。所以工厂方法模式比简单工厂模式更加符合开闭原则。但是存在挺大的问题，这些工厂类的使用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RuleConfigSource</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> RuleConfig <span class=\"title\">load</span><span class=\"params\">(String ruleConfigFilePath)</span> </span>&#123;</span><br><span class=\"line\">    String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);</span><br><span class=\"line\">    IRuleConfigParserFactory parserFactory = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"string\">&quot;json&quot;</span>.equalsIgnoreCase(ruleConfigFilePath))&#123;</span><br><span class=\"line\">      parseFactory = <span class=\"keyword\">new</span> JsonRuleConfigParserFactory();</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">&quot;xml&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension))&#123;</span><br><span class=\"line\">      parserFactory = <span class=\"keyword\">new</span> XmlRuleConfigParserFactory();</span><br><span class=\"line\">    &#125;<span class=\"comment\">//...省略后续的</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    IRuleConfigParser parser = parserFactory.createParser();</span><br><span class=\"line\">    String configText = <span class=\"string\">&quot;&quot;</span>; </span><br><span class=\"line\">    <span class=\"comment\">//从ruleConfigFilePath文件中读取配置文本到configText中 </span></span><br><span class=\"line\">    RuleConfig ruleConfig = parser.parse(configText); </span><br><span class=\"line\">    <span class=\"keyword\">return</span> ruleConfig;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> String <span class=\"title\">getFileExtension</span><span class=\"params\">(String filePath)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...解析文件名获取扩展名，比如rule.json，返回json</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;json&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>工厂类的创建逻辑又耦合到了load()函数中，引入工厂方法不但没有解决问题，还让设计变得更加复杂了。这时候如果我们把工厂方法再创建一个简单工厂，用来创建对象，说白了就是工厂的工厂。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RuleConfigSource</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> RuleConfig <span class=\"title\">load</span><span class=\"params\">(String ruleConfigFilePath)</span> </span>&#123;</span><br><span class=\"line\">    String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);</span><br><span class=\"line\">    IRuleConfigParserFactory parserFactory = RuleConfigParserFactoryMap.getParserFactory(ruleConfigFileExtension);</span><br><span class=\"line\">    <span class=\"comment\">//其余逻辑不变</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//因为工厂类只包含方法，不包含成员变量，完全可以复用</span></span><br><span class=\"line\"><span class=\"comment\">//因为不需要每次都创建新的工厂类对象，所以第二种方式实现更合适</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RuleConfigParserFactoryMap</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Map cachedFactories = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">  <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">    cachedFactories.put(<span class=\"string\">&quot;json&quot;</span>, <span class=\"keyword\">new</span> JsonRuleConfigParserFactory());</span><br><span class=\"line\">    cachedFactories.put(<span class=\"string\">&quot;xml&quot;</span>, <span class=\"keyword\">new</span> XmlRuleConfigParserFactory());</span><br><span class=\"line\">    cachedFactories.put(<span class=\"string\">&quot;yaml&quot;</span>, <span class=\"keyword\">new</span> YamlRuleConfigParserFactory());</span><br><span class=\"line\">    cachedFactories.put(<span class=\"string\">&quot;properties&quot;</span>, <span class=\"keyword\">new</span> PropertiesRuleConfigParserFactory());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> IRuleConfigParserFactory <span class=\"title\">getParserFactory</span><span class=\"params\">(String type)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(type==<span class=\"keyword\">null</span> || type.isEmpty())&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    IRuleConfigParserFactory parserFactory = cachedFactories.get(type.tolowerCase());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> parserFactory;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样需要添加新的规则配置解析器的时候，创建新的parser类和对应的工厂，并添加到map中即可。代码改动较少，基本符合开闭原则。</p>\n<p>实际上，对于规则配置文件解析场景来说，工厂模式需要额外创建很多工厂类，会增加代码的复杂性，而且每个工厂类功能比较单薄，只有一行代码，没必要设计成单独的类。所以这种场景下，简单工厂模式更合适。</p>\n<p>当对象的创建逻辑比较复杂，不只是简单的new一下就可以，而是要组合其他类的对象，做各种初始化操作的时候，我们推荐工厂方法模式，将复杂的逻辑拆分到多个工厂类中，让每个工厂类都不至于过于复杂。</p>\n<p>如果对象不可复用，还使用简单工厂模式来实现的话，就只能选择包含if分支逻辑的实现方式，如果想避免if分支的话，就要使用工厂方法模式。</p>\n<h3 id=\"抽象工厂\"><a href=\"#抽象工厂\" class=\"headerlink\" title=\"抽象工厂\"></a>抽象工厂</h3><p>如果需要创建多个不同类型的对象，可以让一个工厂负责创建不同类型的对象，这样可以有效减少工厂类的个数。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">IConfigParserFactory</span> </span>&#123; </span><br><span class=\"line\">  <span class=\"function\">IRuleConfigParser <span class=\"title\">createRuleParser</span><span class=\"params\">()</span></span>; </span><br><span class=\"line\">  <span class=\"function\">ISystemConfigParser <span class=\"title\">createSystemParser</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">  <span class=\"comment\">//此处可以扩展新的parser类型，比如IBizConfigParser</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JsonConfigParserFactory</span> <span class=\"keyword\">implements</span> <span class=\"title\">IConfigParserFactory</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> IRuleConfigParser <span class=\"title\">createRuleParser</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> JsonRuleConfigParser(); </span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">  <span class=\"meta\">@Override</span> </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> ISystemConfigParser <span class=\"title\">createSystemParser</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> JsonSystemConfigParser(); </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>工厂模式的作用</p>\n<p>封装变化：创建逻辑有可能变化，封装成工厂类之后，创建逻辑的变更对调用者透明。</p>\n<p>代码复用：创建代码抽离到独立的工厂类之后可以复用。</p>\n<p>隔离复杂性：封装复杂的创建逻辑，调用者无需了解如何创建对象。</p>\n<p>控制复杂度：将创建代码抽离出来，让原本的函数或者类职责更单一，代码更简洁。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"简单工厂模式\"><a href=\"#简单工厂模式\" class=\"headerlink\" title=\"简单工厂模式\"></a>简单工厂模式</h3><p>在下面的代码中，我们需要根据后缀（json、xml、yaml、properties）选择不同的解析器（JsonRuleConfigParser、XmlRuleConfigParser…），将存储在文件中的配置解析成内存对象RuleConfig。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RuleConfigSource</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> RuleConfig <span class=\"title\">load</span><span class=\"params\">(String ruleConfigFilePath)</span> </span>&#123;</span><br><span class=\"line\">    String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);</span><br><span class=\"line\">    IRuleConfigParser parser = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"string\">&quot;json&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension))&#123;</span><br><span class=\"line\">      parser = <span class=\"keyword\">new</span> JsonRuleConfigParser();</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">&quot;xml&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123; </span><br><span class=\"line\">      parser = <span class=\"keyword\">new</span> XmlRuleConfigParser(); </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">&quot;yaml&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123; </span><br><span class=\"line\">      parser = <span class=\"keyword\">new</span> YamlRuleConfigParser(); </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">&quot;properties&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123; </span><br><span class=\"line\">      parser = <span class=\"keyword\">new</span> PropertiesRuleConfigParser(); </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123; </span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> InvalidRuleConfigException( <span class=\"string\">&quot;Rule config file format is not supported: &quot;</span>+ruleConfigFilePath);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    Stirng configText = <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">    <span class=\"comment\">//从ruleConfigFilePath文件中读取配置文本到configText中</span></span><br><span class=\"line\">    RuleConfig ruleConfig = parser.parse(configText);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ruleConfig;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> String <span class=\"title\">getFileExtension</span><span class=\"params\">(String filePath)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...解析文件名获取扩展名</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;json&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>为了让代码逻辑更加清晰，可读性更好，我们可以给创建不同解析器封装成一个函数，createParser()函数。代码比较简单，就不写了。我们为了类的职责更加单一、代码更加清晰，可以创建这部分放到一个独立的类里，让这个类只负责对象的创建。这个类就是简单工厂模式类。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//简单工厂模式的一种方法</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RuleConfigParserFactory</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> IruleConfigParser <span class=\"title\">createParser</span><span class=\"params\">(String configFormat)</span> </span>&#123;</span><br><span class=\"line\">    IRuleConfigParser parser = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"string\">&quot;json&quot;</span>.equalsIgnoreCase(configFormat)) &#123;</span><br><span class=\"line\">      parser = <span class=\"keyword\">new</span> JsonRuleConfigParser();    </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">&quot;xml&quot;</span>.equalsIgnoreCase(configFormat)) &#123;</span><br><span class=\"line\">      parser = <span class=\"keyword\">new</span> XmlRuleConfigParser();    </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">&quot;yaml&quot;</span>.equalsIgnoreCase(configFormat)) &#123;</span><br><span class=\"line\">      parser = <span class=\"keyword\">new</span> YamlRuleConfigParser();    </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">&quot;properties&quot;</span>.equalsIgnoreCase(configFormat)) &#123;</span><br><span class=\"line\">      parser = <span class=\"keyword\">new</span> PropertiesRuleConfigParser();    </span><br><span class=\"line\">    &#125;    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> parser;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的代码实现中，我们每次调用createParser()都会创建一个新的parser，如果parser可以复用，我们可以将parser事先创建好缓存起来。获取实例的时候，直接从缓存中取出parser对象直接使用，有点类似于单例模式和简单工厂模式的结合。上面就是简单工厂模式的第一种实现方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//另一种简单工厂模式的实现方法</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RuleConfigParserFactory</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Map&lt;String,RuleConfigParser&gt; cachedParsers = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">  <span class=\"keyword\">static</span> &#123; </span><br><span class=\"line\">    cachedParsers.put(<span class=\"string\">&quot;json&quot;</span>, <span class=\"keyword\">new</span> JsonRuleConfigParser());</span><br><span class=\"line\">    cachedParsers.put(<span class=\"string\">&quot;xml&quot;</span>, <span class=\"keyword\">new</span> XmlRuleConfigParser());</span><br><span class=\"line\">    cachedParsers.put(<span class=\"string\">&quot;yaml&quot;</span>, <span class=\"keyword\">new</span> YamlRuleConfigParser());</span><br><span class=\"line\">    cachedParsers.put(<span class=\"string\">&quot;properties&quot;</span>, <span class=\"keyword\">new</span> PropertiesRuleConfigParser());</span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> IRuleConfigParser <span class=\"title\">createParser</span><span class=\"params\">(String configFormat)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (configFormat == <span class=\"keyword\">null</span> || configFormat.isEmpty()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;<span class=\"comment\">//返回null还是IllegalArgumentException全凭你自己说了算 </span></span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    IRuleConfigParser parser = cachedParsers.get(configFormat.toLowerCase()); </span><br><span class=\"line\">    <span class=\"keyword\">return</span> parser; </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面两种简单工厂模式的实现方法，如果要添加新的parser，势必要改动RuleConfigParserFactory的代码，这样就违反开闭原则。实际上，如果不是频繁的添加新的parser，只是偶尔修改一下，也是可以接受的，活学活用，灵活变通。尽管简单工厂模式的实现中，有多处if分支判断，违背了开闭原则，但是权衡扩展性和可读性，这样的代码实现在大多数情况下(不需要频繁添加parser，没有太多parser)是没有问题的。</p>\n<h3 id=\"工厂方法\"><a href=\"#工厂方法\" class=\"headerlink\" title=\"工厂方法\"></a>工厂方法</h3><p>如果非要去掉if，应该怎么处理呢？可以通过多态来实现。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">IRuleConfigParserFactory</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\">IRuleConfigParser <span class=\"title\">createParser</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JsonRuleConfigParserFactory</span> <span class=\"keyword\">implements</span> <span class=\"title\">IRuleConfigParserFactory</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span> </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> IRuleConfigParser <span class=\"title\">createParser</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> JsonRuleConfigParser(); </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">XmlRuleConfigParserFactory</span> <span class=\"keyword\">implements</span> <span class=\"title\">IRuleConfigParserFactory</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> IRuleConfigParser <span class=\"title\">createParser</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> XmlRuleConfigParser(); </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">YamlRuleConfigParserFactory</span> <span class=\"keyword\">implements</span> <span class=\"title\">IRuleConfigParserFactory</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span> </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> IRuleConfigParser <span class=\"title\">createParser</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> YamlRuleConfigParser(); </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PropertiesRuleConfigParserFactory</span> <span class=\"keyword\">implements</span> <span class=\"title\">IRuleConfigParserFactory</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> IRuleConfigParser <span class=\"title\">createParser</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> PropertiesRuleConfigParser(); </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这种实现的话，如果需要新增parser的时候，只需要新增一个实现接口的类就可以了。所以工厂方法模式比简单工厂模式更加符合开闭原则。但是存在挺大的问题，这些工厂类的使用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RuleConfigSource</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> RuleConfig <span class=\"title\">load</span><span class=\"params\">(String ruleConfigFilePath)</span> </span>&#123;</span><br><span class=\"line\">    String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);</span><br><span class=\"line\">    IRuleConfigParserFactory parserFactory = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"string\">&quot;json&quot;</span>.equalsIgnoreCase(ruleConfigFilePath))&#123;</span><br><span class=\"line\">      parseFactory = <span class=\"keyword\">new</span> JsonRuleConfigParserFactory();</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">&quot;xml&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension))&#123;</span><br><span class=\"line\">      parserFactory = <span class=\"keyword\">new</span> XmlRuleConfigParserFactory();</span><br><span class=\"line\">    &#125;<span class=\"comment\">//...省略后续的</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    IRuleConfigParser parser = parserFactory.createParser();</span><br><span class=\"line\">    String configText = <span class=\"string\">&quot;&quot;</span>; </span><br><span class=\"line\">    <span class=\"comment\">//从ruleConfigFilePath文件中读取配置文本到configText中 </span></span><br><span class=\"line\">    RuleConfig ruleConfig = parser.parse(configText); </span><br><span class=\"line\">    <span class=\"keyword\">return</span> ruleConfig;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> String <span class=\"title\">getFileExtension</span><span class=\"params\">(String filePath)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...解析文件名获取扩展名，比如rule.json，返回json</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;json&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>工厂类的创建逻辑又耦合到了load()函数中，引入工厂方法不但没有解决问题，还让设计变得更加复杂了。这时候如果我们把工厂方法再创建一个简单工厂，用来创建对象，说白了就是工厂的工厂。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RuleConfigSource</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> RuleConfig <span class=\"title\">load</span><span class=\"params\">(String ruleConfigFilePath)</span> </span>&#123;</span><br><span class=\"line\">    String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);</span><br><span class=\"line\">    IRuleConfigParserFactory parserFactory = RuleConfigParserFactoryMap.getParserFactory(ruleConfigFileExtension);</span><br><span class=\"line\">    <span class=\"comment\">//其余逻辑不变</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//因为工厂类只包含方法，不包含成员变量，完全可以复用</span></span><br><span class=\"line\"><span class=\"comment\">//因为不需要每次都创建新的工厂类对象，所以第二种方式实现更合适</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RuleConfigParserFactoryMap</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Map cachedFactories = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">  <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">    cachedFactories.put(<span class=\"string\">&quot;json&quot;</span>, <span class=\"keyword\">new</span> JsonRuleConfigParserFactory());</span><br><span class=\"line\">    cachedFactories.put(<span class=\"string\">&quot;xml&quot;</span>, <span class=\"keyword\">new</span> XmlRuleConfigParserFactory());</span><br><span class=\"line\">    cachedFactories.put(<span class=\"string\">&quot;yaml&quot;</span>, <span class=\"keyword\">new</span> YamlRuleConfigParserFactory());</span><br><span class=\"line\">    cachedFactories.put(<span class=\"string\">&quot;properties&quot;</span>, <span class=\"keyword\">new</span> PropertiesRuleConfigParserFactory());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> IRuleConfigParserFactory <span class=\"title\">getParserFactory</span><span class=\"params\">(String type)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(type==<span class=\"keyword\">null</span> || type.isEmpty())&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    IRuleConfigParserFactory parserFactory = cachedFactories.get(type.tolowerCase());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> parserFactory;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样需要添加新的规则配置解析器的时候，创建新的parser类和对应的工厂，并添加到map中即可。代码改动较少，基本符合开闭原则。</p>\n<p>实际上，对于规则配置文件解析场景来说，工厂模式需要额外创建很多工厂类，会增加代码的复杂性，而且每个工厂类功能比较单薄，只有一行代码，没必要设计成单独的类。所以这种场景下，简单工厂模式更合适。</p>\n<p>当对象的创建逻辑比较复杂，不只是简单的new一下就可以，而是要组合其他类的对象，做各种初始化操作的时候，我们推荐工厂方法模式，将复杂的逻辑拆分到多个工厂类中，让每个工厂类都不至于过于复杂。</p>\n<p>如果对象不可复用，还使用简单工厂模式来实现的话，就只能选择包含if分支逻辑的实现方式，如果想避免if分支的话，就要使用工厂方法模式。</p>\n<h3 id=\"抽象工厂\"><a href=\"#抽象工厂\" class=\"headerlink\" title=\"抽象工厂\"></a>抽象工厂</h3><p>如果需要创建多个不同类型的对象，可以让一个工厂负责创建不同类型的对象，这样可以有效减少工厂类的个数。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">IConfigParserFactory</span> </span>&#123; </span><br><span class=\"line\">  <span class=\"function\">IRuleConfigParser <span class=\"title\">createRuleParser</span><span class=\"params\">()</span></span>; </span><br><span class=\"line\">  <span class=\"function\">ISystemConfigParser <span class=\"title\">createSystemParser</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">  <span class=\"comment\">//此处可以扩展新的parser类型，比如IBizConfigParser</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JsonConfigParserFactory</span> <span class=\"keyword\">implements</span> <span class=\"title\">IConfigParserFactory</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> IRuleConfigParser <span class=\"title\">createRuleParser</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> JsonRuleConfigParser(); </span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">  <span class=\"meta\">@Override</span> </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> ISystemConfigParser <span class=\"title\">createSystemParser</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> JsonSystemConfigParser(); </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>工厂模式的作用</p>\n<p>封装变化：创建逻辑有可能变化，封装成工厂类之后，创建逻辑的变更对调用者透明。</p>\n<p>代码复用：创建代码抽离到独立的工厂类之后可以复用。</p>\n<p>隔离复杂性：封装复杂的创建逻辑，调用者无需了解如何创建对象。</p>\n<p>控制复杂度：将创建代码抽离出来，让原本的函数或者类职责更单一，代码更简洁。</p>\n"},{"layout":"post","title":"设计模式之建造者模式","description":"设计模式之建造者模式","date":"2021-05-07T05:26:10.000Z","_content":"\n```java\npublic class ResourcePoolConfig {\n  private String name;\n  private int maxTotal;\n  private int maxIdle;\n  private int minIdle;\n  \n  private ResourcerePoolConfig(Builder builder) {\n    this.name = builder.name;\n    this,maxTotal = builder.maxTotal;\n    this.maxIdle = builder.maxIdle;\n    this.minIdle = builder.minIdle;\n  }\n  //...省略getter方法\n  //我们将Builder类设计成了ResourcePoolConfig的内部类 \n  //我们也可以将Builder类设计成独立的非内部类ResourcePoolConfigBuilder。\n  public static class Builder {\n    private static final int DEFAULT_MAX_TOTAL = 8;\n    private static final int DEFAULT_MAX_IDLE = 8;\n    private static final int DEFAULT_MIN_IDLE = 0;\n    \n    private String name;\n  \tprivate int maxTotal = DEFAULT_MAX_TOTAL;\n    private int maxIdle = DEFAULT_MAX_IDLE;\n    private int minIdle = DEFAULT_MIN_IDLE;\n    \n    public ResourcePoolConfig build() {\n      //校验逻辑放到这里来做，包括必填项校验、依赖关系校验、约束条件校验等\n      if(Stringutils.isBlank(name)) {\n        throw new IllegalArgumentException(\"...\");\n      }\n      if(maxIdle > maxTotal) {\n        throw new IllegalArgumentException(\"...\");\n      }\n      if (minIdle > maxTotal || minIdle > maxIdle) { \n        throw new IllegalArgumentException(\"...\"); \n      }\n      return new ResourcePoolConfig(this);\n    }\n    \n    public Builder setName(String name) { \n      if (StringUtils.isBlank(name)) { \n        throw new IllegalArgumentException(\"...\"); \n      } \n      this.name = name; \n      return this; \n    }\n    \n    public Builder setMaxTotal(int maxTotal) { \n      if (maxTotal <= 0) { \n        throw new IllegalArgumentException(\"...\");\n      } \n      this.maxTotal = maxTotal; \n      return this; \n    }\n    \n    public Builder setMaxIdle(int maxIdle) {\n      if (maxIdle < 0) {\n        throw new IllegalArgumentException(\"...\"); \n      } \n      this.maxIdle = maxIdle; \n      return this; \n    }\n    \n    public Builder setMinIdle(int minIdle) { \n      if (minIdle < 0) { \n        throw new IllegalArgumentException(\"...\"); \n      } \n      this.minIdle = minIdle; \n      return this; \n    }\n    \n    ResourcePoolConfig config = new ResourcePoolConfig.Builder()\n      .setName(\"dbconnectionpool\")\n      .setMaxTotal(16)\n      .setMaxIdle(10) \n      .setMinIdle(12)\n      .build();\n  }\n}\n```\n\n#### 与工厂模式的区别\n\n建造者模式是让建造者来负责对象的创建工作。工厂模式是用来创建不用但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。建造者模式是用来创建一种类型的复杂对象，通过设置不同的可选参数，“定制化”地创建不同的对象。\n\n有一个例子解释了两者的区别。\n\n顾客走进一家餐馆点餐，我们利用工厂模式，根据用户的不同选择，来制作不同的食物（创建不同的对象），比如汉堡、披萨、沙拉。对于披萨来说（复杂的对象，可以自由组合属性），用户又有各种配料可以定制，比如奶酪、西红柿、起司，我们通过建造者模式根据用户选择的不同配料来制作披萨。\n\n#### 建造者模式使用场景\n\n如果一个类中有很多属性，为了避免构造函数的参数列表过长，影响代码的可读性和易用性，我们可以通过构造函数配合set()方法来解决。但是如果存在下面的情况，就要考虑使用建造者模式了\n\n- 类的必填属性放到构造函数中，强制创建对象的时候就设置。如果必填的属性有很多，把这些必填属性都放到构造函数中设置，那构造函数就又会出现参数列表很长的问题。如果把必填属性通过set()方法设置，那校验这些必填属性是否已经填写的逻辑就无处安放了。\n- 如果类的属性之间有一定的依赖关系或者约束条件，我们继续使用构造函数配合set()方法的设计思路，那这些依赖关系或约束条件的校验逻辑就无处安放了。\n- 如果我们希望创建不可变对象，也就是说，对象在创建好之后，就不能再修改内部的属性值，要实现这个功能，我们就不能在类中暴露set()方法。构造函数配合set()方法来设置属性值的方式就不适用了。\n\n\n\n\n\n","source":"_posts/设计模式之建造者模式.md","raw":"---\nlayout:    post\ntitle:     设计模式之建造者模式\ncategory:  设计模式之美\ndescription: 设计模式之建造者模式\ntags: 设计模式之美\ndate: 2021/05/07 13:26:10\n---\n\n```java\npublic class ResourcePoolConfig {\n  private String name;\n  private int maxTotal;\n  private int maxIdle;\n  private int minIdle;\n  \n  private ResourcerePoolConfig(Builder builder) {\n    this.name = builder.name;\n    this,maxTotal = builder.maxTotal;\n    this.maxIdle = builder.maxIdle;\n    this.minIdle = builder.minIdle;\n  }\n  //...省略getter方法\n  //我们将Builder类设计成了ResourcePoolConfig的内部类 \n  //我们也可以将Builder类设计成独立的非内部类ResourcePoolConfigBuilder。\n  public static class Builder {\n    private static final int DEFAULT_MAX_TOTAL = 8;\n    private static final int DEFAULT_MAX_IDLE = 8;\n    private static final int DEFAULT_MIN_IDLE = 0;\n    \n    private String name;\n  \tprivate int maxTotal = DEFAULT_MAX_TOTAL;\n    private int maxIdle = DEFAULT_MAX_IDLE;\n    private int minIdle = DEFAULT_MIN_IDLE;\n    \n    public ResourcePoolConfig build() {\n      //校验逻辑放到这里来做，包括必填项校验、依赖关系校验、约束条件校验等\n      if(Stringutils.isBlank(name)) {\n        throw new IllegalArgumentException(\"...\");\n      }\n      if(maxIdle > maxTotal) {\n        throw new IllegalArgumentException(\"...\");\n      }\n      if (minIdle > maxTotal || minIdle > maxIdle) { \n        throw new IllegalArgumentException(\"...\"); \n      }\n      return new ResourcePoolConfig(this);\n    }\n    \n    public Builder setName(String name) { \n      if (StringUtils.isBlank(name)) { \n        throw new IllegalArgumentException(\"...\"); \n      } \n      this.name = name; \n      return this; \n    }\n    \n    public Builder setMaxTotal(int maxTotal) { \n      if (maxTotal <= 0) { \n        throw new IllegalArgumentException(\"...\");\n      } \n      this.maxTotal = maxTotal; \n      return this; \n    }\n    \n    public Builder setMaxIdle(int maxIdle) {\n      if (maxIdle < 0) {\n        throw new IllegalArgumentException(\"...\"); \n      } \n      this.maxIdle = maxIdle; \n      return this; \n    }\n    \n    public Builder setMinIdle(int minIdle) { \n      if (minIdle < 0) { \n        throw new IllegalArgumentException(\"...\"); \n      } \n      this.minIdle = minIdle; \n      return this; \n    }\n    \n    ResourcePoolConfig config = new ResourcePoolConfig.Builder()\n      .setName(\"dbconnectionpool\")\n      .setMaxTotal(16)\n      .setMaxIdle(10) \n      .setMinIdle(12)\n      .build();\n  }\n}\n```\n\n#### 与工厂模式的区别\n\n建造者模式是让建造者来负责对象的创建工作。工厂模式是用来创建不用但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。建造者模式是用来创建一种类型的复杂对象，通过设置不同的可选参数，“定制化”地创建不同的对象。\n\n有一个例子解释了两者的区别。\n\n顾客走进一家餐馆点餐，我们利用工厂模式，根据用户的不同选择，来制作不同的食物（创建不同的对象），比如汉堡、披萨、沙拉。对于披萨来说（复杂的对象，可以自由组合属性），用户又有各种配料可以定制，比如奶酪、西红柿、起司，我们通过建造者模式根据用户选择的不同配料来制作披萨。\n\n#### 建造者模式使用场景\n\n如果一个类中有很多属性，为了避免构造函数的参数列表过长，影响代码的可读性和易用性，我们可以通过构造函数配合set()方法来解决。但是如果存在下面的情况，就要考虑使用建造者模式了\n\n- 类的必填属性放到构造函数中，强制创建对象的时候就设置。如果必填的属性有很多，把这些必填属性都放到构造函数中设置，那构造函数就又会出现参数列表很长的问题。如果把必填属性通过set()方法设置，那校验这些必填属性是否已经填写的逻辑就无处安放了。\n- 如果类的属性之间有一定的依赖关系或者约束条件，我们继续使用构造函数配合set()方法的设计思路，那这些依赖关系或约束条件的校验逻辑就无处安放了。\n- 如果我们希望创建不可变对象，也就是说，对象在创建好之后，就不能再修改内部的属性值，要实现这个功能，我们就不能在类中暴露set()方法。构造函数配合set()方法来设置属性值的方式就不适用了。\n\n\n\n\n\n","slug":"设计模式之建造者模式","published":1,"updated":"2021-05-07T05:26:10.000Z","comments":1,"photos":[],"link":"","_id":"cm1m304xr001u31b493crgfaj","content":"<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ResourcePoolConfig</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> maxTotal;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> maxIdle;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> minIdle;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">ResourcerePoolConfig</span><span class=\"params\">(Builder builder)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = builder.name;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>,maxTotal = builder.maxTotal;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.maxIdle = builder.maxIdle;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.minIdle = builder.minIdle;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//...省略getter方法</span></span><br><span class=\"line\">  <span class=\"comment\">//我们将Builder类设计成了ResourcePoolConfig的内部类 </span></span><br><span class=\"line\">  <span class=\"comment\">//我们也可以将Builder类设计成独立的非内部类ResourcePoolConfigBuilder。</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Builder</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_MAX_TOTAL = <span class=\"number\">8</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_MAX_IDLE = <span class=\"number\">8</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_MIN_IDLE = <span class=\"number\">0</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">  \t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> maxTotal = DEFAULT_MAX_TOTAL;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> maxIdle = DEFAULT_MAX_IDLE;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> minIdle = DEFAULT_MIN_IDLE;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ResourcePoolConfig <span class=\"title\">build</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">//校验逻辑放到这里来做，包括必填项校验、依赖关系校验、约束条件校验等</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span>(Stringutils.isBlank(name)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">&quot;...&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(maxIdle &gt; maxTotal) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">&quot;...&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (minIdle &gt; maxTotal || minIdle &gt; maxIdle) &#123; </span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">&quot;...&quot;</span>); </span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ResourcePoolConfig(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123; </span><br><span class=\"line\">      <span class=\"keyword\">if</span> (StringUtils.isBlank(name)) &#123; </span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">&quot;...&quot;</span>); </span><br><span class=\"line\">      &#125; </span><br><span class=\"line\">      <span class=\"keyword\">this</span>.name = name; </span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">setMaxTotal</span><span class=\"params\">(<span class=\"keyword\">int</span> maxTotal)</span> </span>&#123; </span><br><span class=\"line\">      <span class=\"keyword\">if</span> (maxTotal &lt;= <span class=\"number\">0</span>) &#123; </span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">&quot;...&quot;</span>);</span><br><span class=\"line\">      &#125; </span><br><span class=\"line\">      <span class=\"keyword\">this</span>.maxTotal = maxTotal; </span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">setMaxIdle</span><span class=\"params\">(<span class=\"keyword\">int</span> maxIdle)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (maxIdle &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">&quot;...&quot;</span>); </span><br><span class=\"line\">      &#125; </span><br><span class=\"line\">      <span class=\"keyword\">this</span>.maxIdle = maxIdle; </span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">setMinIdle</span><span class=\"params\">(<span class=\"keyword\">int</span> minIdle)</span> </span>&#123; </span><br><span class=\"line\">      <span class=\"keyword\">if</span> (minIdle &lt; <span class=\"number\">0</span>) &#123; </span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">&quot;...&quot;</span>); </span><br><span class=\"line\">      &#125; </span><br><span class=\"line\">      <span class=\"keyword\">this</span>.minIdle = minIdle; </span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    ResourcePoolConfig config = <span class=\"keyword\">new</span> ResourcePoolConfig.Builder()</span><br><span class=\"line\">      .setName(<span class=\"string\">&quot;dbconnectionpool&quot;</span>)</span><br><span class=\"line\">      .setMaxTotal(<span class=\"number\">16</span>)</span><br><span class=\"line\">      .setMaxIdle(<span class=\"number\">10</span>) </span><br><span class=\"line\">      .setMinIdle(<span class=\"number\">12</span>)</span><br><span class=\"line\">      .build();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"与工厂模式的区别\"><a href=\"#与工厂模式的区别\" class=\"headerlink\" title=\"与工厂模式的区别\"></a>与工厂模式的区别</h4><p>建造者模式是让建造者来负责对象的创建工作。工厂模式是用来创建不用但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。建造者模式是用来创建一种类型的复杂对象，通过设置不同的可选参数，“定制化”地创建不同的对象。</p>\n<p>有一个例子解释了两者的区别。</p>\n<p>顾客走进一家餐馆点餐，我们利用工厂模式，根据用户的不同选择，来制作不同的食物（创建不同的对象），比如汉堡、披萨、沙拉。对于披萨来说（复杂的对象，可以自由组合属性），用户又有各种配料可以定制，比如奶酪、西红柿、起司，我们通过建造者模式根据用户选择的不同配料来制作披萨。</p>\n<h4 id=\"建造者模式使用场景\"><a href=\"#建造者模式使用场景\" class=\"headerlink\" title=\"建造者模式使用场景\"></a>建造者模式使用场景</h4><p>如果一个类中有很多属性，为了避免构造函数的参数列表过长，影响代码的可读性和易用性，我们可以通过构造函数配合set()方法来解决。但是如果存在下面的情况，就要考虑使用建造者模式了</p>\n<ul>\n<li>类的必填属性放到构造函数中，强制创建对象的时候就设置。如果必填的属性有很多，把这些必填属性都放到构造函数中设置，那构造函数就又会出现参数列表很长的问题。如果把必填属性通过set()方法设置，那校验这些必填属性是否已经填写的逻辑就无处安放了。</li>\n<li>如果类的属性之间有一定的依赖关系或者约束条件，我们继续使用构造函数配合set()方法的设计思路，那这些依赖关系或约束条件的校验逻辑就无处安放了。</li>\n<li>如果我们希望创建不可变对象，也就是说，对象在创建好之后，就不能再修改内部的属性值，要实现这个功能，我们就不能在类中暴露set()方法。构造函数配合set()方法来设置属性值的方式就不适用了。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ResourcePoolConfig</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> maxTotal;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> maxIdle;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> minIdle;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">ResourcerePoolConfig</span><span class=\"params\">(Builder builder)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = builder.name;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>,maxTotal = builder.maxTotal;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.maxIdle = builder.maxIdle;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.minIdle = builder.minIdle;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//...省略getter方法</span></span><br><span class=\"line\">  <span class=\"comment\">//我们将Builder类设计成了ResourcePoolConfig的内部类 </span></span><br><span class=\"line\">  <span class=\"comment\">//我们也可以将Builder类设计成独立的非内部类ResourcePoolConfigBuilder。</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Builder</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_MAX_TOTAL = <span class=\"number\">8</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_MAX_IDLE = <span class=\"number\">8</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_MIN_IDLE = <span class=\"number\">0</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">  \t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> maxTotal = DEFAULT_MAX_TOTAL;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> maxIdle = DEFAULT_MAX_IDLE;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> minIdle = DEFAULT_MIN_IDLE;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ResourcePoolConfig <span class=\"title\">build</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">//校验逻辑放到这里来做，包括必填项校验、依赖关系校验、约束条件校验等</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span>(Stringutils.isBlank(name)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">&quot;...&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(maxIdle &gt; maxTotal) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">&quot;...&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (minIdle &gt; maxTotal || minIdle &gt; maxIdle) &#123; </span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">&quot;...&quot;</span>); </span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ResourcePoolConfig(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123; </span><br><span class=\"line\">      <span class=\"keyword\">if</span> (StringUtils.isBlank(name)) &#123; </span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">&quot;...&quot;</span>); </span><br><span class=\"line\">      &#125; </span><br><span class=\"line\">      <span class=\"keyword\">this</span>.name = name; </span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">setMaxTotal</span><span class=\"params\">(<span class=\"keyword\">int</span> maxTotal)</span> </span>&#123; </span><br><span class=\"line\">      <span class=\"keyword\">if</span> (maxTotal &lt;= <span class=\"number\">0</span>) &#123; </span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">&quot;...&quot;</span>);</span><br><span class=\"line\">      &#125; </span><br><span class=\"line\">      <span class=\"keyword\">this</span>.maxTotal = maxTotal; </span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">setMaxIdle</span><span class=\"params\">(<span class=\"keyword\">int</span> maxIdle)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (maxIdle &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">&quot;...&quot;</span>); </span><br><span class=\"line\">      &#125; </span><br><span class=\"line\">      <span class=\"keyword\">this</span>.maxIdle = maxIdle; </span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">setMinIdle</span><span class=\"params\">(<span class=\"keyword\">int</span> minIdle)</span> </span>&#123; </span><br><span class=\"line\">      <span class=\"keyword\">if</span> (minIdle &lt; <span class=\"number\">0</span>) &#123; </span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">&quot;...&quot;</span>); </span><br><span class=\"line\">      &#125; </span><br><span class=\"line\">      <span class=\"keyword\">this</span>.minIdle = minIdle; </span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    ResourcePoolConfig config = <span class=\"keyword\">new</span> ResourcePoolConfig.Builder()</span><br><span class=\"line\">      .setName(<span class=\"string\">&quot;dbconnectionpool&quot;</span>)</span><br><span class=\"line\">      .setMaxTotal(<span class=\"number\">16</span>)</span><br><span class=\"line\">      .setMaxIdle(<span class=\"number\">10</span>) </span><br><span class=\"line\">      .setMinIdle(<span class=\"number\">12</span>)</span><br><span class=\"line\">      .build();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"与工厂模式的区别\"><a href=\"#与工厂模式的区别\" class=\"headerlink\" title=\"与工厂模式的区别\"></a>与工厂模式的区别</h4><p>建造者模式是让建造者来负责对象的创建工作。工厂模式是用来创建不用但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。建造者模式是用来创建一种类型的复杂对象，通过设置不同的可选参数，“定制化”地创建不同的对象。</p>\n<p>有一个例子解释了两者的区别。</p>\n<p>顾客走进一家餐馆点餐，我们利用工厂模式，根据用户的不同选择，来制作不同的食物（创建不同的对象），比如汉堡、披萨、沙拉。对于披萨来说（复杂的对象，可以自由组合属性），用户又有各种配料可以定制，比如奶酪、西红柿、起司，我们通过建造者模式根据用户选择的不同配料来制作披萨。</p>\n<h4 id=\"建造者模式使用场景\"><a href=\"#建造者模式使用场景\" class=\"headerlink\" title=\"建造者模式使用场景\"></a>建造者模式使用场景</h4><p>如果一个类中有很多属性，为了避免构造函数的参数列表过长，影响代码的可读性和易用性，我们可以通过构造函数配合set()方法来解决。但是如果存在下面的情况，就要考虑使用建造者模式了</p>\n<ul>\n<li>类的必填属性放到构造函数中，强制创建对象的时候就设置。如果必填的属性有很多，把这些必填属性都放到构造函数中设置，那构造函数就又会出现参数列表很长的问题。如果把必填属性通过set()方法设置，那校验这些必填属性是否已经填写的逻辑就无处安放了。</li>\n<li>如果类的属性之间有一定的依赖关系或者约束条件，我们继续使用构造函数配合set()方法的设计思路，那这些依赖关系或约束条件的校验逻辑就无处安放了。</li>\n<li>如果我们希望创建不可变对象，也就是说，对象在创建好之后，就不能再修改内部的属性值，要实现这个功能，我们就不能在类中暴露set()方法。构造函数配合set()方法来设置属性值的方式就不适用了。</li>\n</ul>\n"},{"layout":"post","title":"设计模式之桥接模式","description":"设计模式之桥接模式","date":"2021-05-19T05:26:10.000Z","_content":"\n桥接模式，也叫做桥梁莫斯。在 GoF 的《设计模式》一书中，桥接模式是这么定义的：“Decouple an abstraction from its implementation so that the two can vary independently。”翻译成中文就是：“将抽象和实现解耦，让它们可以独立变化。”。还有另一种理解方式：“一个类存在两个（或多个）独立变化的维度，我们通过组合的方式，让这两个（或多个）维度可以独立进行扩展。”通过组合关系来替代继承关系，避免继承层次的指数级爆炸。\n\nJDBC驱动是桥接模式的经典应用。\n\n```java\nClass.forName(\"com.mysql.jdbc.Driver\");//加载及注册JDBC驱动程序\nString url = \"jdbc:mysql://localhost:3306/sample_db?user=root&password=your_password\";\nConnection con = DriverManager.getConnection(url);\nStatement stmt = con.createStatement();\nString query = \"select * from test\";\nResultSet rs = stmt.executeQuery(query);\nwhile(rs.next()) {\n  rs.getString(1);\n  rs.getInt(2);\n}\n```\n\n如果想把MySQL数据库换成Oracle数据库，只需要把第一行代码中的com.mysql.jdbc.Driver换成oracle.jdbc.driver.OracleDriver就可以了。也可以把需要加载的Driver类写到配置文件中，程序启动的时候，从配置文件中加载，切换数据库的时候，只需要修改配置文件就可以了。\n\n一个数据库切换到另一种数据库都只需要改动很少的代码，或者完全不需要改动代码。源码之下无秘密，要弄清他们如何实现的，先从com.mysql.jdbc.Driver这个类的代码看起。\n\n```java\n\npackage com.mysql.jdbc;\nimport java.sql.SQLException;\n\npublic class Driver extends NonRegisteringDriver implements java.sql.Driver {\n  static {\n    try {\n      java.sql.DriverManager.registerDriver(new Driver());\n    } catch (SQLException E) {\n      throw new RuntimeException(\"Can't register driver!\");\n    }\n  }\n\n  /**\n   * Construct a new driver and register it with DriverManager\n   * @throws SQLException if a database error occurs.\n   */\n  public Driver() throws SQLException {\n    // Required for Class.forName().newInstance()\n  }\n}\n```\n\n结合com.mysql.jdbc.Driver的代码实现，可以发现，执行Class.forName(\"com.mysql.jdbc.Driver\")这条语句的时候，实际做了两件事，1.要求JVM查找并加载指定的Driver类，2.执行该类的静态代码，也就是将MySQL Driver注册到DriverManager类中。\n\n看下DriverManager类干嘛的。当我们把Driver实现类注册到DriverManager之后，后续所有JDBC接口的调用，都会委派到具体的Driver实现类来执行。而Driver实现类都实现了相同的接口（java.sql.Driver），这也是可以灵活切换Driver的原因。\n\n```java\n\npublic class DriverManager {\n  private final static CopyOnWriteArrayList<DriverInfo> registeredDrivers = new CopyOnWriteArrayList<DriverInfo>();\n\n  //...\n  static {\n    loadInitialDrivers();\n    println(\"JDBC DriverManager initialized\");\n  }\n  //...\n\n  public static synchronized void registerDriver(java.sql.Driver driver) throws SQLException {\n    if (driver != null) {\n      registeredDrivers.addIfAbsent(new DriverInfo(driver));\n    } else {\n      throw new NullPointerException();\n    }\n  }\n\n  public static Connection getConnection(String url, String user, String password) throws SQLException {\n    java.util.Properties info = new java.util.Properties();\n    if (user != null) {\n      info.put(\"user\", user);\n    }\n    if (password != null) {\n      info.put(\"password\", password);\n    }\n    return (getConnection(url, info, Reflection.getCallerClass()));\n  }\n  //...\n}\n```\n\n桥接模式的定义是“将抽象和实现解耦，让它们可以独立变化”。实际上JDBC本身就相当于“抽象”。这里所说的抽象，并非是抽象类或者接口，而是跟具体的数据库无关的、被抽象出来的一套“类库”。具体的Driver（比如com.mysql.jdbc.Driver）就相当于实现。这里说的实现，并非接口的实现类，而是跟具体的数据库相关的一套类库。JDBC和Driver独立开发，通过对象间的组合关系，组装在一起。JDBC的所有逻辑操作，最终都委托给Driver来执行。\n\n##### 桥接模式应用举例\n\n根据不同的告警规则，触发不同类型的告警。告警支持多种通知渠道，包括：邮件、短信、微信、自动语音电话。通知的紧急程度又多种类型，包括SERVER（严重）、URGENCY（紧急）、NORMAL（普通）、TRIVIAL（无关紧要）。不同的紧急程度对应不同的通知渠道。比如SERVER级别的消息会通过自动语音电话告知相关人员。最简单的代码实现方式如下\n\n```java\n\npublic enum NotificationEmergencyLevel {\n  SEVERE, URGENCY, NORMAL, TRIVIAL\n}\n\npublic class Notification {\n  private List<String> emailAddresses;\n  private List<String> telephones;\n  private List<String> wechatIds;\n\n  public Notification() {}\n\n  public void setEmailAddress(List<String> emailAddress) {\n    this.emailAddresses = emailAddress;\n  }\n\n  public void setTelephones(List<String> telephones) {\n    this.telephones = telephones;\n  }\n\n  public void setWechatIds(List<String> wechatIds) {\n    this.wechatIds = wechatIds;\n  }\n\n  public void notify(NotificationEmergencyLevel level, String message) {\n    if (level.equals(NotificationEmergencyLevel.SEVERE)) {\n      //...自动语音电话\n    } else if (level.equals(NotificationEmergencyLevel.URGENCY)) {\n      //...发微信\n    } else if (level.equals(NotificationEmergencyLevel.NORMAL)) {\n      //...发邮件\n    } else if (level.equals(NotificationEmergencyLevel.TRIVIAL)) {\n      //...发邮件\n    }\n  }\n}\n\n//在API监控告警的例子中，我们如下方式来使用Notification类：\npublic class ErrorAlertHandler extends AlertHandler {\n  public ErrorAlertHandler(AlertRule rule, Notification notification){\n    super(rule, notification);\n  }\n\n  @Override\n  public void check(ApiStatInfo apiStatInfo) {\n    if (apiStatInfo.getErrorCount() > rule.getMatchedRule(apiStatInfo.getApi()).getMaxErrorCount()) {\n      notification.notify(NotificationEmergencyLevel.SEVERE, \"...\");\n    }\n  }\n}\n```\n\nNotification类的代码有一个最明显的问题，就是有很多if-else分支逻辑。但是如果每个分支中的代码逻辑都不复杂，后期也没有无限膨胀的可能，那这样的设计问题不大，没必要非的摒弃if-else分支逻辑。\n\n不过Notification的代码显然不符合这个条件，因为每个if-else分支中的代码逻辑都比较复杂，发送通知的所有逻辑都扎堆在Notification类中。很多设计模式都是试图将庞大的类拆分成更细小的类，然后再通过各种更合理的结构组装在一起。\n\n针对Notification的代码，我们将不同渠道的发送逻辑剥离出来，形成独立的消息发送类（MsgSender相关类）。其中Notification类相当于抽象，MsgSender类相当于实现，两者可以独立开发，通过组合关系（也就是桥梁）任意组合在一起。所谓任意组合的意思就是，不同紧急程度的消息和发送渠道之间的对应关系，不是在代码中固定写死的，我们可以动态地去指定（比如通过读取配置来获取对应关系）。\n\n按照这个思路，对代码进行重构，重构之后的代码如下:\n\n```java\npublic interface MsgSender {\n  void send(String message);\n}\n\npublic class TelephoneMsgSender implements MsgSender {\n  private List<String> telephones;\n  \n  public TelephoneMsgSender(List<String> telephones) {\n    this.telephones = telephones;\n  }\n  \n  @Override\n  public void send(String message){\n    //...\n  }\n  \n  public class EmailMsgSender implements MsgSender {\n    //与TelephoneMsgSender代码结构类似，所以省略...\n  }\n  \n  public class WechatMsgSender implements MsgSender {\n    //与TelephoneMsgSender代码结构类似，所以省略...\n  }\n  \n  public abstract class Notification {\n    protected MsgSender msgSender;\n    \n    public Notification(MsgSender msgSender) {\n      this.msgSender = msgSender;\n    }\n    \n    public abstract void notify(String message);\n  }\n  \n  public class ServerNotification extends Notification {\n    public ServerNotification(MsgSender msgSender) {\n      super(msgSender);\n    }\n    \n    @Override\n    public void notify(String message) {\n      msgSender.send(message);\n    }\n  }\n  \n  public class UrgencyNotification extends Notification { \n    // 与SevereNotification代码结构类似，所以省略...\n  }\n  public class NormalNotification extends Notification { \n    // 与SevereNotification代码结构类似，所以省略...\n  }\n  public class TrivialNotification extends Notification { \n    // 与SevereNotification代码结构类似，所以省略...\n  }\n}\n```\n\n在其他资料中，还有另外一种更加简单的理解方式：一个类存在两个（或多个）独立变化的维度，我们通过组合的方式，让这两个（或多个）维度可以独立进行扩展。\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/设计模式之桥接模式.md","raw":"---\nlayout:    post\ntitle:     设计模式之桥接模式\ncategory:  设计模式之美\ndescription: 设计模式之桥接模式\ntags: 设计模式之美\ndate: 2021/05/19 13:26:10\n---\n\n桥接模式，也叫做桥梁莫斯。在 GoF 的《设计模式》一书中，桥接模式是这么定义的：“Decouple an abstraction from its implementation so that the two can vary independently。”翻译成中文就是：“将抽象和实现解耦，让它们可以独立变化。”。还有另一种理解方式：“一个类存在两个（或多个）独立变化的维度，我们通过组合的方式，让这两个（或多个）维度可以独立进行扩展。”通过组合关系来替代继承关系，避免继承层次的指数级爆炸。\n\nJDBC驱动是桥接模式的经典应用。\n\n```java\nClass.forName(\"com.mysql.jdbc.Driver\");//加载及注册JDBC驱动程序\nString url = \"jdbc:mysql://localhost:3306/sample_db?user=root&password=your_password\";\nConnection con = DriverManager.getConnection(url);\nStatement stmt = con.createStatement();\nString query = \"select * from test\";\nResultSet rs = stmt.executeQuery(query);\nwhile(rs.next()) {\n  rs.getString(1);\n  rs.getInt(2);\n}\n```\n\n如果想把MySQL数据库换成Oracle数据库，只需要把第一行代码中的com.mysql.jdbc.Driver换成oracle.jdbc.driver.OracleDriver就可以了。也可以把需要加载的Driver类写到配置文件中，程序启动的时候，从配置文件中加载，切换数据库的时候，只需要修改配置文件就可以了。\n\n一个数据库切换到另一种数据库都只需要改动很少的代码，或者完全不需要改动代码。源码之下无秘密，要弄清他们如何实现的，先从com.mysql.jdbc.Driver这个类的代码看起。\n\n```java\n\npackage com.mysql.jdbc;\nimport java.sql.SQLException;\n\npublic class Driver extends NonRegisteringDriver implements java.sql.Driver {\n  static {\n    try {\n      java.sql.DriverManager.registerDriver(new Driver());\n    } catch (SQLException E) {\n      throw new RuntimeException(\"Can't register driver!\");\n    }\n  }\n\n  /**\n   * Construct a new driver and register it with DriverManager\n   * @throws SQLException if a database error occurs.\n   */\n  public Driver() throws SQLException {\n    // Required for Class.forName().newInstance()\n  }\n}\n```\n\n结合com.mysql.jdbc.Driver的代码实现，可以发现，执行Class.forName(\"com.mysql.jdbc.Driver\")这条语句的时候，实际做了两件事，1.要求JVM查找并加载指定的Driver类，2.执行该类的静态代码，也就是将MySQL Driver注册到DriverManager类中。\n\n看下DriverManager类干嘛的。当我们把Driver实现类注册到DriverManager之后，后续所有JDBC接口的调用，都会委派到具体的Driver实现类来执行。而Driver实现类都实现了相同的接口（java.sql.Driver），这也是可以灵活切换Driver的原因。\n\n```java\n\npublic class DriverManager {\n  private final static CopyOnWriteArrayList<DriverInfo> registeredDrivers = new CopyOnWriteArrayList<DriverInfo>();\n\n  //...\n  static {\n    loadInitialDrivers();\n    println(\"JDBC DriverManager initialized\");\n  }\n  //...\n\n  public static synchronized void registerDriver(java.sql.Driver driver) throws SQLException {\n    if (driver != null) {\n      registeredDrivers.addIfAbsent(new DriverInfo(driver));\n    } else {\n      throw new NullPointerException();\n    }\n  }\n\n  public static Connection getConnection(String url, String user, String password) throws SQLException {\n    java.util.Properties info = new java.util.Properties();\n    if (user != null) {\n      info.put(\"user\", user);\n    }\n    if (password != null) {\n      info.put(\"password\", password);\n    }\n    return (getConnection(url, info, Reflection.getCallerClass()));\n  }\n  //...\n}\n```\n\n桥接模式的定义是“将抽象和实现解耦，让它们可以独立变化”。实际上JDBC本身就相当于“抽象”。这里所说的抽象，并非是抽象类或者接口，而是跟具体的数据库无关的、被抽象出来的一套“类库”。具体的Driver（比如com.mysql.jdbc.Driver）就相当于实现。这里说的实现，并非接口的实现类，而是跟具体的数据库相关的一套类库。JDBC和Driver独立开发，通过对象间的组合关系，组装在一起。JDBC的所有逻辑操作，最终都委托给Driver来执行。\n\n##### 桥接模式应用举例\n\n根据不同的告警规则，触发不同类型的告警。告警支持多种通知渠道，包括：邮件、短信、微信、自动语音电话。通知的紧急程度又多种类型，包括SERVER（严重）、URGENCY（紧急）、NORMAL（普通）、TRIVIAL（无关紧要）。不同的紧急程度对应不同的通知渠道。比如SERVER级别的消息会通过自动语音电话告知相关人员。最简单的代码实现方式如下\n\n```java\n\npublic enum NotificationEmergencyLevel {\n  SEVERE, URGENCY, NORMAL, TRIVIAL\n}\n\npublic class Notification {\n  private List<String> emailAddresses;\n  private List<String> telephones;\n  private List<String> wechatIds;\n\n  public Notification() {}\n\n  public void setEmailAddress(List<String> emailAddress) {\n    this.emailAddresses = emailAddress;\n  }\n\n  public void setTelephones(List<String> telephones) {\n    this.telephones = telephones;\n  }\n\n  public void setWechatIds(List<String> wechatIds) {\n    this.wechatIds = wechatIds;\n  }\n\n  public void notify(NotificationEmergencyLevel level, String message) {\n    if (level.equals(NotificationEmergencyLevel.SEVERE)) {\n      //...自动语音电话\n    } else if (level.equals(NotificationEmergencyLevel.URGENCY)) {\n      //...发微信\n    } else if (level.equals(NotificationEmergencyLevel.NORMAL)) {\n      //...发邮件\n    } else if (level.equals(NotificationEmergencyLevel.TRIVIAL)) {\n      //...发邮件\n    }\n  }\n}\n\n//在API监控告警的例子中，我们如下方式来使用Notification类：\npublic class ErrorAlertHandler extends AlertHandler {\n  public ErrorAlertHandler(AlertRule rule, Notification notification){\n    super(rule, notification);\n  }\n\n  @Override\n  public void check(ApiStatInfo apiStatInfo) {\n    if (apiStatInfo.getErrorCount() > rule.getMatchedRule(apiStatInfo.getApi()).getMaxErrorCount()) {\n      notification.notify(NotificationEmergencyLevel.SEVERE, \"...\");\n    }\n  }\n}\n```\n\nNotification类的代码有一个最明显的问题，就是有很多if-else分支逻辑。但是如果每个分支中的代码逻辑都不复杂，后期也没有无限膨胀的可能，那这样的设计问题不大，没必要非的摒弃if-else分支逻辑。\n\n不过Notification的代码显然不符合这个条件，因为每个if-else分支中的代码逻辑都比较复杂，发送通知的所有逻辑都扎堆在Notification类中。很多设计模式都是试图将庞大的类拆分成更细小的类，然后再通过各种更合理的结构组装在一起。\n\n针对Notification的代码，我们将不同渠道的发送逻辑剥离出来，形成独立的消息发送类（MsgSender相关类）。其中Notification类相当于抽象，MsgSender类相当于实现，两者可以独立开发，通过组合关系（也就是桥梁）任意组合在一起。所谓任意组合的意思就是，不同紧急程度的消息和发送渠道之间的对应关系，不是在代码中固定写死的，我们可以动态地去指定（比如通过读取配置来获取对应关系）。\n\n按照这个思路，对代码进行重构，重构之后的代码如下:\n\n```java\npublic interface MsgSender {\n  void send(String message);\n}\n\npublic class TelephoneMsgSender implements MsgSender {\n  private List<String> telephones;\n  \n  public TelephoneMsgSender(List<String> telephones) {\n    this.telephones = telephones;\n  }\n  \n  @Override\n  public void send(String message){\n    //...\n  }\n  \n  public class EmailMsgSender implements MsgSender {\n    //与TelephoneMsgSender代码结构类似，所以省略...\n  }\n  \n  public class WechatMsgSender implements MsgSender {\n    //与TelephoneMsgSender代码结构类似，所以省略...\n  }\n  \n  public abstract class Notification {\n    protected MsgSender msgSender;\n    \n    public Notification(MsgSender msgSender) {\n      this.msgSender = msgSender;\n    }\n    \n    public abstract void notify(String message);\n  }\n  \n  public class ServerNotification extends Notification {\n    public ServerNotification(MsgSender msgSender) {\n      super(msgSender);\n    }\n    \n    @Override\n    public void notify(String message) {\n      msgSender.send(message);\n    }\n  }\n  \n  public class UrgencyNotification extends Notification { \n    // 与SevereNotification代码结构类似，所以省略...\n  }\n  public class NormalNotification extends Notification { \n    // 与SevereNotification代码结构类似，所以省略...\n  }\n  public class TrivialNotification extends Notification { \n    // 与SevereNotification代码结构类似，所以省略...\n  }\n}\n```\n\n在其他资料中，还有另外一种更加简单的理解方式：一个类存在两个（或多个）独立变化的维度，我们通过组合的方式，让这两个（或多个）维度可以独立进行扩展。\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"设计模式之桥接模式","published":1,"updated":"2021-05-19T05:26:10.000Z","comments":1,"photos":[],"link":"","_id":"cm1m304xr001x31b4aieq7omv","content":"<p>桥接模式，也叫做桥梁莫斯。在 GoF 的《设计模式》一书中，桥接模式是这么定义的：“Decouple an abstraction from its implementation so that the two can vary independently。”翻译成中文就是：“将抽象和实现解耦，让它们可以独立变化。”。还有另一种理解方式：“一个类存在两个（或多个）独立变化的维度，我们通过组合的方式，让这两个（或多个）维度可以独立进行扩展。”通过组合关系来替代继承关系，避免继承层次的指数级爆炸。</p>\n<p>JDBC驱动是桥接模式的经典应用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class.forName(<span class=\"string\">&quot;com.mysql.jdbc.Driver&quot;</span>);<span class=\"comment\">//加载及注册JDBC驱动程序</span></span><br><span class=\"line\">String url = <span class=\"string\">&quot;jdbc:mysql://localhost:3306/sample_db?user=root&amp;password=your_password&quot;</span>;</span><br><span class=\"line\">Connection con = DriverManager.getConnection(url);</span><br><span class=\"line\">Statement stmt = con.createStatement();</span><br><span class=\"line\">String query = <span class=\"string\">&quot;select * from test&quot;</span>;</span><br><span class=\"line\">ResultSet rs = stmt.executeQuery(query);</span><br><span class=\"line\"><span class=\"keyword\">while</span>(rs.next()) &#123;</span><br><span class=\"line\">  rs.getString(<span class=\"number\">1</span>);</span><br><span class=\"line\">  rs.getInt(<span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果想把MySQL数据库换成Oracle数据库，只需要把第一行代码中的com.mysql.jdbc.Driver换成oracle.jdbc.driver.OracleDriver就可以了。也可以把需要加载的Driver类写到配置文件中，程序启动的时候，从配置文件中加载，切换数据库的时候，只需要修改配置文件就可以了。</p>\n<p>一个数据库切换到另一种数据库都只需要改动很少的代码，或者完全不需要改动代码。源码之下无秘密，要弄清他们如何实现的，先从com.mysql.jdbc.Driver这个类的代码看起。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">package</span> com.mysql.jdbc;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.sql.SQLException;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Driver</span> <span class=\"keyword\">extends</span> <span class=\"title\">NonRegisteringDriver</span> <span class=\"keyword\">implements</span> <span class=\"title\">java</span>.<span class=\"title\">sql</span>.<span class=\"title\">Driver</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      java.sql.DriverManager.registerDriver(<span class=\"keyword\">new</span> Driver());</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (SQLException E) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">&quot;Can&#x27;t register driver!&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * Construct a new driver and register it with DriverManager</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@throws</span> SQLException if a database error occurs.</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Driver</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> SQLException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Required for Class.forName().newInstance()</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>结合com.mysql.jdbc.Driver的代码实现，可以发现，执行Class.forName(“com.mysql.jdbc.Driver”)这条语句的时候，实际做了两件事，1.要求JVM查找并加载指定的Driver类，2.执行该类的静态代码，也就是将MySQL Driver注册到DriverManager类中。</p>\n<p>看下DriverManager类干嘛的。当我们把Driver实现类注册到DriverManager之后，后续所有JDBC接口的调用，都会委派到具体的Driver实现类来执行。而Driver实现类都实现了相同的接口（java.sql.Driver），这也是可以灵活切换Driver的原因。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DriverManager</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> CopyOnWriteArrayList&lt;DriverInfo&gt; registeredDrivers = <span class=\"keyword\">new</span> CopyOnWriteArrayList&lt;DriverInfo&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">  <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">    loadInitialDrivers();</span><br><span class=\"line\">    println(<span class=\"string\">&quot;JDBC DriverManager initialized&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">registerDriver</span><span class=\"params\">(java.sql.Driver driver)</span> <span class=\"keyword\">throws</span> SQLException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (driver != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      registeredDrivers.addIfAbsent(<span class=\"keyword\">new</span> DriverInfo(driver));</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Connection <span class=\"title\">getConnection</span><span class=\"params\">(String url, String user, String password)</span> <span class=\"keyword\">throws</span> SQLException </span>&#123;</span><br><span class=\"line\">    java.util.Properties info = <span class=\"keyword\">new</span> java.util.Properties();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (user != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      info.put(<span class=\"string\">&quot;user&quot;</span>, user);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (password != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      info.put(<span class=\"string\">&quot;password&quot;</span>, password);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (getConnection(url, info, Reflection.getCallerClass()));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>桥接模式的定义是“将抽象和实现解耦，让它们可以独立变化”。实际上JDBC本身就相当于“抽象”。这里所说的抽象，并非是抽象类或者接口，而是跟具体的数据库无关的、被抽象出来的一套“类库”。具体的Driver（比如com.mysql.jdbc.Driver）就相当于实现。这里说的实现，并非接口的实现类，而是跟具体的数据库相关的一套类库。JDBC和Driver独立开发，通过对象间的组合关系，组装在一起。JDBC的所有逻辑操作，最终都委托给Driver来执行。</p>\n<h5 id=\"桥接模式应用举例\"><a href=\"#桥接模式应用举例\" class=\"headerlink\" title=\"桥接模式应用举例\"></a>桥接模式应用举例</h5><p>根据不同的告警规则，触发不同类型的告警。告警支持多种通知渠道，包括：邮件、短信、微信、自动语音电话。通知的紧急程度又多种类型，包括SERVER（严重）、URGENCY（紧急）、NORMAL（普通）、TRIVIAL（无关紧要）。不同的紧急程度对应不同的通知渠道。比如SERVER级别的消息会通过自动语音电话告知相关人员。最简单的代码实现方式如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">NotificationEmergencyLevel</span> </span>&#123;</span><br><span class=\"line\">  SEVERE, URGENCY, NORMAL, TRIVIAL</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Notification</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> List&lt;String&gt; emailAddresses;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> List&lt;String&gt; telephones;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> List&lt;String&gt; wechatIds;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Notification</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setEmailAddress</span><span class=\"params\">(List&lt;String&gt; emailAddress)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.emailAddresses = emailAddress;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setTelephones</span><span class=\"params\">(List&lt;String&gt; telephones)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.telephones = telephones;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setWechatIds</span><span class=\"params\">(List&lt;String&gt; wechatIds)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.wechatIds = wechatIds;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">notify</span><span class=\"params\">(NotificationEmergencyLevel level, String message)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (level.equals(NotificationEmergencyLevel.SEVERE)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//...自动语音电话</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (level.equals(NotificationEmergencyLevel.URGENCY)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//...发微信</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (level.equals(NotificationEmergencyLevel.NORMAL)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//...发邮件</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (level.equals(NotificationEmergencyLevel.TRIVIAL)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//...发邮件</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//在API监控告警的例子中，我们如下方式来使用Notification类：</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ErrorAlertHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">AlertHandler</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ErrorAlertHandler</span><span class=\"params\">(AlertRule rule, Notification notification)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(rule, notification);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">check</span><span class=\"params\">(ApiStatInfo apiStatInfo)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (apiStatInfo.getErrorCount() &gt; rule.getMatchedRule(apiStatInfo.getApi()).getMaxErrorCount()) &#123;</span><br><span class=\"line\">      notification.notify(NotificationEmergencyLevel.SEVERE, <span class=\"string\">&quot;...&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Notification类的代码有一个最明显的问题，就是有很多if-else分支逻辑。但是如果每个分支中的代码逻辑都不复杂，后期也没有无限膨胀的可能，那这样的设计问题不大，没必要非的摒弃if-else分支逻辑。</p>\n<p>不过Notification的代码显然不符合这个条件，因为每个if-else分支中的代码逻辑都比较复杂，发送通知的所有逻辑都扎堆在Notification类中。很多设计模式都是试图将庞大的类拆分成更细小的类，然后再通过各种更合理的结构组装在一起。</p>\n<p>针对Notification的代码，我们将不同渠道的发送逻辑剥离出来，形成独立的消息发送类（MsgSender相关类）。其中Notification类相当于抽象，MsgSender类相当于实现，两者可以独立开发，通过组合关系（也就是桥梁）任意组合在一起。所谓任意组合的意思就是，不同紧急程度的消息和发送渠道之间的对应关系，不是在代码中固定写死的，我们可以动态地去指定（比如通过读取配置来获取对应关系）。</p>\n<p>按照这个思路，对代码进行重构，重构之后的代码如下:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MsgSender</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">send</span><span class=\"params\">(String message)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TelephoneMsgSender</span> <span class=\"keyword\">implements</span> <span class=\"title\">MsgSender</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> List&lt;String&gt; telephones;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">TelephoneMsgSender</span><span class=\"params\">(List&lt;String&gt; telephones)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.telephones = telephones;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">send</span><span class=\"params\">(String message)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EmailMsgSender</span> <span class=\"keyword\">implements</span> <span class=\"title\">MsgSender</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//与TelephoneMsgSender代码结构类似，所以省略...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WechatMsgSender</span> <span class=\"keyword\">implements</span> <span class=\"title\">MsgSender</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//与TelephoneMsgSender代码结构类似，所以省略...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Notification</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> MsgSender msgSender;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Notification</span><span class=\"params\">(MsgSender msgSender)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.msgSender = msgSender;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">notify</span><span class=\"params\">(String message)</span></span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ServerNotification</span> <span class=\"keyword\">extends</span> <span class=\"title\">Notification</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ServerNotification</span><span class=\"params\">(MsgSender msgSender)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">super</span>(msgSender);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">notify</span><span class=\"params\">(String message)</span> </span>&#123;</span><br><span class=\"line\">      msgSender.send(message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UrgencyNotification</span> <span class=\"keyword\">extends</span> <span class=\"title\">Notification</span> </span>&#123; </span><br><span class=\"line\">    <span class=\"comment\">// 与SevereNotification代码结构类似，所以省略...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NormalNotification</span> <span class=\"keyword\">extends</span> <span class=\"title\">Notification</span> </span>&#123; </span><br><span class=\"line\">    <span class=\"comment\">// 与SevereNotification代码结构类似，所以省略...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TrivialNotification</span> <span class=\"keyword\">extends</span> <span class=\"title\">Notification</span> </span>&#123; </span><br><span class=\"line\">    <span class=\"comment\">// 与SevereNotification代码结构类似，所以省略...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在其他资料中，还有另外一种更加简单的理解方式：一个类存在两个（或多个）独立变化的维度，我们通过组合的方式，让这两个（或多个）维度可以独立进行扩展。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>桥接模式，也叫做桥梁莫斯。在 GoF 的《设计模式》一书中，桥接模式是这么定义的：“Decouple an abstraction from its implementation so that the two can vary independently。”翻译成中文就是：“将抽象和实现解耦，让它们可以独立变化。”。还有另一种理解方式：“一个类存在两个（或多个）独立变化的维度，我们通过组合的方式，让这两个（或多个）维度可以独立进行扩展。”通过组合关系来替代继承关系，避免继承层次的指数级爆炸。</p>\n<p>JDBC驱动是桥接模式的经典应用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class.forName(<span class=\"string\">&quot;com.mysql.jdbc.Driver&quot;</span>);<span class=\"comment\">//加载及注册JDBC驱动程序</span></span><br><span class=\"line\">String url = <span class=\"string\">&quot;jdbc:mysql://localhost:3306/sample_db?user=root&amp;password=your_password&quot;</span>;</span><br><span class=\"line\">Connection con = DriverManager.getConnection(url);</span><br><span class=\"line\">Statement stmt = con.createStatement();</span><br><span class=\"line\">String query = <span class=\"string\">&quot;select * from test&quot;</span>;</span><br><span class=\"line\">ResultSet rs = stmt.executeQuery(query);</span><br><span class=\"line\"><span class=\"keyword\">while</span>(rs.next()) &#123;</span><br><span class=\"line\">  rs.getString(<span class=\"number\">1</span>);</span><br><span class=\"line\">  rs.getInt(<span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果想把MySQL数据库换成Oracle数据库，只需要把第一行代码中的com.mysql.jdbc.Driver换成oracle.jdbc.driver.OracleDriver就可以了。也可以把需要加载的Driver类写到配置文件中，程序启动的时候，从配置文件中加载，切换数据库的时候，只需要修改配置文件就可以了。</p>\n<p>一个数据库切换到另一种数据库都只需要改动很少的代码，或者完全不需要改动代码。源码之下无秘密，要弄清他们如何实现的，先从com.mysql.jdbc.Driver这个类的代码看起。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">package</span> com.mysql.jdbc;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.sql.SQLException;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Driver</span> <span class=\"keyword\">extends</span> <span class=\"title\">NonRegisteringDriver</span> <span class=\"keyword\">implements</span> <span class=\"title\">java</span>.<span class=\"title\">sql</span>.<span class=\"title\">Driver</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      java.sql.DriverManager.registerDriver(<span class=\"keyword\">new</span> Driver());</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (SQLException E) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">&quot;Can&#x27;t register driver!&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * Construct a new driver and register it with DriverManager</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@throws</span> SQLException if a database error occurs.</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Driver</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> SQLException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Required for Class.forName().newInstance()</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>结合com.mysql.jdbc.Driver的代码实现，可以发现，执行Class.forName(“com.mysql.jdbc.Driver”)这条语句的时候，实际做了两件事，1.要求JVM查找并加载指定的Driver类，2.执行该类的静态代码，也就是将MySQL Driver注册到DriverManager类中。</p>\n<p>看下DriverManager类干嘛的。当我们把Driver实现类注册到DriverManager之后，后续所有JDBC接口的调用，都会委派到具体的Driver实现类来执行。而Driver实现类都实现了相同的接口（java.sql.Driver），这也是可以灵活切换Driver的原因。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DriverManager</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> CopyOnWriteArrayList&lt;DriverInfo&gt; registeredDrivers = <span class=\"keyword\">new</span> CopyOnWriteArrayList&lt;DriverInfo&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">  <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">    loadInitialDrivers();</span><br><span class=\"line\">    println(<span class=\"string\">&quot;JDBC DriverManager initialized&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">registerDriver</span><span class=\"params\">(java.sql.Driver driver)</span> <span class=\"keyword\">throws</span> SQLException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (driver != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      registeredDrivers.addIfAbsent(<span class=\"keyword\">new</span> DriverInfo(driver));</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Connection <span class=\"title\">getConnection</span><span class=\"params\">(String url, String user, String password)</span> <span class=\"keyword\">throws</span> SQLException </span>&#123;</span><br><span class=\"line\">    java.util.Properties info = <span class=\"keyword\">new</span> java.util.Properties();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (user != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      info.put(<span class=\"string\">&quot;user&quot;</span>, user);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (password != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      info.put(<span class=\"string\">&quot;password&quot;</span>, password);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (getConnection(url, info, Reflection.getCallerClass()));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>桥接模式的定义是“将抽象和实现解耦，让它们可以独立变化”。实际上JDBC本身就相当于“抽象”。这里所说的抽象，并非是抽象类或者接口，而是跟具体的数据库无关的、被抽象出来的一套“类库”。具体的Driver（比如com.mysql.jdbc.Driver）就相当于实现。这里说的实现，并非接口的实现类，而是跟具体的数据库相关的一套类库。JDBC和Driver独立开发，通过对象间的组合关系，组装在一起。JDBC的所有逻辑操作，最终都委托给Driver来执行。</p>\n<h5 id=\"桥接模式应用举例\"><a href=\"#桥接模式应用举例\" class=\"headerlink\" title=\"桥接模式应用举例\"></a>桥接模式应用举例</h5><p>根据不同的告警规则，触发不同类型的告警。告警支持多种通知渠道，包括：邮件、短信、微信、自动语音电话。通知的紧急程度又多种类型，包括SERVER（严重）、URGENCY（紧急）、NORMAL（普通）、TRIVIAL（无关紧要）。不同的紧急程度对应不同的通知渠道。比如SERVER级别的消息会通过自动语音电话告知相关人员。最简单的代码实现方式如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">NotificationEmergencyLevel</span> </span>&#123;</span><br><span class=\"line\">  SEVERE, URGENCY, NORMAL, TRIVIAL</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Notification</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> List&lt;String&gt; emailAddresses;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> List&lt;String&gt; telephones;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> List&lt;String&gt; wechatIds;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Notification</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setEmailAddress</span><span class=\"params\">(List&lt;String&gt; emailAddress)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.emailAddresses = emailAddress;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setTelephones</span><span class=\"params\">(List&lt;String&gt; telephones)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.telephones = telephones;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setWechatIds</span><span class=\"params\">(List&lt;String&gt; wechatIds)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.wechatIds = wechatIds;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">notify</span><span class=\"params\">(NotificationEmergencyLevel level, String message)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (level.equals(NotificationEmergencyLevel.SEVERE)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//...自动语音电话</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (level.equals(NotificationEmergencyLevel.URGENCY)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//...发微信</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (level.equals(NotificationEmergencyLevel.NORMAL)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//...发邮件</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (level.equals(NotificationEmergencyLevel.TRIVIAL)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//...发邮件</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//在API监控告警的例子中，我们如下方式来使用Notification类：</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ErrorAlertHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">AlertHandler</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ErrorAlertHandler</span><span class=\"params\">(AlertRule rule, Notification notification)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(rule, notification);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">check</span><span class=\"params\">(ApiStatInfo apiStatInfo)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (apiStatInfo.getErrorCount() &gt; rule.getMatchedRule(apiStatInfo.getApi()).getMaxErrorCount()) &#123;</span><br><span class=\"line\">      notification.notify(NotificationEmergencyLevel.SEVERE, <span class=\"string\">&quot;...&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Notification类的代码有一个最明显的问题，就是有很多if-else分支逻辑。但是如果每个分支中的代码逻辑都不复杂，后期也没有无限膨胀的可能，那这样的设计问题不大，没必要非的摒弃if-else分支逻辑。</p>\n<p>不过Notification的代码显然不符合这个条件，因为每个if-else分支中的代码逻辑都比较复杂，发送通知的所有逻辑都扎堆在Notification类中。很多设计模式都是试图将庞大的类拆分成更细小的类，然后再通过各种更合理的结构组装在一起。</p>\n<p>针对Notification的代码，我们将不同渠道的发送逻辑剥离出来，形成独立的消息发送类（MsgSender相关类）。其中Notification类相当于抽象，MsgSender类相当于实现，两者可以独立开发，通过组合关系（也就是桥梁）任意组合在一起。所谓任意组合的意思就是，不同紧急程度的消息和发送渠道之间的对应关系，不是在代码中固定写死的，我们可以动态地去指定（比如通过读取配置来获取对应关系）。</p>\n<p>按照这个思路，对代码进行重构，重构之后的代码如下:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MsgSender</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">send</span><span class=\"params\">(String message)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TelephoneMsgSender</span> <span class=\"keyword\">implements</span> <span class=\"title\">MsgSender</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> List&lt;String&gt; telephones;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">TelephoneMsgSender</span><span class=\"params\">(List&lt;String&gt; telephones)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.telephones = telephones;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">send</span><span class=\"params\">(String message)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EmailMsgSender</span> <span class=\"keyword\">implements</span> <span class=\"title\">MsgSender</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//与TelephoneMsgSender代码结构类似，所以省略...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WechatMsgSender</span> <span class=\"keyword\">implements</span> <span class=\"title\">MsgSender</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//与TelephoneMsgSender代码结构类似，所以省略...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Notification</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> MsgSender msgSender;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Notification</span><span class=\"params\">(MsgSender msgSender)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.msgSender = msgSender;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">notify</span><span class=\"params\">(String message)</span></span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ServerNotification</span> <span class=\"keyword\">extends</span> <span class=\"title\">Notification</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ServerNotification</span><span class=\"params\">(MsgSender msgSender)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">super</span>(msgSender);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">notify</span><span class=\"params\">(String message)</span> </span>&#123;</span><br><span class=\"line\">      msgSender.send(message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UrgencyNotification</span> <span class=\"keyword\">extends</span> <span class=\"title\">Notification</span> </span>&#123; </span><br><span class=\"line\">    <span class=\"comment\">// 与SevereNotification代码结构类似，所以省略...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NormalNotification</span> <span class=\"keyword\">extends</span> <span class=\"title\">Notification</span> </span>&#123; </span><br><span class=\"line\">    <span class=\"comment\">// 与SevereNotification代码结构类似，所以省略...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TrivialNotification</span> <span class=\"keyword\">extends</span> <span class=\"title\">Notification</span> </span>&#123; </span><br><span class=\"line\">    <span class=\"comment\">// 与SevereNotification代码结构类似，所以省略...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在其他资料中，还有另外一种更加简单的理解方式：一个类存在两个（或多个）独立变化的维度，我们通过组合的方式，让这两个（或多个）维度可以独立进行扩展。</p>\n"},{"layout":"post","title":"设计模式之组合模式","description":"设计模式之组合模式","date":"2021-05-31T05:26:10.000Z","_content":"\n组合模式和“组合关系（通过组合来组装两个类）”完全是两码事。组合模式，主要用来处理树形结构数据。这里的“数据”，可以理解为一组对象结合。\n\n正因为其应用场景的特殊性，数据必须能表示成树形结构，这也导致了这种模式在实际的项目开发中并不常用。但是，一旦数据满足树形结构，应用这种模式就能发挥很大的作用，能让代码变得非常简洁。\n\n##### 组合模式的原理与实现\n\nGoF的《设计模式》中，组合模式这样定义的：\n\n> Compose objects into tree structure to represent part-whole hierarchies.Composite lets client treat individual objects and compositions of objects uniformly.\n\n翻译成中文就是：将一组对象组织（Compose）成树形结构，以表示一种“部分-整体”的层次结构。组合让客户端可以统一单个对象和组合对象的处理逻辑。\n\n假设有这样一个需求：设计一个类来表示文件系统中的目录，能方便地实现下面这些功能：\n\n- 动态地添加、删除某个目录下的子目录或文件\n- 统计制定目录下的问题个数\n- 统计制定目录下的文件总大小\n\n给出了骨架代码，核心逻辑未实现。在下面的代码中，文件和目录统一使用FileSystemNode类来表示，并且通过isFile属性来区分。\n\n```java\npublic class FileSystemNode {\n  private String path;\n  private boolean isFile;\n  private List<FileSystemNode> subNodes = new ArrayList<>();\n  \n  public FileSystemNode(String path,boolean isFile) {\n    this.path = path;\n    this.isFile = isFile;\n  }\n  \n  public int countNumOfFiles() {\n    if(isFile) {\n      return 1;\n    }\n    int numOfFiles = 0;\n    for(FileSystemNode fileOrDir : subNodes) {\n      numOfFiles += fileOrDir.countNumOfFiles();\n    }\n    return numOfFiles;\n  }\n  \n  public long countSizeOfFiles() {\n    if(isFile) {\n      File file = new File(path);\n      if(!file.exists()) return 0;\n      return file.length();\n    }\n    long sizeOfFiles = 0;\n    for(FileSystemNode fileOrDir : subNodes) {\n      sizeOfFiles += fileOrDir.countSizeOfFiles();\n    }\n    return sizeOfFiles;\n  }\n  \n  public String getPath() {\n    return path;\n  }\n  \n  public void addSubNode(FileSystemNode fileOrDis) {\n    subNodes.add(fileOrDir);\n  }\n  \n  public void removeSubNode(FileSystemNode fileOrDir) {\n    int size = subNodes.size();\n    int i = 0;\n    for(;i<size;i++) {\n      if(subNodes.get(i).getPath().equalsIgnoreCase(fileOrDir.getPath())) {\n        break;\n      }\n    }\n    if(i < size) {\n      subNodes.remove(i);\n    }\n  }\n}\n```\n\n要实现其中的countNumOfFiles()和countSizeOfFiles()这两个函数，实际上就是树上的递归遍历算法。对于文件，直接返回文件的个数（返回1）或大小。对于目录，遍历目录中每个子目录或者文件，递归计算它们的个数或者大小，然后求和，就是这个目录下的文件个数和文件大小。\n\n单纯从功能实现角度来说，上面的代码没有问题，已经实现了想要的功能。但是如果开发的是一个大型系统，从扩展性（文件或目录可能会对应不同的操作）、业务建模（文件和目录从业务上是两个概念）、代码的可读性（文件和目录区分对待更加符合人们对业务的认知）的角度来说，我们最好对文件和目录进行区分设计，定义为File和Directory两个类。\n\n按照这个思路，对代码进行重构。\n\n```java\npublic abstract class FileSystemNode {\n  protected String path;\n  \n  public FileSystemNode(String path) {\n    this.path = path;\n  }\n  \n  public abstract int countNumOfFiles();\n  public abstract long countSizeOfFiles();\n  \n  public String getPath() {\n    return path;\n  }\n}\n  \npublic class File extends FileSystemNode {\n  public File(String path) {\n    super(path);\n  }\n\n  @Override\n  public int countNumOfFiles() {\n    return 1;\n  }\n\n  @Override\n  public long countSizeOfFiles() {\n    java.io.File file = new java.io.File(path);\n    if(!file.exists()) return 0;\n    return file.length();\n  }\n}\n\npublic class Directory extends FileSystemNode {\n  private List<FileSystemNode> subNodes = new ArrayList<>();\n  \n  public Directory(String path) {\n    super(path);\n  }\n  \n  @Override\n  public int countNumOfFiles() {\n    int numOfFiles = 0;\n    for(FileSystemNode fileOrDir : subNodes) {\n      numOfFiles += fileOrDir.countNumOfFiles();\n    }\n    return numOfFiles;\n  }\n  \n  public void addSubNode(FileSystemNode fileOrDir) {\n    subNodes.add(fileOrDir);\n  }\n  \n  public void removeSubNode(FileSystemNode fileOrDir) {\n    int size = subNodes.size();\n    int i = 0;\n    for(;i < size; ++i) {\n      if(subNodes.get(i).getPath().equalsIgnoreCase(fileOrDir.getPath())) {\n        break;\n      }\n    }\n    if(i < size) {\n      subNodes.remove(i);\n    }\n  }\n}\n```\n\n文件和目录类都设计好了，看下它们表示一个文件系统中的目录树结构。\n\n```java\n\npublic class Demo {\n  public static void main(String[] args) {\n    /**\n     * /\n     * /wz/\n     * /wz/a.txt\n     * /wz/b.txt\n     * /wz/movies/\n     * /wz/movies/c.avi\n     * /xzg/\n     * /xzg/docs/\n     * /xzg/docs/d.txt\n     */\n    Directory fileSystemTree = new Directory(\"/\");\n    Directory node_wz = new Directory(\"/wz/\");\n    Directory node_xzg = new Directory(\"/xzg/\");\n    fileSystemTree.addSubNode(node_wz);\n    fileSystemTree.addSubNode(node_xzg);\n\n    File node_wz_a = new File(\"/wz/a.txt\");\n    File node_wz_b = new File(\"/wz/b.txt\");\n    Directory node_wz_movies = new Directory(\"/wz/movies/\");\n    node_wz.addSubNode(node_wz_a);\n    node_wz.addSubNode(node_wz_b);\n    node_wz.addSubNode(node_wz_movies);\n\n    File node_wz_movies_c = new File(\"/wz/movies/c.avi\");\n    node_wz_movies.addSubNode(node_wz_movies_c);\n\n    Directory node_xzg_docs = new Directory(\"/xzg/docs/\");\n    node_xzg.addSubNode(node_xzg_docs);\n\n    File node_xzg_docs_d = new File(\"/xzg/docs/d.txt\");\n    node_xzg_docs.addSubNode(node_xzg_docs_d);\n\n    System.out.println(\"/ files num:\" + fileSystemTree.countNumOfFiles());\n    System.out.println(\"/wz/ files num:\" + node_wz.countNumOfFiles());\n  }\n}\n```\n\n对照着这个例子，再重新看下组合模式的定义：“将一组对象（文件和目录）组织成树形结构，以表示一种 部分-整体 的层次结构（目录与子目录的嵌套结构）。组合模式让客户端可以统一单个对象（文件）和组合对象（目录）的处理逻辑（递归遍历）。”\n\n实际上，刚才的组合模式的设计思路，与其说是一种设计模式，倒不如说是对业务场景的一种数据结构和算法的抽象。其中，数据可以表示成树这种数据结构，业务需求可以通过在树上的递归遍历算法来实现。\n\n##### 组合模式的应用场景举例\n\n假设在开发一个OA系统（办公自动化系统）。公司的组织结构包含部门和员工两种数据类型。其中，部门有可以包含子部门和员工。在数据库中的表结构如下所示\n\n部门表（Department）\n\n| 部门ID |    隶属上级部门ID    | ...  | ...  | ...  |\n| :----: | :------------------: | :--: | :--: | :--: |\n|   id   | parent_department_id | ...  | ...  | ...  |\n\n员工表（Employee）\n\n| 员工ID | 隶属上级部门ID | ...  | ...  | ...  |\n| :----: | :------------: | :--: | :--: | :--: |\n|   id   | department_id  | ...  | ...  | ...  |\n\n我们希望在内存中构建整个公司的人员架构图（部门、子部门、员工的隶属关系）， 并且提供接口计算出部门的薪资成本（隶属于这个部门的所有员工的薪资和）。\n\n部门包含子部门和员工，这是一种嵌套结构，可以表示成树这种数据结构。计算每个部门的薪资开支这样一个需求，也可以通过在树上的遍历算法来实现。所以，从这个角度来看，这个应用场景可以使用组合模式来设计和实现。\n\n这个例子的代码结构和上面的例子很相似。HumanResource是部门类（Department）和员工类（Employee）抽象出来的父类，为的是能统一薪资的处理逻辑。Demo中的代码负责从数据库中读取数据并在内存中构建组织架构图。\n\n```java\npublic abstract class HumanResource {\n  protected long id;\n  protected double salary;\n  \n  public HumanResource(long id) {\n    this.id = id;\n  }\n  \n  public long getId() {\n    return id;\n  }\n  \n  public abstract double calculateSalary();\n}\n\npublic class Employee extends HumanResource {\n  public Employee(long id,double salary) {\n    super(id);\n    this.salary = salary;\n  }\n  \n  @Override\n  public double calculateSalary() {\n    return salary;\n  }\n  \n  public class Department extends HumanResource {\n    private List<HumanResource> subNodes = new ArrayList<>();\n    \n    public Department(long id) {\n      super(id);\n    }\n    \n    @Override\n    public double calculateSalary() {\n      double totalSalary = 0;\n      for(HumanResource hr: subNodes) {\n        totalSalary += hr.calculateSalary();\n      }\n      this.salary = totalSalary;\n      return totalSalary;\n    }\n    \n    public void addSubNode(HumanResource hr) {\n      subNodes.add(hr);\n    }\n  }\n  \n  //构建组织架构的代码\n  public class Demo {\n    private static final long ORGANIZATION_ROOT_ID = 1001;\n    private DepartmentRepo departmentRepo; //依赖注入\n    private EmployeeRepo employeeRepo; //依赖注入\n    \n    public void buildOrganization() {\n      Department rootDepartment = new Department(ORGANIZATION_ROOT_ID);\n      buildOrganization(rootDepartment);\n    }\n    \n    private void buildOrgnization(Department department) {\n      List<Long> subDepartmentIds = departmentRepo.getSubDepartmentIds(department.getId());    \n    \tfor(Long subDepartmentId : subDepartmentIds) {\n        Department subDepartment = new Department(subDepartmentId);\n        department.addSubNode(subDepartment);\n        buildOrganization(subDepartment);\n      }\n      List<Long> employeeIds = employeeRepo.getDepartmentEmployeeIds(department.getId());\n      for(Long employeeId : employeeIds) {\n        double salary = employeeRepo.getEmployeeSalary(employeeId);\n        department.addSubNode(new Employee(employeeId,salary));\n      }\n    }\n  }\n}\n```\n\n组合模式让客户端可以统一单个对象（员工）和组合对象（部门）的处理逻辑（递归遍历）。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/设计模式之组合模式.md","raw":"---\nlayout:    post\ntitle:     设计模式之组合模式\ncategory:  设计模式之美\ndescription: 设计模式之组合模式\ntags: 设计模式之美\ndate: 2021/05/31 13:26:10\n---\n\n组合模式和“组合关系（通过组合来组装两个类）”完全是两码事。组合模式，主要用来处理树形结构数据。这里的“数据”，可以理解为一组对象结合。\n\n正因为其应用场景的特殊性，数据必须能表示成树形结构，这也导致了这种模式在实际的项目开发中并不常用。但是，一旦数据满足树形结构，应用这种模式就能发挥很大的作用，能让代码变得非常简洁。\n\n##### 组合模式的原理与实现\n\nGoF的《设计模式》中，组合模式这样定义的：\n\n> Compose objects into tree structure to represent part-whole hierarchies.Composite lets client treat individual objects and compositions of objects uniformly.\n\n翻译成中文就是：将一组对象组织（Compose）成树形结构，以表示一种“部分-整体”的层次结构。组合让客户端可以统一单个对象和组合对象的处理逻辑。\n\n假设有这样一个需求：设计一个类来表示文件系统中的目录，能方便地实现下面这些功能：\n\n- 动态地添加、删除某个目录下的子目录或文件\n- 统计制定目录下的问题个数\n- 统计制定目录下的文件总大小\n\n给出了骨架代码，核心逻辑未实现。在下面的代码中，文件和目录统一使用FileSystemNode类来表示，并且通过isFile属性来区分。\n\n```java\npublic class FileSystemNode {\n  private String path;\n  private boolean isFile;\n  private List<FileSystemNode> subNodes = new ArrayList<>();\n  \n  public FileSystemNode(String path,boolean isFile) {\n    this.path = path;\n    this.isFile = isFile;\n  }\n  \n  public int countNumOfFiles() {\n    if(isFile) {\n      return 1;\n    }\n    int numOfFiles = 0;\n    for(FileSystemNode fileOrDir : subNodes) {\n      numOfFiles += fileOrDir.countNumOfFiles();\n    }\n    return numOfFiles;\n  }\n  \n  public long countSizeOfFiles() {\n    if(isFile) {\n      File file = new File(path);\n      if(!file.exists()) return 0;\n      return file.length();\n    }\n    long sizeOfFiles = 0;\n    for(FileSystemNode fileOrDir : subNodes) {\n      sizeOfFiles += fileOrDir.countSizeOfFiles();\n    }\n    return sizeOfFiles;\n  }\n  \n  public String getPath() {\n    return path;\n  }\n  \n  public void addSubNode(FileSystemNode fileOrDis) {\n    subNodes.add(fileOrDir);\n  }\n  \n  public void removeSubNode(FileSystemNode fileOrDir) {\n    int size = subNodes.size();\n    int i = 0;\n    for(;i<size;i++) {\n      if(subNodes.get(i).getPath().equalsIgnoreCase(fileOrDir.getPath())) {\n        break;\n      }\n    }\n    if(i < size) {\n      subNodes.remove(i);\n    }\n  }\n}\n```\n\n要实现其中的countNumOfFiles()和countSizeOfFiles()这两个函数，实际上就是树上的递归遍历算法。对于文件，直接返回文件的个数（返回1）或大小。对于目录，遍历目录中每个子目录或者文件，递归计算它们的个数或者大小，然后求和，就是这个目录下的文件个数和文件大小。\n\n单纯从功能实现角度来说，上面的代码没有问题，已经实现了想要的功能。但是如果开发的是一个大型系统，从扩展性（文件或目录可能会对应不同的操作）、业务建模（文件和目录从业务上是两个概念）、代码的可读性（文件和目录区分对待更加符合人们对业务的认知）的角度来说，我们最好对文件和目录进行区分设计，定义为File和Directory两个类。\n\n按照这个思路，对代码进行重构。\n\n```java\npublic abstract class FileSystemNode {\n  protected String path;\n  \n  public FileSystemNode(String path) {\n    this.path = path;\n  }\n  \n  public abstract int countNumOfFiles();\n  public abstract long countSizeOfFiles();\n  \n  public String getPath() {\n    return path;\n  }\n}\n  \npublic class File extends FileSystemNode {\n  public File(String path) {\n    super(path);\n  }\n\n  @Override\n  public int countNumOfFiles() {\n    return 1;\n  }\n\n  @Override\n  public long countSizeOfFiles() {\n    java.io.File file = new java.io.File(path);\n    if(!file.exists()) return 0;\n    return file.length();\n  }\n}\n\npublic class Directory extends FileSystemNode {\n  private List<FileSystemNode> subNodes = new ArrayList<>();\n  \n  public Directory(String path) {\n    super(path);\n  }\n  \n  @Override\n  public int countNumOfFiles() {\n    int numOfFiles = 0;\n    for(FileSystemNode fileOrDir : subNodes) {\n      numOfFiles += fileOrDir.countNumOfFiles();\n    }\n    return numOfFiles;\n  }\n  \n  public void addSubNode(FileSystemNode fileOrDir) {\n    subNodes.add(fileOrDir);\n  }\n  \n  public void removeSubNode(FileSystemNode fileOrDir) {\n    int size = subNodes.size();\n    int i = 0;\n    for(;i < size; ++i) {\n      if(subNodes.get(i).getPath().equalsIgnoreCase(fileOrDir.getPath())) {\n        break;\n      }\n    }\n    if(i < size) {\n      subNodes.remove(i);\n    }\n  }\n}\n```\n\n文件和目录类都设计好了，看下它们表示一个文件系统中的目录树结构。\n\n```java\n\npublic class Demo {\n  public static void main(String[] args) {\n    /**\n     * /\n     * /wz/\n     * /wz/a.txt\n     * /wz/b.txt\n     * /wz/movies/\n     * /wz/movies/c.avi\n     * /xzg/\n     * /xzg/docs/\n     * /xzg/docs/d.txt\n     */\n    Directory fileSystemTree = new Directory(\"/\");\n    Directory node_wz = new Directory(\"/wz/\");\n    Directory node_xzg = new Directory(\"/xzg/\");\n    fileSystemTree.addSubNode(node_wz);\n    fileSystemTree.addSubNode(node_xzg);\n\n    File node_wz_a = new File(\"/wz/a.txt\");\n    File node_wz_b = new File(\"/wz/b.txt\");\n    Directory node_wz_movies = new Directory(\"/wz/movies/\");\n    node_wz.addSubNode(node_wz_a);\n    node_wz.addSubNode(node_wz_b);\n    node_wz.addSubNode(node_wz_movies);\n\n    File node_wz_movies_c = new File(\"/wz/movies/c.avi\");\n    node_wz_movies.addSubNode(node_wz_movies_c);\n\n    Directory node_xzg_docs = new Directory(\"/xzg/docs/\");\n    node_xzg.addSubNode(node_xzg_docs);\n\n    File node_xzg_docs_d = new File(\"/xzg/docs/d.txt\");\n    node_xzg_docs.addSubNode(node_xzg_docs_d);\n\n    System.out.println(\"/ files num:\" + fileSystemTree.countNumOfFiles());\n    System.out.println(\"/wz/ files num:\" + node_wz.countNumOfFiles());\n  }\n}\n```\n\n对照着这个例子，再重新看下组合模式的定义：“将一组对象（文件和目录）组织成树形结构，以表示一种 部分-整体 的层次结构（目录与子目录的嵌套结构）。组合模式让客户端可以统一单个对象（文件）和组合对象（目录）的处理逻辑（递归遍历）。”\n\n实际上，刚才的组合模式的设计思路，与其说是一种设计模式，倒不如说是对业务场景的一种数据结构和算法的抽象。其中，数据可以表示成树这种数据结构，业务需求可以通过在树上的递归遍历算法来实现。\n\n##### 组合模式的应用场景举例\n\n假设在开发一个OA系统（办公自动化系统）。公司的组织结构包含部门和员工两种数据类型。其中，部门有可以包含子部门和员工。在数据库中的表结构如下所示\n\n部门表（Department）\n\n| 部门ID |    隶属上级部门ID    | ...  | ...  | ...  |\n| :----: | :------------------: | :--: | :--: | :--: |\n|   id   | parent_department_id | ...  | ...  | ...  |\n\n员工表（Employee）\n\n| 员工ID | 隶属上级部门ID | ...  | ...  | ...  |\n| :----: | :------------: | :--: | :--: | :--: |\n|   id   | department_id  | ...  | ...  | ...  |\n\n我们希望在内存中构建整个公司的人员架构图（部门、子部门、员工的隶属关系）， 并且提供接口计算出部门的薪资成本（隶属于这个部门的所有员工的薪资和）。\n\n部门包含子部门和员工，这是一种嵌套结构，可以表示成树这种数据结构。计算每个部门的薪资开支这样一个需求，也可以通过在树上的遍历算法来实现。所以，从这个角度来看，这个应用场景可以使用组合模式来设计和实现。\n\n这个例子的代码结构和上面的例子很相似。HumanResource是部门类（Department）和员工类（Employee）抽象出来的父类，为的是能统一薪资的处理逻辑。Demo中的代码负责从数据库中读取数据并在内存中构建组织架构图。\n\n```java\npublic abstract class HumanResource {\n  protected long id;\n  protected double salary;\n  \n  public HumanResource(long id) {\n    this.id = id;\n  }\n  \n  public long getId() {\n    return id;\n  }\n  \n  public abstract double calculateSalary();\n}\n\npublic class Employee extends HumanResource {\n  public Employee(long id,double salary) {\n    super(id);\n    this.salary = salary;\n  }\n  \n  @Override\n  public double calculateSalary() {\n    return salary;\n  }\n  \n  public class Department extends HumanResource {\n    private List<HumanResource> subNodes = new ArrayList<>();\n    \n    public Department(long id) {\n      super(id);\n    }\n    \n    @Override\n    public double calculateSalary() {\n      double totalSalary = 0;\n      for(HumanResource hr: subNodes) {\n        totalSalary += hr.calculateSalary();\n      }\n      this.salary = totalSalary;\n      return totalSalary;\n    }\n    \n    public void addSubNode(HumanResource hr) {\n      subNodes.add(hr);\n    }\n  }\n  \n  //构建组织架构的代码\n  public class Demo {\n    private static final long ORGANIZATION_ROOT_ID = 1001;\n    private DepartmentRepo departmentRepo; //依赖注入\n    private EmployeeRepo employeeRepo; //依赖注入\n    \n    public void buildOrganization() {\n      Department rootDepartment = new Department(ORGANIZATION_ROOT_ID);\n      buildOrganization(rootDepartment);\n    }\n    \n    private void buildOrgnization(Department department) {\n      List<Long> subDepartmentIds = departmentRepo.getSubDepartmentIds(department.getId());    \n    \tfor(Long subDepartmentId : subDepartmentIds) {\n        Department subDepartment = new Department(subDepartmentId);\n        department.addSubNode(subDepartment);\n        buildOrganization(subDepartment);\n      }\n      List<Long> employeeIds = employeeRepo.getDepartmentEmployeeIds(department.getId());\n      for(Long employeeId : employeeIds) {\n        double salary = employeeRepo.getEmployeeSalary(employeeId);\n        department.addSubNode(new Employee(employeeId,salary));\n      }\n    }\n  }\n}\n```\n\n组合模式让客户端可以统一单个对象（员工）和组合对象（部门）的处理逻辑（递归遍历）。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"设计模式之组合模式","published":1,"updated":"2021-05-31T05:26:10.000Z","comments":1,"photos":[],"link":"","_id":"cm1m304xs002131b4ae7sb952","content":"<p>组合模式和“组合关系（通过组合来组装两个类）”完全是两码事。组合模式，主要用来处理树形结构数据。这里的“数据”，可以理解为一组对象结合。</p>\n<p>正因为其应用场景的特殊性，数据必须能表示成树形结构，这也导致了这种模式在实际的项目开发中并不常用。但是，一旦数据满足树形结构，应用这种模式就能发挥很大的作用，能让代码变得非常简洁。</p>\n<h5 id=\"组合模式的原理与实现\"><a href=\"#组合模式的原理与实现\" class=\"headerlink\" title=\"组合模式的原理与实现\"></a>组合模式的原理与实现</h5><p>GoF的《设计模式》中，组合模式这样定义的：</p>\n<blockquote>\n<p>Compose objects into tree structure to represent part-whole hierarchies.Composite lets client treat individual objects and compositions of objects uniformly.</p>\n</blockquote>\n<p>翻译成中文就是：将一组对象组织（Compose）成树形结构，以表示一种“部分-整体”的层次结构。组合让客户端可以统一单个对象和组合对象的处理逻辑。</p>\n<p>假设有这样一个需求：设计一个类来表示文件系统中的目录，能方便地实现下面这些功能：</p>\n<ul>\n<li>动态地添加、删除某个目录下的子目录或文件</li>\n<li>统计制定目录下的问题个数</li>\n<li>统计制定目录下的文件总大小</li>\n</ul>\n<p>给出了骨架代码，核心逻辑未实现。在下面的代码中，文件和目录统一使用FileSystemNode类来表示，并且通过isFile属性来区分。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FileSystemNode</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> String path;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> isFile;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> List&lt;FileSystemNode&gt; subNodes = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">FileSystemNode</span><span class=\"params\">(String path,<span class=\"keyword\">boolean</span> isFile)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.path = path;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.isFile = isFile;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">countNumOfFiles</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(isFile) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> numOfFiles = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(FileSystemNode fileOrDir : subNodes) &#123;</span><br><span class=\"line\">      numOfFiles += fileOrDir.countNumOfFiles();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> numOfFiles;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">countSizeOfFiles</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(isFile) &#123;</span><br><span class=\"line\">      File file = <span class=\"keyword\">new</span> File(path);</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(!file.exists()) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> file.length();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> sizeOfFiles = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(FileSystemNode fileOrDir : subNodes) &#123;</span><br><span class=\"line\">      sizeOfFiles += fileOrDir.countSizeOfFiles();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sizeOfFiles;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getPath</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> path;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addSubNode</span><span class=\"params\">(FileSystemNode fileOrDis)</span> </span>&#123;</span><br><span class=\"line\">    subNodes.add(fileOrDir);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">removeSubNode</span><span class=\"params\">(FileSystemNode fileOrDir)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> size = subNodes.size();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(;i&lt;size;i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(subNodes.get(i).getPath().equalsIgnoreCase(fileOrDir.getPath())) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(i &lt; size) &#123;</span><br><span class=\"line\">      subNodes.remove(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>要实现其中的countNumOfFiles()和countSizeOfFiles()这两个函数，实际上就是树上的递归遍历算法。对于文件，直接返回文件的个数（返回1）或大小。对于目录，遍历目录中每个子目录或者文件，递归计算它们的个数或者大小，然后求和，就是这个目录下的文件个数和文件大小。</p>\n<p>单纯从功能实现角度来说，上面的代码没有问题，已经实现了想要的功能。但是如果开发的是一个大型系统，从扩展性（文件或目录可能会对应不同的操作）、业务建模（文件和目录从业务上是两个概念）、代码的可读性（文件和目录区分对待更加符合人们对业务的认知）的角度来说，我们最好对文件和目录进行区分设计，定义为File和Directory两个类。</p>\n<p>按照这个思路，对代码进行重构。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FileSystemNode</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">protected</span> String path;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">FileSystemNode</span><span class=\"params\">(String path)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.path = path;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">int</span> <span class=\"title\">countNumOfFiles</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">long</span> <span class=\"title\">countSizeOfFiles</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getPath</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> path;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">File</span> <span class=\"keyword\">extends</span> <span class=\"title\">FileSystemNode</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">File</span><span class=\"params\">(String path)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(path);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">countNumOfFiles</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">countSizeOfFiles</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    java.io.File file = <span class=\"keyword\">new</span> java.io.File(path);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!file.exists()) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> file.length();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Directory</span> <span class=\"keyword\">extends</span> <span class=\"title\">FileSystemNode</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> List&lt;FileSystemNode&gt; subNodes = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Directory</span><span class=\"params\">(String path)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(path);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">countNumOfFiles</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> numOfFiles = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(FileSystemNode fileOrDir : subNodes) &#123;</span><br><span class=\"line\">      numOfFiles += fileOrDir.countNumOfFiles();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> numOfFiles;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addSubNode</span><span class=\"params\">(FileSystemNode fileOrDir)</span> </span>&#123;</span><br><span class=\"line\">    subNodes.add(fileOrDir);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">removeSubNode</span><span class=\"params\">(FileSystemNode fileOrDir)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> size = subNodes.size();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(;i &lt; size; ++i) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(subNodes.get(i).getPath().equalsIgnoreCase(fileOrDir.getPath())) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(i &lt; size) &#123;</span><br><span class=\"line\">      subNodes.remove(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>文件和目录类都设计好了，看下它们表示一个文件系统中的目录树结构。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * /</span></span><br><span class=\"line\"><span class=\"comment\">     * /wz/</span></span><br><span class=\"line\"><span class=\"comment\">     * /wz/a.txt</span></span><br><span class=\"line\"><span class=\"comment\">     * /wz/b.txt</span></span><br><span class=\"line\"><span class=\"comment\">     * /wz/movies/</span></span><br><span class=\"line\"><span class=\"comment\">     * /wz/movies/c.avi</span></span><br><span class=\"line\"><span class=\"comment\">     * /xzg/</span></span><br><span class=\"line\"><span class=\"comment\">     * /xzg/docs/</span></span><br><span class=\"line\"><span class=\"comment\">     * /xzg/docs/d.txt</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    Directory fileSystemTree = <span class=\"keyword\">new</span> Directory(<span class=\"string\">&quot;/&quot;</span>);</span><br><span class=\"line\">    Directory node_wz = <span class=\"keyword\">new</span> Directory(<span class=\"string\">&quot;/wz/&quot;</span>);</span><br><span class=\"line\">    Directory node_xzg = <span class=\"keyword\">new</span> Directory(<span class=\"string\">&quot;/xzg/&quot;</span>);</span><br><span class=\"line\">    fileSystemTree.addSubNode(node_wz);</span><br><span class=\"line\">    fileSystemTree.addSubNode(node_xzg);</span><br><span class=\"line\"></span><br><span class=\"line\">    File node_wz_a = <span class=\"keyword\">new</span> File(<span class=\"string\">&quot;/wz/a.txt&quot;</span>);</span><br><span class=\"line\">    File node_wz_b = <span class=\"keyword\">new</span> File(<span class=\"string\">&quot;/wz/b.txt&quot;</span>);</span><br><span class=\"line\">    Directory node_wz_movies = <span class=\"keyword\">new</span> Directory(<span class=\"string\">&quot;/wz/movies/&quot;</span>);</span><br><span class=\"line\">    node_wz.addSubNode(node_wz_a);</span><br><span class=\"line\">    node_wz.addSubNode(node_wz_b);</span><br><span class=\"line\">    node_wz.addSubNode(node_wz_movies);</span><br><span class=\"line\"></span><br><span class=\"line\">    File node_wz_movies_c = <span class=\"keyword\">new</span> File(<span class=\"string\">&quot;/wz/movies/c.avi&quot;</span>);</span><br><span class=\"line\">    node_wz_movies.addSubNode(node_wz_movies_c);</span><br><span class=\"line\"></span><br><span class=\"line\">    Directory node_xzg_docs = <span class=\"keyword\">new</span> Directory(<span class=\"string\">&quot;/xzg/docs/&quot;</span>);</span><br><span class=\"line\">    node_xzg.addSubNode(node_xzg_docs);</span><br><span class=\"line\"></span><br><span class=\"line\">    File node_xzg_docs_d = <span class=\"keyword\">new</span> File(<span class=\"string\">&quot;/xzg/docs/d.txt&quot;</span>);</span><br><span class=\"line\">    node_xzg_docs.addSubNode(node_xzg_docs_d);</span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;/ files num:&quot;</span> + fileSystemTree.countNumOfFiles());</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;/wz/ files num:&quot;</span> + node_wz.countNumOfFiles());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对照着这个例子，再重新看下组合模式的定义：“将一组对象（文件和目录）组织成树形结构，以表示一种 部分-整体 的层次结构（目录与子目录的嵌套结构）。组合模式让客户端可以统一单个对象（文件）和组合对象（目录）的处理逻辑（递归遍历）。”</p>\n<p>实际上，刚才的组合模式的设计思路，与其说是一种设计模式，倒不如说是对业务场景的一种数据结构和算法的抽象。其中，数据可以表示成树这种数据结构，业务需求可以通过在树上的递归遍历算法来实现。</p>\n<h5 id=\"组合模式的应用场景举例\"><a href=\"#组合模式的应用场景举例\" class=\"headerlink\" title=\"组合模式的应用场景举例\"></a>组合模式的应用场景举例</h5><p>假设在开发一个OA系统（办公自动化系统）。公司的组织结构包含部门和员工两种数据类型。其中，部门有可以包含子部门和员工。在数据库中的表结构如下所示</p>\n<p>部门表（Department）</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">部门ID</th>\n<th align=\"center\">隶属上级部门ID</th>\n<th align=\"center\">…</th>\n<th align=\"center\">…</th>\n<th align=\"center\">…</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">id</td>\n<td align=\"center\">parent_department_id</td>\n<td align=\"center\">…</td>\n<td align=\"center\">…</td>\n<td align=\"center\">…</td>\n</tr>\n</tbody></table>\n<p>员工表（Employee）</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">员工ID</th>\n<th align=\"center\">隶属上级部门ID</th>\n<th align=\"center\">…</th>\n<th align=\"center\">…</th>\n<th align=\"center\">…</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">id</td>\n<td align=\"center\">department_id</td>\n<td align=\"center\">…</td>\n<td align=\"center\">…</td>\n<td align=\"center\">…</td>\n</tr>\n</tbody></table>\n<p>我们希望在内存中构建整个公司的人员架构图（部门、子部门、员工的隶属关系）， 并且提供接口计算出部门的薪资成本（隶属于这个部门的所有员工的薪资和）。</p>\n<p>部门包含子部门和员工，这是一种嵌套结构，可以表示成树这种数据结构。计算每个部门的薪资开支这样一个需求，也可以通过在树上的遍历算法来实现。所以，从这个角度来看，这个应用场景可以使用组合模式来设计和实现。</p>\n<p>这个例子的代码结构和上面的例子很相似。HumanResource是部门类（Department）和员工类（Employee）抽象出来的父类，为的是能统一薪资的处理逻辑。Demo中的代码负责从数据库中读取数据并在内存中构建组织架构图。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HumanResource</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">protected</span> <span class=\"keyword\">long</span> id;</span><br><span class=\"line\">  <span class=\"keyword\">protected</span> <span class=\"keyword\">double</span> salary;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HumanResource</span><span class=\"params\">(<span class=\"keyword\">long</span> id)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.id = id;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">getId</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> id;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">double</span> <span class=\"title\">calculateSalary</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Employee</span> <span class=\"keyword\">extends</span> <span class=\"title\">HumanResource</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Employee</span><span class=\"params\">(<span class=\"keyword\">long</span> id,<span class=\"keyword\">double</span> salary)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(id);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.salary = salary;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">double</span> <span class=\"title\">calculateSalary</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> salary;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Department</span> <span class=\"keyword\">extends</span> <span class=\"title\">HumanResource</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;HumanResource&gt; subNodes = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Department</span><span class=\"params\">(<span class=\"keyword\">long</span> id)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">super</span>(id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">double</span> <span class=\"title\">calculateSalary</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">double</span> totalSalary = <span class=\"number\">0</span>;</span><br><span class=\"line\">      <span class=\"keyword\">for</span>(HumanResource hr: subNodes) &#123;</span><br><span class=\"line\">        totalSalary += hr.calculateSalary();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.salary = totalSalary;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> totalSalary;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addSubNode</span><span class=\"params\">(HumanResource hr)</span> </span>&#123;</span><br><span class=\"line\">      subNodes.add(hr);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">//构建组织架构的代码</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> ORGANIZATION_ROOT_ID = <span class=\"number\">1001</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> DepartmentRepo departmentRepo; <span class=\"comment\">//依赖注入</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> EmployeeRepo employeeRepo; <span class=\"comment\">//依赖注入</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">buildOrganization</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      Department rootDepartment = <span class=\"keyword\">new</span> Department(ORGANIZATION_ROOT_ID);</span><br><span class=\"line\">      buildOrganization(rootDepartment);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">buildOrgnization</span><span class=\"params\">(Department department)</span> </span>&#123;</span><br><span class=\"line\">      List&lt;Long&gt; subDepartmentIds = departmentRepo.getSubDepartmentIds(department.getId());    </span><br><span class=\"line\">    \t<span class=\"keyword\">for</span>(Long subDepartmentId : subDepartmentIds) &#123;</span><br><span class=\"line\">        Department subDepartment = <span class=\"keyword\">new</span> Department(subDepartmentId);</span><br><span class=\"line\">        department.addSubNode(subDepartment);</span><br><span class=\"line\">        buildOrganization(subDepartment);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      List&lt;Long&gt; employeeIds = employeeRepo.getDepartmentEmployeeIds(department.getId());</span><br><span class=\"line\">      <span class=\"keyword\">for</span>(Long employeeId : employeeIds) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">double</span> salary = employeeRepo.getEmployeeSalary(employeeId);</span><br><span class=\"line\">        department.addSubNode(<span class=\"keyword\">new</span> Employee(employeeId,salary));</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>组合模式让客户端可以统一单个对象（员工）和组合对象（部门）的处理逻辑（递归遍历）。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>组合模式和“组合关系（通过组合来组装两个类）”完全是两码事。组合模式，主要用来处理树形结构数据。这里的“数据”，可以理解为一组对象结合。</p>\n<p>正因为其应用场景的特殊性，数据必须能表示成树形结构，这也导致了这种模式在实际的项目开发中并不常用。但是，一旦数据满足树形结构，应用这种模式就能发挥很大的作用，能让代码变得非常简洁。</p>\n<h5 id=\"组合模式的原理与实现\"><a href=\"#组合模式的原理与实现\" class=\"headerlink\" title=\"组合模式的原理与实现\"></a>组合模式的原理与实现</h5><p>GoF的《设计模式》中，组合模式这样定义的：</p>\n<blockquote>\n<p>Compose objects into tree structure to represent part-whole hierarchies.Composite lets client treat individual objects and compositions of objects uniformly.</p>\n</blockquote>\n<p>翻译成中文就是：将一组对象组织（Compose）成树形结构，以表示一种“部分-整体”的层次结构。组合让客户端可以统一单个对象和组合对象的处理逻辑。</p>\n<p>假设有这样一个需求：设计一个类来表示文件系统中的目录，能方便地实现下面这些功能：</p>\n<ul>\n<li>动态地添加、删除某个目录下的子目录或文件</li>\n<li>统计制定目录下的问题个数</li>\n<li>统计制定目录下的文件总大小</li>\n</ul>\n<p>给出了骨架代码，核心逻辑未实现。在下面的代码中，文件和目录统一使用FileSystemNode类来表示，并且通过isFile属性来区分。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FileSystemNode</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> String path;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> isFile;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> List&lt;FileSystemNode&gt; subNodes = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">FileSystemNode</span><span class=\"params\">(String path,<span class=\"keyword\">boolean</span> isFile)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.path = path;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.isFile = isFile;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">countNumOfFiles</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(isFile) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> numOfFiles = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(FileSystemNode fileOrDir : subNodes) &#123;</span><br><span class=\"line\">      numOfFiles += fileOrDir.countNumOfFiles();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> numOfFiles;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">countSizeOfFiles</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(isFile) &#123;</span><br><span class=\"line\">      File file = <span class=\"keyword\">new</span> File(path);</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(!file.exists()) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> file.length();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> sizeOfFiles = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(FileSystemNode fileOrDir : subNodes) &#123;</span><br><span class=\"line\">      sizeOfFiles += fileOrDir.countSizeOfFiles();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sizeOfFiles;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getPath</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> path;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addSubNode</span><span class=\"params\">(FileSystemNode fileOrDis)</span> </span>&#123;</span><br><span class=\"line\">    subNodes.add(fileOrDir);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">removeSubNode</span><span class=\"params\">(FileSystemNode fileOrDir)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> size = subNodes.size();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(;i&lt;size;i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(subNodes.get(i).getPath().equalsIgnoreCase(fileOrDir.getPath())) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(i &lt; size) &#123;</span><br><span class=\"line\">      subNodes.remove(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>要实现其中的countNumOfFiles()和countSizeOfFiles()这两个函数，实际上就是树上的递归遍历算法。对于文件，直接返回文件的个数（返回1）或大小。对于目录，遍历目录中每个子目录或者文件，递归计算它们的个数或者大小，然后求和，就是这个目录下的文件个数和文件大小。</p>\n<p>单纯从功能实现角度来说，上面的代码没有问题，已经实现了想要的功能。但是如果开发的是一个大型系统，从扩展性（文件或目录可能会对应不同的操作）、业务建模（文件和目录从业务上是两个概念）、代码的可读性（文件和目录区分对待更加符合人们对业务的认知）的角度来说，我们最好对文件和目录进行区分设计，定义为File和Directory两个类。</p>\n<p>按照这个思路，对代码进行重构。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FileSystemNode</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">protected</span> String path;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">FileSystemNode</span><span class=\"params\">(String path)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.path = path;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">int</span> <span class=\"title\">countNumOfFiles</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">long</span> <span class=\"title\">countSizeOfFiles</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getPath</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> path;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">File</span> <span class=\"keyword\">extends</span> <span class=\"title\">FileSystemNode</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">File</span><span class=\"params\">(String path)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(path);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">countNumOfFiles</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">countSizeOfFiles</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    java.io.File file = <span class=\"keyword\">new</span> java.io.File(path);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!file.exists()) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> file.length();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Directory</span> <span class=\"keyword\">extends</span> <span class=\"title\">FileSystemNode</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> List&lt;FileSystemNode&gt; subNodes = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Directory</span><span class=\"params\">(String path)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(path);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">countNumOfFiles</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> numOfFiles = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(FileSystemNode fileOrDir : subNodes) &#123;</span><br><span class=\"line\">      numOfFiles += fileOrDir.countNumOfFiles();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> numOfFiles;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addSubNode</span><span class=\"params\">(FileSystemNode fileOrDir)</span> </span>&#123;</span><br><span class=\"line\">    subNodes.add(fileOrDir);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">removeSubNode</span><span class=\"params\">(FileSystemNode fileOrDir)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> size = subNodes.size();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(;i &lt; size; ++i) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(subNodes.get(i).getPath().equalsIgnoreCase(fileOrDir.getPath())) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(i &lt; size) &#123;</span><br><span class=\"line\">      subNodes.remove(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>文件和目录类都设计好了，看下它们表示一个文件系统中的目录树结构。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * /</span></span><br><span class=\"line\"><span class=\"comment\">     * /wz/</span></span><br><span class=\"line\"><span class=\"comment\">     * /wz/a.txt</span></span><br><span class=\"line\"><span class=\"comment\">     * /wz/b.txt</span></span><br><span class=\"line\"><span class=\"comment\">     * /wz/movies/</span></span><br><span class=\"line\"><span class=\"comment\">     * /wz/movies/c.avi</span></span><br><span class=\"line\"><span class=\"comment\">     * /xzg/</span></span><br><span class=\"line\"><span class=\"comment\">     * /xzg/docs/</span></span><br><span class=\"line\"><span class=\"comment\">     * /xzg/docs/d.txt</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    Directory fileSystemTree = <span class=\"keyword\">new</span> Directory(<span class=\"string\">&quot;/&quot;</span>);</span><br><span class=\"line\">    Directory node_wz = <span class=\"keyword\">new</span> Directory(<span class=\"string\">&quot;/wz/&quot;</span>);</span><br><span class=\"line\">    Directory node_xzg = <span class=\"keyword\">new</span> Directory(<span class=\"string\">&quot;/xzg/&quot;</span>);</span><br><span class=\"line\">    fileSystemTree.addSubNode(node_wz);</span><br><span class=\"line\">    fileSystemTree.addSubNode(node_xzg);</span><br><span class=\"line\"></span><br><span class=\"line\">    File node_wz_a = <span class=\"keyword\">new</span> File(<span class=\"string\">&quot;/wz/a.txt&quot;</span>);</span><br><span class=\"line\">    File node_wz_b = <span class=\"keyword\">new</span> File(<span class=\"string\">&quot;/wz/b.txt&quot;</span>);</span><br><span class=\"line\">    Directory node_wz_movies = <span class=\"keyword\">new</span> Directory(<span class=\"string\">&quot;/wz/movies/&quot;</span>);</span><br><span class=\"line\">    node_wz.addSubNode(node_wz_a);</span><br><span class=\"line\">    node_wz.addSubNode(node_wz_b);</span><br><span class=\"line\">    node_wz.addSubNode(node_wz_movies);</span><br><span class=\"line\"></span><br><span class=\"line\">    File node_wz_movies_c = <span class=\"keyword\">new</span> File(<span class=\"string\">&quot;/wz/movies/c.avi&quot;</span>);</span><br><span class=\"line\">    node_wz_movies.addSubNode(node_wz_movies_c);</span><br><span class=\"line\"></span><br><span class=\"line\">    Directory node_xzg_docs = <span class=\"keyword\">new</span> Directory(<span class=\"string\">&quot;/xzg/docs/&quot;</span>);</span><br><span class=\"line\">    node_xzg.addSubNode(node_xzg_docs);</span><br><span class=\"line\"></span><br><span class=\"line\">    File node_xzg_docs_d = <span class=\"keyword\">new</span> File(<span class=\"string\">&quot;/xzg/docs/d.txt&quot;</span>);</span><br><span class=\"line\">    node_xzg_docs.addSubNode(node_xzg_docs_d);</span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;/ files num:&quot;</span> + fileSystemTree.countNumOfFiles());</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;/wz/ files num:&quot;</span> + node_wz.countNumOfFiles());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对照着这个例子，再重新看下组合模式的定义：“将一组对象（文件和目录）组织成树形结构，以表示一种 部分-整体 的层次结构（目录与子目录的嵌套结构）。组合模式让客户端可以统一单个对象（文件）和组合对象（目录）的处理逻辑（递归遍历）。”</p>\n<p>实际上，刚才的组合模式的设计思路，与其说是一种设计模式，倒不如说是对业务场景的一种数据结构和算法的抽象。其中，数据可以表示成树这种数据结构，业务需求可以通过在树上的递归遍历算法来实现。</p>\n<h5 id=\"组合模式的应用场景举例\"><a href=\"#组合模式的应用场景举例\" class=\"headerlink\" title=\"组合模式的应用场景举例\"></a>组合模式的应用场景举例</h5><p>假设在开发一个OA系统（办公自动化系统）。公司的组织结构包含部门和员工两种数据类型。其中，部门有可以包含子部门和员工。在数据库中的表结构如下所示</p>\n<p>部门表（Department）</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">部门ID</th>\n<th align=\"center\">隶属上级部门ID</th>\n<th align=\"center\">…</th>\n<th align=\"center\">…</th>\n<th align=\"center\">…</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">id</td>\n<td align=\"center\">parent_department_id</td>\n<td align=\"center\">…</td>\n<td align=\"center\">…</td>\n<td align=\"center\">…</td>\n</tr>\n</tbody></table>\n<p>员工表（Employee）</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">员工ID</th>\n<th align=\"center\">隶属上级部门ID</th>\n<th align=\"center\">…</th>\n<th align=\"center\">…</th>\n<th align=\"center\">…</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">id</td>\n<td align=\"center\">department_id</td>\n<td align=\"center\">…</td>\n<td align=\"center\">…</td>\n<td align=\"center\">…</td>\n</tr>\n</tbody></table>\n<p>我们希望在内存中构建整个公司的人员架构图（部门、子部门、员工的隶属关系）， 并且提供接口计算出部门的薪资成本（隶属于这个部门的所有员工的薪资和）。</p>\n<p>部门包含子部门和员工，这是一种嵌套结构，可以表示成树这种数据结构。计算每个部门的薪资开支这样一个需求，也可以通过在树上的遍历算法来实现。所以，从这个角度来看，这个应用场景可以使用组合模式来设计和实现。</p>\n<p>这个例子的代码结构和上面的例子很相似。HumanResource是部门类（Department）和员工类（Employee）抽象出来的父类，为的是能统一薪资的处理逻辑。Demo中的代码负责从数据库中读取数据并在内存中构建组织架构图。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HumanResource</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">protected</span> <span class=\"keyword\">long</span> id;</span><br><span class=\"line\">  <span class=\"keyword\">protected</span> <span class=\"keyword\">double</span> salary;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HumanResource</span><span class=\"params\">(<span class=\"keyword\">long</span> id)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.id = id;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">getId</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> id;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">double</span> <span class=\"title\">calculateSalary</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Employee</span> <span class=\"keyword\">extends</span> <span class=\"title\">HumanResource</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Employee</span><span class=\"params\">(<span class=\"keyword\">long</span> id,<span class=\"keyword\">double</span> salary)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(id);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.salary = salary;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">double</span> <span class=\"title\">calculateSalary</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> salary;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Department</span> <span class=\"keyword\">extends</span> <span class=\"title\">HumanResource</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;HumanResource&gt; subNodes = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Department</span><span class=\"params\">(<span class=\"keyword\">long</span> id)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">super</span>(id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">double</span> <span class=\"title\">calculateSalary</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">double</span> totalSalary = <span class=\"number\">0</span>;</span><br><span class=\"line\">      <span class=\"keyword\">for</span>(HumanResource hr: subNodes) &#123;</span><br><span class=\"line\">        totalSalary += hr.calculateSalary();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.salary = totalSalary;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> totalSalary;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addSubNode</span><span class=\"params\">(HumanResource hr)</span> </span>&#123;</span><br><span class=\"line\">      subNodes.add(hr);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">//构建组织架构的代码</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> ORGANIZATION_ROOT_ID = <span class=\"number\">1001</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> DepartmentRepo departmentRepo; <span class=\"comment\">//依赖注入</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> EmployeeRepo employeeRepo; <span class=\"comment\">//依赖注入</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">buildOrganization</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      Department rootDepartment = <span class=\"keyword\">new</span> Department(ORGANIZATION_ROOT_ID);</span><br><span class=\"line\">      buildOrganization(rootDepartment);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">buildOrgnization</span><span class=\"params\">(Department department)</span> </span>&#123;</span><br><span class=\"line\">      List&lt;Long&gt; subDepartmentIds = departmentRepo.getSubDepartmentIds(department.getId());    </span><br><span class=\"line\">    \t<span class=\"keyword\">for</span>(Long subDepartmentId : subDepartmentIds) &#123;</span><br><span class=\"line\">        Department subDepartment = <span class=\"keyword\">new</span> Department(subDepartmentId);</span><br><span class=\"line\">        department.addSubNode(subDepartment);</span><br><span class=\"line\">        buildOrganization(subDepartment);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      List&lt;Long&gt; employeeIds = employeeRepo.getDepartmentEmployeeIds(department.getId());</span><br><span class=\"line\">      <span class=\"keyword\">for</span>(Long employeeId : employeeIds) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">double</span> salary = employeeRepo.getEmployeeSalary(employeeId);</span><br><span class=\"line\">        department.addSubNode(<span class=\"keyword\">new</span> Employee(employeeId,salary));</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>组合模式让客户端可以统一单个对象（员工）和组合对象（部门）的处理逻辑（递归遍历）。</p>\n"},{"layout":"post","title":"设计模式之装饰器模式","description":"设计模式之装饰器模式","date":"2021-05-25T05:26:10.000Z","_content":"\n装饰模式是一种结构性设计模式，允许你通过将对象\n\n通过剖析Java IO类的设计思想，来学习装饰器模式。\n\n IO类库非常庞大和复杂，有几个个类，负责IO数据的读取和写入。如果对Java IO类做分类，可以从下面两个维度将它划分为四类。\n\n|        |    字节流    | 字符流 |\n| :----: | :----------: | :----: |\n| 输入流 | InputStream  | Reader |\n| 输出流 | OutputStream | Writer |\n\n针对不同的读取和写入场景，Java IO在这四个父类基础上扩展出了很多子类。\n\n![img](https://static001.geekbang.org/resource/image/50/13/5082df8e7d5a4d44a34811b9f562d613.jpg)\n\n我们使用IO读取文件数据\n\n```java\nInputStream in = new FileInputStream(\"/user/wangzheng/test.txt\");\nInputStream bin = new BufferedInputStream(in);\nbyte[] data = new byte[128];\nwhile (bin.read(data) != -1) {\n  //...\n}\n```\n\n初步看，java IO的用法比较麻烦，需要先创建一个FileInputStream对象，然后再传递给BufferedinputStream对象来使用。java IO为什么不设计一个继承FileInputStream并且支持缓存的BufferedFileInputStream类呢？这样就可以直接创建一个BufferedFileInputStream类对象，打开文件读取数据，岂不是更简单？\n\n```java\nInputStream bin = new BufferedFileInputStream(\"/user/wangzheng/test.txt\");\nbyte[] data = new byte[128];\nwhile (bin.read(data) != -1) { \n  //...\n}\n```\n\n##### 基于继承的设计方案\n\n如果inputStream只有一个子类FileInputStream的话，那我们在FileInputStream基础之上，再设计一个孙子类BufferedFileInputStream，也算是可以接受的，毕竟继承结构还算简单。但实际上，继承InputStream的子类有很多。我们需要给每一个InputStream的子类，再继续派生支持缓存读取的子类。\n\n除了支持缓存读取之外，如果我们还需要对功能进行其他方面的增强，比如下面的DataInputStream类，支持按照基本数据类型(int、boolean、long等)来读取数据。\n\n```java\nFileInputStream in = new FileInputStream(\"/user/wangzheng/test.txt\");\nDataInputStream din = new DataInputStream(in);\nint data = din.readInt();\n```\n\n这种情况下，如果按照继承方式来实现的话，就需要再继续派生出DataFileInputStream、DataPipedInputStream等类。如果我们还需要既支持缓存、有支持按照基本类型读取数据的类，那就要再继续派生出BufferedDataFileInputStream、BufferedDataPipedInputStream等n多类。这还只是附加了两个增强功能，如果需要附加更多的增强功能，那就会导致组合爆炸，类继承结构变得无比复杂，代码即不好扩展，也不好维护，这也是不推荐使用继承的原因。\n\n##### 基于装饰器模式的设计方案\n\n可以使用组合来替代继承，针对刚刚继承结构过于复杂的问题，可以将继承关系改为组合关系来解决。\n\n```java\npublic abstract class InputStream {\n  //...\n  public int read(byte b[]) throws IOException { \n    return read(b, 0, b.length);\n  }\n  public int read(byte b[], int off, int len) throws IOException { \n    //... \n  } \n  public long skip(long n) throws IOException { \n    //... \n  } \n  public int available() throws IOException { \n    return 0; \n  } \n  public void close() throws IOException {\n    \n  } \n  public synchronized void mark(int readlimit) {\n    \n  } \n  public synchronized void reset() throws IOException {\n    throw new IOException(\"mark/reset not supported\"); \n  } \n  public boolean markSupported() { \n    return false;\n  }\n  \n  public class BufferedInputStream extends InputStream {\n    protected volatile InputStream in;\n    \n    protected BufferedInputStream(InputStream in) {\n      this.in = in;\n    }\n    \n    //...实现基于缓存的数据接口...\n  }\n  \n  public class DataInputStream extends InputStream {\n    protected volatile InputStream in;\n    \n    protected DataInputStream(InputStream in) {\n      this.in = in;\n    }\n    \n    //...实现读取基本类型数据的接口\n  }\n}\n```\n\n看了上面的代码，可能觉得装饰器模式就是简单的“用组合代替继承”，当然不是。从Java IO的设计来看，装饰器模式相对于简单的组合关系，还有两个比较特殊的地方。\n\n**第一个比较特殊的地方是：装饰器类和原始类继承同样的父类，这样我们可以对原始类“嵌套”多个装饰器类**。比如，我们对FileInputStream嵌套了两个装饰器类：BufferedInputStream和DataInputStream，让它既支持缓存读取，又支持按照基本数据类型来读取数据。\n\n```java\nInputStream in = new FileInputStream(\"/user/test.txt\");\nInputStream bin = new BufferedInputStream(in);\nDataInputStream din = new DataInputStream(bin);\nint data = din.readInt();\n```\n\n**第二个比较特殊的地方是：装饰器类是对功能的增强，这也是装饰器模式应用场景的一个重要特点**。实际上符合这种“组合关系”代码结构的设计模式有很多，比如代理模式、桥接模式、还有装饰器模式。尽管他们代码架构很相似，但是没中设计模式的意图是不同的。就拿比较相似的代理模式和装饰器模式来说，代理模式中，代理类附加的是跟原始类无关的功能，而在装饰器模式中，装饰器类附加的是跟原始类相关的增强功能。\n\n实际上，查看JDK源码，BufferedInputStream、DataInputStream并非继承自InputStream，而是另外一个叫FilterInputStream的。重新看一下BufferedInputStream类的代码。InputStream是一个抽象类而非接口，而且它的大部分函数（read()、available()）都有默认实现，按理来说，只需要在BufferedInputStream类中重新实现那些需要增加缓存功能的函数就可以了，其他函数继承InputStream的默认实现。但实际上，这样行不通。\n\n对于即便是不需要增加缓存功能的函数来说，BufferedInputStream还是必须把它重新实现一遍，简单包裹对InputStream对象的函数调用。具体示例如下，如果不重新实现，那BufferedInputStream类就无法将最终读取数据的任务，委托给传递进来的InputStream对象来完成。\n\n```java\npublic class BufferedInputStream extends InputStream {\n  protected volatile InputStream in;\n  \n  protected BufferedInputStream(InputStream in) {\n    this.in = in;\n  }\n  \n  //f()函数不需要增强，只是重新调用一下inputStream in对象的f()\n  public void f() {\n    in.f();\n  }\n}\n```\n\n实际上，DataInputStream也存在跟BufferedInputStream同样的问题。为了避免代码重复，Java IO抽象出了一个装饰器父类FilterInputStream，代码实现如下所示。InputStream的所有的装饰器类（BufferedInputStream、DataInputStream）都继承自这个装饰器父类。这样，装饰器只需要实现它需要增强的方法就可以了，其他方法继承装饰器父类的默认实现。\n\n```java\npublic class FilterInputStream extends InputStream {\n  protected volatile InputStream in;\n  \n  protected FilterInputStream(InputStrean in) {\n    this.in = in;\n  }\n  \n  public int read() throws IOException {\n    return in.read();\n  }\n  \n  public int read(byte[] b) throws IOException {\n    return read(b,0,b.length);\n  }\n  \n  public int read(byte[] b,int off,int len) throws IOException {\n    return in.read(b,off,len);\n  }\n  \n  public int available() throws IOException {\n    return in.available();\n  }\n  \n  public void close() throws IOException {\n    in.close();\n  }\n  \n  public synchronized void mark(int readlimit) {\n    in.mark(readlimit);\n  }\n  \n  public synchronized void reset() throws IOException {\n    in.reset();\n  }\n  \n  public boolean markSupported() {\n    return in.markSupported();\n  }\n}\n```\n\n装饰器模式主要解决继承关系过于复杂的问题，通过组合来替代继承。它主要的作用是给原始类添加增强功能。这也是判断是否该用装饰器模式的一个重要的依据。除此之外，装饰器模式还有一个特点，就是可以对原始类嵌套使用多个装饰器。为了满足这个应用场景，在设计的时候，装饰器类需要跟原始类继承相同的抽象类或者接口。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/设计模式之装饰器模式.md","raw":"---\nlayout:    post\ntitle:     设计模式之装饰器模式\ncategory:  设计模式之美\ndescription: 设计模式之装饰器模式\ntags: 设计模式之美\ndate: 2021/05/25 13:26:10\n---\n\n装饰模式是一种结构性设计模式，允许你通过将对象\n\n通过剖析Java IO类的设计思想，来学习装饰器模式。\n\n IO类库非常庞大和复杂，有几个个类，负责IO数据的读取和写入。如果对Java IO类做分类，可以从下面两个维度将它划分为四类。\n\n|        |    字节流    | 字符流 |\n| :----: | :----------: | :----: |\n| 输入流 | InputStream  | Reader |\n| 输出流 | OutputStream | Writer |\n\n针对不同的读取和写入场景，Java IO在这四个父类基础上扩展出了很多子类。\n\n![img](https://static001.geekbang.org/resource/image/50/13/5082df8e7d5a4d44a34811b9f562d613.jpg)\n\n我们使用IO读取文件数据\n\n```java\nInputStream in = new FileInputStream(\"/user/wangzheng/test.txt\");\nInputStream bin = new BufferedInputStream(in);\nbyte[] data = new byte[128];\nwhile (bin.read(data) != -1) {\n  //...\n}\n```\n\n初步看，java IO的用法比较麻烦，需要先创建一个FileInputStream对象，然后再传递给BufferedinputStream对象来使用。java IO为什么不设计一个继承FileInputStream并且支持缓存的BufferedFileInputStream类呢？这样就可以直接创建一个BufferedFileInputStream类对象，打开文件读取数据，岂不是更简单？\n\n```java\nInputStream bin = new BufferedFileInputStream(\"/user/wangzheng/test.txt\");\nbyte[] data = new byte[128];\nwhile (bin.read(data) != -1) { \n  //...\n}\n```\n\n##### 基于继承的设计方案\n\n如果inputStream只有一个子类FileInputStream的话，那我们在FileInputStream基础之上，再设计一个孙子类BufferedFileInputStream，也算是可以接受的，毕竟继承结构还算简单。但实际上，继承InputStream的子类有很多。我们需要给每一个InputStream的子类，再继续派生支持缓存读取的子类。\n\n除了支持缓存读取之外，如果我们还需要对功能进行其他方面的增强，比如下面的DataInputStream类，支持按照基本数据类型(int、boolean、long等)来读取数据。\n\n```java\nFileInputStream in = new FileInputStream(\"/user/wangzheng/test.txt\");\nDataInputStream din = new DataInputStream(in);\nint data = din.readInt();\n```\n\n这种情况下，如果按照继承方式来实现的话，就需要再继续派生出DataFileInputStream、DataPipedInputStream等类。如果我们还需要既支持缓存、有支持按照基本类型读取数据的类，那就要再继续派生出BufferedDataFileInputStream、BufferedDataPipedInputStream等n多类。这还只是附加了两个增强功能，如果需要附加更多的增强功能，那就会导致组合爆炸，类继承结构变得无比复杂，代码即不好扩展，也不好维护，这也是不推荐使用继承的原因。\n\n##### 基于装饰器模式的设计方案\n\n可以使用组合来替代继承，针对刚刚继承结构过于复杂的问题，可以将继承关系改为组合关系来解决。\n\n```java\npublic abstract class InputStream {\n  //...\n  public int read(byte b[]) throws IOException { \n    return read(b, 0, b.length);\n  }\n  public int read(byte b[], int off, int len) throws IOException { \n    //... \n  } \n  public long skip(long n) throws IOException { \n    //... \n  } \n  public int available() throws IOException { \n    return 0; \n  } \n  public void close() throws IOException {\n    \n  } \n  public synchronized void mark(int readlimit) {\n    \n  } \n  public synchronized void reset() throws IOException {\n    throw new IOException(\"mark/reset not supported\"); \n  } \n  public boolean markSupported() { \n    return false;\n  }\n  \n  public class BufferedInputStream extends InputStream {\n    protected volatile InputStream in;\n    \n    protected BufferedInputStream(InputStream in) {\n      this.in = in;\n    }\n    \n    //...实现基于缓存的数据接口...\n  }\n  \n  public class DataInputStream extends InputStream {\n    protected volatile InputStream in;\n    \n    protected DataInputStream(InputStream in) {\n      this.in = in;\n    }\n    \n    //...实现读取基本类型数据的接口\n  }\n}\n```\n\n看了上面的代码，可能觉得装饰器模式就是简单的“用组合代替继承”，当然不是。从Java IO的设计来看，装饰器模式相对于简单的组合关系，还有两个比较特殊的地方。\n\n**第一个比较特殊的地方是：装饰器类和原始类继承同样的父类，这样我们可以对原始类“嵌套”多个装饰器类**。比如，我们对FileInputStream嵌套了两个装饰器类：BufferedInputStream和DataInputStream，让它既支持缓存读取，又支持按照基本数据类型来读取数据。\n\n```java\nInputStream in = new FileInputStream(\"/user/test.txt\");\nInputStream bin = new BufferedInputStream(in);\nDataInputStream din = new DataInputStream(bin);\nint data = din.readInt();\n```\n\n**第二个比较特殊的地方是：装饰器类是对功能的增强，这也是装饰器模式应用场景的一个重要特点**。实际上符合这种“组合关系”代码结构的设计模式有很多，比如代理模式、桥接模式、还有装饰器模式。尽管他们代码架构很相似，但是没中设计模式的意图是不同的。就拿比较相似的代理模式和装饰器模式来说，代理模式中，代理类附加的是跟原始类无关的功能，而在装饰器模式中，装饰器类附加的是跟原始类相关的增强功能。\n\n实际上，查看JDK源码，BufferedInputStream、DataInputStream并非继承自InputStream，而是另外一个叫FilterInputStream的。重新看一下BufferedInputStream类的代码。InputStream是一个抽象类而非接口，而且它的大部分函数（read()、available()）都有默认实现，按理来说，只需要在BufferedInputStream类中重新实现那些需要增加缓存功能的函数就可以了，其他函数继承InputStream的默认实现。但实际上，这样行不通。\n\n对于即便是不需要增加缓存功能的函数来说，BufferedInputStream还是必须把它重新实现一遍，简单包裹对InputStream对象的函数调用。具体示例如下，如果不重新实现，那BufferedInputStream类就无法将最终读取数据的任务，委托给传递进来的InputStream对象来完成。\n\n```java\npublic class BufferedInputStream extends InputStream {\n  protected volatile InputStream in;\n  \n  protected BufferedInputStream(InputStream in) {\n    this.in = in;\n  }\n  \n  //f()函数不需要增强，只是重新调用一下inputStream in对象的f()\n  public void f() {\n    in.f();\n  }\n}\n```\n\n实际上，DataInputStream也存在跟BufferedInputStream同样的问题。为了避免代码重复，Java IO抽象出了一个装饰器父类FilterInputStream，代码实现如下所示。InputStream的所有的装饰器类（BufferedInputStream、DataInputStream）都继承自这个装饰器父类。这样，装饰器只需要实现它需要增强的方法就可以了，其他方法继承装饰器父类的默认实现。\n\n```java\npublic class FilterInputStream extends InputStream {\n  protected volatile InputStream in;\n  \n  protected FilterInputStream(InputStrean in) {\n    this.in = in;\n  }\n  \n  public int read() throws IOException {\n    return in.read();\n  }\n  \n  public int read(byte[] b) throws IOException {\n    return read(b,0,b.length);\n  }\n  \n  public int read(byte[] b,int off,int len) throws IOException {\n    return in.read(b,off,len);\n  }\n  \n  public int available() throws IOException {\n    return in.available();\n  }\n  \n  public void close() throws IOException {\n    in.close();\n  }\n  \n  public synchronized void mark(int readlimit) {\n    in.mark(readlimit);\n  }\n  \n  public synchronized void reset() throws IOException {\n    in.reset();\n  }\n  \n  public boolean markSupported() {\n    return in.markSupported();\n  }\n}\n```\n\n装饰器模式主要解决继承关系过于复杂的问题，通过组合来替代继承。它主要的作用是给原始类添加增强功能。这也是判断是否该用装饰器模式的一个重要的依据。除此之外，装饰器模式还有一个特点，就是可以对原始类嵌套使用多个装饰器。为了满足这个应用场景，在设计的时候，装饰器类需要跟原始类继承相同的抽象类或者接口。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"设计模式之装饰器模式","published":1,"updated":"2021-05-25T05:26:10.000Z","comments":1,"photos":[],"link":"","_id":"cm1m304xt002331b4h7za026y","content":"<p>装饰模式是一种结构性设计模式，允许你通过将对象</p>\n<p>通过剖析Java IO类的设计思想，来学习装饰器模式。</p>\n<p> IO类库非常庞大和复杂，有几个个类，负责IO数据的读取和写入。如果对Java IO类做分类，可以从下面两个维度将它划分为四类。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\"></th>\n<th align=\"center\">字节流</th>\n<th align=\"center\">字符流</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">输入流</td>\n<td align=\"center\">InputStream</td>\n<td align=\"center\">Reader</td>\n</tr>\n<tr>\n<td align=\"center\">输出流</td>\n<td align=\"center\">OutputStream</td>\n<td align=\"center\">Writer</td>\n</tr>\n</tbody></table>\n<p>针对不同的读取和写入场景，Java IO在这四个父类基础上扩展出了很多子类。</p>\n<p><img src=\"https://static001.geekbang.org/resource/image/50/13/5082df8e7d5a4d44a34811b9f562d613.jpg\" alt=\"img\"></p>\n<p>我们使用IO读取文件数据</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">InputStream in = <span class=\"keyword\">new</span> FileInputStream(<span class=\"string\">&quot;/user/wangzheng/test.txt&quot;</span>);</span><br><span class=\"line\">InputStream bin = <span class=\"keyword\">new</span> BufferedInputStream(in);</span><br><span class=\"line\"><span class=\"keyword\">byte</span>[] data = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">128</span>];</span><br><span class=\"line\"><span class=\"keyword\">while</span> (bin.read(data) != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>初步看，java IO的用法比较麻烦，需要先创建一个FileInputStream对象，然后再传递给BufferedinputStream对象来使用。java IO为什么不设计一个继承FileInputStream并且支持缓存的BufferedFileInputStream类呢？这样就可以直接创建一个BufferedFileInputStream类对象，打开文件读取数据，岂不是更简单？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">InputStream bin = <span class=\"keyword\">new</span> BufferedFileInputStream(<span class=\"string\">&quot;/user/wangzheng/test.txt&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">byte</span>[] data = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">128</span>];</span><br><span class=\"line\"><span class=\"keyword\">while</span> (bin.read(data) != -<span class=\"number\">1</span>) &#123; </span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"基于继承的设计方案\"><a href=\"#基于继承的设计方案\" class=\"headerlink\" title=\"基于继承的设计方案\"></a>基于继承的设计方案</h5><p>如果inputStream只有一个子类FileInputStream的话，那我们在FileInputStream基础之上，再设计一个孙子类BufferedFileInputStream，也算是可以接受的，毕竟继承结构还算简单。但实际上，继承InputStream的子类有很多。我们需要给每一个InputStream的子类，再继续派生支持缓存读取的子类。</p>\n<p>除了支持缓存读取之外，如果我们还需要对功能进行其他方面的增强，比如下面的DataInputStream类，支持按照基本数据类型(int、boolean、long等)来读取数据。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FileInputStream in = <span class=\"keyword\">new</span> FileInputStream(<span class=\"string\">&quot;/user/wangzheng/test.txt&quot;</span>);</span><br><span class=\"line\">DataInputStream din = <span class=\"keyword\">new</span> DataInputStream(in);</span><br><span class=\"line\"><span class=\"keyword\">int</span> data = din.readInt();</span><br></pre></td></tr></table></figure>\n\n<p>这种情况下，如果按照继承方式来实现的话，就需要再继续派生出DataFileInputStream、DataPipedInputStream等类。如果我们还需要既支持缓存、有支持按照基本类型读取数据的类，那就要再继续派生出BufferedDataFileInputStream、BufferedDataPipedInputStream等n多类。这还只是附加了两个增强功能，如果需要附加更多的增强功能，那就会导致组合爆炸，类继承结构变得无比复杂，代码即不好扩展，也不好维护，这也是不推荐使用继承的原因。</p>\n<h5 id=\"基于装饰器模式的设计方案\"><a href=\"#基于装饰器模式的设计方案\" class=\"headerlink\" title=\"基于装饰器模式的设计方案\"></a>基于装饰器模式的设计方案</h5><p>可以使用组合来替代继承，针对刚刚继承结构过于复杂的问题，可以将继承关系改为组合关系来解决。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InputStream</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">read</span><span class=\"params\">(<span class=\"keyword\">byte</span> b[])</span> <span class=\"keyword\">throws</span> IOException </span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> read(b, <span class=\"number\">0</span>, b.length);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">read</span><span class=\"params\">(<span class=\"keyword\">byte</span> b[], <span class=\"keyword\">int</span> off, <span class=\"keyword\">int</span> len)</span> <span class=\"keyword\">throws</span> IOException </span>&#123; </span><br><span class=\"line\">    <span class=\"comment\">//... </span></span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">skip</span><span class=\"params\">(<span class=\"keyword\">long</span> n)</span> <span class=\"keyword\">throws</span> IOException </span>&#123; </span><br><span class=\"line\">    <span class=\"comment\">//... </span></span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">available</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>; </span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">close</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">mark</span><span class=\"params\">(<span class=\"keyword\">int</span> readlimit)</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">reset</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IOException(<span class=\"string\">&quot;mark/reset not supported&quot;</span>); </span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">markSupported</span><span class=\"params\">()</span> </span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BufferedInputStream</span> <span class=\"keyword\">extends</span> <span class=\"title\">InputStream</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">volatile</span> InputStream in;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"title\">BufferedInputStream</span><span class=\"params\">(InputStream in)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.in = in;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//...实现基于缓存的数据接口...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DataInputStream</span> <span class=\"keyword\">extends</span> <span class=\"title\">InputStream</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">volatile</span> InputStream in;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"title\">DataInputStream</span><span class=\"params\">(InputStream in)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.in = in;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//...实现读取基本类型数据的接口</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>看了上面的代码，可能觉得装饰器模式就是简单的“用组合代替继承”，当然不是。从Java IO的设计来看，装饰器模式相对于简单的组合关系，还有两个比较特殊的地方。</p>\n<p><strong>第一个比较特殊的地方是：装饰器类和原始类继承同样的父类，这样我们可以对原始类“嵌套”多个装饰器类</strong>。比如，我们对FileInputStream嵌套了两个装饰器类：BufferedInputStream和DataInputStream，让它既支持缓存读取，又支持按照基本数据类型来读取数据。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">InputStream in = <span class=\"keyword\">new</span> FileInputStream(<span class=\"string\">&quot;/user/test.txt&quot;</span>);</span><br><span class=\"line\">InputStream bin = <span class=\"keyword\">new</span> BufferedInputStream(in);</span><br><span class=\"line\">DataInputStream din = <span class=\"keyword\">new</span> DataInputStream(bin);</span><br><span class=\"line\"><span class=\"keyword\">int</span> data = din.readInt();</span><br></pre></td></tr></table></figure>\n\n<p><strong>第二个比较特殊的地方是：装饰器类是对功能的增强，这也是装饰器模式应用场景的一个重要特点</strong>。实际上符合这种“组合关系”代码结构的设计模式有很多，比如代理模式、桥接模式、还有装饰器模式。尽管他们代码架构很相似，但是没中设计模式的意图是不同的。就拿比较相似的代理模式和装饰器模式来说，代理模式中，代理类附加的是跟原始类无关的功能，而在装饰器模式中，装饰器类附加的是跟原始类相关的增强功能。</p>\n<p>实际上，查看JDK源码，BufferedInputStream、DataInputStream并非继承自InputStream，而是另外一个叫FilterInputStream的。重新看一下BufferedInputStream类的代码。InputStream是一个抽象类而非接口，而且它的大部分函数（read()、available()）都有默认实现，按理来说，只需要在BufferedInputStream类中重新实现那些需要增加缓存功能的函数就可以了，其他函数继承InputStream的默认实现。但实际上，这样行不通。</p>\n<p>对于即便是不需要增加缓存功能的函数来说，BufferedInputStream还是必须把它重新实现一遍，简单包裹对InputStream对象的函数调用。具体示例如下，如果不重新实现，那BufferedInputStream类就无法将最终读取数据的任务，委托给传递进来的InputStream对象来完成。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BufferedInputStream</span> <span class=\"keyword\">extends</span> <span class=\"title\">InputStream</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">protected</span> <span class=\"keyword\">volatile</span> InputStream in;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"title\">BufferedInputStream</span><span class=\"params\">(InputStream in)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.in = in;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">//f()函数不需要增强，只是重新调用一下inputStream in对象的f()</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    in.f();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实际上，DataInputStream也存在跟BufferedInputStream同样的问题。为了避免代码重复，Java IO抽象出了一个装饰器父类FilterInputStream，代码实现如下所示。InputStream的所有的装饰器类（BufferedInputStream、DataInputStream）都继承自这个装饰器父类。这样，装饰器只需要实现它需要增强的方法就可以了，其他方法继承装饰器父类的默认实现。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FilterInputStream</span> <span class=\"keyword\">extends</span> <span class=\"title\">InputStream</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">protected</span> <span class=\"keyword\">volatile</span> InputStream in;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"title\">FilterInputStream</span><span class=\"params\">(InputStrean in)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.in = in;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">read</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> in.read();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">read</span><span class=\"params\">(<span class=\"keyword\">byte</span>[] b)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> read(b,<span class=\"number\">0</span>,b.length);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">read</span><span class=\"params\">(<span class=\"keyword\">byte</span>[] b,<span class=\"keyword\">int</span> off,<span class=\"keyword\">int</span> len)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> in.read(b,off,len);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">available</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> in.available();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">close</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    in.close();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">mark</span><span class=\"params\">(<span class=\"keyword\">int</span> readlimit)</span> </span>&#123;</span><br><span class=\"line\">    in.mark(readlimit);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">reset</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    in.reset();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">markSupported</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> in.markSupported();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>装饰器模式主要解决继承关系过于复杂的问题，通过组合来替代继承。它主要的作用是给原始类添加增强功能。这也是判断是否该用装饰器模式的一个重要的依据。除此之外，装饰器模式还有一个特点，就是可以对原始类嵌套使用多个装饰器。为了满足这个应用场景，在设计的时候，装饰器类需要跟原始类继承相同的抽象类或者接口。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>装饰模式是一种结构性设计模式，允许你通过将对象</p>\n<p>通过剖析Java IO类的设计思想，来学习装饰器模式。</p>\n<p> IO类库非常庞大和复杂，有几个个类，负责IO数据的读取和写入。如果对Java IO类做分类，可以从下面两个维度将它划分为四类。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\"></th>\n<th align=\"center\">字节流</th>\n<th align=\"center\">字符流</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">输入流</td>\n<td align=\"center\">InputStream</td>\n<td align=\"center\">Reader</td>\n</tr>\n<tr>\n<td align=\"center\">输出流</td>\n<td align=\"center\">OutputStream</td>\n<td align=\"center\">Writer</td>\n</tr>\n</tbody></table>\n<p>针对不同的读取和写入场景，Java IO在这四个父类基础上扩展出了很多子类。</p>\n<p><img src=\"https://static001.geekbang.org/resource/image/50/13/5082df8e7d5a4d44a34811b9f562d613.jpg\" alt=\"img\"></p>\n<p>我们使用IO读取文件数据</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">InputStream in = <span class=\"keyword\">new</span> FileInputStream(<span class=\"string\">&quot;/user/wangzheng/test.txt&quot;</span>);</span><br><span class=\"line\">InputStream bin = <span class=\"keyword\">new</span> BufferedInputStream(in);</span><br><span class=\"line\"><span class=\"keyword\">byte</span>[] data = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">128</span>];</span><br><span class=\"line\"><span class=\"keyword\">while</span> (bin.read(data) != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>初步看，java IO的用法比较麻烦，需要先创建一个FileInputStream对象，然后再传递给BufferedinputStream对象来使用。java IO为什么不设计一个继承FileInputStream并且支持缓存的BufferedFileInputStream类呢？这样就可以直接创建一个BufferedFileInputStream类对象，打开文件读取数据，岂不是更简单？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">InputStream bin = <span class=\"keyword\">new</span> BufferedFileInputStream(<span class=\"string\">&quot;/user/wangzheng/test.txt&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">byte</span>[] data = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">128</span>];</span><br><span class=\"line\"><span class=\"keyword\">while</span> (bin.read(data) != -<span class=\"number\">1</span>) &#123; </span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"基于继承的设计方案\"><a href=\"#基于继承的设计方案\" class=\"headerlink\" title=\"基于继承的设计方案\"></a>基于继承的设计方案</h5><p>如果inputStream只有一个子类FileInputStream的话，那我们在FileInputStream基础之上，再设计一个孙子类BufferedFileInputStream，也算是可以接受的，毕竟继承结构还算简单。但实际上，继承InputStream的子类有很多。我们需要给每一个InputStream的子类，再继续派生支持缓存读取的子类。</p>\n<p>除了支持缓存读取之外，如果我们还需要对功能进行其他方面的增强，比如下面的DataInputStream类，支持按照基本数据类型(int、boolean、long等)来读取数据。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FileInputStream in = <span class=\"keyword\">new</span> FileInputStream(<span class=\"string\">&quot;/user/wangzheng/test.txt&quot;</span>);</span><br><span class=\"line\">DataInputStream din = <span class=\"keyword\">new</span> DataInputStream(in);</span><br><span class=\"line\"><span class=\"keyword\">int</span> data = din.readInt();</span><br></pre></td></tr></table></figure>\n\n<p>这种情况下，如果按照继承方式来实现的话，就需要再继续派生出DataFileInputStream、DataPipedInputStream等类。如果我们还需要既支持缓存、有支持按照基本类型读取数据的类，那就要再继续派生出BufferedDataFileInputStream、BufferedDataPipedInputStream等n多类。这还只是附加了两个增强功能，如果需要附加更多的增强功能，那就会导致组合爆炸，类继承结构变得无比复杂，代码即不好扩展，也不好维护，这也是不推荐使用继承的原因。</p>\n<h5 id=\"基于装饰器模式的设计方案\"><a href=\"#基于装饰器模式的设计方案\" class=\"headerlink\" title=\"基于装饰器模式的设计方案\"></a>基于装饰器模式的设计方案</h5><p>可以使用组合来替代继承，针对刚刚继承结构过于复杂的问题，可以将继承关系改为组合关系来解决。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InputStream</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">read</span><span class=\"params\">(<span class=\"keyword\">byte</span> b[])</span> <span class=\"keyword\">throws</span> IOException </span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> read(b, <span class=\"number\">0</span>, b.length);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">read</span><span class=\"params\">(<span class=\"keyword\">byte</span> b[], <span class=\"keyword\">int</span> off, <span class=\"keyword\">int</span> len)</span> <span class=\"keyword\">throws</span> IOException </span>&#123; </span><br><span class=\"line\">    <span class=\"comment\">//... </span></span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">skip</span><span class=\"params\">(<span class=\"keyword\">long</span> n)</span> <span class=\"keyword\">throws</span> IOException </span>&#123; </span><br><span class=\"line\">    <span class=\"comment\">//... </span></span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">available</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>; </span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">close</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">mark</span><span class=\"params\">(<span class=\"keyword\">int</span> readlimit)</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">reset</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IOException(<span class=\"string\">&quot;mark/reset not supported&quot;</span>); </span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">markSupported</span><span class=\"params\">()</span> </span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BufferedInputStream</span> <span class=\"keyword\">extends</span> <span class=\"title\">InputStream</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">volatile</span> InputStream in;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"title\">BufferedInputStream</span><span class=\"params\">(InputStream in)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.in = in;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//...实现基于缓存的数据接口...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DataInputStream</span> <span class=\"keyword\">extends</span> <span class=\"title\">InputStream</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">volatile</span> InputStream in;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"title\">DataInputStream</span><span class=\"params\">(InputStream in)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.in = in;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//...实现读取基本类型数据的接口</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>看了上面的代码，可能觉得装饰器模式就是简单的“用组合代替继承”，当然不是。从Java IO的设计来看，装饰器模式相对于简单的组合关系，还有两个比较特殊的地方。</p>\n<p><strong>第一个比较特殊的地方是：装饰器类和原始类继承同样的父类，这样我们可以对原始类“嵌套”多个装饰器类</strong>。比如，我们对FileInputStream嵌套了两个装饰器类：BufferedInputStream和DataInputStream，让它既支持缓存读取，又支持按照基本数据类型来读取数据。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">InputStream in = <span class=\"keyword\">new</span> FileInputStream(<span class=\"string\">&quot;/user/test.txt&quot;</span>);</span><br><span class=\"line\">InputStream bin = <span class=\"keyword\">new</span> BufferedInputStream(in);</span><br><span class=\"line\">DataInputStream din = <span class=\"keyword\">new</span> DataInputStream(bin);</span><br><span class=\"line\"><span class=\"keyword\">int</span> data = din.readInt();</span><br></pre></td></tr></table></figure>\n\n<p><strong>第二个比较特殊的地方是：装饰器类是对功能的增强，这也是装饰器模式应用场景的一个重要特点</strong>。实际上符合这种“组合关系”代码结构的设计模式有很多，比如代理模式、桥接模式、还有装饰器模式。尽管他们代码架构很相似，但是没中设计模式的意图是不同的。就拿比较相似的代理模式和装饰器模式来说，代理模式中，代理类附加的是跟原始类无关的功能，而在装饰器模式中，装饰器类附加的是跟原始类相关的增强功能。</p>\n<p>实际上，查看JDK源码，BufferedInputStream、DataInputStream并非继承自InputStream，而是另外一个叫FilterInputStream的。重新看一下BufferedInputStream类的代码。InputStream是一个抽象类而非接口，而且它的大部分函数（read()、available()）都有默认实现，按理来说，只需要在BufferedInputStream类中重新实现那些需要增加缓存功能的函数就可以了，其他函数继承InputStream的默认实现。但实际上，这样行不通。</p>\n<p>对于即便是不需要增加缓存功能的函数来说，BufferedInputStream还是必须把它重新实现一遍，简单包裹对InputStream对象的函数调用。具体示例如下，如果不重新实现，那BufferedInputStream类就无法将最终读取数据的任务，委托给传递进来的InputStream对象来完成。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BufferedInputStream</span> <span class=\"keyword\">extends</span> <span class=\"title\">InputStream</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">protected</span> <span class=\"keyword\">volatile</span> InputStream in;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"title\">BufferedInputStream</span><span class=\"params\">(InputStream in)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.in = in;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">//f()函数不需要增强，只是重新调用一下inputStream in对象的f()</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    in.f();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实际上，DataInputStream也存在跟BufferedInputStream同样的问题。为了避免代码重复，Java IO抽象出了一个装饰器父类FilterInputStream，代码实现如下所示。InputStream的所有的装饰器类（BufferedInputStream、DataInputStream）都继承自这个装饰器父类。这样，装饰器只需要实现它需要增强的方法就可以了，其他方法继承装饰器父类的默认实现。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FilterInputStream</span> <span class=\"keyword\">extends</span> <span class=\"title\">InputStream</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">protected</span> <span class=\"keyword\">volatile</span> InputStream in;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"title\">FilterInputStream</span><span class=\"params\">(InputStrean in)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.in = in;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">read</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> in.read();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">read</span><span class=\"params\">(<span class=\"keyword\">byte</span>[] b)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> read(b,<span class=\"number\">0</span>,b.length);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">read</span><span class=\"params\">(<span class=\"keyword\">byte</span>[] b,<span class=\"keyword\">int</span> off,<span class=\"keyword\">int</span> len)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> in.read(b,off,len);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">available</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> in.available();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">close</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    in.close();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">mark</span><span class=\"params\">(<span class=\"keyword\">int</span> readlimit)</span> </span>&#123;</span><br><span class=\"line\">    in.mark(readlimit);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">reset</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    in.reset();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">markSupported</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> in.markSupported();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>装饰器模式主要解决继承关系过于复杂的问题，通过组合来替代继承。它主要的作用是给原始类添加增强功能。这也是判断是否该用装饰器模式的一个重要的依据。除此之外，装饰器模式还有一个特点，就是可以对原始类嵌套使用多个装饰器。为了满足这个应用场景，在设计的时候，装饰器类需要跟原始类继承相同的抽象类或者接口。</p>\n"},{"layout":"post","title":"设计模式之状态模式","description":"设计模式之状态模式","date":"2021-06-07T05:26:10.000Z","_content":"\n状态模式一般用来实现状态机，而状态机常用在游戏、工作流引擎等系统开发中。不过，状态机的实现方式有多种，除了状态模式，比较常用的还有分支逻辑法和查表法。\n\n有限状态机\n\n英文翻译是Finite State Machine，缩写为FSM，简称为状态机。状态机有3个组成部分：状态（State）、事件（Event）、动作（Action）。其中，事件也称为转移条件（Transition Condition）。事件触发状态的转移以及动作的执行。不过动作不是必须的，也可能只转移状态，不执行任何动作。\n\n“超级马里奥”游戏就是一个典型的例子，在游戏中，马里奥可以变身多种形态，比如小马里奥（Small Mario）、超级马里奥（Super Mario）、火焰马里奥（Fire Mario）、斗篷马里奥（Cape Mario）等。在不同的游戏情节下，各个形态会互相转化，并相应的增减积分。比如初始小马里奥，吃了蘑菇之后会变成超级马里奥，并且增加100积分。\n\n马里奥的形态转变就是一个状态机。马里奥的不同形态就是状态机中的“状态”，游戏情节（比如吃蘑菇）就是状态机中的“事件”，加减积分就是状态机中的“动作”。比如，吃蘑菇这个事件会触发状态的转移：从小马里奥转移到超级马里奥，以及触发动作的执行（增加100积分）。\n\n<img src=\"https://static001.geekbang.org/resource/image/5a/6c/5aa0310b9b3ea08794cfc2f376c8f96c.jpg\" alt=\"img\" style=\"zoom:50%;\" />\n\n如何变成来实现上面的状态机呢？\n\n```java\npublic enum State {\n  SMALL(0),\n  SUPER(1),\n  FIRE(2),\n  CAPE(3);\n  \n  private int value;\n  \n  private State(int value) {\n    this.value = value;\n  }\n  \n  public int getValue() {\n    return this.value;\n  }\n}\n\npublic class MarioStateMachine {\n  private int score;\n  private State currentState;\n  \n  public MarioStateMachine() {\n    this.score = 0;\n    this.currentState = State.SMALL;\n  }\n  \n  public void obtainMushRoom() {\n    \n  }\n  \n  public void obtainCape() {\n    \n  }\n  \n  public void obtainFireFlower() {\n    \n  }\n  \n  public void meetMonster() {\n    \n  }\n  \n  public int getScore() {\n    return this.score;\n  }\n  \n  public State getCurrentState() {\n    return this.currentState;\n  }\n  \n  public class ApplicationDemo {\n    public static void main(String[] args) {\n      MarioStateMachine mario = new MarioStateMachine();\n      mario.obtainMushRoom();\n      int score = mario.getScore();\n      State state = mario.getCurrentState();\n      System.out.println(\"mario score: \" + score + \"; state: \" + state);\n    }\n  }\n}\n```\n\n状态机实现方式一：分支逻辑法\n\n实现状态机最简单的方式是，参照状态转移图，将每一个状态转移，原模原样地直译成代码。这样的代码包含大量的if-else或switch-case分支逻辑判断，甚至是嵌套的分支判断逻辑。按照这个实现思路，把上面的代码补全下。补全之后的代码如下：\n\n```java\n\npublic class MarioStateMachine {\n  private int score;\n  private State currentState;\n\n  public MarioStateMachine() {\n    this.score = 0;\n    this.currentState = State.SMALL;\n  }\n\n  public void obtainMushRoom() {\n    if (currentState.equals(State.SMALL)) {\n      this.currentState = State.SUPER;\n      this.score += 100;\n    }\n  }\n\n  public void obtainCape() {\n    if (currentState.equals(State.SMALL) || currentState.equals(State.SUPER) ) {\n      this.currentState = State.CAPE;\n      this.score += 200;\n    }\n  }\n\n  public void obtainFireFlower() {\n    if (currentState.equals(State.SMALL) || currentState.equals(State.SUPER) ) {\n      this.currentState = State.FIRE;\n      this.score += 300;\n    }\n  }\n\n  public void meetMonster() {\n    if (currentState.equals(State.SUPER)) {\n      this.currentState = State.SMALL;\n      this.score -= 100;\n      return;\n    }\n\n    if (currentState.equals(State.CAPE)) {\n      this.currentState = State.SMALL;\n      this.score -= 200;\n      return;\n    }\n\n    if (currentState.equals(State.FIRE)) {\n      this.currentState = State.SMALL;\n      this.score -= 300;\n      return;\n    }\n  }\n\n  public int getScore() {\n    return this.score;\n  }\n\n  public State getCurrentState() {\n    return this.currentState;\n  }\n}\n```\n\n对于简单的状态机来说，分支逻辑这种实现方式是可以接受的。但是对于复杂的状态机来说，这种实现方式极易漏写或者错写某个状态转移。除此之外，代码中充斥着大量的if-else或者switch-case分支判断逻辑，可读性和可维护性都很差，如果某天修改了状态机中的某个状态转移，要在冗长的分支逻辑中找到对应的代码进行修改，很容易改错，引入bug。\n\n状态机实现方式二：查表法\n\n除了用状态转移图来表示之外，状态机还可以用二维表来表示，如下所示，在这个二维表中，第一维表示当前状态，第二维表示事件，值表示当前状态经过事件之后，转移到的新状态及其执行的动作。\n\n|       | E1(Got MushRoom) | E2(Got Cape) | E3(Got Fire Flower) | E4(Met Monster) |\n| :---: | :--------------: | :----------: | :-----------------: | :-------------: |\n| Small |    Super/+100    |  Cape/+200   |      Fire/+300      |        /        |\n| Super |        /         |  Cape/+200   |      Fire/+300      |   Small/-100    |\n| Cape  |        /         |      /       |          /          |   Small/-200    |\n| Fire  |        /         |      /       |          /          |   Small/-300    |\n\n注：表中的斜杠表示不存在者众状态转移。\n\n相对于分支逻辑的实现方式，查表法的代码实现更加清晰，可读性和可维护性更好。当修改状态机时，我们只需要修改transitionTable和actionTable两个二维数组即可。实际上，如果把这两个二维数组存储在配置文件中，当需要修改状态机时，我们甚至可以不修改任何代码，只需要修改配置文件就可以了。代码实现如下:\n\n```java\npublic enum Event {\n  GOT_MUSHROOM(0),\n  GOT_CAPE(1),\n  GOT_FIRE(2),\n  GOT_MONSTER(3);\n  \n  private int value;\n  \n  private Event(int value) {\n    this.value = value;\n  }\n  \n  public int getValue() {\n    return this.value;\n  }\n}\n\npublic class MarioStateMachine {\n  private int score;\n  private State currentState;\n  \n  private static final State[][] transitionTable = {\n    {SUPER,CAPE,FIRE,SMALL},\n    {SUPER,CAPE,FIRE,SMALL},\n    {CAPE,CAPE,CAPE,SMALL},\n    {FIRE,FIRE,FIRE,SMALL}\n  };\n  \n  private static final int[][] actionTable = {\n    {+100,+200,+300,+0},\n    {+0,+200,+300,-100},\n    {+0,+0,+0,-200},\n    {+0,+0,+0,-300}\n  };\n  \n  public MarioStateMachine() {\n    this.score = 0;\n    this.currentState = State.SMALL;\n  }\n  \n  public void obtainMushRoom() {\n    executeEvent(Event.GOT_MUSHROOM);\n  }\n  \n  public void obtainCape() {\n    executeEvent(Event.GOT_CAPE);\n  }\n  \n  public void obtainFireFlower() {\n    executeEvent(Event.GOT_FIRE);\n  }\n  \n  public void meetMonster() {\n    executeEvent(Event.MET_MONSTER);\n  }\n  \n  private void executeEvent(Event event) {\n    int stateValue = currentState.getValue();\n    int eventValue = event.getValue();\n    this.currentState = transitionTable[stateValue][eventValue];\n    this.score += actionTable[stateValue][eventValue];\n  }\n  \n  public int getScore(){\n    return this.score;\n  }\n  \n  public State getCurrentState() {\n    return this.currentState;\n  }\n}\n```\n\n状态机实现方式三：状态模式\n\n查表法的代码实现中，事件触发的都工作只是简单的积分加减，所以用一个int类型的二维数组actionTable就能表示，二维数组中的值表示积分的加减值。但是如果要执行的动作并非这么简单，而是一系列复杂的逻辑操作（比如加减积分、写数据库、发送消息通知等等），就没办法用如此简单的二维数组来表示了，也就是说，查表法的实现方式有一定局限性。\n\n虽然分支逻辑的实现方式不存在这个问题，但是又存在前面讲的其他问题，比如分支判断逻辑较多，导致代码可读性和可维护性不好等。针对分支逻辑法存在的问题，我们可以使用状态模式来解决。\n\n状态模式通过将事件触发的状态转移和动作执行拆分到不同的状态类中，来避免分支判断逻辑。\n\n利用状态模式，来补全MarioStateMachine类。\n\nIMario时状态的接口，定义了所有的事件。SmallMario、SuperMario、CapeMario、FireMario是IMario接口的实现类，分别对应状态机中的4个状态。原来所有状态转移和动作执行的代码逻辑，都集中在MarioStateMachine类中，现在这些逻辑被分散到了这4个状态类中。\n\n```java\npublic interface IMario { //所有状态类的接口\n  State getName();\n  //以下是定义的事件\n  void obtainMushRoom();\n  void obtainCape();\n  void obtainFireFlower();\n  void meetMonster();\n}\n\npublic class SmallMario implements IMario {\n  private MarioStateMachine stateMachine;\n  \n  public SmallMario(MarioStateMachine stateMachine) {\n    this.stateMachin = stateMachine;\n  }\n  \n  @Override\n  public State getName() {\n    return State.SMALL;\n  }\n  \n  @Override\n  public void obtainMushRoom() {\n    stateMachine.setCurrentState(new SuperMario(stateMachine));\n    stateMachine.setScore(stateMachine.getScore() + 100);\n  }\n  \n  @Override\n  public void obtainCape() {\n    stateMachine.setCurrentState(new CapeMario(stateMachine));\n    stateMachine.setScore(stateMachine.getScore() + 200);\n  }\n  \n  @Override\n  public void obtainFireFlower() {\n    stateMachine.setCurrentState(new FireMario(stateMachine));\n    stateMachine.setScore(stateMachine.getScore() + 300);\n  }\n  \n  @Override\n  public void meetMonster() {\n    //do nothing...\n  }\n}\n\npublic class SuperMario implements IMario {\n  private MarioStateMachine stateMachine;\n  \n  public SuperMario(MarioStateMachine stateMachine) {\n    this.stateMachine = stateMachine;\n  }\n  \n  @Override\n  public State getName() {\n    return State.SUPER;\n  }\n  \n  @Override\n  public void obtainMushRoom() {\n    //do nothing\n  }\n  \n  @Override\n  public void obtainCape() {\n    stateMachine.setCurrentState(new CapeMario(stateMachine));\n    stateMachine.setScore(stateMachine.getScore() + 200);\n  }\n  \n  @Override\n  public void obtainFireFlower() {\n    stateMachine.setCurrentState(new SmallMario(stateMachine));\n    stateMachine.setScore(stateMachine.getScore() - 100);\n  }\n}\n\n//省略CapeMario、FireMario类\n\n\npublic class MarioStateMachine {\n  private int score;\n  private IMario currentState; //不再使用枚举来表示状态\n  \n  public MarioStateMachine() {\n    this.score = 0;\n    this.currentState = new SmallMario(this);\n  }\n  \n  public void obtainMushRoom() {\n    this.currentState.obtainMushRoom();\n  }\n  \n  public void obtainCape() {\n    this.currentState.obtainCape();\n  }\n  \n  public void obtainFireFlower() {\n    this.currentState.obtainFireFlower();\n  }\n  \n  public void meetMonster() {\n    this.currentState.meetMonster();\n  }\n  \n  public int getScore() {\n    return this.score;\n  }\n  \n  public State getCurrentState() {\n    return this.currentState.getName();\n  }\n  \n  public void setScore(int score) {\n  \tthis.score = score;\n  }\n  \n  public void setCurrentState(IMario currentState) {\n    this.currentState = currentState;\n  }\n} \n```\n\nMarioStatemachine和各个状态类之间是双向依赖关系。MarioStateMachine依赖各个状态类是理所当然的，但是，各个状态类为什么要依赖MarioStateMachine呢？这是因为，各个状态类需要更新MarioStateMachine中的两个变量，score和currentState。\n\n上面的代码还可以继续优化，可以将状态类设计成单例，毕竟状态类中不包含任何成员变量。但是，当将状态类设计成单例之后，我们就无法通过构造函数来传递MarioStateMachine了，而状态类又要依赖MarioStateMachine，这又该如何解决呢？\n\n可以通过函数参数将MarioStateMachine传递进状态类。根据这个设计思路，对上面代码进行重构。\n\n```java\npublic interface IMario {\n  State getName();\n  void obtainMushRoom(MarioStateMachine stateMachine);\n  void obtainCape(MarioStateMachine stateMachine);\n  void obtainFireFlower(MarioStateMachine stateMachine);\n  void meetMonster(MarioStateMachine stateMachine);\n}\n\npublic class SmallMario implements IMario {\n  private static final SmallMario instance = new SmallMario();\n  private SmallMario() {}\n  public static SmallMario getInstance() {\n    return instance;\n  }\n  \n  @Override\n  public State getName() {\n    return State.SMALL;\n  }\n  \n  @Override\n  public void obtainMushRoom(MarioStateMachine stateMachine) {\n    stateMachine.setCurrentState(SuperMario.getInstance());\n    stateMachine.setScore(stateMachine.getScore() + 100);\n  }\n  \n  @Override\n  public void obtainCape(MarioStateMachine stateMachine){\n    stateMachine.setCurrentState(CapeMario.getInstance());\n    stateMachine.setScore(stateMachine.getScore() + 200);\n  }\n  \n  @Override\n  public void obtainFireFlower(MarioStateMachine stateMachine) {\n    stateMachine.setCurrentState(FireMario.getInstance());\n    stateMachine.setScore(stateMachine.getScore() + 300);\n  }\n  \n  @Override\n  public void meetMonster(MarioStateMachine stateMachine) {\n    //do nothing\n  }\n}\n\n// 省略SuperMario、CapeMario、FireMario类...\n\npublic class MarioStateMachine {\n  private int score;\n  private IMario currentState;\n  \n  public MarioStateMachine() {\n    this.score = 0;\n    this.currentState = SmallMario.getInstance();\n  }\n  \n  public void obtainMushRoom() {\n    this.currentState.obtainMushRoom(this);\n  }\n  \n  public void obtainCape() {\n    this.currentState.obtainCape(this);\n  }\n  \n  public void obtainFireFlower() {\n    this.currentState.obtainFireFlower(this);\n  }\n  \n  public void meetMonster() {\n    this.currentState.meetMonster(this);\n  }\n  \n  public int getScore() {\n    return this.score;\n  }\n  \n  public State getCurrentState() {\n    return this.currentState.getName();\n  }\n  \n  public void setScore(int score) {\n    this.score = score;\n  }\n  \n  public void setCurrentState(IMario currentState) {\n    this.currentState = currentState;\n  }\n}\n```\n\n电商下单、外卖下单这种类型的状态机，他们的状态并不多，状态转移也比较简单，但事件触发执行的动作包含的业务逻辑可能会比较复杂，所以，更加推荐使用状态模式来实现。\n\n状态机三种实现方式比较\n\n分支逻辑法，利用if-else或者switch-case分支逻辑，参照状态转移图，将每一个状态转移原模原样地直译成代码。对于简单的状态机来说，这种实现方式最简单、最直接，是首选。\n\n查表法，对于状态很多、状态转移比较复杂的状态机来说，查表法比较合适。通过二维数组来表示状态转移图，能极大地提高代码的可读性和可维护性。\n\n状态模式，对于状态并不多、状态转移也比较简单，但事件触发执行的动作包含的业务逻辑可能比较复杂的状态机来说，我们首选这种实现方式。\n\n思考：状态模式的实现还存在一些问题，比如，状态接口中定义了所有的事件函数，这就导致，即便某个状态类并不需要支持其中的某个或者某些事件，但也要实现所有的事件函数。不仅如此，添加一个事件到状态接口，所有的状态类都要做相应的修改。\n\n实现方式，通过将事件抽象成接口，这样这个状态支持这个事件，那么就实现该接口，如果需要增加一个事件，只需要在需要支持这个事件的状态类实现该事件即可。表示该状态下，支持这个功能。也更面向对象。","source":"_posts/设计模式之状态模式.md","raw":"---\nlayout:    post\ntitle:     设计模式之状态模式\ncategory:  设计模式之美\ndescription: 设计模式之状态模式\ntags: 设计模式之美\ndate: 2021/06/07 13:26:10\n---\n\n状态模式一般用来实现状态机，而状态机常用在游戏、工作流引擎等系统开发中。不过，状态机的实现方式有多种，除了状态模式，比较常用的还有分支逻辑法和查表法。\n\n有限状态机\n\n英文翻译是Finite State Machine，缩写为FSM，简称为状态机。状态机有3个组成部分：状态（State）、事件（Event）、动作（Action）。其中，事件也称为转移条件（Transition Condition）。事件触发状态的转移以及动作的执行。不过动作不是必须的，也可能只转移状态，不执行任何动作。\n\n“超级马里奥”游戏就是一个典型的例子，在游戏中，马里奥可以变身多种形态，比如小马里奥（Small Mario）、超级马里奥（Super Mario）、火焰马里奥（Fire Mario）、斗篷马里奥（Cape Mario）等。在不同的游戏情节下，各个形态会互相转化，并相应的增减积分。比如初始小马里奥，吃了蘑菇之后会变成超级马里奥，并且增加100积分。\n\n马里奥的形态转变就是一个状态机。马里奥的不同形态就是状态机中的“状态”，游戏情节（比如吃蘑菇）就是状态机中的“事件”，加减积分就是状态机中的“动作”。比如，吃蘑菇这个事件会触发状态的转移：从小马里奥转移到超级马里奥，以及触发动作的执行（增加100积分）。\n\n<img src=\"https://static001.geekbang.org/resource/image/5a/6c/5aa0310b9b3ea08794cfc2f376c8f96c.jpg\" alt=\"img\" style=\"zoom:50%;\" />\n\n如何变成来实现上面的状态机呢？\n\n```java\npublic enum State {\n  SMALL(0),\n  SUPER(1),\n  FIRE(2),\n  CAPE(3);\n  \n  private int value;\n  \n  private State(int value) {\n    this.value = value;\n  }\n  \n  public int getValue() {\n    return this.value;\n  }\n}\n\npublic class MarioStateMachine {\n  private int score;\n  private State currentState;\n  \n  public MarioStateMachine() {\n    this.score = 0;\n    this.currentState = State.SMALL;\n  }\n  \n  public void obtainMushRoom() {\n    \n  }\n  \n  public void obtainCape() {\n    \n  }\n  \n  public void obtainFireFlower() {\n    \n  }\n  \n  public void meetMonster() {\n    \n  }\n  \n  public int getScore() {\n    return this.score;\n  }\n  \n  public State getCurrentState() {\n    return this.currentState;\n  }\n  \n  public class ApplicationDemo {\n    public static void main(String[] args) {\n      MarioStateMachine mario = new MarioStateMachine();\n      mario.obtainMushRoom();\n      int score = mario.getScore();\n      State state = mario.getCurrentState();\n      System.out.println(\"mario score: \" + score + \"; state: \" + state);\n    }\n  }\n}\n```\n\n状态机实现方式一：分支逻辑法\n\n实现状态机最简单的方式是，参照状态转移图，将每一个状态转移，原模原样地直译成代码。这样的代码包含大量的if-else或switch-case分支逻辑判断，甚至是嵌套的分支判断逻辑。按照这个实现思路，把上面的代码补全下。补全之后的代码如下：\n\n```java\n\npublic class MarioStateMachine {\n  private int score;\n  private State currentState;\n\n  public MarioStateMachine() {\n    this.score = 0;\n    this.currentState = State.SMALL;\n  }\n\n  public void obtainMushRoom() {\n    if (currentState.equals(State.SMALL)) {\n      this.currentState = State.SUPER;\n      this.score += 100;\n    }\n  }\n\n  public void obtainCape() {\n    if (currentState.equals(State.SMALL) || currentState.equals(State.SUPER) ) {\n      this.currentState = State.CAPE;\n      this.score += 200;\n    }\n  }\n\n  public void obtainFireFlower() {\n    if (currentState.equals(State.SMALL) || currentState.equals(State.SUPER) ) {\n      this.currentState = State.FIRE;\n      this.score += 300;\n    }\n  }\n\n  public void meetMonster() {\n    if (currentState.equals(State.SUPER)) {\n      this.currentState = State.SMALL;\n      this.score -= 100;\n      return;\n    }\n\n    if (currentState.equals(State.CAPE)) {\n      this.currentState = State.SMALL;\n      this.score -= 200;\n      return;\n    }\n\n    if (currentState.equals(State.FIRE)) {\n      this.currentState = State.SMALL;\n      this.score -= 300;\n      return;\n    }\n  }\n\n  public int getScore() {\n    return this.score;\n  }\n\n  public State getCurrentState() {\n    return this.currentState;\n  }\n}\n```\n\n对于简单的状态机来说，分支逻辑这种实现方式是可以接受的。但是对于复杂的状态机来说，这种实现方式极易漏写或者错写某个状态转移。除此之外，代码中充斥着大量的if-else或者switch-case分支判断逻辑，可读性和可维护性都很差，如果某天修改了状态机中的某个状态转移，要在冗长的分支逻辑中找到对应的代码进行修改，很容易改错，引入bug。\n\n状态机实现方式二：查表法\n\n除了用状态转移图来表示之外，状态机还可以用二维表来表示，如下所示，在这个二维表中，第一维表示当前状态，第二维表示事件，值表示当前状态经过事件之后，转移到的新状态及其执行的动作。\n\n|       | E1(Got MushRoom) | E2(Got Cape) | E3(Got Fire Flower) | E4(Met Monster) |\n| :---: | :--------------: | :----------: | :-----------------: | :-------------: |\n| Small |    Super/+100    |  Cape/+200   |      Fire/+300      |        /        |\n| Super |        /         |  Cape/+200   |      Fire/+300      |   Small/-100    |\n| Cape  |        /         |      /       |          /          |   Small/-200    |\n| Fire  |        /         |      /       |          /          |   Small/-300    |\n\n注：表中的斜杠表示不存在者众状态转移。\n\n相对于分支逻辑的实现方式，查表法的代码实现更加清晰，可读性和可维护性更好。当修改状态机时，我们只需要修改transitionTable和actionTable两个二维数组即可。实际上，如果把这两个二维数组存储在配置文件中，当需要修改状态机时，我们甚至可以不修改任何代码，只需要修改配置文件就可以了。代码实现如下:\n\n```java\npublic enum Event {\n  GOT_MUSHROOM(0),\n  GOT_CAPE(1),\n  GOT_FIRE(2),\n  GOT_MONSTER(3);\n  \n  private int value;\n  \n  private Event(int value) {\n    this.value = value;\n  }\n  \n  public int getValue() {\n    return this.value;\n  }\n}\n\npublic class MarioStateMachine {\n  private int score;\n  private State currentState;\n  \n  private static final State[][] transitionTable = {\n    {SUPER,CAPE,FIRE,SMALL},\n    {SUPER,CAPE,FIRE,SMALL},\n    {CAPE,CAPE,CAPE,SMALL},\n    {FIRE,FIRE,FIRE,SMALL}\n  };\n  \n  private static final int[][] actionTable = {\n    {+100,+200,+300,+0},\n    {+0,+200,+300,-100},\n    {+0,+0,+0,-200},\n    {+0,+0,+0,-300}\n  };\n  \n  public MarioStateMachine() {\n    this.score = 0;\n    this.currentState = State.SMALL;\n  }\n  \n  public void obtainMushRoom() {\n    executeEvent(Event.GOT_MUSHROOM);\n  }\n  \n  public void obtainCape() {\n    executeEvent(Event.GOT_CAPE);\n  }\n  \n  public void obtainFireFlower() {\n    executeEvent(Event.GOT_FIRE);\n  }\n  \n  public void meetMonster() {\n    executeEvent(Event.MET_MONSTER);\n  }\n  \n  private void executeEvent(Event event) {\n    int stateValue = currentState.getValue();\n    int eventValue = event.getValue();\n    this.currentState = transitionTable[stateValue][eventValue];\n    this.score += actionTable[stateValue][eventValue];\n  }\n  \n  public int getScore(){\n    return this.score;\n  }\n  \n  public State getCurrentState() {\n    return this.currentState;\n  }\n}\n```\n\n状态机实现方式三：状态模式\n\n查表法的代码实现中，事件触发的都工作只是简单的积分加减，所以用一个int类型的二维数组actionTable就能表示，二维数组中的值表示积分的加减值。但是如果要执行的动作并非这么简单，而是一系列复杂的逻辑操作（比如加减积分、写数据库、发送消息通知等等），就没办法用如此简单的二维数组来表示了，也就是说，查表法的实现方式有一定局限性。\n\n虽然分支逻辑的实现方式不存在这个问题，但是又存在前面讲的其他问题，比如分支判断逻辑较多，导致代码可读性和可维护性不好等。针对分支逻辑法存在的问题，我们可以使用状态模式来解决。\n\n状态模式通过将事件触发的状态转移和动作执行拆分到不同的状态类中，来避免分支判断逻辑。\n\n利用状态模式，来补全MarioStateMachine类。\n\nIMario时状态的接口，定义了所有的事件。SmallMario、SuperMario、CapeMario、FireMario是IMario接口的实现类，分别对应状态机中的4个状态。原来所有状态转移和动作执行的代码逻辑，都集中在MarioStateMachine类中，现在这些逻辑被分散到了这4个状态类中。\n\n```java\npublic interface IMario { //所有状态类的接口\n  State getName();\n  //以下是定义的事件\n  void obtainMushRoom();\n  void obtainCape();\n  void obtainFireFlower();\n  void meetMonster();\n}\n\npublic class SmallMario implements IMario {\n  private MarioStateMachine stateMachine;\n  \n  public SmallMario(MarioStateMachine stateMachine) {\n    this.stateMachin = stateMachine;\n  }\n  \n  @Override\n  public State getName() {\n    return State.SMALL;\n  }\n  \n  @Override\n  public void obtainMushRoom() {\n    stateMachine.setCurrentState(new SuperMario(stateMachine));\n    stateMachine.setScore(stateMachine.getScore() + 100);\n  }\n  \n  @Override\n  public void obtainCape() {\n    stateMachine.setCurrentState(new CapeMario(stateMachine));\n    stateMachine.setScore(stateMachine.getScore() + 200);\n  }\n  \n  @Override\n  public void obtainFireFlower() {\n    stateMachine.setCurrentState(new FireMario(stateMachine));\n    stateMachine.setScore(stateMachine.getScore() + 300);\n  }\n  \n  @Override\n  public void meetMonster() {\n    //do nothing...\n  }\n}\n\npublic class SuperMario implements IMario {\n  private MarioStateMachine stateMachine;\n  \n  public SuperMario(MarioStateMachine stateMachine) {\n    this.stateMachine = stateMachine;\n  }\n  \n  @Override\n  public State getName() {\n    return State.SUPER;\n  }\n  \n  @Override\n  public void obtainMushRoom() {\n    //do nothing\n  }\n  \n  @Override\n  public void obtainCape() {\n    stateMachine.setCurrentState(new CapeMario(stateMachine));\n    stateMachine.setScore(stateMachine.getScore() + 200);\n  }\n  \n  @Override\n  public void obtainFireFlower() {\n    stateMachine.setCurrentState(new SmallMario(stateMachine));\n    stateMachine.setScore(stateMachine.getScore() - 100);\n  }\n}\n\n//省略CapeMario、FireMario类\n\n\npublic class MarioStateMachine {\n  private int score;\n  private IMario currentState; //不再使用枚举来表示状态\n  \n  public MarioStateMachine() {\n    this.score = 0;\n    this.currentState = new SmallMario(this);\n  }\n  \n  public void obtainMushRoom() {\n    this.currentState.obtainMushRoom();\n  }\n  \n  public void obtainCape() {\n    this.currentState.obtainCape();\n  }\n  \n  public void obtainFireFlower() {\n    this.currentState.obtainFireFlower();\n  }\n  \n  public void meetMonster() {\n    this.currentState.meetMonster();\n  }\n  \n  public int getScore() {\n    return this.score;\n  }\n  \n  public State getCurrentState() {\n    return this.currentState.getName();\n  }\n  \n  public void setScore(int score) {\n  \tthis.score = score;\n  }\n  \n  public void setCurrentState(IMario currentState) {\n    this.currentState = currentState;\n  }\n} \n```\n\nMarioStatemachine和各个状态类之间是双向依赖关系。MarioStateMachine依赖各个状态类是理所当然的，但是，各个状态类为什么要依赖MarioStateMachine呢？这是因为，各个状态类需要更新MarioStateMachine中的两个变量，score和currentState。\n\n上面的代码还可以继续优化，可以将状态类设计成单例，毕竟状态类中不包含任何成员变量。但是，当将状态类设计成单例之后，我们就无法通过构造函数来传递MarioStateMachine了，而状态类又要依赖MarioStateMachine，这又该如何解决呢？\n\n可以通过函数参数将MarioStateMachine传递进状态类。根据这个设计思路，对上面代码进行重构。\n\n```java\npublic interface IMario {\n  State getName();\n  void obtainMushRoom(MarioStateMachine stateMachine);\n  void obtainCape(MarioStateMachine stateMachine);\n  void obtainFireFlower(MarioStateMachine stateMachine);\n  void meetMonster(MarioStateMachine stateMachine);\n}\n\npublic class SmallMario implements IMario {\n  private static final SmallMario instance = new SmallMario();\n  private SmallMario() {}\n  public static SmallMario getInstance() {\n    return instance;\n  }\n  \n  @Override\n  public State getName() {\n    return State.SMALL;\n  }\n  \n  @Override\n  public void obtainMushRoom(MarioStateMachine stateMachine) {\n    stateMachine.setCurrentState(SuperMario.getInstance());\n    stateMachine.setScore(stateMachine.getScore() + 100);\n  }\n  \n  @Override\n  public void obtainCape(MarioStateMachine stateMachine){\n    stateMachine.setCurrentState(CapeMario.getInstance());\n    stateMachine.setScore(stateMachine.getScore() + 200);\n  }\n  \n  @Override\n  public void obtainFireFlower(MarioStateMachine stateMachine) {\n    stateMachine.setCurrentState(FireMario.getInstance());\n    stateMachine.setScore(stateMachine.getScore() + 300);\n  }\n  \n  @Override\n  public void meetMonster(MarioStateMachine stateMachine) {\n    //do nothing\n  }\n}\n\n// 省略SuperMario、CapeMario、FireMario类...\n\npublic class MarioStateMachine {\n  private int score;\n  private IMario currentState;\n  \n  public MarioStateMachine() {\n    this.score = 0;\n    this.currentState = SmallMario.getInstance();\n  }\n  \n  public void obtainMushRoom() {\n    this.currentState.obtainMushRoom(this);\n  }\n  \n  public void obtainCape() {\n    this.currentState.obtainCape(this);\n  }\n  \n  public void obtainFireFlower() {\n    this.currentState.obtainFireFlower(this);\n  }\n  \n  public void meetMonster() {\n    this.currentState.meetMonster(this);\n  }\n  \n  public int getScore() {\n    return this.score;\n  }\n  \n  public State getCurrentState() {\n    return this.currentState.getName();\n  }\n  \n  public void setScore(int score) {\n    this.score = score;\n  }\n  \n  public void setCurrentState(IMario currentState) {\n    this.currentState = currentState;\n  }\n}\n```\n\n电商下单、外卖下单这种类型的状态机，他们的状态并不多，状态转移也比较简单，但事件触发执行的动作包含的业务逻辑可能会比较复杂，所以，更加推荐使用状态模式来实现。\n\n状态机三种实现方式比较\n\n分支逻辑法，利用if-else或者switch-case分支逻辑，参照状态转移图，将每一个状态转移原模原样地直译成代码。对于简单的状态机来说，这种实现方式最简单、最直接，是首选。\n\n查表法，对于状态很多、状态转移比较复杂的状态机来说，查表法比较合适。通过二维数组来表示状态转移图，能极大地提高代码的可读性和可维护性。\n\n状态模式，对于状态并不多、状态转移也比较简单，但事件触发执行的动作包含的业务逻辑可能比较复杂的状态机来说，我们首选这种实现方式。\n\n思考：状态模式的实现还存在一些问题，比如，状态接口中定义了所有的事件函数，这就导致，即便某个状态类并不需要支持其中的某个或者某些事件，但也要实现所有的事件函数。不仅如此，添加一个事件到状态接口，所有的状态类都要做相应的修改。\n\n实现方式，通过将事件抽象成接口，这样这个状态支持这个事件，那么就实现该接口，如果需要增加一个事件，只需要在需要支持这个事件的状态类实现该事件即可。表示该状态下，支持这个功能。也更面向对象。","slug":"设计模式之状态模式","published":1,"updated":"2021-06-07T05:26:10.000Z","comments":1,"photos":[],"link":"","_id":"cm1m304xu002831b4eh9lby49","content":"<p>状态模式一般用来实现状态机，而状态机常用在游戏、工作流引擎等系统开发中。不过，状态机的实现方式有多种，除了状态模式，比较常用的还有分支逻辑法和查表法。</p>\n<p>有限状态机</p>\n<p>英文翻译是Finite State Machine，缩写为FSM，简称为状态机。状态机有3个组成部分：状态（State）、事件（Event）、动作（Action）。其中，事件也称为转移条件（Transition Condition）。事件触发状态的转移以及动作的执行。不过动作不是必须的，也可能只转移状态，不执行任何动作。</p>\n<p>“超级马里奥”游戏就是一个典型的例子，在游戏中，马里奥可以变身多种形态，比如小马里奥（Small Mario）、超级马里奥（Super Mario）、火焰马里奥（Fire Mario）、斗篷马里奥（Cape Mario）等。在不同的游戏情节下，各个形态会互相转化，并相应的增减积分。比如初始小马里奥，吃了蘑菇之后会变成超级马里奥，并且增加100积分。</p>\n<p>马里奥的形态转变就是一个状态机。马里奥的不同形态就是状态机中的“状态”，游戏情节（比如吃蘑菇）就是状态机中的“事件”，加减积分就是状态机中的“动作”。比如，吃蘑菇这个事件会触发状态的转移：从小马里奥转移到超级马里奥，以及触发动作的执行（增加100积分）。</p>\n<img src=\"https://static001.geekbang.org/resource/image/5a/6c/5aa0310b9b3ea08794cfc2f376c8f96c.jpg\" alt=\"img\" style=\"zoom:50%;\" />\n\n<p>如何变成来实现上面的状态机呢？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">State</span> </span>&#123;</span><br><span class=\"line\">  SMALL(<span class=\"number\">0</span>),</span><br><span class=\"line\">  SUPER(<span class=\"number\">1</span>),</span><br><span class=\"line\">  FIRE(<span class=\"number\">2</span>),</span><br><span class=\"line\">  CAPE(<span class=\"number\">3</span>);</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> value;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">State</span><span class=\"params\">(<span class=\"keyword\">int</span> value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.value = value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getValue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MarioStateMachine</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> score;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> State currentState;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MarioStateMachine</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.score = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.currentState = State.SMALL;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">obtainMushRoom</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">obtainCape</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">obtainFireFlower</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">meetMonster</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getScore</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.score;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> State <span class=\"title\">getCurrentState</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.currentState;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ApplicationDemo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">      MarioStateMachine mario = <span class=\"keyword\">new</span> MarioStateMachine();</span><br><span class=\"line\">      mario.obtainMushRoom();</span><br><span class=\"line\">      <span class=\"keyword\">int</span> score = mario.getScore();</span><br><span class=\"line\">      State state = mario.getCurrentState();</span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;mario score: &quot;</span> + score + <span class=\"string\">&quot;; state: &quot;</span> + state);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>状态机实现方式一：分支逻辑法</p>\n<p>实现状态机最简单的方式是，参照状态转移图，将每一个状态转移，原模原样地直译成代码。这样的代码包含大量的if-else或switch-case分支逻辑判断，甚至是嵌套的分支判断逻辑。按照这个实现思路，把上面的代码补全下。补全之后的代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MarioStateMachine</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> score;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> State currentState;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MarioStateMachine</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.score = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.currentState = State.SMALL;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">obtainMushRoom</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (currentState.equals(State.SMALL)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.currentState = State.SUPER;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.score += <span class=\"number\">100</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">obtainCape</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (currentState.equals(State.SMALL) || currentState.equals(State.SUPER) ) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.currentState = State.CAPE;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.score += <span class=\"number\">200</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">obtainFireFlower</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (currentState.equals(State.SMALL) || currentState.equals(State.SUPER) ) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.currentState = State.FIRE;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.score += <span class=\"number\">300</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">meetMonster</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (currentState.equals(State.SUPER)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.currentState = State.SMALL;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.score -= <span class=\"number\">100</span>;</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (currentState.equals(State.CAPE)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.currentState = State.SMALL;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.score -= <span class=\"number\">200</span>;</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (currentState.equals(State.FIRE)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.currentState = State.SMALL;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.score -= <span class=\"number\">300</span>;</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getScore</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.score;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> State <span class=\"title\">getCurrentState</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.currentState;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对于简单的状态机来说，分支逻辑这种实现方式是可以接受的。但是对于复杂的状态机来说，这种实现方式极易漏写或者错写某个状态转移。除此之外，代码中充斥着大量的if-else或者switch-case分支判断逻辑，可读性和可维护性都很差，如果某天修改了状态机中的某个状态转移，要在冗长的分支逻辑中找到对应的代码进行修改，很容易改错，引入bug。</p>\n<p>状态机实现方式二：查表法</p>\n<p>除了用状态转移图来表示之外，状态机还可以用二维表来表示，如下所示，在这个二维表中，第一维表示当前状态，第二维表示事件，值表示当前状态经过事件之后，转移到的新状态及其执行的动作。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\"></th>\n<th align=\"center\">E1(Got MushRoom)</th>\n<th align=\"center\">E2(Got Cape)</th>\n<th align=\"center\">E3(Got Fire Flower)</th>\n<th align=\"center\">E4(Met Monster)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">Small</td>\n<td align=\"center\">Super/+100</td>\n<td align=\"center\">Cape/+200</td>\n<td align=\"center\">Fire/+300</td>\n<td align=\"center\">/</td>\n</tr>\n<tr>\n<td align=\"center\">Super</td>\n<td align=\"center\">/</td>\n<td align=\"center\">Cape/+200</td>\n<td align=\"center\">Fire/+300</td>\n<td align=\"center\">Small/-100</td>\n</tr>\n<tr>\n<td align=\"center\">Cape</td>\n<td align=\"center\">/</td>\n<td align=\"center\">/</td>\n<td align=\"center\">/</td>\n<td align=\"center\">Small/-200</td>\n</tr>\n<tr>\n<td align=\"center\">Fire</td>\n<td align=\"center\">/</td>\n<td align=\"center\">/</td>\n<td align=\"center\">/</td>\n<td align=\"center\">Small/-300</td>\n</tr>\n</tbody></table>\n<p>注：表中的斜杠表示不存在者众状态转移。</p>\n<p>相对于分支逻辑的实现方式，查表法的代码实现更加清晰，可读性和可维护性更好。当修改状态机时，我们只需要修改transitionTable和actionTable两个二维数组即可。实际上，如果把这两个二维数组存储在配置文件中，当需要修改状态机时，我们甚至可以不修改任何代码，只需要修改配置文件就可以了。代码实现如下:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">Event</span> </span>&#123;</span><br><span class=\"line\">  GOT_MUSHROOM(<span class=\"number\">0</span>),</span><br><span class=\"line\">  GOT_CAPE(<span class=\"number\">1</span>),</span><br><span class=\"line\">  GOT_FIRE(<span class=\"number\">2</span>),</span><br><span class=\"line\">  GOT_MONSTER(<span class=\"number\">3</span>);</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> value;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Event</span><span class=\"params\">(<span class=\"keyword\">int</span> value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.value = value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getValue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MarioStateMachine</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> score;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> State currentState;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> State[][] transitionTable = &#123;</span><br><span class=\"line\">    &#123;SUPER,CAPE,FIRE,SMALL&#125;,</span><br><span class=\"line\">    &#123;SUPER,CAPE,FIRE,SMALL&#125;,</span><br><span class=\"line\">    &#123;CAPE,CAPE,CAPE,SMALL&#125;,</span><br><span class=\"line\">    &#123;FIRE,FIRE,FIRE,SMALL&#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span>[][] actionTable = &#123;</span><br><span class=\"line\">    &#123;+<span class=\"number\">100</span>,+<span class=\"number\">200</span>,+<span class=\"number\">300</span>,+<span class=\"number\">0</span>&#125;,</span><br><span class=\"line\">    &#123;+<span class=\"number\">0</span>,+<span class=\"number\">200</span>,+<span class=\"number\">300</span>,-<span class=\"number\">100</span>&#125;,</span><br><span class=\"line\">    &#123;+<span class=\"number\">0</span>,+<span class=\"number\">0</span>,+<span class=\"number\">0</span>,-<span class=\"number\">200</span>&#125;,</span><br><span class=\"line\">    &#123;+<span class=\"number\">0</span>,+<span class=\"number\">0</span>,+<span class=\"number\">0</span>,-<span class=\"number\">300</span>&#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MarioStateMachine</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.score = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.currentState = State.SMALL;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">obtainMushRoom</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    executeEvent(Event.GOT_MUSHROOM);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">obtainCape</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    executeEvent(Event.GOT_CAPE);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">obtainFireFlower</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    executeEvent(Event.GOT_FIRE);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">meetMonster</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    executeEvent(Event.MET_MONSTER);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">executeEvent</span><span class=\"params\">(Event event)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> stateValue = currentState.getValue();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> eventValue = event.getValue();</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.currentState = transitionTable[stateValue][eventValue];</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.score += actionTable[stateValue][eventValue];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getScore</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.score;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> State <span class=\"title\">getCurrentState</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.currentState;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>状态机实现方式三：状态模式</p>\n<p>查表法的代码实现中，事件触发的都工作只是简单的积分加减，所以用一个int类型的二维数组actionTable就能表示，二维数组中的值表示积分的加减值。但是如果要执行的动作并非这么简单，而是一系列复杂的逻辑操作（比如加减积分、写数据库、发送消息通知等等），就没办法用如此简单的二维数组来表示了，也就是说，查表法的实现方式有一定局限性。</p>\n<p>虽然分支逻辑的实现方式不存在这个问题，但是又存在前面讲的其他问题，比如分支判断逻辑较多，导致代码可读性和可维护性不好等。针对分支逻辑法存在的问题，我们可以使用状态模式来解决。</p>\n<p>状态模式通过将事件触发的状态转移和动作执行拆分到不同的状态类中，来避免分支判断逻辑。</p>\n<p>利用状态模式，来补全MarioStateMachine类。</p>\n<p>IMario时状态的接口，定义了所有的事件。SmallMario、SuperMario、CapeMario、FireMario是IMario接口的实现类，分别对应状态机中的4个状态。原来所有状态转移和动作执行的代码逻辑，都集中在MarioStateMachine类中，现在这些逻辑被分散到了这4个状态类中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">IMario</span> </span>&#123; <span class=\"comment\">//所有状态类的接口</span></span><br><span class=\"line\">  <span class=\"function\">State <span class=\"title\">getName</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">  <span class=\"comment\">//以下是定义的事件</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">obtainMushRoom</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">obtainCape</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">obtainFireFlower</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">meetMonster</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SmallMario</span> <span class=\"keyword\">implements</span> <span class=\"title\">IMario</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> MarioStateMachine stateMachine;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SmallMario</span><span class=\"params\">(MarioStateMachine stateMachine)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.stateMachin = stateMachine;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> State <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> State.SMALL;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">obtainMushRoom</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    stateMachine.setCurrentState(<span class=\"keyword\">new</span> SuperMario(stateMachine));</span><br><span class=\"line\">    stateMachine.setScore(stateMachine.getScore() + <span class=\"number\">100</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">obtainCape</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    stateMachine.setCurrentState(<span class=\"keyword\">new</span> CapeMario(stateMachine));</span><br><span class=\"line\">    stateMachine.setScore(stateMachine.getScore() + <span class=\"number\">200</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">obtainFireFlower</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    stateMachine.setCurrentState(<span class=\"keyword\">new</span> FireMario(stateMachine));</span><br><span class=\"line\">    stateMachine.setScore(stateMachine.getScore() + <span class=\"number\">300</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">meetMonster</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//do nothing...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SuperMario</span> <span class=\"keyword\">implements</span> <span class=\"title\">IMario</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> MarioStateMachine stateMachine;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SuperMario</span><span class=\"params\">(MarioStateMachine stateMachine)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.stateMachine = stateMachine;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> State <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> State.SUPER;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">obtainMushRoom</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//do nothing</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">obtainCape</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    stateMachine.setCurrentState(<span class=\"keyword\">new</span> CapeMario(stateMachine));</span><br><span class=\"line\">    stateMachine.setScore(stateMachine.getScore() + <span class=\"number\">200</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">obtainFireFlower</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    stateMachine.setCurrentState(<span class=\"keyword\">new</span> SmallMario(stateMachine));</span><br><span class=\"line\">    stateMachine.setScore(stateMachine.getScore() - <span class=\"number\">100</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//省略CapeMario、FireMario类</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MarioStateMachine</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> score;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> IMario currentState; <span class=\"comment\">//不再使用枚举来表示状态</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MarioStateMachine</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.score = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.currentState = <span class=\"keyword\">new</span> SmallMario(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">obtainMushRoom</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.currentState.obtainMushRoom();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">obtainCape</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.currentState.obtainCape();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">obtainFireFlower</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.currentState.obtainFireFlower();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">meetMonster</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.currentState.meetMonster();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getScore</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.score;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> State <span class=\"title\">getCurrentState</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.currentState.getName();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setScore</span><span class=\"params\">(<span class=\"keyword\">int</span> score)</span> </span>&#123;</span><br><span class=\"line\">  \t<span class=\"keyword\">this</span>.score = score;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setCurrentState</span><span class=\"params\">(IMario currentState)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.currentState = currentState;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n\n<p>MarioStatemachine和各个状态类之间是双向依赖关系。MarioStateMachine依赖各个状态类是理所当然的，但是，各个状态类为什么要依赖MarioStateMachine呢？这是因为，各个状态类需要更新MarioStateMachine中的两个变量，score和currentState。</p>\n<p>上面的代码还可以继续优化，可以将状态类设计成单例，毕竟状态类中不包含任何成员变量。但是，当将状态类设计成单例之后，我们就无法通过构造函数来传递MarioStateMachine了，而状态类又要依赖MarioStateMachine，这又该如何解决呢？</p>\n<p>可以通过函数参数将MarioStateMachine传递进状态类。根据这个设计思路，对上面代码进行重构。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">IMario</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\">State <span class=\"title\">getName</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">obtainMushRoom</span><span class=\"params\">(MarioStateMachine stateMachine)</span></span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">obtainCape</span><span class=\"params\">(MarioStateMachine stateMachine)</span></span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">obtainFireFlower</span><span class=\"params\">(MarioStateMachine stateMachine)</span></span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">meetMonster</span><span class=\"params\">(MarioStateMachine stateMachine)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SmallMario</span> <span class=\"keyword\">implements</span> <span class=\"title\">IMario</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> SmallMario instance = <span class=\"keyword\">new</span> SmallMario();</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">SmallMario</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> SmallMario <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> State <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> State.SMALL;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">obtainMushRoom</span><span class=\"params\">(MarioStateMachine stateMachine)</span> </span>&#123;</span><br><span class=\"line\">    stateMachine.setCurrentState(SuperMario.getInstance());</span><br><span class=\"line\">    stateMachine.setScore(stateMachine.getScore() + <span class=\"number\">100</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">obtainCape</span><span class=\"params\">(MarioStateMachine stateMachine)</span></span>&#123;</span><br><span class=\"line\">    stateMachine.setCurrentState(CapeMario.getInstance());</span><br><span class=\"line\">    stateMachine.setScore(stateMachine.getScore() + <span class=\"number\">200</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">obtainFireFlower</span><span class=\"params\">(MarioStateMachine stateMachine)</span> </span>&#123;</span><br><span class=\"line\">    stateMachine.setCurrentState(FireMario.getInstance());</span><br><span class=\"line\">    stateMachine.setScore(stateMachine.getScore() + <span class=\"number\">300</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">meetMonster</span><span class=\"params\">(MarioStateMachine stateMachine)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//do nothing</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 省略SuperMario、CapeMario、FireMario类...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MarioStateMachine</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> score;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> IMario currentState;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MarioStateMachine</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.score = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.currentState = SmallMario.getInstance();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">obtainMushRoom</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.currentState.obtainMushRoom(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">obtainCape</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.currentState.obtainCape(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">obtainFireFlower</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.currentState.obtainFireFlower(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">meetMonster</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.currentState.meetMonster(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getScore</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.score;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> State <span class=\"title\">getCurrentState</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.currentState.getName();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setScore</span><span class=\"params\">(<span class=\"keyword\">int</span> score)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.score = score;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setCurrentState</span><span class=\"params\">(IMario currentState)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.currentState = currentState;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>电商下单、外卖下单这种类型的状态机，他们的状态并不多，状态转移也比较简单，但事件触发执行的动作包含的业务逻辑可能会比较复杂，所以，更加推荐使用状态模式来实现。</p>\n<p>状态机三种实现方式比较</p>\n<p>分支逻辑法，利用if-else或者switch-case分支逻辑，参照状态转移图，将每一个状态转移原模原样地直译成代码。对于简单的状态机来说，这种实现方式最简单、最直接，是首选。</p>\n<p>查表法，对于状态很多、状态转移比较复杂的状态机来说，查表法比较合适。通过二维数组来表示状态转移图，能极大地提高代码的可读性和可维护性。</p>\n<p>状态模式，对于状态并不多、状态转移也比较简单，但事件触发执行的动作包含的业务逻辑可能比较复杂的状态机来说，我们首选这种实现方式。</p>\n<p>思考：状态模式的实现还存在一些问题，比如，状态接口中定义了所有的事件函数，这就导致，即便某个状态类并不需要支持其中的某个或者某些事件，但也要实现所有的事件函数。不仅如此，添加一个事件到状态接口，所有的状态类都要做相应的修改。</p>\n<p>实现方式，通过将事件抽象成接口，这样这个状态支持这个事件，那么就实现该接口，如果需要增加一个事件，只需要在需要支持这个事件的状态类实现该事件即可。表示该状态下，支持这个功能。也更面向对象。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>状态模式一般用来实现状态机，而状态机常用在游戏、工作流引擎等系统开发中。不过，状态机的实现方式有多种，除了状态模式，比较常用的还有分支逻辑法和查表法。</p>\n<p>有限状态机</p>\n<p>英文翻译是Finite State Machine，缩写为FSM，简称为状态机。状态机有3个组成部分：状态（State）、事件（Event）、动作（Action）。其中，事件也称为转移条件（Transition Condition）。事件触发状态的转移以及动作的执行。不过动作不是必须的，也可能只转移状态，不执行任何动作。</p>\n<p>“超级马里奥”游戏就是一个典型的例子，在游戏中，马里奥可以变身多种形态，比如小马里奥（Small Mario）、超级马里奥（Super Mario）、火焰马里奥（Fire Mario）、斗篷马里奥（Cape Mario）等。在不同的游戏情节下，各个形态会互相转化，并相应的增减积分。比如初始小马里奥，吃了蘑菇之后会变成超级马里奥，并且增加100积分。</p>\n<p>马里奥的形态转变就是一个状态机。马里奥的不同形态就是状态机中的“状态”，游戏情节（比如吃蘑菇）就是状态机中的“事件”，加减积分就是状态机中的“动作”。比如，吃蘑菇这个事件会触发状态的转移：从小马里奥转移到超级马里奥，以及触发动作的执行（增加100积分）。</p>\n<img src=\"https://static001.geekbang.org/resource/image/5a/6c/5aa0310b9b3ea08794cfc2f376c8f96c.jpg\" alt=\"img\" style=\"zoom:50%;\" />\n\n<p>如何变成来实现上面的状态机呢？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">State</span> </span>&#123;</span><br><span class=\"line\">  SMALL(<span class=\"number\">0</span>),</span><br><span class=\"line\">  SUPER(<span class=\"number\">1</span>),</span><br><span class=\"line\">  FIRE(<span class=\"number\">2</span>),</span><br><span class=\"line\">  CAPE(<span class=\"number\">3</span>);</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> value;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">State</span><span class=\"params\">(<span class=\"keyword\">int</span> value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.value = value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getValue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MarioStateMachine</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> score;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> State currentState;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MarioStateMachine</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.score = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.currentState = State.SMALL;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">obtainMushRoom</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">obtainCape</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">obtainFireFlower</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">meetMonster</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getScore</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.score;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> State <span class=\"title\">getCurrentState</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.currentState;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ApplicationDemo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">      MarioStateMachine mario = <span class=\"keyword\">new</span> MarioStateMachine();</span><br><span class=\"line\">      mario.obtainMushRoom();</span><br><span class=\"line\">      <span class=\"keyword\">int</span> score = mario.getScore();</span><br><span class=\"line\">      State state = mario.getCurrentState();</span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;mario score: &quot;</span> + score + <span class=\"string\">&quot;; state: &quot;</span> + state);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>状态机实现方式一：分支逻辑法</p>\n<p>实现状态机最简单的方式是，参照状态转移图，将每一个状态转移，原模原样地直译成代码。这样的代码包含大量的if-else或switch-case分支逻辑判断，甚至是嵌套的分支判断逻辑。按照这个实现思路，把上面的代码补全下。补全之后的代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MarioStateMachine</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> score;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> State currentState;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MarioStateMachine</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.score = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.currentState = State.SMALL;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">obtainMushRoom</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (currentState.equals(State.SMALL)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.currentState = State.SUPER;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.score += <span class=\"number\">100</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">obtainCape</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (currentState.equals(State.SMALL) || currentState.equals(State.SUPER) ) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.currentState = State.CAPE;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.score += <span class=\"number\">200</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">obtainFireFlower</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (currentState.equals(State.SMALL) || currentState.equals(State.SUPER) ) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.currentState = State.FIRE;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.score += <span class=\"number\">300</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">meetMonster</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (currentState.equals(State.SUPER)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.currentState = State.SMALL;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.score -= <span class=\"number\">100</span>;</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (currentState.equals(State.CAPE)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.currentState = State.SMALL;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.score -= <span class=\"number\">200</span>;</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (currentState.equals(State.FIRE)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.currentState = State.SMALL;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.score -= <span class=\"number\">300</span>;</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getScore</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.score;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> State <span class=\"title\">getCurrentState</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.currentState;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对于简单的状态机来说，分支逻辑这种实现方式是可以接受的。但是对于复杂的状态机来说，这种实现方式极易漏写或者错写某个状态转移。除此之外，代码中充斥着大量的if-else或者switch-case分支判断逻辑，可读性和可维护性都很差，如果某天修改了状态机中的某个状态转移，要在冗长的分支逻辑中找到对应的代码进行修改，很容易改错，引入bug。</p>\n<p>状态机实现方式二：查表法</p>\n<p>除了用状态转移图来表示之外，状态机还可以用二维表来表示，如下所示，在这个二维表中，第一维表示当前状态，第二维表示事件，值表示当前状态经过事件之后，转移到的新状态及其执行的动作。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\"></th>\n<th align=\"center\">E1(Got MushRoom)</th>\n<th align=\"center\">E2(Got Cape)</th>\n<th align=\"center\">E3(Got Fire Flower)</th>\n<th align=\"center\">E4(Met Monster)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">Small</td>\n<td align=\"center\">Super/+100</td>\n<td align=\"center\">Cape/+200</td>\n<td align=\"center\">Fire/+300</td>\n<td align=\"center\">/</td>\n</tr>\n<tr>\n<td align=\"center\">Super</td>\n<td align=\"center\">/</td>\n<td align=\"center\">Cape/+200</td>\n<td align=\"center\">Fire/+300</td>\n<td align=\"center\">Small/-100</td>\n</tr>\n<tr>\n<td align=\"center\">Cape</td>\n<td align=\"center\">/</td>\n<td align=\"center\">/</td>\n<td align=\"center\">/</td>\n<td align=\"center\">Small/-200</td>\n</tr>\n<tr>\n<td align=\"center\">Fire</td>\n<td align=\"center\">/</td>\n<td align=\"center\">/</td>\n<td align=\"center\">/</td>\n<td align=\"center\">Small/-300</td>\n</tr>\n</tbody></table>\n<p>注：表中的斜杠表示不存在者众状态转移。</p>\n<p>相对于分支逻辑的实现方式，查表法的代码实现更加清晰，可读性和可维护性更好。当修改状态机时，我们只需要修改transitionTable和actionTable两个二维数组即可。实际上，如果把这两个二维数组存储在配置文件中，当需要修改状态机时，我们甚至可以不修改任何代码，只需要修改配置文件就可以了。代码实现如下:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">Event</span> </span>&#123;</span><br><span class=\"line\">  GOT_MUSHROOM(<span class=\"number\">0</span>),</span><br><span class=\"line\">  GOT_CAPE(<span class=\"number\">1</span>),</span><br><span class=\"line\">  GOT_FIRE(<span class=\"number\">2</span>),</span><br><span class=\"line\">  GOT_MONSTER(<span class=\"number\">3</span>);</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> value;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Event</span><span class=\"params\">(<span class=\"keyword\">int</span> value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.value = value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getValue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MarioStateMachine</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> score;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> State currentState;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> State[][] transitionTable = &#123;</span><br><span class=\"line\">    &#123;SUPER,CAPE,FIRE,SMALL&#125;,</span><br><span class=\"line\">    &#123;SUPER,CAPE,FIRE,SMALL&#125;,</span><br><span class=\"line\">    &#123;CAPE,CAPE,CAPE,SMALL&#125;,</span><br><span class=\"line\">    &#123;FIRE,FIRE,FIRE,SMALL&#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span>[][] actionTable = &#123;</span><br><span class=\"line\">    &#123;+<span class=\"number\">100</span>,+<span class=\"number\">200</span>,+<span class=\"number\">300</span>,+<span class=\"number\">0</span>&#125;,</span><br><span class=\"line\">    &#123;+<span class=\"number\">0</span>,+<span class=\"number\">200</span>,+<span class=\"number\">300</span>,-<span class=\"number\">100</span>&#125;,</span><br><span class=\"line\">    &#123;+<span class=\"number\">0</span>,+<span class=\"number\">0</span>,+<span class=\"number\">0</span>,-<span class=\"number\">200</span>&#125;,</span><br><span class=\"line\">    &#123;+<span class=\"number\">0</span>,+<span class=\"number\">0</span>,+<span class=\"number\">0</span>,-<span class=\"number\">300</span>&#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MarioStateMachine</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.score = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.currentState = State.SMALL;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">obtainMushRoom</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    executeEvent(Event.GOT_MUSHROOM);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">obtainCape</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    executeEvent(Event.GOT_CAPE);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">obtainFireFlower</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    executeEvent(Event.GOT_FIRE);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">meetMonster</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    executeEvent(Event.MET_MONSTER);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">executeEvent</span><span class=\"params\">(Event event)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> stateValue = currentState.getValue();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> eventValue = event.getValue();</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.currentState = transitionTable[stateValue][eventValue];</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.score += actionTable[stateValue][eventValue];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getScore</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.score;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> State <span class=\"title\">getCurrentState</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.currentState;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>状态机实现方式三：状态模式</p>\n<p>查表法的代码实现中，事件触发的都工作只是简单的积分加减，所以用一个int类型的二维数组actionTable就能表示，二维数组中的值表示积分的加减值。但是如果要执行的动作并非这么简单，而是一系列复杂的逻辑操作（比如加减积分、写数据库、发送消息通知等等），就没办法用如此简单的二维数组来表示了，也就是说，查表法的实现方式有一定局限性。</p>\n<p>虽然分支逻辑的实现方式不存在这个问题，但是又存在前面讲的其他问题，比如分支判断逻辑较多，导致代码可读性和可维护性不好等。针对分支逻辑法存在的问题，我们可以使用状态模式来解决。</p>\n<p>状态模式通过将事件触发的状态转移和动作执行拆分到不同的状态类中，来避免分支判断逻辑。</p>\n<p>利用状态模式，来补全MarioStateMachine类。</p>\n<p>IMario时状态的接口，定义了所有的事件。SmallMario、SuperMario、CapeMario、FireMario是IMario接口的实现类，分别对应状态机中的4个状态。原来所有状态转移和动作执行的代码逻辑，都集中在MarioStateMachine类中，现在这些逻辑被分散到了这4个状态类中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">IMario</span> </span>&#123; <span class=\"comment\">//所有状态类的接口</span></span><br><span class=\"line\">  <span class=\"function\">State <span class=\"title\">getName</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">  <span class=\"comment\">//以下是定义的事件</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">obtainMushRoom</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">obtainCape</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">obtainFireFlower</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">meetMonster</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SmallMario</span> <span class=\"keyword\">implements</span> <span class=\"title\">IMario</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> MarioStateMachine stateMachine;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SmallMario</span><span class=\"params\">(MarioStateMachine stateMachine)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.stateMachin = stateMachine;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> State <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> State.SMALL;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">obtainMushRoom</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    stateMachine.setCurrentState(<span class=\"keyword\">new</span> SuperMario(stateMachine));</span><br><span class=\"line\">    stateMachine.setScore(stateMachine.getScore() + <span class=\"number\">100</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">obtainCape</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    stateMachine.setCurrentState(<span class=\"keyword\">new</span> CapeMario(stateMachine));</span><br><span class=\"line\">    stateMachine.setScore(stateMachine.getScore() + <span class=\"number\">200</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">obtainFireFlower</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    stateMachine.setCurrentState(<span class=\"keyword\">new</span> FireMario(stateMachine));</span><br><span class=\"line\">    stateMachine.setScore(stateMachine.getScore() + <span class=\"number\">300</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">meetMonster</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//do nothing...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SuperMario</span> <span class=\"keyword\">implements</span> <span class=\"title\">IMario</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> MarioStateMachine stateMachine;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SuperMario</span><span class=\"params\">(MarioStateMachine stateMachine)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.stateMachine = stateMachine;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> State <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> State.SUPER;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">obtainMushRoom</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//do nothing</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">obtainCape</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    stateMachine.setCurrentState(<span class=\"keyword\">new</span> CapeMario(stateMachine));</span><br><span class=\"line\">    stateMachine.setScore(stateMachine.getScore() + <span class=\"number\">200</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">obtainFireFlower</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    stateMachine.setCurrentState(<span class=\"keyword\">new</span> SmallMario(stateMachine));</span><br><span class=\"line\">    stateMachine.setScore(stateMachine.getScore() - <span class=\"number\">100</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//省略CapeMario、FireMario类</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MarioStateMachine</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> score;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> IMario currentState; <span class=\"comment\">//不再使用枚举来表示状态</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MarioStateMachine</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.score = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.currentState = <span class=\"keyword\">new</span> SmallMario(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">obtainMushRoom</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.currentState.obtainMushRoom();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">obtainCape</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.currentState.obtainCape();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">obtainFireFlower</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.currentState.obtainFireFlower();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">meetMonster</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.currentState.meetMonster();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getScore</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.score;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> State <span class=\"title\">getCurrentState</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.currentState.getName();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setScore</span><span class=\"params\">(<span class=\"keyword\">int</span> score)</span> </span>&#123;</span><br><span class=\"line\">  \t<span class=\"keyword\">this</span>.score = score;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setCurrentState</span><span class=\"params\">(IMario currentState)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.currentState = currentState;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n\n<p>MarioStatemachine和各个状态类之间是双向依赖关系。MarioStateMachine依赖各个状态类是理所当然的，但是，各个状态类为什么要依赖MarioStateMachine呢？这是因为，各个状态类需要更新MarioStateMachine中的两个变量，score和currentState。</p>\n<p>上面的代码还可以继续优化，可以将状态类设计成单例，毕竟状态类中不包含任何成员变量。但是，当将状态类设计成单例之后，我们就无法通过构造函数来传递MarioStateMachine了，而状态类又要依赖MarioStateMachine，这又该如何解决呢？</p>\n<p>可以通过函数参数将MarioStateMachine传递进状态类。根据这个设计思路，对上面代码进行重构。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">IMario</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\">State <span class=\"title\">getName</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">obtainMushRoom</span><span class=\"params\">(MarioStateMachine stateMachine)</span></span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">obtainCape</span><span class=\"params\">(MarioStateMachine stateMachine)</span></span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">obtainFireFlower</span><span class=\"params\">(MarioStateMachine stateMachine)</span></span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">meetMonster</span><span class=\"params\">(MarioStateMachine stateMachine)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SmallMario</span> <span class=\"keyword\">implements</span> <span class=\"title\">IMario</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> SmallMario instance = <span class=\"keyword\">new</span> SmallMario();</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">SmallMario</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> SmallMario <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> State <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> State.SMALL;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">obtainMushRoom</span><span class=\"params\">(MarioStateMachine stateMachine)</span> </span>&#123;</span><br><span class=\"line\">    stateMachine.setCurrentState(SuperMario.getInstance());</span><br><span class=\"line\">    stateMachine.setScore(stateMachine.getScore() + <span class=\"number\">100</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">obtainCape</span><span class=\"params\">(MarioStateMachine stateMachine)</span></span>&#123;</span><br><span class=\"line\">    stateMachine.setCurrentState(CapeMario.getInstance());</span><br><span class=\"line\">    stateMachine.setScore(stateMachine.getScore() + <span class=\"number\">200</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">obtainFireFlower</span><span class=\"params\">(MarioStateMachine stateMachine)</span> </span>&#123;</span><br><span class=\"line\">    stateMachine.setCurrentState(FireMario.getInstance());</span><br><span class=\"line\">    stateMachine.setScore(stateMachine.getScore() + <span class=\"number\">300</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">meetMonster</span><span class=\"params\">(MarioStateMachine stateMachine)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//do nothing</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 省略SuperMario、CapeMario、FireMario类...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MarioStateMachine</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> score;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> IMario currentState;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MarioStateMachine</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.score = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.currentState = SmallMario.getInstance();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">obtainMushRoom</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.currentState.obtainMushRoom(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">obtainCape</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.currentState.obtainCape(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">obtainFireFlower</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.currentState.obtainFireFlower(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">meetMonster</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.currentState.meetMonster(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getScore</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.score;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> State <span class=\"title\">getCurrentState</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.currentState.getName();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setScore</span><span class=\"params\">(<span class=\"keyword\">int</span> score)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.score = score;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setCurrentState</span><span class=\"params\">(IMario currentState)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.currentState = currentState;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>电商下单、外卖下单这种类型的状态机，他们的状态并不多，状态转移也比较简单，但事件触发执行的动作包含的业务逻辑可能会比较复杂，所以，更加推荐使用状态模式来实现。</p>\n<p>状态机三种实现方式比较</p>\n<p>分支逻辑法，利用if-else或者switch-case分支逻辑，参照状态转移图，将每一个状态转移原模原样地直译成代码。对于简单的状态机来说，这种实现方式最简单、最直接，是首选。</p>\n<p>查表法，对于状态很多、状态转移比较复杂的状态机来说，查表法比较合适。通过二维数组来表示状态转移图，能极大地提高代码的可读性和可维护性。</p>\n<p>状态模式，对于状态并不多、状态转移也比较简单，但事件触发执行的动作包含的业务逻辑可能比较复杂的状态机来说，我们首选这种实现方式。</p>\n<p>思考：状态模式的实现还存在一些问题，比如，状态接口中定义了所有的事件函数，这就导致，即便某个状态类并不需要支持其中的某个或者某些事件，但也要实现所有的事件函数。不仅如此，添加一个事件到状态接口，所有的状态类都要做相应的修改。</p>\n<p>实现方式，通过将事件抽象成接口，这样这个状态支持这个事件，那么就实现该接口，如果需要增加一个事件，只需要在需要支持这个事件的状态类实现该事件即可。表示该状态下，支持这个功能。也更面向对象。</p>\n"},{"layout":"post","title":"设计模式之解释器模式","description":"设计模式之解释器模式","date":"2021-06-28T09:16:10.000Z","_content":"解释器模式，它用来描述如何构建一个简单的“语言”解释器。解释器模式更加小众，只在一些特定的领域会被用到，比如编译器、规则引擎、正则表达式。\n\n解释器模式的英文翻译是Interpreter Design Pattern。在GoF的《设计模式》中，是这样定义的：\n\n>Interpreter pattern is used to defines a grammatical representation for a language and provides an interpreter to deal with this grammar.\n\n翻译成中文就是：解释器模式为某个语言定义它的语法（或者叫文法）表示，并定义一个解释器用来处理这个语法。\n\n要想了解“语言”表达的信息，就需要定义相应的语法规则。这样，书写者就可以根据语法规则来写“句子”（专业说法应该是表达式），阅读者根据语法规则来阅读“句子”，这样才能做到信息的正确传递。而解释器模式，就是用来实现根据语法规则解读“句子”的解释器。\n\n假设定义个一个新的加减乘除计算“语言”，语法规则如下：\n\n- 运算符只包含加、减、乘、除，并且没有优先级的概念\n- 表达式中，先书写数字，后书写运算符，空格隔开；\n- 按照先后顺序，取出两个数字和一个运算符计算结果，结果重新放入数字的最头部位置，循环上述过程，直到只剩下一个数字，这个数字就是表达式的最终计算结果。\n\n举个例子来解释下上面的语法规则。\n\n比如“ 8 3 2 4 - + * ”这样一个表达式，我们按照上面的语法规则来处理，取出数字“8 3”和“-”运算符，计算得到 5，于是表达式就变成了“ 5 2 4 + * ”。然后，我们再取出“ 5 2 ”和“ + ”运算符，计算得到 7，表达式就变成了“ 7 4 * ”。最后，我们取出“ 7 4”和“ * ”运算符，最终得到的结果就是 28。\n\n看懂了语法规则，用代码实现下。用户按照上面的规则书写表达式，传递给interpret()函数，就可以得到最终的计算结果。\n\n```java\npublic class ExpressionInterpreter {\n  private Deque<Long> numbers = new LinkedList<>();\n\n  public long interpret(String expression) {\n    String[] elements = expression.split(\" \");\n    int length = elements.length;\n    for (int i = 0; i < (length+1)/2; ++i) {\n      numbers.addLast(Long.parseLong(elements[i]));\n    }\n\n    for (int i = (length+1)/2; i < length; ++i) {\n      String operator = elements[i];\n      boolean isValid = \"+\".equals(operator) || \"-\".equals(operator)\n              || \"*\".equals(operator) || \"/\".equals(operator);\n      if (!isValid) {\n        throw new RuntimeException(\"Expression is invalid: \" + expression);\n      }\n\n      long number1 = numbers.pollFirst();\n      long number2 = numbers.pollFirst();\n      long result = 0;\n      if (operator.equals(\"+\")) {\n        result = number1 + number2;\n      } else if (operator.equals(\"-\")) {\n        result = number1 - number2;\n      } else if (operator.equals(\"*\")) {\n        result = number1 * number2;\n      } else if (operator.equals(\"/\")) {\n        result = number1 / number2;\n      }\n      numbers.addFirst(result);\n    }\n\n    if (numbers.size() != 1) {\n      throw new RuntimeException(\"Expression is invalid: \" + expression);\n    }\n\n    return numbers.pop();\n  }\n}\n```\n\n上面的代码实现中，语法规则的解析都集中在一个函数中，对于简单的语法规则的解析，这样的设计就足够了。但是对于复杂的语法规则的解析，逻辑复杂，代码量多，所有的解析逻辑都耦合在一个函数中，这样显然是不合适的。这个时候，就需要考虑拆分代码，将解析逻辑拆分到独立的小类中。\n\n解释器模式的代码实现比较灵活，没有固定的模板。可以将语法解析的工作拆分到各个小类中，以此来避免大而全的解析类。一般的做法是，将语法规则拆分成一些小的独立的单元，然后对每个单元进行解析，最终合并为对整个语法规则的解析。\n\n前面的语法规则有两类表达式，一类是数字，一类是运算符，运算符又包括加减乘除，利用解释器模式，可以把解析的工作拆分到NumberExpression、AdditionExpression、SubstractionExpression、MultipicationExpression、DivisionExpression这样五个解析类中。\n\n按照这个思路，对代码进行重构。加减乘除解析比较简单，利用解释器模式的设计思路，有点过度设计，主要是为了解释原理。\n\n```java\npublic interface Expression {\n  long interpret();\n}\n\npublic class NumberExpression implements Expression {\n  private long number;\n\n  public NumberExpression(long number) {\n    this.number = number;\n  }\n\n  public NumberExpression(String number) {\n    this.number = Long.parseLong(number);\n  }\n\n  @Override\n  public long interpret() {\n    return this.number;\n  }\n}\n\npublic class AdditionExpression implements Expression {\n  private Expression exp1;\n  private Expression exp2;\n\n  public AdditionExpression(Expression exp1, Expression exp2) {\n    this.exp1 = exp1;\n    this.exp2 = exp2;\n  }\n\n  @Override\n  public long interpret() {\n    return exp1.interpret() + exp2.interpret();\n  }\n}\n// SubstractionExpression/MultiplicationExpression/DivisionExpression与AdditionExpression代码结构类似，这里就省略了\n\npublic class ExpressionInterpreter {\n  private Deque<Expression> numbers = new LinkedList<>();\n\n  public long interpret(String expression) {\n    String[] elements = expression.split(\" \");\n    int length = elements.length;\n    for (int i = 0; i < (length+1)/2; ++i) {\n      numbers.addLast(new NumberExpression(elements[i]));\n    }\n\n    for (int i = (length+1)/2; i < length; ++i) {\n      String operator = elements[i];\n      boolean isValid = \"+\".equals(operator) || \"-\".equals(operator)\n              || \"*\".equals(operator) || \"/\".equals(operator);\n      if (!isValid) {\n        throw new RuntimeException(\"Expression is invalid: \" + expression);\n      }\n\n      Expression exp1 = numbers.pollFirst();\n      Expression exp2 = numbers.pollFirst();\n      Expression combinedExp = null;\n      if (operator.equals(\"+\")) {\n        combinedExp = new AdditionExpression(exp1, exp2);\n      } else if (operator.equals(\"-\")) {\n        combinedExp = new AdditionExpression(exp1, exp2);\n      } else if (operator.equals(\"*\")) {\n        combinedExp = new AdditionExpression(exp1, exp2);\n      } else if (operator.equals(\"/\")) {\n        combinedExp = new AdditionExpression(exp1, exp2);\n      }\n      long result = combinedExp.interpret();\n      numbers.addFirst(new NumberExpression(result));\n    }\n\n    if (numbers.size() != 1) {\n      throw new RuntimeException(\"Expression is invalid: \" + expression);\n    }\n\n    return numbers.pop().interpret();\n  }\n}\n```\n\n解释器实战\n\n在我们平时的项目开发中，监控系统非常重要，它可以时刻监控业务系统的运行情况，及时将异常报告给开发者。一般来讲，监控系统支持开发者自定义告警规则，比如，我们可以用一个表达式来表示一个告警规则。它表达的意思是：每分钟API总出错数超过100或者每分钟或者每分钟API总调用数超过10000就触发告警。\n\n> api_error_per_minute > 100 || api_count_per_minute > 10000\t\n\n在监控系统中，告警模块只负责根据统计数据和告警规则，判断是否触发告警。至于每分钟API接口出错数、每分钟接口调用数等统计数据的计算，是由其他模块来负责的。其他模块将统计数据放到一个Map中（数据的格式如下），发送给告警模块，接下来，只关注告警模块。\n\n```java\nMap<String, Long> apiStat = new HashMap<>();\napiStat.put(\"api_error_per_minute\", 103);\napiStat.put(\"api_count_per_minute\", 987);\n```\n\n为了简化讲解和代码实现，假设自定义的告警规则只包含“||、&&、>、<、==”这五个运算符，其中，“>、<、==”运算符的优先级高于“||、&&”运算符，“&&”运算符优先级高于“||”。在表达式中，任意元素之间需要通过空格来分隔。除此之外，用户可以自定义要监控的 key，比如前面的 api_error_per_minute、api_count_per_minute。\n\n把自定义的告警规则，看作一种特殊的“语言”语法规则。实现一个解释器，就能够根据规则，针对用户输入的数据，判断是否触发告警。利用解释器模式，把解析表达式的逻辑拆分到各个小类中，避免大而复杂的大类的出现。\n\n```java\npublic interface Expression {\n  boolean interpret(Map<String, Long> stats);\n}\n\npublic class GreaterExpression implements Expression {\n  private String key;\n  private long value;\n\n  public GreaterExpression(String strExpression) {\n    String[] elements = strExpression.trim().split(\"\\\\s+\");\n    if (elements.length != 3 || !elements[1].trim().equals(\">\")) {\n      throw new RuntimeException(\"Expression is invalid: \" + strExpression);\n    }\n    this.key = elements[0].trim();\n    this.value = Long.parseLong(elements[2].trim());\n  }\n\n  public GreaterExpression(String key, long value) {\n    this.key = key;\n    this.value = value;\n  }\n\n  @Override\n  public boolean interpret(Map<String, Long> stats) {\n    if (!stats.containsKey(key)) {\n      return false;\n    }\n    long statValue = stats.get(key);\n    return statValue > value;\n  }\n}\n\n// LessExpression/EqualExpression跟GreaterExpression代码类似，这里就省略了\n\npublic class AndExpression implements Expression {\n  private List<Expression> expressions = new ArrayList<>();\n\n  public AndExpression(String strAndExpression) {\n    String[] strExpressions = strAndExpression.split(\"&&\");\n    for (String strExpr : strExpressions) {\n      if (strExpr.contains(\">\")) {\n        expressions.add(new GreaterExpression(strExpr));\n      } else if (strExpr.contains(\"<\")) {\n        expressions.add(new LessExpression(strExpr));\n      } else if (strExpr.contains(\"==\")) {\n        expressions.add(new EqualExpression(strExpr));\n      } else {\n        throw new RuntimeException(\"Expression is invalid: \" + strAndExpression);\n      }\n    }\n  }\n\n  public AndExpression(List<Expression> expressions) {\n    this.expressions.addAll(expressions);\n  }\n\n  @Override\n  public boolean interpret(Map<String, Long> stats) {\n    for (Expression expr : expressions) {\n      if (!expr.interpret(stats)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n}\n\npublic class OrExpression implements Expression {\n  private List<Expression> expressions = new ArrayList<>();\n\n  public OrExpression(String strOrExpression) {\n    String[] andExpressions = strOrExpression.split(\"\\\\|\\\\|\");\n    for (String andExpr : andExpressions) {\n      expressions.add(new AndExpression(andExpr));\n    }\n  }\n\n  public OrExpression(List<Expression> expressions) {\n    this.expressions.addAll(expressions);\n  }\n\n  @Override\n  public boolean interpret(Map<String, Long> stats) {\n    for (Expression expr : expressions) {\n      if (expr.interpret(stats)) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\n\npublic class AlertRuleInterpreter {\n  private Expression expression;\n\n  public AlertRuleInterpreter(String ruleExpression) {\n    this.expression = new OrExpression(ruleExpression);\n  }\n\n  public boolean interpret(Map<String, Long> stats) {\n    return expression.interpret(stats);\n  }\n} \n```\n\n","source":"_posts/设计模式之解释器模式.md","raw":"---\nlayout:    post\ntitle:     设计模式之解释器模式\ncategory:  设计模式之美\ndescription: 设计模式之解释器模式\ntags: 设计模式之美\ndate: 2021/06/28 17:16:10\n---\n解释器模式，它用来描述如何构建一个简单的“语言”解释器。解释器模式更加小众，只在一些特定的领域会被用到，比如编译器、规则引擎、正则表达式。\n\n解释器模式的英文翻译是Interpreter Design Pattern。在GoF的《设计模式》中，是这样定义的：\n\n>Interpreter pattern is used to defines a grammatical representation for a language and provides an interpreter to deal with this grammar.\n\n翻译成中文就是：解释器模式为某个语言定义它的语法（或者叫文法）表示，并定义一个解释器用来处理这个语法。\n\n要想了解“语言”表达的信息，就需要定义相应的语法规则。这样，书写者就可以根据语法规则来写“句子”（专业说法应该是表达式），阅读者根据语法规则来阅读“句子”，这样才能做到信息的正确传递。而解释器模式，就是用来实现根据语法规则解读“句子”的解释器。\n\n假设定义个一个新的加减乘除计算“语言”，语法规则如下：\n\n- 运算符只包含加、减、乘、除，并且没有优先级的概念\n- 表达式中，先书写数字，后书写运算符，空格隔开；\n- 按照先后顺序，取出两个数字和一个运算符计算结果，结果重新放入数字的最头部位置，循环上述过程，直到只剩下一个数字，这个数字就是表达式的最终计算结果。\n\n举个例子来解释下上面的语法规则。\n\n比如“ 8 3 2 4 - + * ”这样一个表达式，我们按照上面的语法规则来处理，取出数字“8 3”和“-”运算符，计算得到 5，于是表达式就变成了“ 5 2 4 + * ”。然后，我们再取出“ 5 2 ”和“ + ”运算符，计算得到 7，表达式就变成了“ 7 4 * ”。最后，我们取出“ 7 4”和“ * ”运算符，最终得到的结果就是 28。\n\n看懂了语法规则，用代码实现下。用户按照上面的规则书写表达式，传递给interpret()函数，就可以得到最终的计算结果。\n\n```java\npublic class ExpressionInterpreter {\n  private Deque<Long> numbers = new LinkedList<>();\n\n  public long interpret(String expression) {\n    String[] elements = expression.split(\" \");\n    int length = elements.length;\n    for (int i = 0; i < (length+1)/2; ++i) {\n      numbers.addLast(Long.parseLong(elements[i]));\n    }\n\n    for (int i = (length+1)/2; i < length; ++i) {\n      String operator = elements[i];\n      boolean isValid = \"+\".equals(operator) || \"-\".equals(operator)\n              || \"*\".equals(operator) || \"/\".equals(operator);\n      if (!isValid) {\n        throw new RuntimeException(\"Expression is invalid: \" + expression);\n      }\n\n      long number1 = numbers.pollFirst();\n      long number2 = numbers.pollFirst();\n      long result = 0;\n      if (operator.equals(\"+\")) {\n        result = number1 + number2;\n      } else if (operator.equals(\"-\")) {\n        result = number1 - number2;\n      } else if (operator.equals(\"*\")) {\n        result = number1 * number2;\n      } else if (operator.equals(\"/\")) {\n        result = number1 / number2;\n      }\n      numbers.addFirst(result);\n    }\n\n    if (numbers.size() != 1) {\n      throw new RuntimeException(\"Expression is invalid: \" + expression);\n    }\n\n    return numbers.pop();\n  }\n}\n```\n\n上面的代码实现中，语法规则的解析都集中在一个函数中，对于简单的语法规则的解析，这样的设计就足够了。但是对于复杂的语法规则的解析，逻辑复杂，代码量多，所有的解析逻辑都耦合在一个函数中，这样显然是不合适的。这个时候，就需要考虑拆分代码，将解析逻辑拆分到独立的小类中。\n\n解释器模式的代码实现比较灵活，没有固定的模板。可以将语法解析的工作拆分到各个小类中，以此来避免大而全的解析类。一般的做法是，将语法规则拆分成一些小的独立的单元，然后对每个单元进行解析，最终合并为对整个语法规则的解析。\n\n前面的语法规则有两类表达式，一类是数字，一类是运算符，运算符又包括加减乘除，利用解释器模式，可以把解析的工作拆分到NumberExpression、AdditionExpression、SubstractionExpression、MultipicationExpression、DivisionExpression这样五个解析类中。\n\n按照这个思路，对代码进行重构。加减乘除解析比较简单，利用解释器模式的设计思路，有点过度设计，主要是为了解释原理。\n\n```java\npublic interface Expression {\n  long interpret();\n}\n\npublic class NumberExpression implements Expression {\n  private long number;\n\n  public NumberExpression(long number) {\n    this.number = number;\n  }\n\n  public NumberExpression(String number) {\n    this.number = Long.parseLong(number);\n  }\n\n  @Override\n  public long interpret() {\n    return this.number;\n  }\n}\n\npublic class AdditionExpression implements Expression {\n  private Expression exp1;\n  private Expression exp2;\n\n  public AdditionExpression(Expression exp1, Expression exp2) {\n    this.exp1 = exp1;\n    this.exp2 = exp2;\n  }\n\n  @Override\n  public long interpret() {\n    return exp1.interpret() + exp2.interpret();\n  }\n}\n// SubstractionExpression/MultiplicationExpression/DivisionExpression与AdditionExpression代码结构类似，这里就省略了\n\npublic class ExpressionInterpreter {\n  private Deque<Expression> numbers = new LinkedList<>();\n\n  public long interpret(String expression) {\n    String[] elements = expression.split(\" \");\n    int length = elements.length;\n    for (int i = 0; i < (length+1)/2; ++i) {\n      numbers.addLast(new NumberExpression(elements[i]));\n    }\n\n    for (int i = (length+1)/2; i < length; ++i) {\n      String operator = elements[i];\n      boolean isValid = \"+\".equals(operator) || \"-\".equals(operator)\n              || \"*\".equals(operator) || \"/\".equals(operator);\n      if (!isValid) {\n        throw new RuntimeException(\"Expression is invalid: \" + expression);\n      }\n\n      Expression exp1 = numbers.pollFirst();\n      Expression exp2 = numbers.pollFirst();\n      Expression combinedExp = null;\n      if (operator.equals(\"+\")) {\n        combinedExp = new AdditionExpression(exp1, exp2);\n      } else if (operator.equals(\"-\")) {\n        combinedExp = new AdditionExpression(exp1, exp2);\n      } else if (operator.equals(\"*\")) {\n        combinedExp = new AdditionExpression(exp1, exp2);\n      } else if (operator.equals(\"/\")) {\n        combinedExp = new AdditionExpression(exp1, exp2);\n      }\n      long result = combinedExp.interpret();\n      numbers.addFirst(new NumberExpression(result));\n    }\n\n    if (numbers.size() != 1) {\n      throw new RuntimeException(\"Expression is invalid: \" + expression);\n    }\n\n    return numbers.pop().interpret();\n  }\n}\n```\n\n解释器实战\n\n在我们平时的项目开发中，监控系统非常重要，它可以时刻监控业务系统的运行情况，及时将异常报告给开发者。一般来讲，监控系统支持开发者自定义告警规则，比如，我们可以用一个表达式来表示一个告警规则。它表达的意思是：每分钟API总出错数超过100或者每分钟或者每分钟API总调用数超过10000就触发告警。\n\n> api_error_per_minute > 100 || api_count_per_minute > 10000\t\n\n在监控系统中，告警模块只负责根据统计数据和告警规则，判断是否触发告警。至于每分钟API接口出错数、每分钟接口调用数等统计数据的计算，是由其他模块来负责的。其他模块将统计数据放到一个Map中（数据的格式如下），发送给告警模块，接下来，只关注告警模块。\n\n```java\nMap<String, Long> apiStat = new HashMap<>();\napiStat.put(\"api_error_per_minute\", 103);\napiStat.put(\"api_count_per_minute\", 987);\n```\n\n为了简化讲解和代码实现，假设自定义的告警规则只包含“||、&&、>、<、==”这五个运算符，其中，“>、<、==”运算符的优先级高于“||、&&”运算符，“&&”运算符优先级高于“||”。在表达式中，任意元素之间需要通过空格来分隔。除此之外，用户可以自定义要监控的 key，比如前面的 api_error_per_minute、api_count_per_minute。\n\n把自定义的告警规则，看作一种特殊的“语言”语法规则。实现一个解释器，就能够根据规则，针对用户输入的数据，判断是否触发告警。利用解释器模式，把解析表达式的逻辑拆分到各个小类中，避免大而复杂的大类的出现。\n\n```java\npublic interface Expression {\n  boolean interpret(Map<String, Long> stats);\n}\n\npublic class GreaterExpression implements Expression {\n  private String key;\n  private long value;\n\n  public GreaterExpression(String strExpression) {\n    String[] elements = strExpression.trim().split(\"\\\\s+\");\n    if (elements.length != 3 || !elements[1].trim().equals(\">\")) {\n      throw new RuntimeException(\"Expression is invalid: \" + strExpression);\n    }\n    this.key = elements[0].trim();\n    this.value = Long.parseLong(elements[2].trim());\n  }\n\n  public GreaterExpression(String key, long value) {\n    this.key = key;\n    this.value = value;\n  }\n\n  @Override\n  public boolean interpret(Map<String, Long> stats) {\n    if (!stats.containsKey(key)) {\n      return false;\n    }\n    long statValue = stats.get(key);\n    return statValue > value;\n  }\n}\n\n// LessExpression/EqualExpression跟GreaterExpression代码类似，这里就省略了\n\npublic class AndExpression implements Expression {\n  private List<Expression> expressions = new ArrayList<>();\n\n  public AndExpression(String strAndExpression) {\n    String[] strExpressions = strAndExpression.split(\"&&\");\n    for (String strExpr : strExpressions) {\n      if (strExpr.contains(\">\")) {\n        expressions.add(new GreaterExpression(strExpr));\n      } else if (strExpr.contains(\"<\")) {\n        expressions.add(new LessExpression(strExpr));\n      } else if (strExpr.contains(\"==\")) {\n        expressions.add(new EqualExpression(strExpr));\n      } else {\n        throw new RuntimeException(\"Expression is invalid: \" + strAndExpression);\n      }\n    }\n  }\n\n  public AndExpression(List<Expression> expressions) {\n    this.expressions.addAll(expressions);\n  }\n\n  @Override\n  public boolean interpret(Map<String, Long> stats) {\n    for (Expression expr : expressions) {\n      if (!expr.interpret(stats)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n}\n\npublic class OrExpression implements Expression {\n  private List<Expression> expressions = new ArrayList<>();\n\n  public OrExpression(String strOrExpression) {\n    String[] andExpressions = strOrExpression.split(\"\\\\|\\\\|\");\n    for (String andExpr : andExpressions) {\n      expressions.add(new AndExpression(andExpr));\n    }\n  }\n\n  public OrExpression(List<Expression> expressions) {\n    this.expressions.addAll(expressions);\n  }\n\n  @Override\n  public boolean interpret(Map<String, Long> stats) {\n    for (Expression expr : expressions) {\n      if (expr.interpret(stats)) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\n\npublic class AlertRuleInterpreter {\n  private Expression expression;\n\n  public AlertRuleInterpreter(String ruleExpression) {\n    this.expression = new OrExpression(ruleExpression);\n  }\n\n  public boolean interpret(Map<String, Long> stats) {\n    return expression.interpret(stats);\n  }\n} \n```\n\n","slug":"设计模式之解释器模式","published":1,"updated":"2021-06-28T09:16:10.000Z","comments":1,"photos":[],"link":"","_id":"cm1m304xv002b31b4eqsn1r6q","content":"<p>解释器模式，它用来描述如何构建一个简单的“语言”解释器。解释器模式更加小众，只在一些特定的领域会被用到，比如编译器、规则引擎、正则表达式。</p>\n<p>解释器模式的英文翻译是Interpreter Design Pattern。在GoF的《设计模式》中，是这样定义的：</p>\n<blockquote>\n<p>Interpreter pattern is used to defines a grammatical representation for a language and provides an interpreter to deal with this grammar.</p>\n</blockquote>\n<p>翻译成中文就是：解释器模式为某个语言定义它的语法（或者叫文法）表示，并定义一个解释器用来处理这个语法。</p>\n<p>要想了解“语言”表达的信息，就需要定义相应的语法规则。这样，书写者就可以根据语法规则来写“句子”（专业说法应该是表达式），阅读者根据语法规则来阅读“句子”，这样才能做到信息的正确传递。而解释器模式，就是用来实现根据语法规则解读“句子”的解释器。</p>\n<p>假设定义个一个新的加减乘除计算“语言”，语法规则如下：</p>\n<ul>\n<li>运算符只包含加、减、乘、除，并且没有优先级的概念</li>\n<li>表达式中，先书写数字，后书写运算符，空格隔开；</li>\n<li>按照先后顺序，取出两个数字和一个运算符计算结果，结果重新放入数字的最头部位置，循环上述过程，直到只剩下一个数字，这个数字就是表达式的最终计算结果。</li>\n</ul>\n<p>举个例子来解释下上面的语法规则。</p>\n<p>比如“ 8 3 2 4 - + * ”这样一个表达式，我们按照上面的语法规则来处理，取出数字“8 3”和“-”运算符，计算得到 5，于是表达式就变成了“ 5 2 4 + * ”。然后，我们再取出“ 5 2 ”和“ + ”运算符，计算得到 7，表达式就变成了“ 7 4 * ”。最后，我们取出“ 7 4”和“ * ”运算符，最终得到的结果就是 28。</p>\n<p>看懂了语法规则，用代码实现下。用户按照上面的规则书写表达式，传递给interpret()函数，就可以得到最终的计算结果。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExpressionInterpreter</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Deque&lt;Long&gt; numbers = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">interpret</span><span class=\"params\">(String expression)</span> </span>&#123;</span><br><span class=\"line\">    String[] elements = expression.split(<span class=\"string\">&quot; &quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> length = elements.length;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; (length+<span class=\"number\">1</span>)/<span class=\"number\">2</span>; ++i) &#123;</span><br><span class=\"line\">      numbers.addLast(Long.parseLong(elements[i]));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = (length+<span class=\"number\">1</span>)/<span class=\"number\">2</span>; i &lt; length; ++i) &#123;</span><br><span class=\"line\">      String operator = elements[i];</span><br><span class=\"line\">      <span class=\"keyword\">boolean</span> isValid = <span class=\"string\">&quot;+&quot;</span>.equals(operator) || <span class=\"string\">&quot;-&quot;</span>.equals(operator)</span><br><span class=\"line\">              || <span class=\"string\">&quot;*&quot;</span>.equals(operator) || <span class=\"string\">&quot;/&quot;</span>.equals(operator);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!isValid) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">&quot;Expression is invalid: &quot;</span> + expression);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">long</span> number1 = numbers.pollFirst();</span><br><span class=\"line\">      <span class=\"keyword\">long</span> number2 = numbers.pollFirst();</span><br><span class=\"line\">      <span class=\"keyword\">long</span> result = <span class=\"number\">0</span>;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (operator.equals(<span class=\"string\">&quot;+&quot;</span>)) &#123;</span><br><span class=\"line\">        result = number1 + number2;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (operator.equals(<span class=\"string\">&quot;-&quot;</span>)) &#123;</span><br><span class=\"line\">        result = number1 - number2;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (operator.equals(<span class=\"string\">&quot;*&quot;</span>)) &#123;</span><br><span class=\"line\">        result = number1 * number2;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (operator.equals(<span class=\"string\">&quot;/&quot;</span>)) &#123;</span><br><span class=\"line\">        result = number1 / number2;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      numbers.addFirst(result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (numbers.size() != <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">&quot;Expression is invalid: &quot;</span> + expression);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> numbers.pop();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的代码实现中，语法规则的解析都集中在一个函数中，对于简单的语法规则的解析，这样的设计就足够了。但是对于复杂的语法规则的解析，逻辑复杂，代码量多，所有的解析逻辑都耦合在一个函数中，这样显然是不合适的。这个时候，就需要考虑拆分代码，将解析逻辑拆分到独立的小类中。</p>\n<p>解释器模式的代码实现比较灵活，没有固定的模板。可以将语法解析的工作拆分到各个小类中，以此来避免大而全的解析类。一般的做法是，将语法规则拆分成一些小的独立的单元，然后对每个单元进行解析，最终合并为对整个语法规则的解析。</p>\n<p>前面的语法规则有两类表达式，一类是数字，一类是运算符，运算符又包括加减乘除，利用解释器模式，可以把解析的工作拆分到NumberExpression、AdditionExpression、SubstractionExpression、MultipicationExpression、DivisionExpression这样五个解析类中。</p>\n<p>按照这个思路，对代码进行重构。加减乘除解析比较简单，利用解释器模式的设计思路，有点过度设计，主要是为了解释原理。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Expression</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">long</span> <span class=\"title\">interpret</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NumberExpression</span> <span class=\"keyword\">implements</span> <span class=\"title\">Expression</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> number;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">NumberExpression</span><span class=\"params\">(<span class=\"keyword\">long</span> number)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.number = number;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">NumberExpression</span><span class=\"params\">(String number)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.number = Long.parseLong(number);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">interpret</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.number;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AdditionExpression</span> <span class=\"keyword\">implements</span> <span class=\"title\">Expression</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Expression exp1;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Expression exp2;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">AdditionExpression</span><span class=\"params\">(Expression exp1, Expression exp2)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.exp1 = exp1;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.exp2 = exp2;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">interpret</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> exp1.interpret() + exp2.interpret();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// SubstractionExpression/MultiplicationExpression/DivisionExpression与AdditionExpression代码结构类似，这里就省略了</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExpressionInterpreter</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Deque&lt;Expression&gt; numbers = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">interpret</span><span class=\"params\">(String expression)</span> </span>&#123;</span><br><span class=\"line\">    String[] elements = expression.split(<span class=\"string\">&quot; &quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> length = elements.length;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; (length+<span class=\"number\">1</span>)/<span class=\"number\">2</span>; ++i) &#123;</span><br><span class=\"line\">      numbers.addLast(<span class=\"keyword\">new</span> NumberExpression(elements[i]));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = (length+<span class=\"number\">1</span>)/<span class=\"number\">2</span>; i &lt; length; ++i) &#123;</span><br><span class=\"line\">      String operator = elements[i];</span><br><span class=\"line\">      <span class=\"keyword\">boolean</span> isValid = <span class=\"string\">&quot;+&quot;</span>.equals(operator) || <span class=\"string\">&quot;-&quot;</span>.equals(operator)</span><br><span class=\"line\">              || <span class=\"string\">&quot;*&quot;</span>.equals(operator) || <span class=\"string\">&quot;/&quot;</span>.equals(operator);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!isValid) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">&quot;Expression is invalid: &quot;</span> + expression);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      Expression exp1 = numbers.pollFirst();</span><br><span class=\"line\">      Expression exp2 = numbers.pollFirst();</span><br><span class=\"line\">      Expression combinedExp = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (operator.equals(<span class=\"string\">&quot;+&quot;</span>)) &#123;</span><br><span class=\"line\">        combinedExp = <span class=\"keyword\">new</span> AdditionExpression(exp1, exp2);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (operator.equals(<span class=\"string\">&quot;-&quot;</span>)) &#123;</span><br><span class=\"line\">        combinedExp = <span class=\"keyword\">new</span> AdditionExpression(exp1, exp2);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (operator.equals(<span class=\"string\">&quot;*&quot;</span>)) &#123;</span><br><span class=\"line\">        combinedExp = <span class=\"keyword\">new</span> AdditionExpression(exp1, exp2);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (operator.equals(<span class=\"string\">&quot;/&quot;</span>)) &#123;</span><br><span class=\"line\">        combinedExp = <span class=\"keyword\">new</span> AdditionExpression(exp1, exp2);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">long</span> result = combinedExp.interpret();</span><br><span class=\"line\">      numbers.addFirst(<span class=\"keyword\">new</span> NumberExpression(result));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (numbers.size() != <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">&quot;Expression is invalid: &quot;</span> + expression);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> numbers.pop().interpret();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>解释器实战</p>\n<p>在我们平时的项目开发中，监控系统非常重要，它可以时刻监控业务系统的运行情况，及时将异常报告给开发者。一般来讲，监控系统支持开发者自定义告警规则，比如，我们可以用一个表达式来表示一个告警规则。它表达的意思是：每分钟API总出错数超过100或者每分钟或者每分钟API总调用数超过10000就触发告警。</p>\n<blockquote>\n<p>api_error_per_minute &gt; 100 || api_count_per_minute &gt; 10000    </p>\n</blockquote>\n<p>在监控系统中，告警模块只负责根据统计数据和告警规则，判断是否触发告警。至于每分钟API接口出错数、每分钟接口调用数等统计数据的计算，是由其他模块来负责的。其他模块将统计数据放到一个Map中（数据的格式如下），发送给告警模块，接下来，只关注告警模块。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;String, Long&gt; apiStat = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">apiStat.put(<span class=\"string\">&quot;api_error_per_minute&quot;</span>, <span class=\"number\">103</span>);</span><br><span class=\"line\">apiStat.put(<span class=\"string\">&quot;api_count_per_minute&quot;</span>, <span class=\"number\">987</span>);</span><br></pre></td></tr></table></figure>\n\n<p>为了简化讲解和代码实现，假设自定义的告警规则只包含“||、&amp;&amp;、&gt;、&lt;、==”这五个运算符，其中，“&gt;、&lt;、==”运算符的优先级高于“||、&amp;&amp;”运算符，“&amp;&amp;”运算符优先级高于“||”。在表达式中，任意元素之间需要通过空格来分隔。除此之外，用户可以自定义要监控的 key，比如前面的 api_error_per_minute、api_count_per_minute。</p>\n<p>把自定义的告警规则，看作一种特殊的“语言”语法规则。实现一个解释器，就能够根据规则，针对用户输入的数据，判断是否触发告警。利用解释器模式，把解析表达式的逻辑拆分到各个小类中，避免大而复杂的大类的出现。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Expression</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">interpret</span><span class=\"params\">(Map&lt;String, Long&gt; stats)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GreaterExpression</span> <span class=\"keyword\">implements</span> <span class=\"title\">Expression</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> String key;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> value;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">GreaterExpression</span><span class=\"params\">(String strExpression)</span> </span>&#123;</span><br><span class=\"line\">    String[] elements = strExpression.trim().split(<span class=\"string\">&quot;\\\\s+&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (elements.length != <span class=\"number\">3</span> || !elements[<span class=\"number\">1</span>].trim().equals(<span class=\"string\">&quot;&gt;&quot;</span>)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">&quot;Expression is invalid: &quot;</span> + strExpression);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.key = elements[<span class=\"number\">0</span>].trim();</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.value = Long.parseLong(elements[<span class=\"number\">2</span>].trim());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">GreaterExpression</span><span class=\"params\">(String key, <span class=\"keyword\">long</span> value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.key = key;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.value = value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">interpret</span><span class=\"params\">(Map&lt;String, Long&gt; stats)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!stats.containsKey(key)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> statValue = stats.get(key);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> statValue &gt; value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// LessExpression/EqualExpression跟GreaterExpression代码类似，这里就省略了</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AndExpression</span> <span class=\"keyword\">implements</span> <span class=\"title\">Expression</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> List&lt;Expression&gt; expressions = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">AndExpression</span><span class=\"params\">(String strAndExpression)</span> </span>&#123;</span><br><span class=\"line\">    String[] strExpressions = strAndExpression.split(<span class=\"string\">&quot;&amp;&amp;&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (String strExpr : strExpressions) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (strExpr.contains(<span class=\"string\">&quot;&gt;&quot;</span>)) &#123;</span><br><span class=\"line\">        expressions.add(<span class=\"keyword\">new</span> GreaterExpression(strExpr));</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (strExpr.contains(<span class=\"string\">&quot;&lt;&quot;</span>)) &#123;</span><br><span class=\"line\">        expressions.add(<span class=\"keyword\">new</span> LessExpression(strExpr));</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (strExpr.contains(<span class=\"string\">&quot;==&quot;</span>)) &#123;</span><br><span class=\"line\">        expressions.add(<span class=\"keyword\">new</span> EqualExpression(strExpr));</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">&quot;Expression is invalid: &quot;</span> + strAndExpression);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">AndExpression</span><span class=\"params\">(List&lt;Expression&gt; expressions)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.expressions.addAll(expressions);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">interpret</span><span class=\"params\">(Map&lt;String, Long&gt; stats)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Expression expr : expressions) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!expr.interpret(stats)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OrExpression</span> <span class=\"keyword\">implements</span> <span class=\"title\">Expression</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> List&lt;Expression&gt; expressions = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">OrExpression</span><span class=\"params\">(String strOrExpression)</span> </span>&#123;</span><br><span class=\"line\">    String[] andExpressions = strOrExpression.split(<span class=\"string\">&quot;\\\\|\\\\|&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (String andExpr : andExpressions) &#123;</span><br><span class=\"line\">      expressions.add(<span class=\"keyword\">new</span> AndExpression(andExpr));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">OrExpression</span><span class=\"params\">(List&lt;Expression&gt; expressions)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.expressions.addAll(expressions);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">interpret</span><span class=\"params\">(Map&lt;String, Long&gt; stats)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Expression expr : expressions) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (expr.interpret(stats)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AlertRuleInterpreter</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Expression expression;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">AlertRuleInterpreter</span><span class=\"params\">(String ruleExpression)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.expression = <span class=\"keyword\">new</span> OrExpression(ruleExpression);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">interpret</span><span class=\"params\">(Map&lt;String, Long&gt; stats)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> expression.interpret(stats);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<p>解释器模式，它用来描述如何构建一个简单的“语言”解释器。解释器模式更加小众，只在一些特定的领域会被用到，比如编译器、规则引擎、正则表达式。</p>\n<p>解释器模式的英文翻译是Interpreter Design Pattern。在GoF的《设计模式》中，是这样定义的：</p>\n<blockquote>\n<p>Interpreter pattern is used to defines a grammatical representation for a language and provides an interpreter to deal with this grammar.</p>\n</blockquote>\n<p>翻译成中文就是：解释器模式为某个语言定义它的语法（或者叫文法）表示，并定义一个解释器用来处理这个语法。</p>\n<p>要想了解“语言”表达的信息，就需要定义相应的语法规则。这样，书写者就可以根据语法规则来写“句子”（专业说法应该是表达式），阅读者根据语法规则来阅读“句子”，这样才能做到信息的正确传递。而解释器模式，就是用来实现根据语法规则解读“句子”的解释器。</p>\n<p>假设定义个一个新的加减乘除计算“语言”，语法规则如下：</p>\n<ul>\n<li>运算符只包含加、减、乘、除，并且没有优先级的概念</li>\n<li>表达式中，先书写数字，后书写运算符，空格隔开；</li>\n<li>按照先后顺序，取出两个数字和一个运算符计算结果，结果重新放入数字的最头部位置，循环上述过程，直到只剩下一个数字，这个数字就是表达式的最终计算结果。</li>\n</ul>\n<p>举个例子来解释下上面的语法规则。</p>\n<p>比如“ 8 3 2 4 - + * ”这样一个表达式，我们按照上面的语法规则来处理，取出数字“8 3”和“-”运算符，计算得到 5，于是表达式就变成了“ 5 2 4 + * ”。然后，我们再取出“ 5 2 ”和“ + ”运算符，计算得到 7，表达式就变成了“ 7 4 * ”。最后，我们取出“ 7 4”和“ * ”运算符，最终得到的结果就是 28。</p>\n<p>看懂了语法规则，用代码实现下。用户按照上面的规则书写表达式，传递给interpret()函数，就可以得到最终的计算结果。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExpressionInterpreter</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Deque&lt;Long&gt; numbers = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">interpret</span><span class=\"params\">(String expression)</span> </span>&#123;</span><br><span class=\"line\">    String[] elements = expression.split(<span class=\"string\">&quot; &quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> length = elements.length;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; (length+<span class=\"number\">1</span>)/<span class=\"number\">2</span>; ++i) &#123;</span><br><span class=\"line\">      numbers.addLast(Long.parseLong(elements[i]));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = (length+<span class=\"number\">1</span>)/<span class=\"number\">2</span>; i &lt; length; ++i) &#123;</span><br><span class=\"line\">      String operator = elements[i];</span><br><span class=\"line\">      <span class=\"keyword\">boolean</span> isValid = <span class=\"string\">&quot;+&quot;</span>.equals(operator) || <span class=\"string\">&quot;-&quot;</span>.equals(operator)</span><br><span class=\"line\">              || <span class=\"string\">&quot;*&quot;</span>.equals(operator) || <span class=\"string\">&quot;/&quot;</span>.equals(operator);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!isValid) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">&quot;Expression is invalid: &quot;</span> + expression);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">long</span> number1 = numbers.pollFirst();</span><br><span class=\"line\">      <span class=\"keyword\">long</span> number2 = numbers.pollFirst();</span><br><span class=\"line\">      <span class=\"keyword\">long</span> result = <span class=\"number\">0</span>;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (operator.equals(<span class=\"string\">&quot;+&quot;</span>)) &#123;</span><br><span class=\"line\">        result = number1 + number2;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (operator.equals(<span class=\"string\">&quot;-&quot;</span>)) &#123;</span><br><span class=\"line\">        result = number1 - number2;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (operator.equals(<span class=\"string\">&quot;*&quot;</span>)) &#123;</span><br><span class=\"line\">        result = number1 * number2;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (operator.equals(<span class=\"string\">&quot;/&quot;</span>)) &#123;</span><br><span class=\"line\">        result = number1 / number2;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      numbers.addFirst(result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (numbers.size() != <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">&quot;Expression is invalid: &quot;</span> + expression);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> numbers.pop();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的代码实现中，语法规则的解析都集中在一个函数中，对于简单的语法规则的解析，这样的设计就足够了。但是对于复杂的语法规则的解析，逻辑复杂，代码量多，所有的解析逻辑都耦合在一个函数中，这样显然是不合适的。这个时候，就需要考虑拆分代码，将解析逻辑拆分到独立的小类中。</p>\n<p>解释器模式的代码实现比较灵活，没有固定的模板。可以将语法解析的工作拆分到各个小类中，以此来避免大而全的解析类。一般的做法是，将语法规则拆分成一些小的独立的单元，然后对每个单元进行解析，最终合并为对整个语法规则的解析。</p>\n<p>前面的语法规则有两类表达式，一类是数字，一类是运算符，运算符又包括加减乘除，利用解释器模式，可以把解析的工作拆分到NumberExpression、AdditionExpression、SubstractionExpression、MultipicationExpression、DivisionExpression这样五个解析类中。</p>\n<p>按照这个思路，对代码进行重构。加减乘除解析比较简单，利用解释器模式的设计思路，有点过度设计，主要是为了解释原理。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Expression</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">long</span> <span class=\"title\">interpret</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NumberExpression</span> <span class=\"keyword\">implements</span> <span class=\"title\">Expression</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> number;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">NumberExpression</span><span class=\"params\">(<span class=\"keyword\">long</span> number)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.number = number;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">NumberExpression</span><span class=\"params\">(String number)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.number = Long.parseLong(number);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">interpret</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.number;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AdditionExpression</span> <span class=\"keyword\">implements</span> <span class=\"title\">Expression</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Expression exp1;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Expression exp2;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">AdditionExpression</span><span class=\"params\">(Expression exp1, Expression exp2)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.exp1 = exp1;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.exp2 = exp2;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">interpret</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> exp1.interpret() + exp2.interpret();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// SubstractionExpression/MultiplicationExpression/DivisionExpression与AdditionExpression代码结构类似，这里就省略了</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExpressionInterpreter</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Deque&lt;Expression&gt; numbers = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">interpret</span><span class=\"params\">(String expression)</span> </span>&#123;</span><br><span class=\"line\">    String[] elements = expression.split(<span class=\"string\">&quot; &quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> length = elements.length;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; (length+<span class=\"number\">1</span>)/<span class=\"number\">2</span>; ++i) &#123;</span><br><span class=\"line\">      numbers.addLast(<span class=\"keyword\">new</span> NumberExpression(elements[i]));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = (length+<span class=\"number\">1</span>)/<span class=\"number\">2</span>; i &lt; length; ++i) &#123;</span><br><span class=\"line\">      String operator = elements[i];</span><br><span class=\"line\">      <span class=\"keyword\">boolean</span> isValid = <span class=\"string\">&quot;+&quot;</span>.equals(operator) || <span class=\"string\">&quot;-&quot;</span>.equals(operator)</span><br><span class=\"line\">              || <span class=\"string\">&quot;*&quot;</span>.equals(operator) || <span class=\"string\">&quot;/&quot;</span>.equals(operator);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!isValid) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">&quot;Expression is invalid: &quot;</span> + expression);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      Expression exp1 = numbers.pollFirst();</span><br><span class=\"line\">      Expression exp2 = numbers.pollFirst();</span><br><span class=\"line\">      Expression combinedExp = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (operator.equals(<span class=\"string\">&quot;+&quot;</span>)) &#123;</span><br><span class=\"line\">        combinedExp = <span class=\"keyword\">new</span> AdditionExpression(exp1, exp2);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (operator.equals(<span class=\"string\">&quot;-&quot;</span>)) &#123;</span><br><span class=\"line\">        combinedExp = <span class=\"keyword\">new</span> AdditionExpression(exp1, exp2);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (operator.equals(<span class=\"string\">&quot;*&quot;</span>)) &#123;</span><br><span class=\"line\">        combinedExp = <span class=\"keyword\">new</span> AdditionExpression(exp1, exp2);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (operator.equals(<span class=\"string\">&quot;/&quot;</span>)) &#123;</span><br><span class=\"line\">        combinedExp = <span class=\"keyword\">new</span> AdditionExpression(exp1, exp2);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">long</span> result = combinedExp.interpret();</span><br><span class=\"line\">      numbers.addFirst(<span class=\"keyword\">new</span> NumberExpression(result));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (numbers.size() != <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">&quot;Expression is invalid: &quot;</span> + expression);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> numbers.pop().interpret();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>解释器实战</p>\n<p>在我们平时的项目开发中，监控系统非常重要，它可以时刻监控业务系统的运行情况，及时将异常报告给开发者。一般来讲，监控系统支持开发者自定义告警规则，比如，我们可以用一个表达式来表示一个告警规则。它表达的意思是：每分钟API总出错数超过100或者每分钟或者每分钟API总调用数超过10000就触发告警。</p>\n<blockquote>\n<p>api_error_per_minute &gt; 100 || api_count_per_minute &gt; 10000    </p>\n</blockquote>\n<p>在监控系统中，告警模块只负责根据统计数据和告警规则，判断是否触发告警。至于每分钟API接口出错数、每分钟接口调用数等统计数据的计算，是由其他模块来负责的。其他模块将统计数据放到一个Map中（数据的格式如下），发送给告警模块，接下来，只关注告警模块。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;String, Long&gt; apiStat = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">apiStat.put(<span class=\"string\">&quot;api_error_per_minute&quot;</span>, <span class=\"number\">103</span>);</span><br><span class=\"line\">apiStat.put(<span class=\"string\">&quot;api_count_per_minute&quot;</span>, <span class=\"number\">987</span>);</span><br></pre></td></tr></table></figure>\n\n<p>为了简化讲解和代码实现，假设自定义的告警规则只包含“||、&amp;&amp;、&gt;、&lt;、==”这五个运算符，其中，“&gt;、&lt;、==”运算符的优先级高于“||、&amp;&amp;”运算符，“&amp;&amp;”运算符优先级高于“||”。在表达式中，任意元素之间需要通过空格来分隔。除此之外，用户可以自定义要监控的 key，比如前面的 api_error_per_minute、api_count_per_minute。</p>\n<p>把自定义的告警规则，看作一种特殊的“语言”语法规则。实现一个解释器，就能够根据规则，针对用户输入的数据，判断是否触发告警。利用解释器模式，把解析表达式的逻辑拆分到各个小类中，避免大而复杂的大类的出现。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Expression</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">interpret</span><span class=\"params\">(Map&lt;String, Long&gt; stats)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GreaterExpression</span> <span class=\"keyword\">implements</span> <span class=\"title\">Expression</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> String key;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> value;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">GreaterExpression</span><span class=\"params\">(String strExpression)</span> </span>&#123;</span><br><span class=\"line\">    String[] elements = strExpression.trim().split(<span class=\"string\">&quot;\\\\s+&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (elements.length != <span class=\"number\">3</span> || !elements[<span class=\"number\">1</span>].trim().equals(<span class=\"string\">&quot;&gt;&quot;</span>)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">&quot;Expression is invalid: &quot;</span> + strExpression);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.key = elements[<span class=\"number\">0</span>].trim();</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.value = Long.parseLong(elements[<span class=\"number\">2</span>].trim());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">GreaterExpression</span><span class=\"params\">(String key, <span class=\"keyword\">long</span> value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.key = key;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.value = value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">interpret</span><span class=\"params\">(Map&lt;String, Long&gt; stats)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!stats.containsKey(key)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> statValue = stats.get(key);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> statValue &gt; value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// LessExpression/EqualExpression跟GreaterExpression代码类似，这里就省略了</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AndExpression</span> <span class=\"keyword\">implements</span> <span class=\"title\">Expression</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> List&lt;Expression&gt; expressions = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">AndExpression</span><span class=\"params\">(String strAndExpression)</span> </span>&#123;</span><br><span class=\"line\">    String[] strExpressions = strAndExpression.split(<span class=\"string\">&quot;&amp;&amp;&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (String strExpr : strExpressions) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (strExpr.contains(<span class=\"string\">&quot;&gt;&quot;</span>)) &#123;</span><br><span class=\"line\">        expressions.add(<span class=\"keyword\">new</span> GreaterExpression(strExpr));</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (strExpr.contains(<span class=\"string\">&quot;&lt;&quot;</span>)) &#123;</span><br><span class=\"line\">        expressions.add(<span class=\"keyword\">new</span> LessExpression(strExpr));</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (strExpr.contains(<span class=\"string\">&quot;==&quot;</span>)) &#123;</span><br><span class=\"line\">        expressions.add(<span class=\"keyword\">new</span> EqualExpression(strExpr));</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">&quot;Expression is invalid: &quot;</span> + strAndExpression);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">AndExpression</span><span class=\"params\">(List&lt;Expression&gt; expressions)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.expressions.addAll(expressions);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">interpret</span><span class=\"params\">(Map&lt;String, Long&gt; stats)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Expression expr : expressions) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!expr.interpret(stats)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OrExpression</span> <span class=\"keyword\">implements</span> <span class=\"title\">Expression</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> List&lt;Expression&gt; expressions = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">OrExpression</span><span class=\"params\">(String strOrExpression)</span> </span>&#123;</span><br><span class=\"line\">    String[] andExpressions = strOrExpression.split(<span class=\"string\">&quot;\\\\|\\\\|&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (String andExpr : andExpressions) &#123;</span><br><span class=\"line\">      expressions.add(<span class=\"keyword\">new</span> AndExpression(andExpr));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">OrExpression</span><span class=\"params\">(List&lt;Expression&gt; expressions)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.expressions.addAll(expressions);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">interpret</span><span class=\"params\">(Map&lt;String, Long&gt; stats)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Expression expr : expressions) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (expr.interpret(stats)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AlertRuleInterpreter</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Expression expression;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">AlertRuleInterpreter</span><span class=\"params\">(String ruleExpression)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.expression = <span class=\"keyword\">new</span> OrExpression(ruleExpression);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">interpret</span><span class=\"params\">(Map&lt;String, Long&gt; stats)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> expression.interpret(stats);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n\n"},{"layout":"post","title":"设计模式之适配器模式","description":"设计模式之适配器模式","date":"2021-05-31T05:26:10.000Z","_content":"\n#### 适配器模式的原理与实现\n\n适配器模式的英文翻译是Adapter Design Pattern。这个模式就是用来做适配的，它将不兼容的接口转换为可兼容的接口，让原本由于接口不兼容而不能一起工作的类可以一起工作。对于这个模式，又一个经常被拿来解释它的例子，就是USB转接头充当适配器，把两种不兼容的接口，通过转接变得可以一起工作。\n\n原理很简单，看下代码实现。适配器模式有两种实现方式：类适配器和对象适配器。其中，类适配器使用继承关系来实现，对象适配器使用组合关系来实现。具体的代码实现如下所示。其中ITarget表示要转化成的接口定义，Adaptee是一组不兼容ITarget接口定义的接口，Adaptor将Adaptee转换成一组符合ITarget接口定义的接口。\n\n```java\n//类适配器：基于继承\npublic interface ITarget {\n  void f1();\n  void f2();\n  void fc();\n}\n\npublic class Adaptee {\n  public void fa() {}\n  public void fb() {}\n  public void fc() {}\n}\n\npublic class Adaptor extends Adaptee implements ITarget {\n  public void f1() {\n    super.fa();\n  }\n  \n  public void f2() {\n    //重新实现f2()\n  }\n  \n  //这里fc()不需要实现，直接继承自Adaptee，这是跟对象适配器最大的不同点\n}\n```\n\n```java\n//对象适配器：基于组合\npublic interface ITarget {\n  void f1();\n  void f2();\n  void fc();\n}\n\npublic class Adaptee {\n  public void fa() {}\n  public void fb() {}\n  public void fc() {}\n}\n\npublic class Adaptor implements ITarget {\n  private Adaptee adaptee;\n  \n  public Adaptor(Adaptee adaptee) {\n    this.adaptee = adaptee;\n  }\n  \n  public void f1() {\n    adaptee.fa();//委托给Adaptee\n  }\n  \n  public void f2() {\n    //...重新实现f2()...\n  }\n  \n  public void fc() {\n    adaptee.fc();\n  }\n}\n```\n\n实际开发中，应该选择哪种实现呢？判断标准有两个，一个是Adaptee接口的个数，另一个是Adaptee和ITarget的契合程度。\n\n- 如果Adaptdd接口并不多，那两种实现方式都可以。\n- 如果Adaptee接口很多，而且Adaptee和ITarget接口定义大部分都相同， 那我们推荐使用类适配器，因为Adaptor复用父类Adaptee的接口，比起对象适配器的实现方式，Adaptor的代码量要少一些。\n- 如果Adaptee接口很多，而且Adaptee和ITarget接口定义大部分都不相同，那我们推荐使用对象适配器，因为组合结构相对于继承更加灵活。\n\n#### 适配器模式应用场景总结\n\n一般来说，适配器模式可以看作一种“补偿模式”，用来不久设计上的缺陷。应用这种模式算是“无奈之举”。如果在设计初期，我们就能协调规避接口不兼容的问题，那这种模式就没有应用的机会了。\n\n1.封装有缺陷的接口设计\n\n假设我们依赖的外部系统在接口设计方面有缺陷（比如包含大量静态方法），引入之后会影响到我们自身代码的可测试性。为了隔离设计上的缺陷，我们希望对外部系统提供的接口进行二次封装，抽象出更好的接口，这个时候就可以使用适配器模式了。\n\n```java\npublic class CD { //这个类来自外部sdk，我们无权修改它的代码\n  //...\n  public static void staticFunction1() { \n    //... \n  }\n  \n  public void uglyNamingFunction2() { \n    //...\n  }\n\n  public void tooManyParamsFunction3(int paramA, int paramB, int ... params) { \n    //... \n }\n  \n   public void lowPerformanceFunction4() { \n    //... \n }\n}\n\n// 使用适配器模式进行重构\npublic class ITarget {\n  void function1();\n  void function2();\n  void function3(ParamsWrapperDefinition paramsWrapper);\n  void function4();\n  //...\n}\n// 注意：适配器类的命名不一定非得末尾带Adaptor\npublic class CDAdaptor extends CD implements ITarget {\n  //...\n  public void function1() {\n     super.staticFunction1();\n  }\n  \n  public void function2() {\n    super.uglyNamingFucntion2();\n  }\n  \n  public void function3(ParamsWrapperDefinition paramsWrapper) {\n     super.tooManyParamsFunction3(paramsWrapper.getParamA(), 1);\n  }\n  \n  public void function4() {\n    //...reimplement it...\n  }\n}\n```\n\n2.统一多个类的接口设计\n\n某个功能的实现依赖多个外部系统（或者说类）。通过适配器模式，将它们的接口适配为统一的接口定义，然后我们就可以使用多态的特性来复用代码逻辑。\n\n假设我们的系统要对用户输入的文本内容做敏感词过滤，为了提高过滤的召回率，我们引入了多款第三方敏感词过滤系统，依次对用户输入的内容进行过滤，过滤掉尽可能多的敏感词。但是，每个系统提供的过滤接口都是不同的，这就意味着我们没法复用一套逻辑来调用各个系统。这个时候，我们可以使用适配器模式，将所有系统的接口适配为统一的接口定义，这样我们可以服用调用敏感词过滤的代码。\n\n```java\n\npublic class ASensitiveWordsFilter { // A敏感词过滤系统提供的接口\n  //text是原始文本，函数输出用***替换敏感词之后的文本\n  public String filterSexyWords(String text) {\n    // ...\n  }\n  \n  public String filterPoliticalWords(String text) {\n    // ...\n  } \n}\n\npublic class BSensitiveWordsFilter  { // B敏感词过滤系统提供的接口\n  public String filter(String text) {\n    //...\n  }\n}\n\npublic class CSensitiveWordsFilter { // C敏感词过滤系统提供的接口\n  public String filter(String text, String mask) {\n    //...\n  }\n}\n\n// 未使用适配器模式之前的代码：代码的可测试性、扩展性不好\npublic class RiskManagement {\n  private ASensitiveWordsFilter aFilter = new ASensitiveWordsFilter();\n  private BSensitiveWordsFilter bFilter = new BSensitiveWordsFilter();\n  private CSensitiveWordsFilter cFilter = new CSensitiveWordsFilter();\n  \n  public String filterSensitiveWords(String text) {\n    String maskedText = aFilter.filterSexyWords(text);\n    maskedText = aFilter.filterPoliticalWords(maskedText);\n    maskedText = bFilter.filter(maskedText);\n    maskedText = cFilter.filter(maskedText, \"***\");\n    return maskedText;\n  }\n}\n\n// 使用适配器模式进行改造\npublic interface ISensitiveWordsFilter { // 统一接口定义\n  String filter(String text);\n}\n\npublic class ASensitiveWordsFilterAdaptor implements ISensitiveWordsFilter {\n  private ASensitiveWordsFilter aFilter;\n  public String filter(String text) {\n    String maskedText = aFilter.filterSexyWords(text);\n    maskedText = aFilter.filterPoliticalWords(maskedText);\n    return maskedText;\n  }\n}\n//...省略BSensitiveWordsFilterAdaptor、CSensitiveWordsFilterAdaptor...\n\n// 扩展性更好，更加符合开闭原则，如果添加一个新的敏感词过滤系统，\n// 这个类完全不需要改动；而且基于接口而非实现编程，代码的可测试性更好。\npublic class RiskManagement { \n  private List<ISensitiveWordsFilter> filters = new ArrayList<>();\n \n  public void addSensitiveWordsFilter(ISensitiveWordsFilter filter) {\n    filters.add(filter);\n  }\n  \n  public String filterSensitiveWords(String text) {\n    String maskedText = text;\n    for (ISensitiveWordsFilter filter : filters) {\n      maskedText = filter.filter(maskedText);\n    }\n    return maskedText;\n  }\n}\n```\n\n3.替换依赖的外部系统\n\n当我们把项目中依赖的一个外部系统替换为另一个外部系统的时候，利用适配器模式，可以减少对代码的改动。\n\n```java\n//外部系统A\npublic interface IA {\n  //...\n  void fa();\n}\npublic class A implements IA {\n  //...\n  public void fa() {};\n}\n//在我们的项目中，外部系统A的使用示例\npublic class Demo {\n  private IA a;\n  public Demo(IA a) {\n    this.a = a;\n  }\n}\nDemo d = new Demo(new A());\n\n//将外部系统A替换成外部系统B\npublic class BAdaptor implements IA {\n  private B b;\n  public BAdaptor(B b) {\n    this.b = b;\n  }\n  public void fa() {\n    //...\n    b.fb();\n  }\n}\n//借助BAdaptor，Demo的代码中，调用IA接口的地方都无需改动，\n//只需要将BAdaptor如下注入到Demo即可\nDemo d = new Demo(new BAdaptor(new B()));\n```\n\n只需要在注入的时候修改注入的对象就好\n\n4.兼容老版本接口\n\n在做版本升级的时候，对于一些要废弃的接口，我们不直接将其删除，而是暂时保留，并且标注为deprecated，并将内部实现逻辑委托为新的接口实现。这样做的好处是，让使用它的项目有个过渡期，而不是强制进行代码修改。这也可以粗略地看作适配器模式的一个应用场景。\n\nJDK1.0中包含一个遍历集合容器的类Enumeration。JDK2.0对这个类进行了重构，将它改名为Iterator类，并且对它的代码实现做了优化。但是考虑到如果将Enumeration直接从JDK2.0中删除，那使用JDK1.0的项目如果切换到了JDK2.0，代码就会编译不通过。为了避免这种情况发生，我们必须把项目中所有用到Enumeration的地方，都修改为Iterator才行。\n\n单独一个项目做替换，勉强还能接受。但是一次JDK升级，导致所有项目不修改代码就会编译报错，显然是不合理的。为了兼容低版本的JDK的老代码，我们可以暂时保留Enumeration类，并将其实现替换为调用Itertor。\n\n```java\n\npublic class Collections {\n  public static Emueration enumeration(final Collection c) {\n    return new Enumeration() {\n      Iterator i = c.iterator();\n      \n      public boolean hasMoreElements() {\n        return i.hashNext();\n      }\n      \n      public Object nextElement() {\n        return i.next();\n      }\n    };\n  }\n}\n```\n\n5.适配不同格式的数据\n\n适配器模式也可用在不用格式的数据之间的适配。比如，把不同征信系统拉取的不同格式的征信数据，统一为相同的格式，以方便存储和使用。Java中的Arrays.asList()也可以看作一种数据适配器，将数组类型的数据转化为集合容器类型。\n\n```java\nList<String> stooges = Arrays.asList(\"Larry\",\"Moe\",\"Curly\");\n```\n\n剖析适配器模式在Java日志中的应用\n\nJava中有很多日志框架，在项目开发中，我们常常用它们来打印日志信息。常用的有log4j,logback 以及JDK提供的JUL(java,util.logging)和Apcahe的JCL(Jakarta Commons Logging)等。\n\n大部分日志框架都提供了相似的功能，比如按照不同级别打印日志等，但是它们并没有实现统一的接口。\n\n如果只是开发一个自己用的项目，那用什么日志框架都可以，log4j、logback随便选一个就好。但是如果开发的是一个集成到其他系统的组件、框架、类库等，那日志框架的选择就没那么随意了。\n\n比如项目中用到的某个组件使用log4j来打印日志，而我们项目本身使用的是logback。将组件引入到项目之后，我们的项目就相当于有了两套日志打印框架。每种日志框架都有自己的配置方式，所以我们要针对每种日志框架编写不同的配置文件，如果引入多个组件，每个组件使用的日志框架都不一样，那日志本身的管理工作就变得非常复杂。为了解决这个问题，我们需要统一日志打印框架。\n\nSlf4j这个日志框架你肯定不陌生，它相当于JDBC规范，提供了一套打印日志的统一接口规范。不过它只定义了接口，并没有提供具体的实现，需要配合其他日志框架(log4j、logback......)来使用。\n\n不仅如此，Slf4j的出现晚于JUL、JCL、log4j等日志框架，所以这些日志框架也不可能牺牲掉版本兼容性，将接口改造成符合Slf4j接口规范。Slf4j也事先考虑到了这个问题，所以，它不仅仅提供了统一的接口定义，还提供了针对不同日志框架的适配器。对不同日志框架的接口进行二次封装，适配成统一的Slf4j接口定义。\n\n```java\n\n// slf4j统一的接口定义\npackage org.slf4j;\npublic interface Logger {\n  public boolean isTraceEnabled();\n  public void trace(String msg);\n  public void trace(String format, Object arg);\n  public void trace(String format, Object arg1, Object arg2);\n  public void trace(String format, Object[] argArray);\n  public void trace(String msg, Throwable t);\n \n  public boolean isDebugEnabled();\n  public void debug(String msg);\n  public void debug(String format, Object arg);\n  public void debug(String format, Object arg1, Object arg2)\n  public void debug(String format, Object[] argArray)\n  public void debug(String msg, Throwable t);\n\n  //...省略info、warn、error等一堆接口\n}\n\n// log4j日志框架的适配器\n// Log4jLoggerAdapter实现了LocationAwareLogger接口，\n// 其中LocationAwareLogger继承自Logger接口，\n// 也就相当于Log4jLoggerAdapter实现了Logger接口。\npackage org.slf4j.impl;\npublic final class Log4jLoggerAdapter extends MarkerIgnoringBase\n  implements LocationAwareLogger, Serializable {\n  final transient org.apache.log4j.Logger logger; // log4j\n \n  public boolean isDebugEnabled() {\n    return logger.isDebugEnabled();\n  }\n \n  public void debug(String msg) {\n    logger.log(FQCN, Level.DEBUG, msg, null);\n  }\n \n  public void debug(String format, Object arg) {\n    if (logger.isDebugEnabled()) {\n      FormattingTuple ft = MessageFormatter.format(format, arg);\n      logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());\n    }\n  }\n \n  public void debug(String format, Object arg1, Object arg2) {\n    if (logger.isDebugEnabled()) {\n      FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n      logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());\n    }\n  }\n \n  public void debug(String format, Object[] argArray) {\n    if (logger.isDebugEnabled()) {\n      FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);\n      logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());\n    }\n  }\n \n  public void debug(String msg, Throwable t) {\n    logger.log(FQCN, Level.DEBUG, msg, t);\n  }\n  //...省略一堆接口的实现...\n}\n```\n\n所以，在开发业务系统或者开发框架、组件的时候，我们统一使用Slf4j提供的接口来编写打印日志的代码，具体使用那种日志框架实现，是可以动态地制定的(使用java的SPI技术)，只需要将相应的SDK倒入到项目中即可。\n\n##### 代理、桥接、装饰器、适配器4种设计模式的区别\n\n代理、桥接、装饰器、适配器，这4种模式是比较常用的结构型设计模式。他们的代码结构非常相似，笼统的说，它们都可以称为Wrapper模式，也就是通过Wrapper类二次封装原始类。\n\n尽管代码结构相似，但是这4中国呢设计模式的用意完全不同，也就是说要解决的问题、应用场景不同，这也是它们的主要区别。\n\n**代理模式：** 代理模式在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是增强非业务性的功能，这是它跟装饰器模式最大的不同。\n\n**桥接模式：** 桥接模式的目的是将接口部分和实现部分分离，从而让它们可以较为容易、也相对独立地加以改变。\n\n**装饰器模式：** 装饰器模式在不改变原始类接口的情况下，对原始类功能进行增强，并且支持多个装饰器的嵌套使用。\n\n**适配器模式：** 适配器模式是一种事后的不就策略。适配器提供跟原始类不同的接口，而代理模式、装饰器模式提供的都是跟原始类相同的接口。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/设计模式之适配器模式.md","raw":"---\nlayout:    post\ntitle:     设计模式之适配器模式\ncategory:  设计模式之美\ndescription: 设计模式之适配器模式\ntags: 设计模式之美\ndate: 2021/05/31 13:26:10\n---\n\n#### 适配器模式的原理与实现\n\n适配器模式的英文翻译是Adapter Design Pattern。这个模式就是用来做适配的，它将不兼容的接口转换为可兼容的接口，让原本由于接口不兼容而不能一起工作的类可以一起工作。对于这个模式，又一个经常被拿来解释它的例子，就是USB转接头充当适配器，把两种不兼容的接口，通过转接变得可以一起工作。\n\n原理很简单，看下代码实现。适配器模式有两种实现方式：类适配器和对象适配器。其中，类适配器使用继承关系来实现，对象适配器使用组合关系来实现。具体的代码实现如下所示。其中ITarget表示要转化成的接口定义，Adaptee是一组不兼容ITarget接口定义的接口，Adaptor将Adaptee转换成一组符合ITarget接口定义的接口。\n\n```java\n//类适配器：基于继承\npublic interface ITarget {\n  void f1();\n  void f2();\n  void fc();\n}\n\npublic class Adaptee {\n  public void fa() {}\n  public void fb() {}\n  public void fc() {}\n}\n\npublic class Adaptor extends Adaptee implements ITarget {\n  public void f1() {\n    super.fa();\n  }\n  \n  public void f2() {\n    //重新实现f2()\n  }\n  \n  //这里fc()不需要实现，直接继承自Adaptee，这是跟对象适配器最大的不同点\n}\n```\n\n```java\n//对象适配器：基于组合\npublic interface ITarget {\n  void f1();\n  void f2();\n  void fc();\n}\n\npublic class Adaptee {\n  public void fa() {}\n  public void fb() {}\n  public void fc() {}\n}\n\npublic class Adaptor implements ITarget {\n  private Adaptee adaptee;\n  \n  public Adaptor(Adaptee adaptee) {\n    this.adaptee = adaptee;\n  }\n  \n  public void f1() {\n    adaptee.fa();//委托给Adaptee\n  }\n  \n  public void f2() {\n    //...重新实现f2()...\n  }\n  \n  public void fc() {\n    adaptee.fc();\n  }\n}\n```\n\n实际开发中，应该选择哪种实现呢？判断标准有两个，一个是Adaptee接口的个数，另一个是Adaptee和ITarget的契合程度。\n\n- 如果Adaptdd接口并不多，那两种实现方式都可以。\n- 如果Adaptee接口很多，而且Adaptee和ITarget接口定义大部分都相同， 那我们推荐使用类适配器，因为Adaptor复用父类Adaptee的接口，比起对象适配器的实现方式，Adaptor的代码量要少一些。\n- 如果Adaptee接口很多，而且Adaptee和ITarget接口定义大部分都不相同，那我们推荐使用对象适配器，因为组合结构相对于继承更加灵活。\n\n#### 适配器模式应用场景总结\n\n一般来说，适配器模式可以看作一种“补偿模式”，用来不久设计上的缺陷。应用这种模式算是“无奈之举”。如果在设计初期，我们就能协调规避接口不兼容的问题，那这种模式就没有应用的机会了。\n\n1.封装有缺陷的接口设计\n\n假设我们依赖的外部系统在接口设计方面有缺陷（比如包含大量静态方法），引入之后会影响到我们自身代码的可测试性。为了隔离设计上的缺陷，我们希望对外部系统提供的接口进行二次封装，抽象出更好的接口，这个时候就可以使用适配器模式了。\n\n```java\npublic class CD { //这个类来自外部sdk，我们无权修改它的代码\n  //...\n  public static void staticFunction1() { \n    //... \n  }\n  \n  public void uglyNamingFunction2() { \n    //...\n  }\n\n  public void tooManyParamsFunction3(int paramA, int paramB, int ... params) { \n    //... \n }\n  \n   public void lowPerformanceFunction4() { \n    //... \n }\n}\n\n// 使用适配器模式进行重构\npublic class ITarget {\n  void function1();\n  void function2();\n  void function3(ParamsWrapperDefinition paramsWrapper);\n  void function4();\n  //...\n}\n// 注意：适配器类的命名不一定非得末尾带Adaptor\npublic class CDAdaptor extends CD implements ITarget {\n  //...\n  public void function1() {\n     super.staticFunction1();\n  }\n  \n  public void function2() {\n    super.uglyNamingFucntion2();\n  }\n  \n  public void function3(ParamsWrapperDefinition paramsWrapper) {\n     super.tooManyParamsFunction3(paramsWrapper.getParamA(), 1);\n  }\n  \n  public void function4() {\n    //...reimplement it...\n  }\n}\n```\n\n2.统一多个类的接口设计\n\n某个功能的实现依赖多个外部系统（或者说类）。通过适配器模式，将它们的接口适配为统一的接口定义，然后我们就可以使用多态的特性来复用代码逻辑。\n\n假设我们的系统要对用户输入的文本内容做敏感词过滤，为了提高过滤的召回率，我们引入了多款第三方敏感词过滤系统，依次对用户输入的内容进行过滤，过滤掉尽可能多的敏感词。但是，每个系统提供的过滤接口都是不同的，这就意味着我们没法复用一套逻辑来调用各个系统。这个时候，我们可以使用适配器模式，将所有系统的接口适配为统一的接口定义，这样我们可以服用调用敏感词过滤的代码。\n\n```java\n\npublic class ASensitiveWordsFilter { // A敏感词过滤系统提供的接口\n  //text是原始文本，函数输出用***替换敏感词之后的文本\n  public String filterSexyWords(String text) {\n    // ...\n  }\n  \n  public String filterPoliticalWords(String text) {\n    // ...\n  } \n}\n\npublic class BSensitiveWordsFilter  { // B敏感词过滤系统提供的接口\n  public String filter(String text) {\n    //...\n  }\n}\n\npublic class CSensitiveWordsFilter { // C敏感词过滤系统提供的接口\n  public String filter(String text, String mask) {\n    //...\n  }\n}\n\n// 未使用适配器模式之前的代码：代码的可测试性、扩展性不好\npublic class RiskManagement {\n  private ASensitiveWordsFilter aFilter = new ASensitiveWordsFilter();\n  private BSensitiveWordsFilter bFilter = new BSensitiveWordsFilter();\n  private CSensitiveWordsFilter cFilter = new CSensitiveWordsFilter();\n  \n  public String filterSensitiveWords(String text) {\n    String maskedText = aFilter.filterSexyWords(text);\n    maskedText = aFilter.filterPoliticalWords(maskedText);\n    maskedText = bFilter.filter(maskedText);\n    maskedText = cFilter.filter(maskedText, \"***\");\n    return maskedText;\n  }\n}\n\n// 使用适配器模式进行改造\npublic interface ISensitiveWordsFilter { // 统一接口定义\n  String filter(String text);\n}\n\npublic class ASensitiveWordsFilterAdaptor implements ISensitiveWordsFilter {\n  private ASensitiveWordsFilter aFilter;\n  public String filter(String text) {\n    String maskedText = aFilter.filterSexyWords(text);\n    maskedText = aFilter.filterPoliticalWords(maskedText);\n    return maskedText;\n  }\n}\n//...省略BSensitiveWordsFilterAdaptor、CSensitiveWordsFilterAdaptor...\n\n// 扩展性更好，更加符合开闭原则，如果添加一个新的敏感词过滤系统，\n// 这个类完全不需要改动；而且基于接口而非实现编程，代码的可测试性更好。\npublic class RiskManagement { \n  private List<ISensitiveWordsFilter> filters = new ArrayList<>();\n \n  public void addSensitiveWordsFilter(ISensitiveWordsFilter filter) {\n    filters.add(filter);\n  }\n  \n  public String filterSensitiveWords(String text) {\n    String maskedText = text;\n    for (ISensitiveWordsFilter filter : filters) {\n      maskedText = filter.filter(maskedText);\n    }\n    return maskedText;\n  }\n}\n```\n\n3.替换依赖的外部系统\n\n当我们把项目中依赖的一个外部系统替换为另一个外部系统的时候，利用适配器模式，可以减少对代码的改动。\n\n```java\n//外部系统A\npublic interface IA {\n  //...\n  void fa();\n}\npublic class A implements IA {\n  //...\n  public void fa() {};\n}\n//在我们的项目中，外部系统A的使用示例\npublic class Demo {\n  private IA a;\n  public Demo(IA a) {\n    this.a = a;\n  }\n}\nDemo d = new Demo(new A());\n\n//将外部系统A替换成外部系统B\npublic class BAdaptor implements IA {\n  private B b;\n  public BAdaptor(B b) {\n    this.b = b;\n  }\n  public void fa() {\n    //...\n    b.fb();\n  }\n}\n//借助BAdaptor，Demo的代码中，调用IA接口的地方都无需改动，\n//只需要将BAdaptor如下注入到Demo即可\nDemo d = new Demo(new BAdaptor(new B()));\n```\n\n只需要在注入的时候修改注入的对象就好\n\n4.兼容老版本接口\n\n在做版本升级的时候，对于一些要废弃的接口，我们不直接将其删除，而是暂时保留，并且标注为deprecated，并将内部实现逻辑委托为新的接口实现。这样做的好处是，让使用它的项目有个过渡期，而不是强制进行代码修改。这也可以粗略地看作适配器模式的一个应用场景。\n\nJDK1.0中包含一个遍历集合容器的类Enumeration。JDK2.0对这个类进行了重构，将它改名为Iterator类，并且对它的代码实现做了优化。但是考虑到如果将Enumeration直接从JDK2.0中删除，那使用JDK1.0的项目如果切换到了JDK2.0，代码就会编译不通过。为了避免这种情况发生，我们必须把项目中所有用到Enumeration的地方，都修改为Iterator才行。\n\n单独一个项目做替换，勉强还能接受。但是一次JDK升级，导致所有项目不修改代码就会编译报错，显然是不合理的。为了兼容低版本的JDK的老代码，我们可以暂时保留Enumeration类，并将其实现替换为调用Itertor。\n\n```java\n\npublic class Collections {\n  public static Emueration enumeration(final Collection c) {\n    return new Enumeration() {\n      Iterator i = c.iterator();\n      \n      public boolean hasMoreElements() {\n        return i.hashNext();\n      }\n      \n      public Object nextElement() {\n        return i.next();\n      }\n    };\n  }\n}\n```\n\n5.适配不同格式的数据\n\n适配器模式也可用在不用格式的数据之间的适配。比如，把不同征信系统拉取的不同格式的征信数据，统一为相同的格式，以方便存储和使用。Java中的Arrays.asList()也可以看作一种数据适配器，将数组类型的数据转化为集合容器类型。\n\n```java\nList<String> stooges = Arrays.asList(\"Larry\",\"Moe\",\"Curly\");\n```\n\n剖析适配器模式在Java日志中的应用\n\nJava中有很多日志框架，在项目开发中，我们常常用它们来打印日志信息。常用的有log4j,logback 以及JDK提供的JUL(java,util.logging)和Apcahe的JCL(Jakarta Commons Logging)等。\n\n大部分日志框架都提供了相似的功能，比如按照不同级别打印日志等，但是它们并没有实现统一的接口。\n\n如果只是开发一个自己用的项目，那用什么日志框架都可以，log4j、logback随便选一个就好。但是如果开发的是一个集成到其他系统的组件、框架、类库等，那日志框架的选择就没那么随意了。\n\n比如项目中用到的某个组件使用log4j来打印日志，而我们项目本身使用的是logback。将组件引入到项目之后，我们的项目就相当于有了两套日志打印框架。每种日志框架都有自己的配置方式，所以我们要针对每种日志框架编写不同的配置文件，如果引入多个组件，每个组件使用的日志框架都不一样，那日志本身的管理工作就变得非常复杂。为了解决这个问题，我们需要统一日志打印框架。\n\nSlf4j这个日志框架你肯定不陌生，它相当于JDBC规范，提供了一套打印日志的统一接口规范。不过它只定义了接口，并没有提供具体的实现，需要配合其他日志框架(log4j、logback......)来使用。\n\n不仅如此，Slf4j的出现晚于JUL、JCL、log4j等日志框架，所以这些日志框架也不可能牺牲掉版本兼容性，将接口改造成符合Slf4j接口规范。Slf4j也事先考虑到了这个问题，所以，它不仅仅提供了统一的接口定义，还提供了针对不同日志框架的适配器。对不同日志框架的接口进行二次封装，适配成统一的Slf4j接口定义。\n\n```java\n\n// slf4j统一的接口定义\npackage org.slf4j;\npublic interface Logger {\n  public boolean isTraceEnabled();\n  public void trace(String msg);\n  public void trace(String format, Object arg);\n  public void trace(String format, Object arg1, Object arg2);\n  public void trace(String format, Object[] argArray);\n  public void trace(String msg, Throwable t);\n \n  public boolean isDebugEnabled();\n  public void debug(String msg);\n  public void debug(String format, Object arg);\n  public void debug(String format, Object arg1, Object arg2)\n  public void debug(String format, Object[] argArray)\n  public void debug(String msg, Throwable t);\n\n  //...省略info、warn、error等一堆接口\n}\n\n// log4j日志框架的适配器\n// Log4jLoggerAdapter实现了LocationAwareLogger接口，\n// 其中LocationAwareLogger继承自Logger接口，\n// 也就相当于Log4jLoggerAdapter实现了Logger接口。\npackage org.slf4j.impl;\npublic final class Log4jLoggerAdapter extends MarkerIgnoringBase\n  implements LocationAwareLogger, Serializable {\n  final transient org.apache.log4j.Logger logger; // log4j\n \n  public boolean isDebugEnabled() {\n    return logger.isDebugEnabled();\n  }\n \n  public void debug(String msg) {\n    logger.log(FQCN, Level.DEBUG, msg, null);\n  }\n \n  public void debug(String format, Object arg) {\n    if (logger.isDebugEnabled()) {\n      FormattingTuple ft = MessageFormatter.format(format, arg);\n      logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());\n    }\n  }\n \n  public void debug(String format, Object arg1, Object arg2) {\n    if (logger.isDebugEnabled()) {\n      FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);\n      logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());\n    }\n  }\n \n  public void debug(String format, Object[] argArray) {\n    if (logger.isDebugEnabled()) {\n      FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);\n      logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());\n    }\n  }\n \n  public void debug(String msg, Throwable t) {\n    logger.log(FQCN, Level.DEBUG, msg, t);\n  }\n  //...省略一堆接口的实现...\n}\n```\n\n所以，在开发业务系统或者开发框架、组件的时候，我们统一使用Slf4j提供的接口来编写打印日志的代码，具体使用那种日志框架实现，是可以动态地制定的(使用java的SPI技术)，只需要将相应的SDK倒入到项目中即可。\n\n##### 代理、桥接、装饰器、适配器4种设计模式的区别\n\n代理、桥接、装饰器、适配器，这4种模式是比较常用的结构型设计模式。他们的代码结构非常相似，笼统的说，它们都可以称为Wrapper模式，也就是通过Wrapper类二次封装原始类。\n\n尽管代码结构相似，但是这4中国呢设计模式的用意完全不同，也就是说要解决的问题、应用场景不同，这也是它们的主要区别。\n\n**代理模式：** 代理模式在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是增强非业务性的功能，这是它跟装饰器模式最大的不同。\n\n**桥接模式：** 桥接模式的目的是将接口部分和实现部分分离，从而让它们可以较为容易、也相对独立地加以改变。\n\n**装饰器模式：** 装饰器模式在不改变原始类接口的情况下，对原始类功能进行增强，并且支持多个装饰器的嵌套使用。\n\n**适配器模式：** 适配器模式是一种事后的不就策略。适配器提供跟原始类不同的接口，而代理模式、装饰器模式提供的都是跟原始类相同的接口。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"设计模式之适配器模式","published":1,"updated":"2021-05-31T05:26:10.000Z","comments":1,"photos":[],"link":"","_id":"cm1m304y6003i31b445mrf0st","content":"<h4 id=\"适配器模式的原理与实现\"><a href=\"#适配器模式的原理与实现\" class=\"headerlink\" title=\"适配器模式的原理与实现\"></a>适配器模式的原理与实现</h4><p>适配器模式的英文翻译是Adapter Design Pattern。这个模式就是用来做适配的，它将不兼容的接口转换为可兼容的接口，让原本由于接口不兼容而不能一起工作的类可以一起工作。对于这个模式，又一个经常被拿来解释它的例子，就是USB转接头充当适配器，把两种不兼容的接口，通过转接变得可以一起工作。</p>\n<p>原理很简单，看下代码实现。适配器模式有两种实现方式：类适配器和对象适配器。其中，类适配器使用继承关系来实现，对象适配器使用组合关系来实现。具体的代码实现如下所示。其中ITarget表示要转化成的接口定义，Adaptee是一组不兼容ITarget接口定义的接口，Adaptor将Adaptee转换成一组符合ITarget接口定义的接口。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//类适配器：基于继承</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ITarget</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f1</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f2</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fc</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Adaptee</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">fa</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">fb</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">fc</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Adaptor</span> <span class=\"keyword\">extends</span> <span class=\"title\">Adaptee</span> <span class=\"keyword\">implements</span> <span class=\"title\">ITarget</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">f1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.fa();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">f2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//重新实现f2()</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">//这里fc()不需要实现，直接继承自Adaptee，这是跟对象适配器最大的不同点</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//对象适配器：基于组合</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ITarget</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f1</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f2</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fc</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Adaptee</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">fa</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">fb</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">fc</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Adaptor</span> <span class=\"keyword\">implements</span> <span class=\"title\">ITarget</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Adaptee adaptee;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Adaptor</span><span class=\"params\">(Adaptee adaptee)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.adaptee = adaptee;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">f1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    adaptee.fa();<span class=\"comment\">//委托给Adaptee</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">f2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...重新实现f2()...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">fc</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    adaptee.fc();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实际开发中，应该选择哪种实现呢？判断标准有两个，一个是Adaptee接口的个数，另一个是Adaptee和ITarget的契合程度。</p>\n<ul>\n<li>如果Adaptdd接口并不多，那两种实现方式都可以。</li>\n<li>如果Adaptee接口很多，而且Adaptee和ITarget接口定义大部分都相同， 那我们推荐使用类适配器，因为Adaptor复用父类Adaptee的接口，比起对象适配器的实现方式，Adaptor的代码量要少一些。</li>\n<li>如果Adaptee接口很多，而且Adaptee和ITarget接口定义大部分都不相同，那我们推荐使用对象适配器，因为组合结构相对于继承更加灵活。</li>\n</ul>\n<h4 id=\"适配器模式应用场景总结\"><a href=\"#适配器模式应用场景总结\" class=\"headerlink\" title=\"适配器模式应用场景总结\"></a>适配器模式应用场景总结</h4><p>一般来说，适配器模式可以看作一种“补偿模式”，用来不久设计上的缺陷。应用这种模式算是“无奈之举”。如果在设计初期，我们就能协调规避接口不兼容的问题，那这种模式就没有应用的机会了。</p>\n<p>1.封装有缺陷的接口设计</p>\n<p>假设我们依赖的外部系统在接口设计方面有缺陷（比如包含大量静态方法），引入之后会影响到我们自身代码的可测试性。为了隔离设计上的缺陷，我们希望对外部系统提供的接口进行二次封装，抽象出更好的接口，这个时候就可以使用适配器模式了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CD</span> </span>&#123; <span class=\"comment\">//这个类来自外部sdk，我们无权修改它的代码</span></span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">staticFunction1</span><span class=\"params\">()</span> </span>&#123; </span><br><span class=\"line\">    <span class=\"comment\">//... </span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">uglyNamingFunction2</span><span class=\"params\">()</span> </span>&#123; </span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">tooManyParamsFunction3</span><span class=\"params\">(<span class=\"keyword\">int</span> paramA, <span class=\"keyword\">int</span> paramB, <span class=\"keyword\">int</span> ... params)</span> </span>&#123; </span><br><span class=\"line\">    <span class=\"comment\">//... </span></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">lowPerformanceFunction4</span><span class=\"params\">()</span> </span>&#123; </span><br><span class=\"line\">    <span class=\"comment\">//... </span></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用适配器模式进行重构</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ITarget</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">function1</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">function2</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">function3</span><span class=\"params\">(ParamsWrapperDefinition paramsWrapper)</span></span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">function4</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 注意：适配器类的命名不一定非得末尾带Adaptor</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CDAdaptor</span> <span class=\"keyword\">extends</span> <span class=\"title\">CD</span> <span class=\"keyword\">implements</span> <span class=\"title\">ITarget</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">function1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">super</span>.staticFunction1();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">function2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.uglyNamingFucntion2();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">function3</span><span class=\"params\">(ParamsWrapperDefinition paramsWrapper)</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">super</span>.tooManyParamsFunction3(paramsWrapper.getParamA(), <span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">function4</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...reimplement it...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>2.统一多个类的接口设计</p>\n<p>某个功能的实现依赖多个外部系统（或者说类）。通过适配器模式，将它们的接口适配为统一的接口定义，然后我们就可以使用多态的特性来复用代码逻辑。</p>\n<p>假设我们的系统要对用户输入的文本内容做敏感词过滤，为了提高过滤的召回率，我们引入了多款第三方敏感词过滤系统，依次对用户输入的内容进行过滤，过滤掉尽可能多的敏感词。但是，每个系统提供的过滤接口都是不同的，这就意味着我们没法复用一套逻辑来调用各个系统。这个时候，我们可以使用适配器模式，将所有系统的接口适配为统一的接口定义，这样我们可以服用调用敏感词过滤的代码。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ASensitiveWordsFilter</span> </span>&#123; <span class=\"comment\">// A敏感词过滤系统提供的接口</span></span><br><span class=\"line\">  <span class=\"comment\">//text是原始文本，函数输出用***替换敏感词之后的文本</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">filterSexyWords</span><span class=\"params\">(String text)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">filterPoliticalWords</span><span class=\"params\">(String text)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BSensitiveWordsFilter</span>  </span>&#123; <span class=\"comment\">// B敏感词过滤系统提供的接口</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">filter</span><span class=\"params\">(String text)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CSensitiveWordsFilter</span> </span>&#123; <span class=\"comment\">// C敏感词过滤系统提供的接口</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">filter</span><span class=\"params\">(String text, String mask)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 未使用适配器模式之前的代码：代码的可测试性、扩展性不好</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RiskManagement</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> ASensitiveWordsFilter aFilter = <span class=\"keyword\">new</span> ASensitiveWordsFilter();</span><br><span class=\"line\">  <span class=\"keyword\">private</span> BSensitiveWordsFilter bFilter = <span class=\"keyword\">new</span> BSensitiveWordsFilter();</span><br><span class=\"line\">  <span class=\"keyword\">private</span> CSensitiveWordsFilter cFilter = <span class=\"keyword\">new</span> CSensitiveWordsFilter();</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">filterSensitiveWords</span><span class=\"params\">(String text)</span> </span>&#123;</span><br><span class=\"line\">    String maskedText = aFilter.filterSexyWords(text);</span><br><span class=\"line\">    maskedText = aFilter.filterPoliticalWords(maskedText);</span><br><span class=\"line\">    maskedText = bFilter.filter(maskedText);</span><br><span class=\"line\">    maskedText = cFilter.filter(maskedText, <span class=\"string\">&quot;***&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> maskedText;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用适配器模式进行改造</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ISensitiveWordsFilter</span> </span>&#123; <span class=\"comment\">// 统一接口定义</span></span><br><span class=\"line\">  <span class=\"function\">String <span class=\"title\">filter</span><span class=\"params\">(String text)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ASensitiveWordsFilterAdaptor</span> <span class=\"keyword\">implements</span> <span class=\"title\">ISensitiveWordsFilter</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> ASensitiveWordsFilter aFilter;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">filter</span><span class=\"params\">(String text)</span> </span>&#123;</span><br><span class=\"line\">    String maskedText = aFilter.filterSexyWords(text);</span><br><span class=\"line\">    maskedText = aFilter.filterPoliticalWords(maskedText);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> maskedText;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//...省略BSensitiveWordsFilterAdaptor、CSensitiveWordsFilterAdaptor...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 扩展性更好，更加符合开闭原则，如果添加一个新的敏感词过滤系统，</span></span><br><span class=\"line\"><span class=\"comment\">// 这个类完全不需要改动；而且基于接口而非实现编程，代码的可测试性更好。</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RiskManagement</span> </span>&#123; </span><br><span class=\"line\">  <span class=\"keyword\">private</span> List&lt;ISensitiveWordsFilter&gt; filters = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addSensitiveWordsFilter</span><span class=\"params\">(ISensitiveWordsFilter filter)</span> </span>&#123;</span><br><span class=\"line\">    filters.add(filter);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">filterSensitiveWords</span><span class=\"params\">(String text)</span> </span>&#123;</span><br><span class=\"line\">    String maskedText = text;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (ISensitiveWordsFilter filter : filters) &#123;</span><br><span class=\"line\">      maskedText = filter.filter(maskedText);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> maskedText;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>3.替换依赖的外部系统</p>\n<p>当我们把项目中依赖的一个外部系统替换为另一个外部系统的时候，利用适配器模式，可以减少对代码的改动。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//外部系统A</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">IA</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fa</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> <span class=\"keyword\">implements</span> <span class=\"title\">IA</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">fa</span><span class=\"params\">()</span> </span>&#123;&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//在我们的项目中，外部系统A的使用示例</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> IA a;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Demo</span><span class=\"params\">(IA a)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.a = a;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Demo d = <span class=\"keyword\">new</span> Demo(<span class=\"keyword\">new</span> A());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//将外部系统A替换成外部系统B</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BAdaptor</span> <span class=\"keyword\">implements</span> <span class=\"title\">IA</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> B b;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">BAdaptor</span><span class=\"params\">(B b)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.b = b;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">fa</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    b.fb();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//借助BAdaptor，Demo的代码中，调用IA接口的地方都无需改动，</span></span><br><span class=\"line\"><span class=\"comment\">//只需要将BAdaptor如下注入到Demo即可</span></span><br><span class=\"line\">Demo d = <span class=\"keyword\">new</span> Demo(<span class=\"keyword\">new</span> BAdaptor(<span class=\"keyword\">new</span> B()));</span><br></pre></td></tr></table></figure>\n\n<p>只需要在注入的时候修改注入的对象就好</p>\n<p>4.兼容老版本接口</p>\n<p>在做版本升级的时候，对于一些要废弃的接口，我们不直接将其删除，而是暂时保留，并且标注为deprecated，并将内部实现逻辑委托为新的接口实现。这样做的好处是，让使用它的项目有个过渡期，而不是强制进行代码修改。这也可以粗略地看作适配器模式的一个应用场景。</p>\n<p>JDK1.0中包含一个遍历集合容器的类Enumeration。JDK2.0对这个类进行了重构，将它改名为Iterator类，并且对它的代码实现做了优化。但是考虑到如果将Enumeration直接从JDK2.0中删除，那使用JDK1.0的项目如果切换到了JDK2.0，代码就会编译不通过。为了避免这种情况发生，我们必须把项目中所有用到Enumeration的地方，都修改为Iterator才行。</p>\n<p>单独一个项目做替换，勉强还能接受。但是一次JDK升级，导致所有项目不修改代码就会编译报错，显然是不合理的。为了兼容低版本的JDK的老代码，我们可以暂时保留Enumeration类，并将其实现替换为调用Itertor。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Collections</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Emueration <span class=\"title\">enumeration</span><span class=\"params\">(<span class=\"keyword\">final</span> Collection c)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Enumeration() &#123;</span><br><span class=\"line\">      Iterator i = c.iterator();</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasMoreElements</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> i.hashNext();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">nextElement</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> i.next();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>5.适配不同格式的数据</p>\n<p>适配器模式也可用在不用格式的数据之间的适配。比如，把不同征信系统拉取的不同格式的征信数据，统一为相同的格式，以方便存储和使用。Java中的Arrays.asList()也可以看作一种数据适配器，将数组类型的数据转化为集合容器类型。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; stooges = Arrays.asList(<span class=\"string\">&quot;Larry&quot;</span>,<span class=\"string\">&quot;Moe&quot;</span>,<span class=\"string\">&quot;Curly&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>剖析适配器模式在Java日志中的应用</p>\n<p>Java中有很多日志框架，在项目开发中，我们常常用它们来打印日志信息。常用的有log4j,logback 以及JDK提供的JUL(java,util.logging)和Apcahe的JCL(Jakarta Commons Logging)等。</p>\n<p>大部分日志框架都提供了相似的功能，比如按照不同级别打印日志等，但是它们并没有实现统一的接口。</p>\n<p>如果只是开发一个自己用的项目，那用什么日志框架都可以，log4j、logback随便选一个就好。但是如果开发的是一个集成到其他系统的组件、框架、类库等，那日志框架的选择就没那么随意了。</p>\n<p>比如项目中用到的某个组件使用log4j来打印日志，而我们项目本身使用的是logback。将组件引入到项目之后，我们的项目就相当于有了两套日志打印框架。每种日志框架都有自己的配置方式，所以我们要针对每种日志框架编写不同的配置文件，如果引入多个组件，每个组件使用的日志框架都不一样，那日志本身的管理工作就变得非常复杂。为了解决这个问题，我们需要统一日志打印框架。</p>\n<p>Slf4j这个日志框架你肯定不陌生，它相当于JDBC规范，提供了一套打印日志的统一接口规范。不过它只定义了接口，并没有提供具体的实现，需要配合其他日志框架(log4j、logback……)来使用。</p>\n<p>不仅如此，Slf4j的出现晚于JUL、JCL、log4j等日志框架，所以这些日志框架也不可能牺牲掉版本兼容性，将接口改造成符合Slf4j接口规范。Slf4j也事先考虑到了这个问题，所以，它不仅仅提供了统一的接口定义，还提供了针对不同日志框架的适配器。对不同日志框架的接口进行二次封装，适配成统一的Slf4j接口定义。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// slf4j统一的接口定义</span></span><br><span class=\"line\"><span class=\"keyword\">package</span> org.slf4j;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Logger</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isTraceEnabled</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">trace</span><span class=\"params\">(String msg)</span></span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">trace</span><span class=\"params\">(String format, Object arg)</span></span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">trace</span><span class=\"params\">(String format, Object arg1, Object arg2)</span></span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">trace</span><span class=\"params\">(String format, Object[] argArray)</span></span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">trace</span><span class=\"params\">(String msg, Throwable t)</span></span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isDebugEnabled</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">debug</span><span class=\"params\">(String msg)</span></span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">debug</span><span class=\"params\">(String format, Object arg)</span></span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">debug</span><span class=\"params\">(String format, Object arg1, Object arg2)</span></span></span><br><span class=\"line\"><span class=\"function\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">debug</span><span class=\"params\">(String format, Object[] argArray)</span></span></span><br><span class=\"line\"><span class=\"function\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">debug</span><span class=\"params\">(String msg, Throwable t)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//...省略info、warn、error等一堆接口</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// log4j日志框架的适配器</span></span><br><span class=\"line\"><span class=\"comment\">// Log4jLoggerAdapter实现了LocationAwareLogger接口，</span></span><br><span class=\"line\"><span class=\"comment\">// 其中LocationAwareLogger继承自Logger接口，</span></span><br><span class=\"line\"><span class=\"comment\">// 也就相当于Log4jLoggerAdapter实现了Logger接口。</span></span><br><span class=\"line\"><span class=\"keyword\">package</span> org.slf4j.impl;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Log4jLoggerAdapter</span> <span class=\"keyword\">extends</span> <span class=\"title\">MarkerIgnoringBase</span></span></span><br><span class=\"line\"><span class=\"class\">  <span class=\"keyword\">implements</span> <span class=\"title\">LocationAwareLogger</span>, <span class=\"title\">Serializable</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"keyword\">transient</span> org.apache.log4j.Logger logger; <span class=\"comment\">// log4j</span></span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isDebugEnabled</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> logger.isDebugEnabled();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">debug</span><span class=\"params\">(String msg)</span> </span>&#123;</span><br><span class=\"line\">    logger.log(FQCN, Level.DEBUG, msg, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">debug</span><span class=\"params\">(String format, Object arg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">      FormattingTuple ft = MessageFormatter.format(format, arg);</span><br><span class=\"line\">      logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">debug</span><span class=\"params\">(String format, Object arg1, Object arg2)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">      FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);</span><br><span class=\"line\">      logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">debug</span><span class=\"params\">(String format, Object[] argArray)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">      FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);</span><br><span class=\"line\">      logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">debug</span><span class=\"params\">(String msg, Throwable t)</span> </span>&#123;</span><br><span class=\"line\">    logger.log(FQCN, Level.DEBUG, msg, t);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//...省略一堆接口的实现...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>所以，在开发业务系统或者开发框架、组件的时候，我们统一使用Slf4j提供的接口来编写打印日志的代码，具体使用那种日志框架实现，是可以动态地制定的(使用java的SPI技术)，只需要将相应的SDK倒入到项目中即可。</p>\n<h5 id=\"代理、桥接、装饰器、适配器4种设计模式的区别\"><a href=\"#代理、桥接、装饰器、适配器4种设计模式的区别\" class=\"headerlink\" title=\"代理、桥接、装饰器、适配器4种设计模式的区别\"></a>代理、桥接、装饰器、适配器4种设计模式的区别</h5><p>代理、桥接、装饰器、适配器，这4种模式是比较常用的结构型设计模式。他们的代码结构非常相似，笼统的说，它们都可以称为Wrapper模式，也就是通过Wrapper类二次封装原始类。</p>\n<p>尽管代码结构相似，但是这4中国呢设计模式的用意完全不同，也就是说要解决的问题、应用场景不同，这也是它们的主要区别。</p>\n<p><strong>代理模式：</strong> 代理模式在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是增强非业务性的功能，这是它跟装饰器模式最大的不同。</p>\n<p><strong>桥接模式：</strong> 桥接模式的目的是将接口部分和实现部分分离，从而让它们可以较为容易、也相对独立地加以改变。</p>\n<p><strong>装饰器模式：</strong> 装饰器模式在不改变原始类接口的情况下，对原始类功能进行增强，并且支持多个装饰器的嵌套使用。</p>\n<p><strong>适配器模式：</strong> 适配器模式是一种事后的不就策略。适配器提供跟原始类不同的接口，而代理模式、装饰器模式提供的都是跟原始类相同的接口。</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"适配器模式的原理与实现\"><a href=\"#适配器模式的原理与实现\" class=\"headerlink\" title=\"适配器模式的原理与实现\"></a>适配器模式的原理与实现</h4><p>适配器模式的英文翻译是Adapter Design Pattern。这个模式就是用来做适配的，它将不兼容的接口转换为可兼容的接口，让原本由于接口不兼容而不能一起工作的类可以一起工作。对于这个模式，又一个经常被拿来解释它的例子，就是USB转接头充当适配器，把两种不兼容的接口，通过转接变得可以一起工作。</p>\n<p>原理很简单，看下代码实现。适配器模式有两种实现方式：类适配器和对象适配器。其中，类适配器使用继承关系来实现，对象适配器使用组合关系来实现。具体的代码实现如下所示。其中ITarget表示要转化成的接口定义，Adaptee是一组不兼容ITarget接口定义的接口，Adaptor将Adaptee转换成一组符合ITarget接口定义的接口。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//类适配器：基于继承</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ITarget</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f1</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f2</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fc</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Adaptee</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">fa</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">fb</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">fc</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Adaptor</span> <span class=\"keyword\">extends</span> <span class=\"title\">Adaptee</span> <span class=\"keyword\">implements</span> <span class=\"title\">ITarget</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">f1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.fa();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">f2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//重新实现f2()</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">//这里fc()不需要实现，直接继承自Adaptee，这是跟对象适配器最大的不同点</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//对象适配器：基于组合</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ITarget</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f1</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f2</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fc</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Adaptee</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">fa</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">fb</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">fc</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Adaptor</span> <span class=\"keyword\">implements</span> <span class=\"title\">ITarget</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Adaptee adaptee;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Adaptor</span><span class=\"params\">(Adaptee adaptee)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.adaptee = adaptee;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">f1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    adaptee.fa();<span class=\"comment\">//委托给Adaptee</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">f2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...重新实现f2()...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">fc</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    adaptee.fc();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实际开发中，应该选择哪种实现呢？判断标准有两个，一个是Adaptee接口的个数，另一个是Adaptee和ITarget的契合程度。</p>\n<ul>\n<li>如果Adaptdd接口并不多，那两种实现方式都可以。</li>\n<li>如果Adaptee接口很多，而且Adaptee和ITarget接口定义大部分都相同， 那我们推荐使用类适配器，因为Adaptor复用父类Adaptee的接口，比起对象适配器的实现方式，Adaptor的代码量要少一些。</li>\n<li>如果Adaptee接口很多，而且Adaptee和ITarget接口定义大部分都不相同，那我们推荐使用对象适配器，因为组合结构相对于继承更加灵活。</li>\n</ul>\n<h4 id=\"适配器模式应用场景总结\"><a href=\"#适配器模式应用场景总结\" class=\"headerlink\" title=\"适配器模式应用场景总结\"></a>适配器模式应用场景总结</h4><p>一般来说，适配器模式可以看作一种“补偿模式”，用来不久设计上的缺陷。应用这种模式算是“无奈之举”。如果在设计初期，我们就能协调规避接口不兼容的问题，那这种模式就没有应用的机会了。</p>\n<p>1.封装有缺陷的接口设计</p>\n<p>假设我们依赖的外部系统在接口设计方面有缺陷（比如包含大量静态方法），引入之后会影响到我们自身代码的可测试性。为了隔离设计上的缺陷，我们希望对外部系统提供的接口进行二次封装，抽象出更好的接口，这个时候就可以使用适配器模式了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CD</span> </span>&#123; <span class=\"comment\">//这个类来自外部sdk，我们无权修改它的代码</span></span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">staticFunction1</span><span class=\"params\">()</span> </span>&#123; </span><br><span class=\"line\">    <span class=\"comment\">//... </span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">uglyNamingFunction2</span><span class=\"params\">()</span> </span>&#123; </span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">tooManyParamsFunction3</span><span class=\"params\">(<span class=\"keyword\">int</span> paramA, <span class=\"keyword\">int</span> paramB, <span class=\"keyword\">int</span> ... params)</span> </span>&#123; </span><br><span class=\"line\">    <span class=\"comment\">//... </span></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">lowPerformanceFunction4</span><span class=\"params\">()</span> </span>&#123; </span><br><span class=\"line\">    <span class=\"comment\">//... </span></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用适配器模式进行重构</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ITarget</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">function1</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">function2</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">function3</span><span class=\"params\">(ParamsWrapperDefinition paramsWrapper)</span></span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">function4</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 注意：适配器类的命名不一定非得末尾带Adaptor</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CDAdaptor</span> <span class=\"keyword\">extends</span> <span class=\"title\">CD</span> <span class=\"keyword\">implements</span> <span class=\"title\">ITarget</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">function1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">super</span>.staticFunction1();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">function2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.uglyNamingFucntion2();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">function3</span><span class=\"params\">(ParamsWrapperDefinition paramsWrapper)</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">super</span>.tooManyParamsFunction3(paramsWrapper.getParamA(), <span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">function4</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...reimplement it...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>2.统一多个类的接口设计</p>\n<p>某个功能的实现依赖多个外部系统（或者说类）。通过适配器模式，将它们的接口适配为统一的接口定义，然后我们就可以使用多态的特性来复用代码逻辑。</p>\n<p>假设我们的系统要对用户输入的文本内容做敏感词过滤，为了提高过滤的召回率，我们引入了多款第三方敏感词过滤系统，依次对用户输入的内容进行过滤，过滤掉尽可能多的敏感词。但是，每个系统提供的过滤接口都是不同的，这就意味着我们没法复用一套逻辑来调用各个系统。这个时候，我们可以使用适配器模式，将所有系统的接口适配为统一的接口定义，这样我们可以服用调用敏感词过滤的代码。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ASensitiveWordsFilter</span> </span>&#123; <span class=\"comment\">// A敏感词过滤系统提供的接口</span></span><br><span class=\"line\">  <span class=\"comment\">//text是原始文本，函数输出用***替换敏感词之后的文本</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">filterSexyWords</span><span class=\"params\">(String text)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">filterPoliticalWords</span><span class=\"params\">(String text)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BSensitiveWordsFilter</span>  </span>&#123; <span class=\"comment\">// B敏感词过滤系统提供的接口</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">filter</span><span class=\"params\">(String text)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CSensitiveWordsFilter</span> </span>&#123; <span class=\"comment\">// C敏感词过滤系统提供的接口</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">filter</span><span class=\"params\">(String text, String mask)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 未使用适配器模式之前的代码：代码的可测试性、扩展性不好</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RiskManagement</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> ASensitiveWordsFilter aFilter = <span class=\"keyword\">new</span> ASensitiveWordsFilter();</span><br><span class=\"line\">  <span class=\"keyword\">private</span> BSensitiveWordsFilter bFilter = <span class=\"keyword\">new</span> BSensitiveWordsFilter();</span><br><span class=\"line\">  <span class=\"keyword\">private</span> CSensitiveWordsFilter cFilter = <span class=\"keyword\">new</span> CSensitiveWordsFilter();</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">filterSensitiveWords</span><span class=\"params\">(String text)</span> </span>&#123;</span><br><span class=\"line\">    String maskedText = aFilter.filterSexyWords(text);</span><br><span class=\"line\">    maskedText = aFilter.filterPoliticalWords(maskedText);</span><br><span class=\"line\">    maskedText = bFilter.filter(maskedText);</span><br><span class=\"line\">    maskedText = cFilter.filter(maskedText, <span class=\"string\">&quot;***&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> maskedText;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用适配器模式进行改造</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ISensitiveWordsFilter</span> </span>&#123; <span class=\"comment\">// 统一接口定义</span></span><br><span class=\"line\">  <span class=\"function\">String <span class=\"title\">filter</span><span class=\"params\">(String text)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ASensitiveWordsFilterAdaptor</span> <span class=\"keyword\">implements</span> <span class=\"title\">ISensitiveWordsFilter</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> ASensitiveWordsFilter aFilter;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">filter</span><span class=\"params\">(String text)</span> </span>&#123;</span><br><span class=\"line\">    String maskedText = aFilter.filterSexyWords(text);</span><br><span class=\"line\">    maskedText = aFilter.filterPoliticalWords(maskedText);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> maskedText;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//...省略BSensitiveWordsFilterAdaptor、CSensitiveWordsFilterAdaptor...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 扩展性更好，更加符合开闭原则，如果添加一个新的敏感词过滤系统，</span></span><br><span class=\"line\"><span class=\"comment\">// 这个类完全不需要改动；而且基于接口而非实现编程，代码的可测试性更好。</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RiskManagement</span> </span>&#123; </span><br><span class=\"line\">  <span class=\"keyword\">private</span> List&lt;ISensitiveWordsFilter&gt; filters = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addSensitiveWordsFilter</span><span class=\"params\">(ISensitiveWordsFilter filter)</span> </span>&#123;</span><br><span class=\"line\">    filters.add(filter);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">filterSensitiveWords</span><span class=\"params\">(String text)</span> </span>&#123;</span><br><span class=\"line\">    String maskedText = text;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (ISensitiveWordsFilter filter : filters) &#123;</span><br><span class=\"line\">      maskedText = filter.filter(maskedText);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> maskedText;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>3.替换依赖的外部系统</p>\n<p>当我们把项目中依赖的一个外部系统替换为另一个外部系统的时候，利用适配器模式，可以减少对代码的改动。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//外部系统A</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">IA</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fa</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> <span class=\"keyword\">implements</span> <span class=\"title\">IA</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">fa</span><span class=\"params\">()</span> </span>&#123;&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//在我们的项目中，外部系统A的使用示例</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> IA a;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Demo</span><span class=\"params\">(IA a)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.a = a;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Demo d = <span class=\"keyword\">new</span> Demo(<span class=\"keyword\">new</span> A());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//将外部系统A替换成外部系统B</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BAdaptor</span> <span class=\"keyword\">implements</span> <span class=\"title\">IA</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> B b;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">BAdaptor</span><span class=\"params\">(B b)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.b = b;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">fa</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    b.fb();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//借助BAdaptor，Demo的代码中，调用IA接口的地方都无需改动，</span></span><br><span class=\"line\"><span class=\"comment\">//只需要将BAdaptor如下注入到Demo即可</span></span><br><span class=\"line\">Demo d = <span class=\"keyword\">new</span> Demo(<span class=\"keyword\">new</span> BAdaptor(<span class=\"keyword\">new</span> B()));</span><br></pre></td></tr></table></figure>\n\n<p>只需要在注入的时候修改注入的对象就好</p>\n<p>4.兼容老版本接口</p>\n<p>在做版本升级的时候，对于一些要废弃的接口，我们不直接将其删除，而是暂时保留，并且标注为deprecated，并将内部实现逻辑委托为新的接口实现。这样做的好处是，让使用它的项目有个过渡期，而不是强制进行代码修改。这也可以粗略地看作适配器模式的一个应用场景。</p>\n<p>JDK1.0中包含一个遍历集合容器的类Enumeration。JDK2.0对这个类进行了重构，将它改名为Iterator类，并且对它的代码实现做了优化。但是考虑到如果将Enumeration直接从JDK2.0中删除，那使用JDK1.0的项目如果切换到了JDK2.0，代码就会编译不通过。为了避免这种情况发生，我们必须把项目中所有用到Enumeration的地方，都修改为Iterator才行。</p>\n<p>单独一个项目做替换，勉强还能接受。但是一次JDK升级，导致所有项目不修改代码就会编译报错，显然是不合理的。为了兼容低版本的JDK的老代码，我们可以暂时保留Enumeration类，并将其实现替换为调用Itertor。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Collections</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Emueration <span class=\"title\">enumeration</span><span class=\"params\">(<span class=\"keyword\">final</span> Collection c)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Enumeration() &#123;</span><br><span class=\"line\">      Iterator i = c.iterator();</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasMoreElements</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> i.hashNext();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">nextElement</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> i.next();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>5.适配不同格式的数据</p>\n<p>适配器模式也可用在不用格式的数据之间的适配。比如，把不同征信系统拉取的不同格式的征信数据，统一为相同的格式，以方便存储和使用。Java中的Arrays.asList()也可以看作一种数据适配器，将数组类型的数据转化为集合容器类型。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; stooges = Arrays.asList(<span class=\"string\">&quot;Larry&quot;</span>,<span class=\"string\">&quot;Moe&quot;</span>,<span class=\"string\">&quot;Curly&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>剖析适配器模式在Java日志中的应用</p>\n<p>Java中有很多日志框架，在项目开发中，我们常常用它们来打印日志信息。常用的有log4j,logback 以及JDK提供的JUL(java,util.logging)和Apcahe的JCL(Jakarta Commons Logging)等。</p>\n<p>大部分日志框架都提供了相似的功能，比如按照不同级别打印日志等，但是它们并没有实现统一的接口。</p>\n<p>如果只是开发一个自己用的项目，那用什么日志框架都可以，log4j、logback随便选一个就好。但是如果开发的是一个集成到其他系统的组件、框架、类库等，那日志框架的选择就没那么随意了。</p>\n<p>比如项目中用到的某个组件使用log4j来打印日志，而我们项目本身使用的是logback。将组件引入到项目之后，我们的项目就相当于有了两套日志打印框架。每种日志框架都有自己的配置方式，所以我们要针对每种日志框架编写不同的配置文件，如果引入多个组件，每个组件使用的日志框架都不一样，那日志本身的管理工作就变得非常复杂。为了解决这个问题，我们需要统一日志打印框架。</p>\n<p>Slf4j这个日志框架你肯定不陌生，它相当于JDBC规范，提供了一套打印日志的统一接口规范。不过它只定义了接口，并没有提供具体的实现，需要配合其他日志框架(log4j、logback……)来使用。</p>\n<p>不仅如此，Slf4j的出现晚于JUL、JCL、log4j等日志框架，所以这些日志框架也不可能牺牲掉版本兼容性，将接口改造成符合Slf4j接口规范。Slf4j也事先考虑到了这个问题，所以，它不仅仅提供了统一的接口定义，还提供了针对不同日志框架的适配器。对不同日志框架的接口进行二次封装，适配成统一的Slf4j接口定义。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// slf4j统一的接口定义</span></span><br><span class=\"line\"><span class=\"keyword\">package</span> org.slf4j;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Logger</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isTraceEnabled</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">trace</span><span class=\"params\">(String msg)</span></span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">trace</span><span class=\"params\">(String format, Object arg)</span></span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">trace</span><span class=\"params\">(String format, Object arg1, Object arg2)</span></span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">trace</span><span class=\"params\">(String format, Object[] argArray)</span></span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">trace</span><span class=\"params\">(String msg, Throwable t)</span></span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isDebugEnabled</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">debug</span><span class=\"params\">(String msg)</span></span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">debug</span><span class=\"params\">(String format, Object arg)</span></span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">debug</span><span class=\"params\">(String format, Object arg1, Object arg2)</span></span></span><br><span class=\"line\"><span class=\"function\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">debug</span><span class=\"params\">(String format, Object[] argArray)</span></span></span><br><span class=\"line\"><span class=\"function\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">debug</span><span class=\"params\">(String msg, Throwable t)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//...省略info、warn、error等一堆接口</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// log4j日志框架的适配器</span></span><br><span class=\"line\"><span class=\"comment\">// Log4jLoggerAdapter实现了LocationAwareLogger接口，</span></span><br><span class=\"line\"><span class=\"comment\">// 其中LocationAwareLogger继承自Logger接口，</span></span><br><span class=\"line\"><span class=\"comment\">// 也就相当于Log4jLoggerAdapter实现了Logger接口。</span></span><br><span class=\"line\"><span class=\"keyword\">package</span> org.slf4j.impl;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Log4jLoggerAdapter</span> <span class=\"keyword\">extends</span> <span class=\"title\">MarkerIgnoringBase</span></span></span><br><span class=\"line\"><span class=\"class\">  <span class=\"keyword\">implements</span> <span class=\"title\">LocationAwareLogger</span>, <span class=\"title\">Serializable</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"keyword\">transient</span> org.apache.log4j.Logger logger; <span class=\"comment\">// log4j</span></span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isDebugEnabled</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> logger.isDebugEnabled();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">debug</span><span class=\"params\">(String msg)</span> </span>&#123;</span><br><span class=\"line\">    logger.log(FQCN, Level.DEBUG, msg, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">debug</span><span class=\"params\">(String format, Object arg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">      FormattingTuple ft = MessageFormatter.format(format, arg);</span><br><span class=\"line\">      logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">debug</span><span class=\"params\">(String format, Object arg1, Object arg2)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">      FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);</span><br><span class=\"line\">      logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">debug</span><span class=\"params\">(String format, Object[] argArray)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">      FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);</span><br><span class=\"line\">      logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">debug</span><span class=\"params\">(String msg, Throwable t)</span> </span>&#123;</span><br><span class=\"line\">    logger.log(FQCN, Level.DEBUG, msg, t);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//...省略一堆接口的实现...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>所以，在开发业务系统或者开发框架、组件的时候，我们统一使用Slf4j提供的接口来编写打印日志的代码，具体使用那种日志框架实现，是可以动态地制定的(使用java的SPI技术)，只需要将相应的SDK倒入到项目中即可。</p>\n<h5 id=\"代理、桥接、装饰器、适配器4种设计模式的区别\"><a href=\"#代理、桥接、装饰器、适配器4种设计模式的区别\" class=\"headerlink\" title=\"代理、桥接、装饰器、适配器4种设计模式的区别\"></a>代理、桥接、装饰器、适配器4种设计模式的区别</h5><p>代理、桥接、装饰器、适配器，这4种模式是比较常用的结构型设计模式。他们的代码结构非常相似，笼统的说，它们都可以称为Wrapper模式，也就是通过Wrapper类二次封装原始类。</p>\n<p>尽管代码结构相似，但是这4中国呢设计模式的用意完全不同，也就是说要解决的问题、应用场景不同，这也是它们的主要区别。</p>\n<p><strong>代理模式：</strong> 代理模式在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是增强非业务性的功能，这是它跟装饰器模式最大的不同。</p>\n<p><strong>桥接模式：</strong> 桥接模式的目的是将接口部分和实现部分分离，从而让它们可以较为容易、也相对独立地加以改变。</p>\n<p><strong>装饰器模式：</strong> 装饰器模式在不改变原始类接口的情况下，对原始类功能进行增强，并且支持多个装饰器的嵌套使用。</p>\n<p><strong>适配器模式：</strong> 适配器模式是一种事后的不就策略。适配器提供跟原始类不同的接口，而代理模式、装饰器模式提供的都是跟原始类相同的接口。</p>\n"},{"layout":"post","title":"设计模式之门面模式","description":"设计模式之门面模式","date":"2021-05-31T05:26:10.000Z","_content":"\n为了保证接口的可复用性，我们需要将接口尽量设计得细粒度一点，指责单一一点。但是，如果接口粒度过小，在接口的使用者开发一个业务功能时，就会导致需要调用n多细粒度的接口才能完成。调用者肯定会抱怨接口不好用。\n\n相反，如果接口粒度设计的太大，一个接口返回n多数据，要做n多事情，就会导致接口不够通用、可复用性不好。接口不可复用，那针对不同调用者的业务需求，我们就需要开发不同的接口来满足，这就回导致系统的接口无限膨胀。\n\n##### 门面模式的原理与实现\n\n门面模式，也叫外观模式，英文全称是Facade Design Pattern。Gof的《设计模式》书中，门面模式是这样定义的：\n\n> Provide a unified interface to a set of interfaces in a subsystem.Facade Pattern defines a higher-level interface that makes the subsystem easier to use.\n\n翻译成中文就是：门面模式为子系统提供一组统一的接口，定义一组高层接口让子系统更易用。\n\n假设有一个系统A，提供了a、b、c、d四个接口。系统B完成某个业务功能，需要调用A系统的a、b、d接口。利用门面模式，我们提供一个包裹a、b、d接口调用的门面接口x，给系统B直接使用。\n\n可能感觉让系统B直接调用a、b、d没什么太大问题，为什么还要提供一个包裹a、b、d的接口x呢。\n\n假设系统A是后端服务器，系统B是App客户端。App客户端通过后端服务器提供的接口来获取数据。我们知道，App和服务器之间是通过移动网络通信的，网络通信耗时比较多，为了提高App的响应速度，我们要尽量减少App与服务器之间的网络通信次数。\n\n假设，完成某个业务功能（比如现实某个页面信息）需要“依次”调用a、b、d三个接口，因自身业务的特点，不支持并发调用这三个接口。\n\n如果我们现在发现App客户端响应速度比较慢，排查后发现，是因为过多的接口调用过多的网络通信。我们就可以利用门面模式，提供一个包含a、b、d三个接口调用的接口x。客户端通过调用一次接口x，来获取到所有想要的数据，将网络通信的次数从3次减少到1次，也就提高了App的响应速度。\n\n##### 门面模式的应用场景举例\n\n门面模式让子系统更加易用，实际上，它出了解决易用性问题之外，还能考虑其他很多方面的问题。门面模式定义中的“子系统”也可以有多种理解方式。它既可以是一个完整的系统，也可以是更细粒度的类或者模块。\n\n1.解决易用性问题\n\n门面模式可以用来封装系统的底层实现，隐藏系统的复杂性，提供一组更加简单易用、更高层的接口。比如，Linux系统调用函数就可以看作一种“门面”。它是Linux操作系统暴露给开发者的一组“特殊”的编程接口，它封装了底层更基础的Linux内核调用。Linux的Shell命令，实际上也可以看作一种门面模式的应用。它封装系统调用，提供更加友好、简单的命令，让我们可以直接通过执行命令跟操作系统交互。\n\n门面模式有点类似之前讲的迪米特法则（最少知识原则）和接口隔离原则：两个有交互的系统，只暴露有限的必要的接口。除此之外，门面模式还有点类似之前说的封装、抽象的设计思想，提供更抽象的接口，封装底层实现细节。\n\n2.解决性能问题\n\n刚刚的例子已经讲到了。通过将多个接口调用替换为一个门面接口调用，减少网络通信成本，提高App客户端的响应速度。从代码实现的角度来看，如何组织门面接口和非门面接口？\n\n如果门面接口不多，完全可以将它跟非门面接口放到一起，也不需要特殊标记，当作普通接口来用即可。如果门面接口很多，可以在已有的接口之上，再重新抽象出一层，专门放置门面接口，从类、包的命名上跟原来的接口层做区分。如果门面接口特别多，并且很多都是跨多个子系统的，可以将门面接口放到一个新的子系统中。\n\n3.解决分布式事务问题\n\n通过一个例子解释一下。\n\n在一个金融系统中，有两个业务领域模型，用户和钱包。这两个业务领域模型都对外暴露了一系列接口，比如用户的增删改查接口、钱包的增删改查接口。假设有这样一个业务场景：在用户注册的时候，我们不仅会创建用户（在数据库User表中），还会给用户创建一个钱包（在数据库Wallet表中）。\n\n对于这样一个简单的业务需求，我们可以通过依次调用用户的创建接口和钱包的创建接口来完成。但是，用户注册需要事务，也就是说，创建用户和钱包的两个操作，要么都成功，要么都失败，不能一个成功、一个失败。\n\n要支持两个接口调用在一个事务中执行，是比较难实现的，这涉及分布式事务问题。虽然可以通过引入分布式事务框架或者事后补偿的机制来解决，但代码实现都比较复杂。最简单的方案是，利用数据库事务或者Spring框架提供的事务，在一个事务中，执行创建用户和创建钱包这两个SQL操作。这就要求两个SQL操作要在一个接口中完成，所以我们可以借鉴门面模式的思想，再设计一个包裹这两个操作的新接口，让新接口在一个事务中执行两个SQL操作。\n\n类、模块、系统之间的“通信”，一般都是通过接口调用来完成的。接口设计的好坏，直接影响到类、模块、系统是否好用。所以，要多花点心思在接口设计上。完成接口设计，就相当于完成了一半的开发任务，只要接口设计得好，代码就差不到哪里去。\n\n接口的可复用性和易用性需要“微妙”的权衡，针对这个问题，基本处理原则是，尽量保持接口的可复用性，但针对特殊情况，允许提供冗余的门面接口，来提供更易用的接口。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/设计模式之门面模式.md","raw":"---\nlayout:    post\ntitle:     设计模式之门面模式\ncategory:  设计模式之美\ndescription: 设计模式之门面模式\ntags: 设计模式之美\ndate: 2021/05/31 13:26:10\n---\n\n为了保证接口的可复用性，我们需要将接口尽量设计得细粒度一点，指责单一一点。但是，如果接口粒度过小，在接口的使用者开发一个业务功能时，就会导致需要调用n多细粒度的接口才能完成。调用者肯定会抱怨接口不好用。\n\n相反，如果接口粒度设计的太大，一个接口返回n多数据，要做n多事情，就会导致接口不够通用、可复用性不好。接口不可复用，那针对不同调用者的业务需求，我们就需要开发不同的接口来满足，这就回导致系统的接口无限膨胀。\n\n##### 门面模式的原理与实现\n\n门面模式，也叫外观模式，英文全称是Facade Design Pattern。Gof的《设计模式》书中，门面模式是这样定义的：\n\n> Provide a unified interface to a set of interfaces in a subsystem.Facade Pattern defines a higher-level interface that makes the subsystem easier to use.\n\n翻译成中文就是：门面模式为子系统提供一组统一的接口，定义一组高层接口让子系统更易用。\n\n假设有一个系统A，提供了a、b、c、d四个接口。系统B完成某个业务功能，需要调用A系统的a、b、d接口。利用门面模式，我们提供一个包裹a、b、d接口调用的门面接口x，给系统B直接使用。\n\n可能感觉让系统B直接调用a、b、d没什么太大问题，为什么还要提供一个包裹a、b、d的接口x呢。\n\n假设系统A是后端服务器，系统B是App客户端。App客户端通过后端服务器提供的接口来获取数据。我们知道，App和服务器之间是通过移动网络通信的，网络通信耗时比较多，为了提高App的响应速度，我们要尽量减少App与服务器之间的网络通信次数。\n\n假设，完成某个业务功能（比如现实某个页面信息）需要“依次”调用a、b、d三个接口，因自身业务的特点，不支持并发调用这三个接口。\n\n如果我们现在发现App客户端响应速度比较慢，排查后发现，是因为过多的接口调用过多的网络通信。我们就可以利用门面模式，提供一个包含a、b、d三个接口调用的接口x。客户端通过调用一次接口x，来获取到所有想要的数据，将网络通信的次数从3次减少到1次，也就提高了App的响应速度。\n\n##### 门面模式的应用场景举例\n\n门面模式让子系统更加易用，实际上，它出了解决易用性问题之外，还能考虑其他很多方面的问题。门面模式定义中的“子系统”也可以有多种理解方式。它既可以是一个完整的系统，也可以是更细粒度的类或者模块。\n\n1.解决易用性问题\n\n门面模式可以用来封装系统的底层实现，隐藏系统的复杂性，提供一组更加简单易用、更高层的接口。比如，Linux系统调用函数就可以看作一种“门面”。它是Linux操作系统暴露给开发者的一组“特殊”的编程接口，它封装了底层更基础的Linux内核调用。Linux的Shell命令，实际上也可以看作一种门面模式的应用。它封装系统调用，提供更加友好、简单的命令，让我们可以直接通过执行命令跟操作系统交互。\n\n门面模式有点类似之前讲的迪米特法则（最少知识原则）和接口隔离原则：两个有交互的系统，只暴露有限的必要的接口。除此之外，门面模式还有点类似之前说的封装、抽象的设计思想，提供更抽象的接口，封装底层实现细节。\n\n2.解决性能问题\n\n刚刚的例子已经讲到了。通过将多个接口调用替换为一个门面接口调用，减少网络通信成本，提高App客户端的响应速度。从代码实现的角度来看，如何组织门面接口和非门面接口？\n\n如果门面接口不多，完全可以将它跟非门面接口放到一起，也不需要特殊标记，当作普通接口来用即可。如果门面接口很多，可以在已有的接口之上，再重新抽象出一层，专门放置门面接口，从类、包的命名上跟原来的接口层做区分。如果门面接口特别多，并且很多都是跨多个子系统的，可以将门面接口放到一个新的子系统中。\n\n3.解决分布式事务问题\n\n通过一个例子解释一下。\n\n在一个金融系统中，有两个业务领域模型，用户和钱包。这两个业务领域模型都对外暴露了一系列接口，比如用户的增删改查接口、钱包的增删改查接口。假设有这样一个业务场景：在用户注册的时候，我们不仅会创建用户（在数据库User表中），还会给用户创建一个钱包（在数据库Wallet表中）。\n\n对于这样一个简单的业务需求，我们可以通过依次调用用户的创建接口和钱包的创建接口来完成。但是，用户注册需要事务，也就是说，创建用户和钱包的两个操作，要么都成功，要么都失败，不能一个成功、一个失败。\n\n要支持两个接口调用在一个事务中执行，是比较难实现的，这涉及分布式事务问题。虽然可以通过引入分布式事务框架或者事后补偿的机制来解决，但代码实现都比较复杂。最简单的方案是，利用数据库事务或者Spring框架提供的事务，在一个事务中，执行创建用户和创建钱包这两个SQL操作。这就要求两个SQL操作要在一个接口中完成，所以我们可以借鉴门面模式的思想，再设计一个包裹这两个操作的新接口，让新接口在一个事务中执行两个SQL操作。\n\n类、模块、系统之间的“通信”，一般都是通过接口调用来完成的。接口设计的好坏，直接影响到类、模块、系统是否好用。所以，要多花点心思在接口设计上。完成接口设计，就相当于完成了一半的开发任务，只要接口设计得好，代码就差不到哪里去。\n\n接口的可复用性和易用性需要“微妙”的权衡，针对这个问题，基本处理原则是，尽量保持接口的可复用性，但针对特殊情况，允许提供冗余的门面接口，来提供更易用的接口。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"设计模式之门面模式","published":1,"updated":"2021-05-31T05:26:10.000Z","comments":1,"photos":[],"link":"","_id":"cm1m304y7003j31b467d47zo6","content":"<p>为了保证接口的可复用性，我们需要将接口尽量设计得细粒度一点，指责单一一点。但是，如果接口粒度过小，在接口的使用者开发一个业务功能时，就会导致需要调用n多细粒度的接口才能完成。调用者肯定会抱怨接口不好用。</p>\n<p>相反，如果接口粒度设计的太大，一个接口返回n多数据，要做n多事情，就会导致接口不够通用、可复用性不好。接口不可复用，那针对不同调用者的业务需求，我们就需要开发不同的接口来满足，这就回导致系统的接口无限膨胀。</p>\n<h5 id=\"门面模式的原理与实现\"><a href=\"#门面模式的原理与实现\" class=\"headerlink\" title=\"门面模式的原理与实现\"></a>门面模式的原理与实现</h5><p>门面模式，也叫外观模式，英文全称是Facade Design Pattern。Gof的《设计模式》书中，门面模式是这样定义的：</p>\n<blockquote>\n<p>Provide a unified interface to a set of interfaces in a subsystem.Facade Pattern defines a higher-level interface that makes the subsystem easier to use.</p>\n</blockquote>\n<p>翻译成中文就是：门面模式为子系统提供一组统一的接口，定义一组高层接口让子系统更易用。</p>\n<p>假设有一个系统A，提供了a、b、c、d四个接口。系统B完成某个业务功能，需要调用A系统的a、b、d接口。利用门面模式，我们提供一个包裹a、b、d接口调用的门面接口x，给系统B直接使用。</p>\n<p>可能感觉让系统B直接调用a、b、d没什么太大问题，为什么还要提供一个包裹a、b、d的接口x呢。</p>\n<p>假设系统A是后端服务器，系统B是App客户端。App客户端通过后端服务器提供的接口来获取数据。我们知道，App和服务器之间是通过移动网络通信的，网络通信耗时比较多，为了提高App的响应速度，我们要尽量减少App与服务器之间的网络通信次数。</p>\n<p>假设，完成某个业务功能（比如现实某个页面信息）需要“依次”调用a、b、d三个接口，因自身业务的特点，不支持并发调用这三个接口。</p>\n<p>如果我们现在发现App客户端响应速度比较慢，排查后发现，是因为过多的接口调用过多的网络通信。我们就可以利用门面模式，提供一个包含a、b、d三个接口调用的接口x。客户端通过调用一次接口x，来获取到所有想要的数据，将网络通信的次数从3次减少到1次，也就提高了App的响应速度。</p>\n<h5 id=\"门面模式的应用场景举例\"><a href=\"#门面模式的应用场景举例\" class=\"headerlink\" title=\"门面模式的应用场景举例\"></a>门面模式的应用场景举例</h5><p>门面模式让子系统更加易用，实际上，它出了解决易用性问题之外，还能考虑其他很多方面的问题。门面模式定义中的“子系统”也可以有多种理解方式。它既可以是一个完整的系统，也可以是更细粒度的类或者模块。</p>\n<p>1.解决易用性问题</p>\n<p>门面模式可以用来封装系统的底层实现，隐藏系统的复杂性，提供一组更加简单易用、更高层的接口。比如，Linux系统调用函数就可以看作一种“门面”。它是Linux操作系统暴露给开发者的一组“特殊”的编程接口，它封装了底层更基础的Linux内核调用。Linux的Shell命令，实际上也可以看作一种门面模式的应用。它封装系统调用，提供更加友好、简单的命令，让我们可以直接通过执行命令跟操作系统交互。</p>\n<p>门面模式有点类似之前讲的迪米特法则（最少知识原则）和接口隔离原则：两个有交互的系统，只暴露有限的必要的接口。除此之外，门面模式还有点类似之前说的封装、抽象的设计思想，提供更抽象的接口，封装底层实现细节。</p>\n<p>2.解决性能问题</p>\n<p>刚刚的例子已经讲到了。通过将多个接口调用替换为一个门面接口调用，减少网络通信成本，提高App客户端的响应速度。从代码实现的角度来看，如何组织门面接口和非门面接口？</p>\n<p>如果门面接口不多，完全可以将它跟非门面接口放到一起，也不需要特殊标记，当作普通接口来用即可。如果门面接口很多，可以在已有的接口之上，再重新抽象出一层，专门放置门面接口，从类、包的命名上跟原来的接口层做区分。如果门面接口特别多，并且很多都是跨多个子系统的，可以将门面接口放到一个新的子系统中。</p>\n<p>3.解决分布式事务问题</p>\n<p>通过一个例子解释一下。</p>\n<p>在一个金融系统中，有两个业务领域模型，用户和钱包。这两个业务领域模型都对外暴露了一系列接口，比如用户的增删改查接口、钱包的增删改查接口。假设有这样一个业务场景：在用户注册的时候，我们不仅会创建用户（在数据库User表中），还会给用户创建一个钱包（在数据库Wallet表中）。</p>\n<p>对于这样一个简单的业务需求，我们可以通过依次调用用户的创建接口和钱包的创建接口来完成。但是，用户注册需要事务，也就是说，创建用户和钱包的两个操作，要么都成功，要么都失败，不能一个成功、一个失败。</p>\n<p>要支持两个接口调用在一个事务中执行，是比较难实现的，这涉及分布式事务问题。虽然可以通过引入分布式事务框架或者事后补偿的机制来解决，但代码实现都比较复杂。最简单的方案是，利用数据库事务或者Spring框架提供的事务，在一个事务中，执行创建用户和创建钱包这两个SQL操作。这就要求两个SQL操作要在一个接口中完成，所以我们可以借鉴门面模式的思想，再设计一个包裹这两个操作的新接口，让新接口在一个事务中执行两个SQL操作。</p>\n<p>类、模块、系统之间的“通信”，一般都是通过接口调用来完成的。接口设计的好坏，直接影响到类、模块、系统是否好用。所以，要多花点心思在接口设计上。完成接口设计，就相当于完成了一半的开发任务，只要接口设计得好，代码就差不到哪里去。</p>\n<p>接口的可复用性和易用性需要“微妙”的权衡，针对这个问题，基本处理原则是，尽量保持接口的可复用性，但针对特殊情况，允许提供冗余的门面接口，来提供更易用的接口。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>为了保证接口的可复用性，我们需要将接口尽量设计得细粒度一点，指责单一一点。但是，如果接口粒度过小，在接口的使用者开发一个业务功能时，就会导致需要调用n多细粒度的接口才能完成。调用者肯定会抱怨接口不好用。</p>\n<p>相反，如果接口粒度设计的太大，一个接口返回n多数据，要做n多事情，就会导致接口不够通用、可复用性不好。接口不可复用，那针对不同调用者的业务需求，我们就需要开发不同的接口来满足，这就回导致系统的接口无限膨胀。</p>\n<h5 id=\"门面模式的原理与实现\"><a href=\"#门面模式的原理与实现\" class=\"headerlink\" title=\"门面模式的原理与实现\"></a>门面模式的原理与实现</h5><p>门面模式，也叫外观模式，英文全称是Facade Design Pattern。Gof的《设计模式》书中，门面模式是这样定义的：</p>\n<blockquote>\n<p>Provide a unified interface to a set of interfaces in a subsystem.Facade Pattern defines a higher-level interface that makes the subsystem easier to use.</p>\n</blockquote>\n<p>翻译成中文就是：门面模式为子系统提供一组统一的接口，定义一组高层接口让子系统更易用。</p>\n<p>假设有一个系统A，提供了a、b、c、d四个接口。系统B完成某个业务功能，需要调用A系统的a、b、d接口。利用门面模式，我们提供一个包裹a、b、d接口调用的门面接口x，给系统B直接使用。</p>\n<p>可能感觉让系统B直接调用a、b、d没什么太大问题，为什么还要提供一个包裹a、b、d的接口x呢。</p>\n<p>假设系统A是后端服务器，系统B是App客户端。App客户端通过后端服务器提供的接口来获取数据。我们知道，App和服务器之间是通过移动网络通信的，网络通信耗时比较多，为了提高App的响应速度，我们要尽量减少App与服务器之间的网络通信次数。</p>\n<p>假设，完成某个业务功能（比如现实某个页面信息）需要“依次”调用a、b、d三个接口，因自身业务的特点，不支持并发调用这三个接口。</p>\n<p>如果我们现在发现App客户端响应速度比较慢，排查后发现，是因为过多的接口调用过多的网络通信。我们就可以利用门面模式，提供一个包含a、b、d三个接口调用的接口x。客户端通过调用一次接口x，来获取到所有想要的数据，将网络通信的次数从3次减少到1次，也就提高了App的响应速度。</p>\n<h5 id=\"门面模式的应用场景举例\"><a href=\"#门面模式的应用场景举例\" class=\"headerlink\" title=\"门面模式的应用场景举例\"></a>门面模式的应用场景举例</h5><p>门面模式让子系统更加易用，实际上，它出了解决易用性问题之外，还能考虑其他很多方面的问题。门面模式定义中的“子系统”也可以有多种理解方式。它既可以是一个完整的系统，也可以是更细粒度的类或者模块。</p>\n<p>1.解决易用性问题</p>\n<p>门面模式可以用来封装系统的底层实现，隐藏系统的复杂性，提供一组更加简单易用、更高层的接口。比如，Linux系统调用函数就可以看作一种“门面”。它是Linux操作系统暴露给开发者的一组“特殊”的编程接口，它封装了底层更基础的Linux内核调用。Linux的Shell命令，实际上也可以看作一种门面模式的应用。它封装系统调用，提供更加友好、简单的命令，让我们可以直接通过执行命令跟操作系统交互。</p>\n<p>门面模式有点类似之前讲的迪米特法则（最少知识原则）和接口隔离原则：两个有交互的系统，只暴露有限的必要的接口。除此之外，门面模式还有点类似之前说的封装、抽象的设计思想，提供更抽象的接口，封装底层实现细节。</p>\n<p>2.解决性能问题</p>\n<p>刚刚的例子已经讲到了。通过将多个接口调用替换为一个门面接口调用，减少网络通信成本，提高App客户端的响应速度。从代码实现的角度来看，如何组织门面接口和非门面接口？</p>\n<p>如果门面接口不多，完全可以将它跟非门面接口放到一起，也不需要特殊标记，当作普通接口来用即可。如果门面接口很多，可以在已有的接口之上，再重新抽象出一层，专门放置门面接口，从类、包的命名上跟原来的接口层做区分。如果门面接口特别多，并且很多都是跨多个子系统的，可以将门面接口放到一个新的子系统中。</p>\n<p>3.解决分布式事务问题</p>\n<p>通过一个例子解释一下。</p>\n<p>在一个金融系统中，有两个业务领域模型，用户和钱包。这两个业务领域模型都对外暴露了一系列接口，比如用户的增删改查接口、钱包的增删改查接口。假设有这样一个业务场景：在用户注册的时候，我们不仅会创建用户（在数据库User表中），还会给用户创建一个钱包（在数据库Wallet表中）。</p>\n<p>对于这样一个简单的业务需求，我们可以通过依次调用用户的创建接口和钱包的创建接口来完成。但是，用户注册需要事务，也就是说，创建用户和钱包的两个操作，要么都成功，要么都失败，不能一个成功、一个失败。</p>\n<p>要支持两个接口调用在一个事务中执行，是比较难实现的，这涉及分布式事务问题。虽然可以通过引入分布式事务框架或者事后补偿的机制来解决，但代码实现都比较复杂。最简单的方案是，利用数据库事务或者Spring框架提供的事务，在一个事务中，执行创建用户和创建钱包这两个SQL操作。这就要求两个SQL操作要在一个接口中完成，所以我们可以借鉴门面模式的思想，再设计一个包裹这两个操作的新接口，让新接口在一个事务中执行两个SQL操作。</p>\n<p>类、模块、系统之间的“通信”，一般都是通过接口调用来完成的。接口设计的好坏，直接影响到类、模块、系统是否好用。所以，要多花点心思在接口设计上。完成接口设计，就相当于完成了一半的开发任务，只要接口设计得好，代码就差不到哪里去。</p>\n<p>接口的可复用性和易用性需要“微妙”的权衡，针对这个问题，基本处理原则是，尽量保持接口的可复用性，但针对特殊情况，允许提供冗余的门面接口，来提供更易用的接口。</p>\n"},{"layout":"post","title":"AQS源码分析之Condition接口的实现","description":"AQS源码分析之Condition接口的实现","date":"2021-09-02T07:05:10.000Z","_content":"\nCondition接口是用来做控制线程的执行流程的。类似于监视器锁的wait/notify机制。可以先看下Condition提供了哪些方法。Condition接口一共定义了7个方法，根据方法名方法的用途我们也能猜个大概。\n\n| Object                            | Condition                              | 区别                         |\n| --------------------------------- | -------------------------------------- | ---------------------------- |\n| void wait()                       | void await()                           |                              |\n| void wait(long timeout)           | long awaitNanos(long nanosTimeout)     | 时间单位不同，返回值         |\n| void wait(long timeout,int nanos) | boolean await(long time,TimeUnit unit) | 时间单位同，参数类型，返回值 |\n| void notify()                     | void signal()                          |                              |\n| void notifyAll()                  | void signal                            |                              |\n| -                                 | void awaitUninterruptibly()            | Condition独有                |\n| -                                 | boolean awaitUntil(Date deadline)      | Condition独有                |\n\n类比下wait/notify机制：\n\n1.调用wait方法的线程必须是已经进入了同步代码块的线程，也就是获得了监视器锁，那么调用await方法的线程也必须是获得了lock锁。\n\n2.调用wait方法的线程会释放已获得的监视器锁，进入当前监视器锁的等待队列（wait set）中，调用await方法的线程也会释放已经获得的lock锁，进入到当前Condition对应的条件队列中。\n\n3.调用监视器锁的notify方法会唤醒等待在该监视器锁上的线程，这些线程将开始参与锁竞争，并在获得锁后，从wait方法处恢复执行。调用Condition的signal方法会唤醒对应条件队列中的线程，这些线程将开始参与锁竞争，并在获得锁后，从await方法处开始恢复执行。\n\n先来看下Condition怎么使用，这里看一下官方给的例子：\n\n```java\nclass BoundedBuffer {\n    final Lock lock = new ReentrantLock();\n    final Condition notFull = lock.newCondition();\n    final Condition notEmpty = lock.newCondition();\n\n    final Object[] items = new Object[100];\n    int putptr, takeptr, count;\n\n    // 生产者方法，往数组里面写数据\n    public void put(Object x) throws InterruptedException {\n        lock.lock();\n        try {\n            while (count == items.length)\n                notFull.await(); //数组已满，没有空间时，挂起等待，直到数组“非满”（notFull）\n            items[putptr] = x;\n            if (++putptr == items.length) putptr = 0;\n            ++count;\n            notEmpty.signal(); \n        } finally {\n            lock.unlock();\n        }\n    }\n\n    // 消费者方法，从数组里面拿数据\n    public Object take() throws InterruptedException {\n        lock.lock();\n        try {\n            while (count == 0)\n                notEmpty.await(); // 数组是空的，没有数据可拿时，挂起等待，直到数组非空（notEmpty）\n            Object x = items[takeptr];\n            if (++takeptr == items.length) takeptr = 0;\n            --count;\n            notFull.signal();\n            return x;\n        } finally {\n            lock.unlock();\n        }\n    }\n}\n```\n\n这个例子是一个生产者-消费者模型，在同一个lock上，有两个条件队列，当数组满的时候，put方法在notFull条件上等待，直到数组不满的时候。当数组为空时，take方法在notEmpty条件上等待，直到数组不为空的时候。\n\n我们知道，在AQS中所有等待锁的线程会被包装成Node扔到一个同步队列中去，那么因为条件不满足继续执行下去而调用await方法的线程应该也是放到一个队列中去了，而一个lock中又可以有多个Condition，所以我们猜测应该每个Condition内部维护一个条件队列，这样就可以互相不影响了。\n\n但是和等待锁的同步队列不同的是，同步队列是一个双向链表，nextWaiter并没有用来串联链表，而是用了prev，next属性。条件队列是一个单向链表，用nextWaiter来串联链表。\n\n### Condition实现\n\nAQS中Condition的主要实现是ConditionObject，在ConditionObject中有两个重要的属性，一个是firstWaiter，一个是lastWaiter。\n\n```java\n/** First node of condition queue. */\nprivate transient Node firstWaiter;\n/** Last node of condition queue. */\nprivate transient Node lastWaiter;\n```\n\n然后我们看await()方法。\n\n##### await()\n\n```java\npublic final void await() throws InterruptedException {\n    //如果调用await()前已经被中断，则直接抛出InterruptedException\n    if (Thread.interrupted())\n        throw new InterruptedException();\n    //将当前线程加到等待队列中\n    Node node = addConditionWaiter();\n    //释放当前线程所占用的锁\n    int savedState = fullyRelease(node);\n    int interruptMode = 0;\n    //如果当前node不在同步队列中，则直接将线程挂起\n    while (!isOnSyncQueue(node)) {\n        LockSupport.park(this);\n        //检查线程被唤醒原因，是signal还是中断\n        if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)\n            break;\n    }\n    //尝试去获取锁 然后执行后续逻辑\n    if (acquireQueued(node, savedState) && interruptMode != THROW_IE)\n        interruptMode = REINTERRUPT;\n    if (node.nextWaiter != null) // clean up if cancelled\n        unlinkCancelledWaiters();\n    if (interruptMode != 0)\n        reportInterruptAfterWait(interruptMode);\n}\n```\n\n源码中对一些代码也进行了注释，流程基本上就是这样。关于被唤醒之后的分析，我们后面再来看。\n\n##### addConditionWaiter\n\n```java\nprivate Node addConditionWaiter() {\n    Node t = lastWaiter;\n    // If lastWaiter is cancelled, clean out.\n    //如果尾节点被cancel了，则先遍历整个链表，清除所有被cancel的节点\n    if (t != null && t.waitStatus != Node.CONDITION) {\n        unlinkCancelledWaiters();\n        t = lastWaiter;\n    }\n    //当前节点入条件队列\n    Node node = new Node(Thread.currentThread(), Node.CONDITION);\n    if (t == null)\n        firstWaiter = node;\n    else\n        t.nextWaiter = node;\n    lastWaiter = node;\n    return node;\n}\n```\n\n这里看到代码中没有任何加锁操作，那么这个会存在并发问题吗？不存在，因为能进入到await方法中的线程一定是已经获得了锁的，而能获得锁的线程只有一个，也就不会存在并发，所以不需要加锁操作。在这个方法中，我们就是简单的将当前线程封装成Node加到条件队列的末尾。\n\n这里面有三个点需要注意一下：\n\n1. 节点加入sync queue是waitStatus的值是0，但节点加入condition queue是waitStatus的值为Node.CONDITION（-2）。\n2. sync queue的头节点是虚节点，如果队列为空，会先创建一个dummy节点，再创建一个代表当前节点的Node添加在dummy节点的后面。condition queue没有dummy节点，初始化时，直接将firstWaiter和lastWaiter直接指向新建的节点。\n3. sync queue是一个双向队列，在节点入队后，需要同时修改当前节点的前驱和后继。在condition queue中，节点入队，只需要修改前驱节点的nextWaiter，也就是说条件队列是当单项队列使用的。\n\n如果入队的时候，发现尾节点已经取消等待了，那么就不应该把新的node放到取消的尾节点后面，此时调用unlinkCancelledWaiters来剔除那些已经取消等待的线程：\n\n```java\nprivate void unlinkCancelledWaiters() {\n    Node t = firstWaiter;\n    Node trail = null;\n    while (t != null) {\n        Node next = t.nextWaiter;\n        if (t.waitStatus != Node.CONDITION) {\n            t.nextWaiter = null;\n            if (trail == null)\n                firstWaiter = next;\n            else\n                trail.nextWaiter = next;\n            if (next == null)\n                lastWaiter = trail;\n        }\n        else\n            trail = t;\n        t = next;\n    }\n}\n```\n\n这个方法就是从头部开始遍历队列，剔除waitStatus不是Node.CONDITION的节点。\n\n##### fullyRelease\n\n节点被成功添加到队列末尾后，将调用fullyRelease来释放当前线程所占用的锁：\n\n```java\nfinal int fullyRelease(Node node) {\n    boolean failed = true;\n    try {\n        int savedState = getState();\n        if (release(savedState)) {\n            failed = false;\n            return savedState;\n        } else {\n            throw new IllegalMonitorStateException();\n        }\n    } finally {\n        if (failed)\n            node.waitStatus = Node.CANCELLED;\n    }\n}\n```\n\n这个方法中，通过release方法去释放锁。但是这里需要注意，这里对于可重入锁而言，是一次性释放所有的锁，因为getState()拿到的是重入的次数。然后这里还需要注意，这里会抛出IllegalMonitorStateException异常，这是因为当前线程可能不是持有锁的线程，前面说执行await方法的时候一定是拿到锁的线程才能调用await方法。但是我们并没有去判断当前拿到锁的线程是不是exclusiveOwnerThread这个线程。这个检测其实是在AQS子类实现tryRelease方法来做的。ReentrantLock对tryRelease方法的实现如下：\n\n```java\nprotected final boolean tryRelease(int releases) {\n    int c = getState() - releases;\n    if (Thread.currentThread() != getExclusiveOwnerThread())\n        throw new IllegalMonitorStateException();\n    boolean free = false;\n    if (c == 0) {\n        free = true;\n        setExclusiveOwnerThread(null);\n    }\n    setState(c);\n    return free;\n}\n```\n\n当发现当前线程不是持有锁的线程时，就会进入fullyRelease的finally语句块中，将当前node的waitStatus改为Node.CANCELLED，这也是为什么添加新节点的时候，都会检查尾节点是否已经被取消了。因为会抛出IllegalMonitorStateException异常。\n\n在当前线程的锁被释放后，就可以调用LockSupport.park(this)把当前线程挂起，等待signal了。但是源码中还调用了isOnSyncQueue来检查当前线程不在sync queue中。\n\n```java\nfinal boolean isOnSyncQueue(Node node) {\n    if (node.waitStatus == Node.CONDITION || node.prev == null)\n        return false;\n    if (node.next != null) // If has successor, it must be on queue\n        return true;\n\n    return findNodeFromTail(node);\n}\n```\n\n```java\nprivate boolean findNodeFromTail(Node node) {\n    Node t = tail;\n    for (;;) {\n        if (t == node)\n            return true;\n        if (t == null)\n            return false;\n        t = t.prev;\n    }\n}\n```\n\n当前线程应该在一个独立的和sync queue无关的队列中，怎么会出现在sync queue中呢？这个要结合signal方法来看。\n\n##### signalAll\n\n调用signalAll方法的线程本身时已经持有了锁，并且准备释放锁的线程。在条件队列里的线程是已经在对应条件上挂起了，等待被signal唤醒，然后去争夺。\n\n与调用notify时线程必须时已经持有了监视器锁类似，在调用condition的signal方法时，线程必须是已经持有了lock锁：\n\n```java\npublic final void signalAll() {\n    if (!isHeldExclusively())\n        throw new IllegalMonitorStateException();\n    Node first = firstWaiter;\n    if (first != null)\n        doSignalAll(first);\n}\n```\n\nisHeldExclusively这个方法是检查当前线程是不是持有锁的线程，这个方法通常由AQS的子类来实现。ReentrantLock对该方法的实现为：\n\n```java\n        protected final boolean isHeldExclusively() {\n          return getExclusiveOwnerThread() == Thread.currentThread();\n        }\n```\n\n拿到firstWaiter判断条件队列是否为空，如果条件队列不为空，则调用doSignalAll方法：\n\n```java\nprivate void doSignalAll(Node first) {\n    //清空整个队列\n    lastWaiter = firstWaiter = null;\n    do {\n        Node next = first.nextWaiter;\n        first.nextWaiter = null;\n        transferForSignal(first);\n        first = next;\n    } while (first != null);\n}\n```\n\n通过lastWaiter = firstWaiter = null;将整个队列清空掉，然后通过循环将原来的队列的节点拿出来，通过transferForSignal方法将线程一个一个放到sync queue末尾。注意这里是一个一个放进去的，可以看下transferForSignal：\n\n```java\nfinal boolean transferForSignal(Node node) {  \n    //如果这个节点在signal前被取消，那么直接返回\n    if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))\n        return false;\n\n    //节点插入到sync queue中\n    Node p = enq(node);\n    int ws = p.waitStatus;\n    if (ws > 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))\n        LockSupport.unpark(node.thread);\n    return true;\n}\n```\n\n在transferForSignal方法中，先通过CAS操作将当前节点的waitStatus状态由CONDITION设为0，修改失败，则认为该节点已经被取消了，直接返回，操作下一个节点。如果修改成功插入到同步队列中去，这里需要注意enq返回的是node的前驱节点。sync queue中的节点需要靠前驱节点唤醒，所以需要把前驱节点waitStatus设为Node.SIGNAL。这里只要前驱节点被取消或者无法将前驱节点状态修改为Node.SIGNAL，那我们就将Node所代表的线程唤醒，但是这个不意味着lock是可以被获取的，只是唤醒这个线程去获取锁，如果获取失败，继续进入同步队列等待。\n\n总结一下signalAll方法：\n\n1. 清空条件队列（只是把lastWaiter、firstWaiter设为null，队列中节点的关系还存在）\n2. 将条件队列中的头节点取出，将它和后面的节点断开连接，然后调用transferForSignal方法\n3. 判断该节点处于被取消状态，直接跳过该节点（该节点会被GC回收）。节点状态自由，则通过enq方法，将节点放到sync queue的末尾\n4. 根据当前节点的前驱节点的waitStatus状态判断是否要唤醒当前节点，如果前驱节点被取消，或者前驱节点设置SIGNAL状态失败，直接唤醒该节点的线程\n5. 重复2到4的过程，直到整个条件队列中的节点都被处理完成\n\n##### signal\n\nsignal只是唤醒一个节点，对于AQS的实现来说，只是唤醒条件队列中第一个没有被取消的节点。\n\n```java\npublic final void signal() {\n    if (!isHeldExclusively())\n        throw new IllegalMonitorStateException();\n    Node first = firstWaiter;\n    if (first != null)\n        doSignal(first);\n}\n```\n\nisHeldExclusively方法已经分析过，检查当前线程是不是持有锁的线程。然后看doSignal方法：\n\n```java\nprivate void doSignal(Node first) {\n    do {\n        if ( (firstWaiter = first.nextWaiter) == null)\n            lastWaiter = null;\n        first.nextWaiter = null;\n    } while (!transferForSignal(first) &&\n             (first = firstWaiter) != null);\n}\n```\n\n这个看到是一个循环，也是为了找队列中第一个没有被取消的节点，然后将这个节点放到同步队列中去。也是将first取出来，然后将nextWaiter设置为null，调用transferForSignal方法，这个方法的返回值将决定循环是否继续。如果返回true，那么while循环的条件就不满足了，所以只会唤醒一个线程。\n\n唤醒已经讲完了，我们再来看await方法。因为唤醒的时候，会让线程回到原来阻塞的地方继续执行。\n\n```java\npublic final void await() throws InterruptedException {\n    if (Thread.interrupted())\n        throw new InterruptedException();\n    Node node = addConditionWaiter();\n    int savedState = fullyRelease(node);\n    int interruptMode = 0;\n    while (!isOnSyncQueue(node)) {\n        LockSupport.park(this); \n        // 这里就是阻塞回来的位置\n        if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)\n            break;\n    }\n    if (acquireQueued(node, savedState) && interruptMode != THROW_IE)\n        interruptMode = REINTERRUPT;\n    if (node.nextWaiter != null) \n        unlinkCancelledWaiters();\n    if (interruptMode != 0)\n        reportInterruptAfterWait(interruptMode);\n}\n```\n\n但是线程被唤醒，并不知道是什么原因被唤醒的。但是既然唤醒了，那么就需要acquireQueued方法进行“阻塞式”获取锁，抢到锁就返回，抢不到锁就继续被挂起。当await方法返回时，当前线程一定已经持有了lock锁。\n\n如果从线程被唤醒，到线程获取到锁这段过程中发生过中断，应该如何处理呢？\n\n中断对当前线程只是个建议，有当前线程决定怎么对其做出处理。acquireQueued方法对中断是不响应的，只是简单的记录抢锁过程中的中断状态，并在抢到锁后将这个中断状态返回，交给上层调用函数处理，此时也就是await方法。await方法如何处理这个中断，**取决于这个中断发生时，线程是否已经被signal**。\n\n在调用await方法时，就会检查当前线程的中断状态，如果线程还未阻塞就被中断，那么直接抛出InterruptedException。如果中断发生时，线程没有被signal过，那么等待中的线程就会被打断，也就是一个意料之外的唤醒，所以线程被唤醒后，需要抛出InterruptedException，表示当前线程因为中断而被唤醒。如果中断发生时，当前线程已经被signal过了，它就已经正常地从condition queue中唤醒了，那么这个中断来的就比较晚了，因为已经是正常唤醒之后才来的中断，那么就在await方法中补一下这个中断，调用Thread.interrupted()方法检测是否发生中断时也会将中断状态清除，因此如果忽略中断，则应该在await方法将线程恢复成原来的样子。\n\n在await方法中，用变量interruptMode记录中断事件：\n\n1. 0：没有中断发生\n2. 1：REINTERRUPT 表示中断发生在signal之后，需要再次自我中断\n3. -1:THROW_IE 表示中断发生在signal之前，需要抛出InterruptedException\n\nacquireQueued这个方法两个参数，我们前面说了释放锁的时候是释放所有的可重入锁，现在加锁的时候也是原来释放多少，这次就加多少锁。unlinkCancelledWaiters这个方法已经讲过了，就是遍历链表，然后把waitStatus不为CONDITION的节点从队列中移除。reportInterruptAfterWait是用来汇报中断的：\n\n```java\nprivate void reportInterruptAfterWait(int interruptMode)\n    throws InterruptedException {\n    if (interruptMode == THROW_IE)\n        throw new InterruptedException();\n    else if (interruptMode == REINTERRUPT)\n        selfInterrupt();\n}\n```\n\n如果interruptMode=THROW_IE，则直接抛出异常，报告等待的时候被中断异常唤醒。\n\n来总结一下：\n\n**中断发生在signal之前**\n\n1. 线程因为中断被唤醒，通过checkInterruptWhileWaiting方法调用transferAfterCancelledWait方法来确认线程的waitStatus的值为Node.CONDITION，说明线程没有被signal\n2. 修改线程的waitStatus为0，通过enq(node)将其添加到sync queue中\n3. 线程获取锁，如果获取不到，则被再次挂起\n4. 线程获取到锁后，调用unlinkCancelledWaiters方法将自己从条件队列中移除，该方法顺便移除其他取消等待的锁\n5. 通过reportInterruptAfterWait抛出InterruptedException\n\n一个调用await方法挂起的线程在被中断后不会立即抛出InterruptedException，而是进入同步队列去竞争锁，争不到，挂起，如果争到锁了，从同步队列和条件队列移除，抛出InterruptedException。\n\n**中断发生在signal之后**\n\n这种情况其实就是线程被唤醒后，然后产生的中断，并没有影响到我们线程正常的阻塞到被signal唤醒的流程，所以，我们并不需要抛出InterruptedException异常，我们可以忽略这个中断，在await方法返回的时候，将这个线程重新中断一下，对忽略的中断进行一个补偿。\n\n##### await总结\n\n我们对整个await方法进行一个总结：\n\n1. 进入await()时必须已经持有了锁\n2. 离开await()时必须已经持有了锁\n3. 调用await()会使当前线程被封装成Node扔进条件队列，并且释放所有持有的锁\n4. 释放锁后，当前线程被挂起，等待signal或者中断唤醒线程\n5. 线程被唤醒后，进入同步队列进行抢锁\n6. 线程在抢到锁之前发生过中断，则根据中断发生在signal之前还是之后记录中断模式，体现在interruptMode\n7. 线程在抢到锁后进行售后工作（离开条件队列，处理中断异常）\n\n##### awaitUninterruptibly\n\n中断和signal都可以把线程唤醒，但是中断是一种异常唤醒，唤醒以后线程发现等待的条件并为满足，还是需要将线程挂起。当不希望await方法被中断时，可以使用awaitUninterruptibly方法：\n\n```java\npublic final void awaitUninterruptibly() {\n    Node node = addConditionWaiter();\n    int savedState = fullyRelease(node);\n    boolean interrupted = false;\n    while (!isOnSyncQueue(node)) {\n        LockSupport.park(this);\n        if (Thread.interrupted())\n            interrupted = true;\n    }\n    if (acquireQueued(node, savedState) || interrupted)\n        selfInterrupt();\n}\n```\n\n可以看到就算中断唤醒了线程，也仅仅是记录interrupted状态为true，然后继续阻塞，等到signal才会唤醒线程去获取锁，当发生中断，不管什么时候的中断，都是最终补偿中断一次，并且不会抛出InterruptedException\n\n##### awaitNanos\n\n前面的await和awaitUninterruptibly，它们在抢锁的过程中都是阻塞式的，一直抢到锁才能返回，否则线程一直挂起，这样的话就是线程如果长时间抢不到锁，就会一直被阻塞，因此有时候更需要带超时机制的去抢锁，和wait(long timeout)很像。看下源码：\n\n```java\npublic final long awaitNanos(long nanosTimeout)\n    throws InterruptedException {\n    if (Thread.interrupted())\n        throw new InterruptedException();\n    Node node = addConditionWaiter();\n    int savedState = fullyRelease(node);\n    final long deadline = System.nanoTime() + nanosTimeout;\n    int interruptMode = 0;\n    while (!isOnSyncQueue(node)) {\n        if (nanosTimeout <= 0L) {\n            transferAfterCancelledWait(node);\n            break;\n        }\n        if (nanosTimeout >= spinForTimeoutThreshold)\n            LockSupport.parkNanos(this, nanosTimeout);\n        if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)\n            break;\n        nanosTimeout = deadline - System.nanoTime();\n    }\n    if (acquireQueued(node, savedState) && interruptMode != THROW_IE)\n        interruptMode = REINTERRUPT;\n    if (node.nextWaiter != null)\n        unlinkCancelledWaiters();\n    if (interruptMode != 0)\n        reportInterruptAfterWait(interruptMode);\n    return deadline - System.nanoTime();\n}\n```\n\n这个方法基本上和await方法一样，只是多了超时时间的处理。上面这段代码的意思是，如果超时时间没到，那么就将线程挂起，超过等待时间了，将线程从条件队列转移到同步队列中。这里对超时时间很短的时间做了一个优化，当超时时间小于spinForTimeoutThreshold(1000L ns)时，通过自旋的方式等待唤醒，而不是将线程挂起。\n\nwait(0)表示无限期等待，那么如果awaitNanos我们传0是一样的吗？\n\n```java\nif (nanosTimeout <= 0L) {\n    transferAfterCancelledWait(node);\n    break;\n}\n```\n\n上面代码中已经有这段了，我这里单独提出来再来看下。这里可以看到当nanosTimeout<=0的时候，就会将线程从条件等待队列转移到同步队列中，并不会被挂起，也不需要signal。\n\n##### await(long time, TimeUnit unit)\n\n这个方法就是在awaitNanos方法基础上多了对超时时间单位的设置，但是在内部实现上还是会把时间转成纳秒去执行\n\n```java\npublic final boolean await(long time, TimeUnit unit)\n    throws InterruptedException {\n    long nanosTimeout = unit.toNanos(time);\n    if (Thread.interrupted())\n        throw new InterruptedException();\n    Node node = addConditionWaiter();\n    int savedState = fullyRelease(node);\n    final long deadline = System.nanoTime() + nanosTimeout;\n    boolean timedout = false;\n    int interruptMode = 0;\n    while (!isOnSyncQueue(node)) {\n        if (nanosTimeout <= 0L) {\n            timedout = transferAfterCancelledWait(node);\n            break;\n        }\n        if (nanosTimeout >= spinForTimeoutThreshold)\n            LockSupport.parkNanos(this, nanosTimeout);\n        if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)\n            break;\n        nanosTimeout = deadline - System.nanoTime();\n    }\n    if (acquireQueued(node, savedState) && interruptMode != THROW_IE)\n        interruptMode = REINTERRUPT;\n    if (node.nextWaiter != null)\n        unlinkCancelledWaiters();\n    if (interruptMode != 0)\n        reportInterruptAfterWait(interruptMode);\n    return !timedout;\n}\n```\n\nawaitNanos(long nanosTimeout)的返回值是剩余的超时时间，如果该值大于0，说明超时时间还没到，则说明该返回是由signal行为导致的，而await(long time,TimeUnit unit)的返回值是transferAfterCancelledWait(node)的值决定的，调用该方法时，如果node还没有被signal过则返回true，否则返回false。其实这个方法就等价于调用awaitNanos(unit.toNanos(time)) > 0。\n\n### awaitUntil(Date deadline)\n\nawaitUntil方法和上面几个方法类似，只不过这个参数是一个绝对时间\n\n```java\npublic final boolean awaitUntil(Date deadline)\n    throws InterruptedException {\n    long abstime = deadline.getTime();\n    if (Thread.interrupted())\n        throw new InterruptedException();\n    Node node = addConditionWaiter();\n    int savedState = fullyRelease(node);\n    boolean timedout = false;\n    int interruptMode = 0;\n    while (!isOnSyncQueue(node)) {\n        if (System.currentTimeMillis() > abstime) {\n            timedout = transferAfterCancelledWait(node);\n            break;\n        }\n        LockSupport.parkUntil(this, abstime);\n        if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)\n            break;\n    }\n    if (acquireQueued(node, savedState) && interruptMode != THROW_IE)\n        interruptMode = REINTERRUPT;\n    if (node.nextWaiter != null)\n        unlinkCancelledWaiters();\n    if (interruptMode != 0)\n        reportInterruptAfterWait(interruptMode);\n    return !timedout;\n}\n```\n\n这个方法仅仅就是时间用成了绝对时间，并且没有使用spinForTimeoutThreshold进行自旋优化，因为调用这个方法，目的就是设一个较长的等待时间，不然上面的其他方法用起来更方便一些。","source":"_posts/AQS源码分析之Condition接口的实现.md","raw":"---\nlayout:    post\ntitle:     AQS源码分析之Condition接口的实现\ncategory:  JUC\ndescription: AQS源码分析之Condition接口的实现\ntags: \n    - JDK\n    - JUC\n    - AQS\ndate: 2021/09/02 15:05:10\n\n---\n\nCondition接口是用来做控制线程的执行流程的。类似于监视器锁的wait/notify机制。可以先看下Condition提供了哪些方法。Condition接口一共定义了7个方法，根据方法名方法的用途我们也能猜个大概。\n\n| Object                            | Condition                              | 区别                         |\n| --------------------------------- | -------------------------------------- | ---------------------------- |\n| void wait()                       | void await()                           |                              |\n| void wait(long timeout)           | long awaitNanos(long nanosTimeout)     | 时间单位不同，返回值         |\n| void wait(long timeout,int nanos) | boolean await(long time,TimeUnit unit) | 时间单位同，参数类型，返回值 |\n| void notify()                     | void signal()                          |                              |\n| void notifyAll()                  | void signal                            |                              |\n| -                                 | void awaitUninterruptibly()            | Condition独有                |\n| -                                 | boolean awaitUntil(Date deadline)      | Condition独有                |\n\n类比下wait/notify机制：\n\n1.调用wait方法的线程必须是已经进入了同步代码块的线程，也就是获得了监视器锁，那么调用await方法的线程也必须是获得了lock锁。\n\n2.调用wait方法的线程会释放已获得的监视器锁，进入当前监视器锁的等待队列（wait set）中，调用await方法的线程也会释放已经获得的lock锁，进入到当前Condition对应的条件队列中。\n\n3.调用监视器锁的notify方法会唤醒等待在该监视器锁上的线程，这些线程将开始参与锁竞争，并在获得锁后，从wait方法处恢复执行。调用Condition的signal方法会唤醒对应条件队列中的线程，这些线程将开始参与锁竞争，并在获得锁后，从await方法处开始恢复执行。\n\n先来看下Condition怎么使用，这里看一下官方给的例子：\n\n```java\nclass BoundedBuffer {\n    final Lock lock = new ReentrantLock();\n    final Condition notFull = lock.newCondition();\n    final Condition notEmpty = lock.newCondition();\n\n    final Object[] items = new Object[100];\n    int putptr, takeptr, count;\n\n    // 生产者方法，往数组里面写数据\n    public void put(Object x) throws InterruptedException {\n        lock.lock();\n        try {\n            while (count == items.length)\n                notFull.await(); //数组已满，没有空间时，挂起等待，直到数组“非满”（notFull）\n            items[putptr] = x;\n            if (++putptr == items.length) putptr = 0;\n            ++count;\n            notEmpty.signal(); \n        } finally {\n            lock.unlock();\n        }\n    }\n\n    // 消费者方法，从数组里面拿数据\n    public Object take() throws InterruptedException {\n        lock.lock();\n        try {\n            while (count == 0)\n                notEmpty.await(); // 数组是空的，没有数据可拿时，挂起等待，直到数组非空（notEmpty）\n            Object x = items[takeptr];\n            if (++takeptr == items.length) takeptr = 0;\n            --count;\n            notFull.signal();\n            return x;\n        } finally {\n            lock.unlock();\n        }\n    }\n}\n```\n\n这个例子是一个生产者-消费者模型，在同一个lock上，有两个条件队列，当数组满的时候，put方法在notFull条件上等待，直到数组不满的时候。当数组为空时，take方法在notEmpty条件上等待，直到数组不为空的时候。\n\n我们知道，在AQS中所有等待锁的线程会被包装成Node扔到一个同步队列中去，那么因为条件不满足继续执行下去而调用await方法的线程应该也是放到一个队列中去了，而一个lock中又可以有多个Condition，所以我们猜测应该每个Condition内部维护一个条件队列，这样就可以互相不影响了。\n\n但是和等待锁的同步队列不同的是，同步队列是一个双向链表，nextWaiter并没有用来串联链表，而是用了prev，next属性。条件队列是一个单向链表，用nextWaiter来串联链表。\n\n### Condition实现\n\nAQS中Condition的主要实现是ConditionObject，在ConditionObject中有两个重要的属性，一个是firstWaiter，一个是lastWaiter。\n\n```java\n/** First node of condition queue. */\nprivate transient Node firstWaiter;\n/** Last node of condition queue. */\nprivate transient Node lastWaiter;\n```\n\n然后我们看await()方法。\n\n##### await()\n\n```java\npublic final void await() throws InterruptedException {\n    //如果调用await()前已经被中断，则直接抛出InterruptedException\n    if (Thread.interrupted())\n        throw new InterruptedException();\n    //将当前线程加到等待队列中\n    Node node = addConditionWaiter();\n    //释放当前线程所占用的锁\n    int savedState = fullyRelease(node);\n    int interruptMode = 0;\n    //如果当前node不在同步队列中，则直接将线程挂起\n    while (!isOnSyncQueue(node)) {\n        LockSupport.park(this);\n        //检查线程被唤醒原因，是signal还是中断\n        if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)\n            break;\n    }\n    //尝试去获取锁 然后执行后续逻辑\n    if (acquireQueued(node, savedState) && interruptMode != THROW_IE)\n        interruptMode = REINTERRUPT;\n    if (node.nextWaiter != null) // clean up if cancelled\n        unlinkCancelledWaiters();\n    if (interruptMode != 0)\n        reportInterruptAfterWait(interruptMode);\n}\n```\n\n源码中对一些代码也进行了注释，流程基本上就是这样。关于被唤醒之后的分析，我们后面再来看。\n\n##### addConditionWaiter\n\n```java\nprivate Node addConditionWaiter() {\n    Node t = lastWaiter;\n    // If lastWaiter is cancelled, clean out.\n    //如果尾节点被cancel了，则先遍历整个链表，清除所有被cancel的节点\n    if (t != null && t.waitStatus != Node.CONDITION) {\n        unlinkCancelledWaiters();\n        t = lastWaiter;\n    }\n    //当前节点入条件队列\n    Node node = new Node(Thread.currentThread(), Node.CONDITION);\n    if (t == null)\n        firstWaiter = node;\n    else\n        t.nextWaiter = node;\n    lastWaiter = node;\n    return node;\n}\n```\n\n这里看到代码中没有任何加锁操作，那么这个会存在并发问题吗？不存在，因为能进入到await方法中的线程一定是已经获得了锁的，而能获得锁的线程只有一个，也就不会存在并发，所以不需要加锁操作。在这个方法中，我们就是简单的将当前线程封装成Node加到条件队列的末尾。\n\n这里面有三个点需要注意一下：\n\n1. 节点加入sync queue是waitStatus的值是0，但节点加入condition queue是waitStatus的值为Node.CONDITION（-2）。\n2. sync queue的头节点是虚节点，如果队列为空，会先创建一个dummy节点，再创建一个代表当前节点的Node添加在dummy节点的后面。condition queue没有dummy节点，初始化时，直接将firstWaiter和lastWaiter直接指向新建的节点。\n3. sync queue是一个双向队列，在节点入队后，需要同时修改当前节点的前驱和后继。在condition queue中，节点入队，只需要修改前驱节点的nextWaiter，也就是说条件队列是当单项队列使用的。\n\n如果入队的时候，发现尾节点已经取消等待了，那么就不应该把新的node放到取消的尾节点后面，此时调用unlinkCancelledWaiters来剔除那些已经取消等待的线程：\n\n```java\nprivate void unlinkCancelledWaiters() {\n    Node t = firstWaiter;\n    Node trail = null;\n    while (t != null) {\n        Node next = t.nextWaiter;\n        if (t.waitStatus != Node.CONDITION) {\n            t.nextWaiter = null;\n            if (trail == null)\n                firstWaiter = next;\n            else\n                trail.nextWaiter = next;\n            if (next == null)\n                lastWaiter = trail;\n        }\n        else\n            trail = t;\n        t = next;\n    }\n}\n```\n\n这个方法就是从头部开始遍历队列，剔除waitStatus不是Node.CONDITION的节点。\n\n##### fullyRelease\n\n节点被成功添加到队列末尾后，将调用fullyRelease来释放当前线程所占用的锁：\n\n```java\nfinal int fullyRelease(Node node) {\n    boolean failed = true;\n    try {\n        int savedState = getState();\n        if (release(savedState)) {\n            failed = false;\n            return savedState;\n        } else {\n            throw new IllegalMonitorStateException();\n        }\n    } finally {\n        if (failed)\n            node.waitStatus = Node.CANCELLED;\n    }\n}\n```\n\n这个方法中，通过release方法去释放锁。但是这里需要注意，这里对于可重入锁而言，是一次性释放所有的锁，因为getState()拿到的是重入的次数。然后这里还需要注意，这里会抛出IllegalMonitorStateException异常，这是因为当前线程可能不是持有锁的线程，前面说执行await方法的时候一定是拿到锁的线程才能调用await方法。但是我们并没有去判断当前拿到锁的线程是不是exclusiveOwnerThread这个线程。这个检测其实是在AQS子类实现tryRelease方法来做的。ReentrantLock对tryRelease方法的实现如下：\n\n```java\nprotected final boolean tryRelease(int releases) {\n    int c = getState() - releases;\n    if (Thread.currentThread() != getExclusiveOwnerThread())\n        throw new IllegalMonitorStateException();\n    boolean free = false;\n    if (c == 0) {\n        free = true;\n        setExclusiveOwnerThread(null);\n    }\n    setState(c);\n    return free;\n}\n```\n\n当发现当前线程不是持有锁的线程时，就会进入fullyRelease的finally语句块中，将当前node的waitStatus改为Node.CANCELLED，这也是为什么添加新节点的时候，都会检查尾节点是否已经被取消了。因为会抛出IllegalMonitorStateException异常。\n\n在当前线程的锁被释放后，就可以调用LockSupport.park(this)把当前线程挂起，等待signal了。但是源码中还调用了isOnSyncQueue来检查当前线程不在sync queue中。\n\n```java\nfinal boolean isOnSyncQueue(Node node) {\n    if (node.waitStatus == Node.CONDITION || node.prev == null)\n        return false;\n    if (node.next != null) // If has successor, it must be on queue\n        return true;\n\n    return findNodeFromTail(node);\n}\n```\n\n```java\nprivate boolean findNodeFromTail(Node node) {\n    Node t = tail;\n    for (;;) {\n        if (t == node)\n            return true;\n        if (t == null)\n            return false;\n        t = t.prev;\n    }\n}\n```\n\n当前线程应该在一个独立的和sync queue无关的队列中，怎么会出现在sync queue中呢？这个要结合signal方法来看。\n\n##### signalAll\n\n调用signalAll方法的线程本身时已经持有了锁，并且准备释放锁的线程。在条件队列里的线程是已经在对应条件上挂起了，等待被signal唤醒，然后去争夺。\n\n与调用notify时线程必须时已经持有了监视器锁类似，在调用condition的signal方法时，线程必须是已经持有了lock锁：\n\n```java\npublic final void signalAll() {\n    if (!isHeldExclusively())\n        throw new IllegalMonitorStateException();\n    Node first = firstWaiter;\n    if (first != null)\n        doSignalAll(first);\n}\n```\n\nisHeldExclusively这个方法是检查当前线程是不是持有锁的线程，这个方法通常由AQS的子类来实现。ReentrantLock对该方法的实现为：\n\n```java\n        protected final boolean isHeldExclusively() {\n          return getExclusiveOwnerThread() == Thread.currentThread();\n        }\n```\n\n拿到firstWaiter判断条件队列是否为空，如果条件队列不为空，则调用doSignalAll方法：\n\n```java\nprivate void doSignalAll(Node first) {\n    //清空整个队列\n    lastWaiter = firstWaiter = null;\n    do {\n        Node next = first.nextWaiter;\n        first.nextWaiter = null;\n        transferForSignal(first);\n        first = next;\n    } while (first != null);\n}\n```\n\n通过lastWaiter = firstWaiter = null;将整个队列清空掉，然后通过循环将原来的队列的节点拿出来，通过transferForSignal方法将线程一个一个放到sync queue末尾。注意这里是一个一个放进去的，可以看下transferForSignal：\n\n```java\nfinal boolean transferForSignal(Node node) {  \n    //如果这个节点在signal前被取消，那么直接返回\n    if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))\n        return false;\n\n    //节点插入到sync queue中\n    Node p = enq(node);\n    int ws = p.waitStatus;\n    if (ws > 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))\n        LockSupport.unpark(node.thread);\n    return true;\n}\n```\n\n在transferForSignal方法中，先通过CAS操作将当前节点的waitStatus状态由CONDITION设为0，修改失败，则认为该节点已经被取消了，直接返回，操作下一个节点。如果修改成功插入到同步队列中去，这里需要注意enq返回的是node的前驱节点。sync queue中的节点需要靠前驱节点唤醒，所以需要把前驱节点waitStatus设为Node.SIGNAL。这里只要前驱节点被取消或者无法将前驱节点状态修改为Node.SIGNAL，那我们就将Node所代表的线程唤醒，但是这个不意味着lock是可以被获取的，只是唤醒这个线程去获取锁，如果获取失败，继续进入同步队列等待。\n\n总结一下signalAll方法：\n\n1. 清空条件队列（只是把lastWaiter、firstWaiter设为null，队列中节点的关系还存在）\n2. 将条件队列中的头节点取出，将它和后面的节点断开连接，然后调用transferForSignal方法\n3. 判断该节点处于被取消状态，直接跳过该节点（该节点会被GC回收）。节点状态自由，则通过enq方法，将节点放到sync queue的末尾\n4. 根据当前节点的前驱节点的waitStatus状态判断是否要唤醒当前节点，如果前驱节点被取消，或者前驱节点设置SIGNAL状态失败，直接唤醒该节点的线程\n5. 重复2到4的过程，直到整个条件队列中的节点都被处理完成\n\n##### signal\n\nsignal只是唤醒一个节点，对于AQS的实现来说，只是唤醒条件队列中第一个没有被取消的节点。\n\n```java\npublic final void signal() {\n    if (!isHeldExclusively())\n        throw new IllegalMonitorStateException();\n    Node first = firstWaiter;\n    if (first != null)\n        doSignal(first);\n}\n```\n\nisHeldExclusively方法已经分析过，检查当前线程是不是持有锁的线程。然后看doSignal方法：\n\n```java\nprivate void doSignal(Node first) {\n    do {\n        if ( (firstWaiter = first.nextWaiter) == null)\n            lastWaiter = null;\n        first.nextWaiter = null;\n    } while (!transferForSignal(first) &&\n             (first = firstWaiter) != null);\n}\n```\n\n这个看到是一个循环，也是为了找队列中第一个没有被取消的节点，然后将这个节点放到同步队列中去。也是将first取出来，然后将nextWaiter设置为null，调用transferForSignal方法，这个方法的返回值将决定循环是否继续。如果返回true，那么while循环的条件就不满足了，所以只会唤醒一个线程。\n\n唤醒已经讲完了，我们再来看await方法。因为唤醒的时候，会让线程回到原来阻塞的地方继续执行。\n\n```java\npublic final void await() throws InterruptedException {\n    if (Thread.interrupted())\n        throw new InterruptedException();\n    Node node = addConditionWaiter();\n    int savedState = fullyRelease(node);\n    int interruptMode = 0;\n    while (!isOnSyncQueue(node)) {\n        LockSupport.park(this); \n        // 这里就是阻塞回来的位置\n        if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)\n            break;\n    }\n    if (acquireQueued(node, savedState) && interruptMode != THROW_IE)\n        interruptMode = REINTERRUPT;\n    if (node.nextWaiter != null) \n        unlinkCancelledWaiters();\n    if (interruptMode != 0)\n        reportInterruptAfterWait(interruptMode);\n}\n```\n\n但是线程被唤醒，并不知道是什么原因被唤醒的。但是既然唤醒了，那么就需要acquireQueued方法进行“阻塞式”获取锁，抢到锁就返回，抢不到锁就继续被挂起。当await方法返回时，当前线程一定已经持有了lock锁。\n\n如果从线程被唤醒，到线程获取到锁这段过程中发生过中断，应该如何处理呢？\n\n中断对当前线程只是个建议，有当前线程决定怎么对其做出处理。acquireQueued方法对中断是不响应的，只是简单的记录抢锁过程中的中断状态，并在抢到锁后将这个中断状态返回，交给上层调用函数处理，此时也就是await方法。await方法如何处理这个中断，**取决于这个中断发生时，线程是否已经被signal**。\n\n在调用await方法时，就会检查当前线程的中断状态，如果线程还未阻塞就被中断，那么直接抛出InterruptedException。如果中断发生时，线程没有被signal过，那么等待中的线程就会被打断，也就是一个意料之外的唤醒，所以线程被唤醒后，需要抛出InterruptedException，表示当前线程因为中断而被唤醒。如果中断发生时，当前线程已经被signal过了，它就已经正常地从condition queue中唤醒了，那么这个中断来的就比较晚了，因为已经是正常唤醒之后才来的中断，那么就在await方法中补一下这个中断，调用Thread.interrupted()方法检测是否发生中断时也会将中断状态清除，因此如果忽略中断，则应该在await方法将线程恢复成原来的样子。\n\n在await方法中，用变量interruptMode记录中断事件：\n\n1. 0：没有中断发生\n2. 1：REINTERRUPT 表示中断发生在signal之后，需要再次自我中断\n3. -1:THROW_IE 表示中断发生在signal之前，需要抛出InterruptedException\n\nacquireQueued这个方法两个参数，我们前面说了释放锁的时候是释放所有的可重入锁，现在加锁的时候也是原来释放多少，这次就加多少锁。unlinkCancelledWaiters这个方法已经讲过了，就是遍历链表，然后把waitStatus不为CONDITION的节点从队列中移除。reportInterruptAfterWait是用来汇报中断的：\n\n```java\nprivate void reportInterruptAfterWait(int interruptMode)\n    throws InterruptedException {\n    if (interruptMode == THROW_IE)\n        throw new InterruptedException();\n    else if (interruptMode == REINTERRUPT)\n        selfInterrupt();\n}\n```\n\n如果interruptMode=THROW_IE，则直接抛出异常，报告等待的时候被中断异常唤醒。\n\n来总结一下：\n\n**中断发生在signal之前**\n\n1. 线程因为中断被唤醒，通过checkInterruptWhileWaiting方法调用transferAfterCancelledWait方法来确认线程的waitStatus的值为Node.CONDITION，说明线程没有被signal\n2. 修改线程的waitStatus为0，通过enq(node)将其添加到sync queue中\n3. 线程获取锁，如果获取不到，则被再次挂起\n4. 线程获取到锁后，调用unlinkCancelledWaiters方法将自己从条件队列中移除，该方法顺便移除其他取消等待的锁\n5. 通过reportInterruptAfterWait抛出InterruptedException\n\n一个调用await方法挂起的线程在被中断后不会立即抛出InterruptedException，而是进入同步队列去竞争锁，争不到，挂起，如果争到锁了，从同步队列和条件队列移除，抛出InterruptedException。\n\n**中断发生在signal之后**\n\n这种情况其实就是线程被唤醒后，然后产生的中断，并没有影响到我们线程正常的阻塞到被signal唤醒的流程，所以，我们并不需要抛出InterruptedException异常，我们可以忽略这个中断，在await方法返回的时候，将这个线程重新中断一下，对忽略的中断进行一个补偿。\n\n##### await总结\n\n我们对整个await方法进行一个总结：\n\n1. 进入await()时必须已经持有了锁\n2. 离开await()时必须已经持有了锁\n3. 调用await()会使当前线程被封装成Node扔进条件队列，并且释放所有持有的锁\n4. 释放锁后，当前线程被挂起，等待signal或者中断唤醒线程\n5. 线程被唤醒后，进入同步队列进行抢锁\n6. 线程在抢到锁之前发生过中断，则根据中断发生在signal之前还是之后记录中断模式，体现在interruptMode\n7. 线程在抢到锁后进行售后工作（离开条件队列，处理中断异常）\n\n##### awaitUninterruptibly\n\n中断和signal都可以把线程唤醒，但是中断是一种异常唤醒，唤醒以后线程发现等待的条件并为满足，还是需要将线程挂起。当不希望await方法被中断时，可以使用awaitUninterruptibly方法：\n\n```java\npublic final void awaitUninterruptibly() {\n    Node node = addConditionWaiter();\n    int savedState = fullyRelease(node);\n    boolean interrupted = false;\n    while (!isOnSyncQueue(node)) {\n        LockSupport.park(this);\n        if (Thread.interrupted())\n            interrupted = true;\n    }\n    if (acquireQueued(node, savedState) || interrupted)\n        selfInterrupt();\n}\n```\n\n可以看到就算中断唤醒了线程，也仅仅是记录interrupted状态为true，然后继续阻塞，等到signal才会唤醒线程去获取锁，当发生中断，不管什么时候的中断，都是最终补偿中断一次，并且不会抛出InterruptedException\n\n##### awaitNanos\n\n前面的await和awaitUninterruptibly，它们在抢锁的过程中都是阻塞式的，一直抢到锁才能返回，否则线程一直挂起，这样的话就是线程如果长时间抢不到锁，就会一直被阻塞，因此有时候更需要带超时机制的去抢锁，和wait(long timeout)很像。看下源码：\n\n```java\npublic final long awaitNanos(long nanosTimeout)\n    throws InterruptedException {\n    if (Thread.interrupted())\n        throw new InterruptedException();\n    Node node = addConditionWaiter();\n    int savedState = fullyRelease(node);\n    final long deadline = System.nanoTime() + nanosTimeout;\n    int interruptMode = 0;\n    while (!isOnSyncQueue(node)) {\n        if (nanosTimeout <= 0L) {\n            transferAfterCancelledWait(node);\n            break;\n        }\n        if (nanosTimeout >= spinForTimeoutThreshold)\n            LockSupport.parkNanos(this, nanosTimeout);\n        if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)\n            break;\n        nanosTimeout = deadline - System.nanoTime();\n    }\n    if (acquireQueued(node, savedState) && interruptMode != THROW_IE)\n        interruptMode = REINTERRUPT;\n    if (node.nextWaiter != null)\n        unlinkCancelledWaiters();\n    if (interruptMode != 0)\n        reportInterruptAfterWait(interruptMode);\n    return deadline - System.nanoTime();\n}\n```\n\n这个方法基本上和await方法一样，只是多了超时时间的处理。上面这段代码的意思是，如果超时时间没到，那么就将线程挂起，超过等待时间了，将线程从条件队列转移到同步队列中。这里对超时时间很短的时间做了一个优化，当超时时间小于spinForTimeoutThreshold(1000L ns)时，通过自旋的方式等待唤醒，而不是将线程挂起。\n\nwait(0)表示无限期等待，那么如果awaitNanos我们传0是一样的吗？\n\n```java\nif (nanosTimeout <= 0L) {\n    transferAfterCancelledWait(node);\n    break;\n}\n```\n\n上面代码中已经有这段了，我这里单独提出来再来看下。这里可以看到当nanosTimeout<=0的时候，就会将线程从条件等待队列转移到同步队列中，并不会被挂起，也不需要signal。\n\n##### await(long time, TimeUnit unit)\n\n这个方法就是在awaitNanos方法基础上多了对超时时间单位的设置，但是在内部实现上还是会把时间转成纳秒去执行\n\n```java\npublic final boolean await(long time, TimeUnit unit)\n    throws InterruptedException {\n    long nanosTimeout = unit.toNanos(time);\n    if (Thread.interrupted())\n        throw new InterruptedException();\n    Node node = addConditionWaiter();\n    int savedState = fullyRelease(node);\n    final long deadline = System.nanoTime() + nanosTimeout;\n    boolean timedout = false;\n    int interruptMode = 0;\n    while (!isOnSyncQueue(node)) {\n        if (nanosTimeout <= 0L) {\n            timedout = transferAfterCancelledWait(node);\n            break;\n        }\n        if (nanosTimeout >= spinForTimeoutThreshold)\n            LockSupport.parkNanos(this, nanosTimeout);\n        if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)\n            break;\n        nanosTimeout = deadline - System.nanoTime();\n    }\n    if (acquireQueued(node, savedState) && interruptMode != THROW_IE)\n        interruptMode = REINTERRUPT;\n    if (node.nextWaiter != null)\n        unlinkCancelledWaiters();\n    if (interruptMode != 0)\n        reportInterruptAfterWait(interruptMode);\n    return !timedout;\n}\n```\n\nawaitNanos(long nanosTimeout)的返回值是剩余的超时时间，如果该值大于0，说明超时时间还没到，则说明该返回是由signal行为导致的，而await(long time,TimeUnit unit)的返回值是transferAfterCancelledWait(node)的值决定的，调用该方法时，如果node还没有被signal过则返回true，否则返回false。其实这个方法就等价于调用awaitNanos(unit.toNanos(time)) > 0。\n\n### awaitUntil(Date deadline)\n\nawaitUntil方法和上面几个方法类似，只不过这个参数是一个绝对时间\n\n```java\npublic final boolean awaitUntil(Date deadline)\n    throws InterruptedException {\n    long abstime = deadline.getTime();\n    if (Thread.interrupted())\n        throw new InterruptedException();\n    Node node = addConditionWaiter();\n    int savedState = fullyRelease(node);\n    boolean timedout = false;\n    int interruptMode = 0;\n    while (!isOnSyncQueue(node)) {\n        if (System.currentTimeMillis() > abstime) {\n            timedout = transferAfterCancelledWait(node);\n            break;\n        }\n        LockSupport.parkUntil(this, abstime);\n        if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)\n            break;\n    }\n    if (acquireQueued(node, savedState) && interruptMode != THROW_IE)\n        interruptMode = REINTERRUPT;\n    if (node.nextWaiter != null)\n        unlinkCancelledWaiters();\n    if (interruptMode != 0)\n        reportInterruptAfterWait(interruptMode);\n    return !timedout;\n}\n```\n\n这个方法仅仅就是时间用成了绝对时间，并且没有使用spinForTimeoutThreshold进行自旋优化，因为调用这个方法，目的就是设一个较长的等待时间，不然上面的其他方法用起来更方便一些。","slug":"AQS源码分析之Condition接口的实现","published":1,"updated":"2021-09-02T07:05:10.000Z","comments":1,"photos":[],"link":"","_id":"cm1m304y7003l31b4cz8oa60y","content":"<p>Condition接口是用来做控制线程的执行流程的。类似于监视器锁的wait/notify机制。可以先看下Condition提供了哪些方法。Condition接口一共定义了7个方法，根据方法名方法的用途我们也能猜个大概。</p>\n<table>\n<thead>\n<tr>\n<th>Object</th>\n<th>Condition</th>\n<th>区别</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>void wait()</td>\n<td>void await()</td>\n<td></td>\n</tr>\n<tr>\n<td>void wait(long timeout)</td>\n<td>long awaitNanos(long nanosTimeout)</td>\n<td>时间单位不同，返回值</td>\n</tr>\n<tr>\n<td>void wait(long timeout,int nanos)</td>\n<td>boolean await(long time,TimeUnit unit)</td>\n<td>时间单位同，参数类型，返回值</td>\n</tr>\n<tr>\n<td>void notify()</td>\n<td>void signal()</td>\n<td></td>\n</tr>\n<tr>\n<td>void notifyAll()</td>\n<td>void signal</td>\n<td></td>\n</tr>\n<tr>\n<td>-</td>\n<td>void awaitUninterruptibly()</td>\n<td>Condition独有</td>\n</tr>\n<tr>\n<td>-</td>\n<td>boolean awaitUntil(Date deadline)</td>\n<td>Condition独有</td>\n</tr>\n</tbody></table>\n<p>类比下wait/notify机制：</p>\n<p>1.调用wait方法的线程必须是已经进入了同步代码块的线程，也就是获得了监视器锁，那么调用await方法的线程也必须是获得了lock锁。</p>\n<p>2.调用wait方法的线程会释放已获得的监视器锁，进入当前监视器锁的等待队列（wait set）中，调用await方法的线程也会释放已经获得的lock锁，进入到当前Condition对应的条件队列中。</p>\n<p>3.调用监视器锁的notify方法会唤醒等待在该监视器锁上的线程，这些线程将开始参与锁竞争，并在获得锁后，从wait方法处恢复执行。调用Condition的signal方法会唤醒对应条件队列中的线程，这些线程将开始参与锁竞争，并在获得锁后，从await方法处开始恢复执行。</p>\n<p>先来看下Condition怎么使用，这里看一下官方给的例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BoundedBuffer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Lock lock = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Condition notFull = lock.newCondition();</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Condition notEmpty = lock.newCondition();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> Object[] items = <span class=\"keyword\">new</span> Object[<span class=\"number\">100</span>];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> putptr, takeptr, count;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 生产者方法，往数组里面写数据</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">put</span><span class=\"params\">(Object x)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        lock.lock();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (count == items.length)</span><br><span class=\"line\">                notFull.await(); <span class=\"comment\">//数组已满，没有空间时，挂起等待，直到数组“非满”（notFull）</span></span><br><span class=\"line\">            items[putptr] = x;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (++putptr == items.length) putptr = <span class=\"number\">0</span>;</span><br><span class=\"line\">            ++count;</span><br><span class=\"line\">            notEmpty.signal(); </span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 消费者方法，从数组里面拿数据</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">take</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        lock.lock();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (count == <span class=\"number\">0</span>)</span><br><span class=\"line\">                notEmpty.await(); <span class=\"comment\">// 数组是空的，没有数据可拿时，挂起等待，直到数组非空（notEmpty）</span></span><br><span class=\"line\">            Object x = items[takeptr];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (++takeptr == items.length) takeptr = <span class=\"number\">0</span>;</span><br><span class=\"line\">            --count;</span><br><span class=\"line\">            notFull.signal();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个例子是一个生产者-消费者模型，在同一个lock上，有两个条件队列，当数组满的时候，put方法在notFull条件上等待，直到数组不满的时候。当数组为空时，take方法在notEmpty条件上等待，直到数组不为空的时候。</p>\n<p>我们知道，在AQS中所有等待锁的线程会被包装成Node扔到一个同步队列中去，那么因为条件不满足继续执行下去而调用await方法的线程应该也是放到一个队列中去了，而一个lock中又可以有多个Condition，所以我们猜测应该每个Condition内部维护一个条件队列，这样就可以互相不影响了。</p>\n<p>但是和等待锁的同步队列不同的是，同步队列是一个双向链表，nextWaiter并没有用来串联链表，而是用了prev，next属性。条件队列是一个单向链表，用nextWaiter来串联链表。</p>\n<h3 id=\"Condition实现\"><a href=\"#Condition实现\" class=\"headerlink\" title=\"Condition实现\"></a>Condition实现</h3><p>AQS中Condition的主要实现是ConditionObject，在ConditionObject中有两个重要的属性，一个是firstWaiter，一个是lastWaiter。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** First node of condition queue. */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> Node firstWaiter;</span><br><span class=\"line\"><span class=\"comment\">/** Last node of condition queue. */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> Node lastWaiter;</span><br></pre></td></tr></table></figure>\n\n<p>然后我们看await()方法。</p>\n<h5 id=\"await\"><a href=\"#await\" class=\"headerlink\" title=\"await()\"></a>await()</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">await</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//如果调用await()前已经被中断，则直接抛出InterruptedException</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Thread.interrupted())</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> InterruptedException();</span><br><span class=\"line\">    <span class=\"comment\">//将当前线程加到等待队列中</span></span><br><span class=\"line\">    Node node = addConditionWaiter();</span><br><span class=\"line\">    <span class=\"comment\">//释放当前线程所占用的锁</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> savedState = fullyRelease(node);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> interruptMode = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">//如果当前node不在同步队列中，则直接将线程挂起</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class=\"line\">        LockSupport.park(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        <span class=\"comment\">//检查线程被唤醒原因，是signal还是中断</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//尝试去获取锁 然后执行后续逻辑</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class=\"line\">        interruptMode = REINTERRUPT;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node.nextWaiter != <span class=\"keyword\">null</span>) <span class=\"comment\">// clean up if cancelled</span></span><br><span class=\"line\">        unlinkCancelledWaiters();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (interruptMode != <span class=\"number\">0</span>)</span><br><span class=\"line\">        reportInterruptAfterWait(interruptMode);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>源码中对一些代码也进行了注释，流程基本上就是这样。关于被唤醒之后的分析，我们后面再来看。</p>\n<h5 id=\"addConditionWaiter\"><a href=\"#addConditionWaiter\" class=\"headerlink\" title=\"addConditionWaiter\"></a>addConditionWaiter</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Node <span class=\"title\">addConditionWaiter</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Node t = lastWaiter;</span><br><span class=\"line\">    <span class=\"comment\">// If lastWaiter is cancelled, clean out.</span></span><br><span class=\"line\">    <span class=\"comment\">//如果尾节点被cancel了，则先遍历整个链表，清除所有被cancel的节点</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (t != <span class=\"keyword\">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class=\"line\">        unlinkCancelledWaiters();</span><br><span class=\"line\">        t = lastWaiter;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//当前节点入条件队列</span></span><br><span class=\"line\">    Node node = <span class=\"keyword\">new</span> Node(Thread.currentThread(), Node.CONDITION);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (t == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        firstWaiter = node;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        t.nextWaiter = node;</span><br><span class=\"line\">    lastWaiter = node;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里看到代码中没有任何加锁操作，那么这个会存在并发问题吗？不存在，因为能进入到await方法中的线程一定是已经获得了锁的，而能获得锁的线程只有一个，也就不会存在并发，所以不需要加锁操作。在这个方法中，我们就是简单的将当前线程封装成Node加到条件队列的末尾。</p>\n<p>这里面有三个点需要注意一下：</p>\n<ol>\n<li>节点加入sync queue是waitStatus的值是0，但节点加入condition queue是waitStatus的值为Node.CONDITION（-2）。</li>\n<li>sync queue的头节点是虚节点，如果队列为空，会先创建一个dummy节点，再创建一个代表当前节点的Node添加在dummy节点的后面。condition queue没有dummy节点，初始化时，直接将firstWaiter和lastWaiter直接指向新建的节点。</li>\n<li>sync queue是一个双向队列，在节点入队后，需要同时修改当前节点的前驱和后继。在condition queue中，节点入队，只需要修改前驱节点的nextWaiter，也就是说条件队列是当单项队列使用的。</li>\n</ol>\n<p>如果入队的时候，发现尾节点已经取消等待了，那么就不应该把新的node放到取消的尾节点后面，此时调用unlinkCancelledWaiters来剔除那些已经取消等待的线程：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">unlinkCancelledWaiters</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Node t = firstWaiter;</span><br><span class=\"line\">    Node trail = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (t != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        Node next = t.nextWaiter;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (t.waitStatus != Node.CONDITION) &#123;</span><br><span class=\"line\">            t.nextWaiter = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (trail == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                firstWaiter = next;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                trail.nextWaiter = next;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (next == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                lastWaiter = trail;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            trail = t;</span><br><span class=\"line\">        t = next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个方法就是从头部开始遍历队列，剔除waitStatus不是Node.CONDITION的节点。</p>\n<h5 id=\"fullyRelease\"><a href=\"#fullyRelease\" class=\"headerlink\" title=\"fullyRelease\"></a>fullyRelease</h5><p>节点被成功添加到队列末尾后，将调用fullyRelease来释放当前线程所占用的锁：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">fullyRelease</span><span class=\"params\">(Node node)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> failed = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> savedState = getState();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (release(savedState)) &#123;</span><br><span class=\"line\">            failed = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> savedState;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalMonitorStateException();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (failed)</span><br><span class=\"line\">            node.waitStatus = Node.CANCELLED;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个方法中，通过release方法去释放锁。但是这里需要注意，这里对于可重入锁而言，是一次性释放所有的锁，因为getState()拿到的是重入的次数。然后这里还需要注意，这里会抛出IllegalMonitorStateException异常，这是因为当前线程可能不是持有锁的线程，前面说执行await方法的时候一定是拿到锁的线程才能调用await方法。但是我们并没有去判断当前拿到锁的线程是不是exclusiveOwnerThread这个线程。这个检测其实是在AQS子类实现tryRelease方法来做的。ReentrantLock对tryRelease方法的实现如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryRelease</span><span class=\"params\">(<span class=\"keyword\">int</span> releases)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> c = getState() - releases;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalMonitorStateException();</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> free = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        free = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        setExclusiveOwnerThread(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    setState(c);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> free;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当发现当前线程不是持有锁的线程时，就会进入fullyRelease的finally语句块中，将当前node的waitStatus改为Node.CANCELLED，这也是为什么添加新节点的时候，都会检查尾节点是否已经被取消了。因为会抛出IllegalMonitorStateException异常。</p>\n<p>在当前线程的锁被释放后，就可以调用LockSupport.park(this)把当前线程挂起，等待signal了。但是源码中还调用了isOnSyncQueue来检查当前线程不在sync queue中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isOnSyncQueue</span><span class=\"params\">(Node node)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node.waitStatus == Node.CONDITION || node.prev == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node.next != <span class=\"keyword\">null</span>) <span class=\"comment\">// If has successor, it must be on queue</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> findNodeFromTail(node);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">findNodeFromTail</span><span class=\"params\">(Node node)</span> </span>&#123;</span><br><span class=\"line\">    Node t = tail;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (t == node)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (t == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        t = t.prev;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当前线程应该在一个独立的和sync queue无关的队列中，怎么会出现在sync queue中呢？这个要结合signal方法来看。</p>\n<h5 id=\"signalAll\"><a href=\"#signalAll\" class=\"headerlink\" title=\"signalAll\"></a>signalAll</h5><p>调用signalAll方法的线程本身时已经持有了锁，并且准备释放锁的线程。在条件队列里的线程是已经在对应条件上挂起了，等待被signal唤醒，然后去争夺。</p>\n<p>与调用notify时线程必须时已经持有了监视器锁类似，在调用condition的signal方法时，线程必须是已经持有了lock锁：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">signalAll</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isHeldExclusively())</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalMonitorStateException();</span><br><span class=\"line\">    Node first = firstWaiter;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (first != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        doSignalAll(first);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>isHeldExclusively这个方法是检查当前线程是不是持有锁的线程，这个方法通常由AQS的子类来实现。ReentrantLock对该方法的实现为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isHeldExclusively</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> getExclusiveOwnerThread() == Thread.currentThread();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>拿到firstWaiter判断条件队列是否为空，如果条件队列不为空，则调用doSignalAll方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">doSignalAll</span><span class=\"params\">(Node first)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//清空整个队列</span></span><br><span class=\"line\">    lastWaiter = firstWaiter = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        Node next = first.nextWaiter;</span><br><span class=\"line\">        first.nextWaiter = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        transferForSignal(first);</span><br><span class=\"line\">        first = next;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (first != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过lastWaiter = firstWaiter = null;将整个队列清空掉，然后通过循环将原来的队列的节点拿出来，通过transferForSignal方法将线程一个一个放到sync queue末尾。注意这里是一个一个放进去的，可以看下transferForSignal：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">transferForSignal</span><span class=\"params\">(Node node)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"comment\">//如果这个节点在signal前被取消，那么直接返回</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class=\"number\">0</span>))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//节点插入到sync queue中</span></span><br><span class=\"line\">    Node p = enq(node);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ws = p.waitStatus;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ws &gt; <span class=\"number\">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class=\"line\">        LockSupport.unpark(node.thread);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在transferForSignal方法中，先通过CAS操作将当前节点的waitStatus状态由CONDITION设为0，修改失败，则认为该节点已经被取消了，直接返回，操作下一个节点。如果修改成功插入到同步队列中去，这里需要注意enq返回的是node的前驱节点。sync queue中的节点需要靠前驱节点唤醒，所以需要把前驱节点waitStatus设为Node.SIGNAL。这里只要前驱节点被取消或者无法将前驱节点状态修改为Node.SIGNAL，那我们就将Node所代表的线程唤醒，但是这个不意味着lock是可以被获取的，只是唤醒这个线程去获取锁，如果获取失败，继续进入同步队列等待。</p>\n<p>总结一下signalAll方法：</p>\n<ol>\n<li>清空条件队列（只是把lastWaiter、firstWaiter设为null，队列中节点的关系还存在）</li>\n<li>将条件队列中的头节点取出，将它和后面的节点断开连接，然后调用transferForSignal方法</li>\n<li>判断该节点处于被取消状态，直接跳过该节点（该节点会被GC回收）。节点状态自由，则通过enq方法，将节点放到sync queue的末尾</li>\n<li>根据当前节点的前驱节点的waitStatus状态判断是否要唤醒当前节点，如果前驱节点被取消，或者前驱节点设置SIGNAL状态失败，直接唤醒该节点的线程</li>\n<li>重复2到4的过程，直到整个条件队列中的节点都被处理完成</li>\n</ol>\n<h5 id=\"signal\"><a href=\"#signal\" class=\"headerlink\" title=\"signal\"></a>signal</h5><p>signal只是唤醒一个节点，对于AQS的实现来说，只是唤醒条件队列中第一个没有被取消的节点。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">signal</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isHeldExclusively())</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalMonitorStateException();</span><br><span class=\"line\">    Node first = firstWaiter;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (first != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        doSignal(first);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>isHeldExclusively方法已经分析过，检查当前线程是不是持有锁的线程。然后看doSignal方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">doSignal</span><span class=\"params\">(Node first)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( (firstWaiter = first.nextWaiter) == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            lastWaiter = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        first.nextWaiter = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (!transferForSignal(first) &amp;&amp;</span><br><span class=\"line\">             (first = firstWaiter) != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个看到是一个循环，也是为了找队列中第一个没有被取消的节点，然后将这个节点放到同步队列中去。也是将first取出来，然后将nextWaiter设置为null，调用transferForSignal方法，这个方法的返回值将决定循环是否继续。如果返回true，那么while循环的条件就不满足了，所以只会唤醒一个线程。</p>\n<p>唤醒已经讲完了，我们再来看await方法。因为唤醒的时候，会让线程回到原来阻塞的地方继续执行。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">await</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Thread.interrupted())</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> InterruptedException();</span><br><span class=\"line\">    Node node = addConditionWaiter();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> savedState = fullyRelease(node);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> interruptMode = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class=\"line\">        LockSupport.park(<span class=\"keyword\">this</span>); </span><br><span class=\"line\">        <span class=\"comment\">// 这里就是阻塞回来的位置</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class=\"line\">        interruptMode = REINTERRUPT;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node.nextWaiter != <span class=\"keyword\">null</span>) </span><br><span class=\"line\">        unlinkCancelledWaiters();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (interruptMode != <span class=\"number\">0</span>)</span><br><span class=\"line\">        reportInterruptAfterWait(interruptMode);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是线程被唤醒，并不知道是什么原因被唤醒的。但是既然唤醒了，那么就需要acquireQueued方法进行“阻塞式”获取锁，抢到锁就返回，抢不到锁就继续被挂起。当await方法返回时，当前线程一定已经持有了lock锁。</p>\n<p>如果从线程被唤醒，到线程获取到锁这段过程中发生过中断，应该如何处理呢？</p>\n<p>中断对当前线程只是个建议，有当前线程决定怎么对其做出处理。acquireQueued方法对中断是不响应的，只是简单的记录抢锁过程中的中断状态，并在抢到锁后将这个中断状态返回，交给上层调用函数处理，此时也就是await方法。await方法如何处理这个中断，<strong>取决于这个中断发生时，线程是否已经被signal</strong>。</p>\n<p>在调用await方法时，就会检查当前线程的中断状态，如果线程还未阻塞就被中断，那么直接抛出InterruptedException。如果中断发生时，线程没有被signal过，那么等待中的线程就会被打断，也就是一个意料之外的唤醒，所以线程被唤醒后，需要抛出InterruptedException，表示当前线程因为中断而被唤醒。如果中断发生时，当前线程已经被signal过了，它就已经正常地从condition queue中唤醒了，那么这个中断来的就比较晚了，因为已经是正常唤醒之后才来的中断，那么就在await方法中补一下这个中断，调用Thread.interrupted()方法检测是否发生中断时也会将中断状态清除，因此如果忽略中断，则应该在await方法将线程恢复成原来的样子。</p>\n<p>在await方法中，用变量interruptMode记录中断事件：</p>\n<ol>\n<li>0：没有中断发生</li>\n<li>1：REINTERRUPT 表示中断发生在signal之后，需要再次自我中断</li>\n<li>-1:THROW_IE 表示中断发生在signal之前，需要抛出InterruptedException</li>\n</ol>\n<p>acquireQueued这个方法两个参数，我们前面说了释放锁的时候是释放所有的可重入锁，现在加锁的时候也是原来释放多少，这次就加多少锁。unlinkCancelledWaiters这个方法已经讲过了，就是遍历链表，然后把waitStatus不为CONDITION的节点从队列中移除。reportInterruptAfterWait是用来汇报中断的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">reportInterruptAfterWait</span><span class=\"params\">(<span class=\"keyword\">int</span> interruptMode)</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (interruptMode == THROW_IE)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> InterruptedException();</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (interruptMode == REINTERRUPT)</span><br><span class=\"line\">        selfInterrupt();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果interruptMode=THROW_IE，则直接抛出异常，报告等待的时候被中断异常唤醒。</p>\n<p>来总结一下：</p>\n<p><strong>中断发生在signal之前</strong></p>\n<ol>\n<li>线程因为中断被唤醒，通过checkInterruptWhileWaiting方法调用transferAfterCancelledWait方法来确认线程的waitStatus的值为Node.CONDITION，说明线程没有被signal</li>\n<li>修改线程的waitStatus为0，通过enq(node)将其添加到sync queue中</li>\n<li>线程获取锁，如果获取不到，则被再次挂起</li>\n<li>线程获取到锁后，调用unlinkCancelledWaiters方法将自己从条件队列中移除，该方法顺便移除其他取消等待的锁</li>\n<li>通过reportInterruptAfterWait抛出InterruptedException</li>\n</ol>\n<p>一个调用await方法挂起的线程在被中断后不会立即抛出InterruptedException，而是进入同步队列去竞争锁，争不到，挂起，如果争到锁了，从同步队列和条件队列移除，抛出InterruptedException。</p>\n<p><strong>中断发生在signal之后</strong></p>\n<p>这种情况其实就是线程被唤醒后，然后产生的中断，并没有影响到我们线程正常的阻塞到被signal唤醒的流程，所以，我们并不需要抛出InterruptedException异常，我们可以忽略这个中断，在await方法返回的时候，将这个线程重新中断一下，对忽略的中断进行一个补偿。</p>\n<h5 id=\"await总结\"><a href=\"#await总结\" class=\"headerlink\" title=\"await总结\"></a>await总结</h5><p>我们对整个await方法进行一个总结：</p>\n<ol>\n<li>进入await()时必须已经持有了锁</li>\n<li>离开await()时必须已经持有了锁</li>\n<li>调用await()会使当前线程被封装成Node扔进条件队列，并且释放所有持有的锁</li>\n<li>释放锁后，当前线程被挂起，等待signal或者中断唤醒线程</li>\n<li>线程被唤醒后，进入同步队列进行抢锁</li>\n<li>线程在抢到锁之前发生过中断，则根据中断发生在signal之前还是之后记录中断模式，体现在interruptMode</li>\n<li>线程在抢到锁后进行售后工作（离开条件队列，处理中断异常）</li>\n</ol>\n<h5 id=\"awaitUninterruptibly\"><a href=\"#awaitUninterruptibly\" class=\"headerlink\" title=\"awaitUninterruptibly\"></a>awaitUninterruptibly</h5><p>中断和signal都可以把线程唤醒，但是中断是一种异常唤醒，唤醒以后线程发现等待的条件并为满足，还是需要将线程挂起。当不希望await方法被中断时，可以使用awaitUninterruptibly方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">awaitUninterruptibly</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Node node = addConditionWaiter();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> savedState = fullyRelease(node);</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> interrupted = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class=\"line\">        LockSupport.park(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Thread.interrupted())</span><br><span class=\"line\">            interrupted = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (acquireQueued(node, savedState) || interrupted)</span><br><span class=\"line\">        selfInterrupt();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到就算中断唤醒了线程，也仅仅是记录interrupted状态为true，然后继续阻塞，等到signal才会唤醒线程去获取锁，当发生中断，不管什么时候的中断，都是最终补偿中断一次，并且不会抛出InterruptedException</p>\n<h5 id=\"awaitNanos\"><a href=\"#awaitNanos\" class=\"headerlink\" title=\"awaitNanos\"></a>awaitNanos</h5><p>前面的await和awaitUninterruptibly，它们在抢锁的过程中都是阻塞式的，一直抢到锁才能返回，否则线程一直挂起，这样的话就是线程如果长时间抢不到锁，就会一直被阻塞，因此有时候更需要带超时机制的去抢锁，和wait(long timeout)很像。看下源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> <span class=\"title\">awaitNanos</span><span class=\"params\">(<span class=\"keyword\">long</span> nanosTimeout)</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Thread.interrupted())</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> InterruptedException();</span><br><span class=\"line\">    Node node = addConditionWaiter();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> savedState = fullyRelease(node);</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> deadline = System.nanoTime() + nanosTimeout;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> interruptMode = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nanosTimeout &lt;= <span class=\"number\">0L</span>) &#123;</span><br><span class=\"line\">            transferAfterCancelledWait(node);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nanosTimeout &gt;= spinForTimeoutThreshold)</span><br><span class=\"line\">            LockSupport.parkNanos(<span class=\"keyword\">this</span>, nanosTimeout);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        nanosTimeout = deadline - System.nanoTime();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class=\"line\">        interruptMode = REINTERRUPT;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node.nextWaiter != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        unlinkCancelledWaiters();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (interruptMode != <span class=\"number\">0</span>)</span><br><span class=\"line\">        reportInterruptAfterWait(interruptMode);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> deadline - System.nanoTime();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个方法基本上和await方法一样，只是多了超时时间的处理。上面这段代码的意思是，如果超时时间没到，那么就将线程挂起，超过等待时间了，将线程从条件队列转移到同步队列中。这里对超时时间很短的时间做了一个优化，当超时时间小于spinForTimeoutThreshold(1000L ns)时，通过自旋的方式等待唤醒，而不是将线程挂起。</p>\n<p>wait(0)表示无限期等待，那么如果awaitNanos我们传0是一样的吗？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (nanosTimeout &lt;= <span class=\"number\">0L</span>) &#123;</span><br><span class=\"line\">    transferAfterCancelledWait(node);</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中已经有这段了，我这里单独提出来再来看下。这里可以看到当nanosTimeout&lt;=0的时候，就会将线程从条件等待队列转移到同步队列中，并不会被挂起，也不需要signal。</p>\n<h5 id=\"await-long-time-TimeUnit-unit\"><a href=\"#await-long-time-TimeUnit-unit\" class=\"headerlink\" title=\"await(long time, TimeUnit unit)\"></a>await(long time, TimeUnit unit)</h5><p>这个方法就是在awaitNanos方法基础上多了对超时时间单位的设置，但是在内部实现上还是会把时间转成纳秒去执行</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">await</span><span class=\"params\">(<span class=\"keyword\">long</span> time, TimeUnit unit)</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> nanosTimeout = unit.toNanos(time);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Thread.interrupted())</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> InterruptedException();</span><br><span class=\"line\">    Node node = addConditionWaiter();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> savedState = fullyRelease(node);</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> deadline = System.nanoTime() + nanosTimeout;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> timedout = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> interruptMode = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nanosTimeout &lt;= <span class=\"number\">0L</span>) &#123;</span><br><span class=\"line\">            timedout = transferAfterCancelledWait(node);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nanosTimeout &gt;= spinForTimeoutThreshold)</span><br><span class=\"line\">            LockSupport.parkNanos(<span class=\"keyword\">this</span>, nanosTimeout);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        nanosTimeout = deadline - System.nanoTime();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class=\"line\">        interruptMode = REINTERRUPT;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node.nextWaiter != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        unlinkCancelledWaiters();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (interruptMode != <span class=\"number\">0</span>)</span><br><span class=\"line\">        reportInterruptAfterWait(interruptMode);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> !timedout;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>awaitNanos(long nanosTimeout)的返回值是剩余的超时时间，如果该值大于0，说明超时时间还没到，则说明该返回是由signal行为导致的，而await(long time,TimeUnit unit)的返回值是transferAfterCancelledWait(node)的值决定的，调用该方法时，如果node还没有被signal过则返回true，否则返回false。其实这个方法就等价于调用awaitNanos(unit.toNanos(time)) &gt; 0。</p>\n<h3 id=\"awaitUntil-Date-deadline\"><a href=\"#awaitUntil-Date-deadline\" class=\"headerlink\" title=\"awaitUntil(Date deadline)\"></a>awaitUntil(Date deadline)</h3><p>awaitUntil方法和上面几个方法类似，只不过这个参数是一个绝对时间</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">awaitUntil</span><span class=\"params\">(Date deadline)</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> abstime = deadline.getTime();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Thread.interrupted())</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> InterruptedException();</span><br><span class=\"line\">    Node node = addConditionWaiter();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> savedState = fullyRelease(node);</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> timedout = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> interruptMode = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (System.currentTimeMillis() &gt; abstime) &#123;</span><br><span class=\"line\">            timedout = transferAfterCancelledWait(node);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        LockSupport.parkUntil(<span class=\"keyword\">this</span>, abstime);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class=\"line\">        interruptMode = REINTERRUPT;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node.nextWaiter != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        unlinkCancelledWaiters();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (interruptMode != <span class=\"number\">0</span>)</span><br><span class=\"line\">        reportInterruptAfterWait(interruptMode);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> !timedout;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个方法仅仅就是时间用成了绝对时间，并且没有使用spinForTimeoutThreshold进行自旋优化，因为调用这个方法，目的就是设一个较长的等待时间，不然上面的其他方法用起来更方便一些。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Condition接口是用来做控制线程的执行流程的。类似于监视器锁的wait/notify机制。可以先看下Condition提供了哪些方法。Condition接口一共定义了7个方法，根据方法名方法的用途我们也能猜个大概。</p>\n<table>\n<thead>\n<tr>\n<th>Object</th>\n<th>Condition</th>\n<th>区别</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>void wait()</td>\n<td>void await()</td>\n<td></td>\n</tr>\n<tr>\n<td>void wait(long timeout)</td>\n<td>long awaitNanos(long nanosTimeout)</td>\n<td>时间单位不同，返回值</td>\n</tr>\n<tr>\n<td>void wait(long timeout,int nanos)</td>\n<td>boolean await(long time,TimeUnit unit)</td>\n<td>时间单位同，参数类型，返回值</td>\n</tr>\n<tr>\n<td>void notify()</td>\n<td>void signal()</td>\n<td></td>\n</tr>\n<tr>\n<td>void notifyAll()</td>\n<td>void signal</td>\n<td></td>\n</tr>\n<tr>\n<td>-</td>\n<td>void awaitUninterruptibly()</td>\n<td>Condition独有</td>\n</tr>\n<tr>\n<td>-</td>\n<td>boolean awaitUntil(Date deadline)</td>\n<td>Condition独有</td>\n</tr>\n</tbody></table>\n<p>类比下wait/notify机制：</p>\n<p>1.调用wait方法的线程必须是已经进入了同步代码块的线程，也就是获得了监视器锁，那么调用await方法的线程也必须是获得了lock锁。</p>\n<p>2.调用wait方法的线程会释放已获得的监视器锁，进入当前监视器锁的等待队列（wait set）中，调用await方法的线程也会释放已经获得的lock锁，进入到当前Condition对应的条件队列中。</p>\n<p>3.调用监视器锁的notify方法会唤醒等待在该监视器锁上的线程，这些线程将开始参与锁竞争，并在获得锁后，从wait方法处恢复执行。调用Condition的signal方法会唤醒对应条件队列中的线程，这些线程将开始参与锁竞争，并在获得锁后，从await方法处开始恢复执行。</p>\n<p>先来看下Condition怎么使用，这里看一下官方给的例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BoundedBuffer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Lock lock = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Condition notFull = lock.newCondition();</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Condition notEmpty = lock.newCondition();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> Object[] items = <span class=\"keyword\">new</span> Object[<span class=\"number\">100</span>];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> putptr, takeptr, count;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 生产者方法，往数组里面写数据</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">put</span><span class=\"params\">(Object x)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        lock.lock();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (count == items.length)</span><br><span class=\"line\">                notFull.await(); <span class=\"comment\">//数组已满，没有空间时，挂起等待，直到数组“非满”（notFull）</span></span><br><span class=\"line\">            items[putptr] = x;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (++putptr == items.length) putptr = <span class=\"number\">0</span>;</span><br><span class=\"line\">            ++count;</span><br><span class=\"line\">            notEmpty.signal(); </span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 消费者方法，从数组里面拿数据</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">take</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        lock.lock();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (count == <span class=\"number\">0</span>)</span><br><span class=\"line\">                notEmpty.await(); <span class=\"comment\">// 数组是空的，没有数据可拿时，挂起等待，直到数组非空（notEmpty）</span></span><br><span class=\"line\">            Object x = items[takeptr];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (++takeptr == items.length) takeptr = <span class=\"number\">0</span>;</span><br><span class=\"line\">            --count;</span><br><span class=\"line\">            notFull.signal();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个例子是一个生产者-消费者模型，在同一个lock上，有两个条件队列，当数组满的时候，put方法在notFull条件上等待，直到数组不满的时候。当数组为空时，take方法在notEmpty条件上等待，直到数组不为空的时候。</p>\n<p>我们知道，在AQS中所有等待锁的线程会被包装成Node扔到一个同步队列中去，那么因为条件不满足继续执行下去而调用await方法的线程应该也是放到一个队列中去了，而一个lock中又可以有多个Condition，所以我们猜测应该每个Condition内部维护一个条件队列，这样就可以互相不影响了。</p>\n<p>但是和等待锁的同步队列不同的是，同步队列是一个双向链表，nextWaiter并没有用来串联链表，而是用了prev，next属性。条件队列是一个单向链表，用nextWaiter来串联链表。</p>\n<h3 id=\"Condition实现\"><a href=\"#Condition实现\" class=\"headerlink\" title=\"Condition实现\"></a>Condition实现</h3><p>AQS中Condition的主要实现是ConditionObject，在ConditionObject中有两个重要的属性，一个是firstWaiter，一个是lastWaiter。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** First node of condition queue. */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> Node firstWaiter;</span><br><span class=\"line\"><span class=\"comment\">/** Last node of condition queue. */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> Node lastWaiter;</span><br></pre></td></tr></table></figure>\n\n<p>然后我们看await()方法。</p>\n<h5 id=\"await\"><a href=\"#await\" class=\"headerlink\" title=\"await()\"></a>await()</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">await</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//如果调用await()前已经被中断，则直接抛出InterruptedException</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Thread.interrupted())</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> InterruptedException();</span><br><span class=\"line\">    <span class=\"comment\">//将当前线程加到等待队列中</span></span><br><span class=\"line\">    Node node = addConditionWaiter();</span><br><span class=\"line\">    <span class=\"comment\">//释放当前线程所占用的锁</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> savedState = fullyRelease(node);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> interruptMode = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">//如果当前node不在同步队列中，则直接将线程挂起</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class=\"line\">        LockSupport.park(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        <span class=\"comment\">//检查线程被唤醒原因，是signal还是中断</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//尝试去获取锁 然后执行后续逻辑</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class=\"line\">        interruptMode = REINTERRUPT;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node.nextWaiter != <span class=\"keyword\">null</span>) <span class=\"comment\">// clean up if cancelled</span></span><br><span class=\"line\">        unlinkCancelledWaiters();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (interruptMode != <span class=\"number\">0</span>)</span><br><span class=\"line\">        reportInterruptAfterWait(interruptMode);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>源码中对一些代码也进行了注释，流程基本上就是这样。关于被唤醒之后的分析，我们后面再来看。</p>\n<h5 id=\"addConditionWaiter\"><a href=\"#addConditionWaiter\" class=\"headerlink\" title=\"addConditionWaiter\"></a>addConditionWaiter</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Node <span class=\"title\">addConditionWaiter</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Node t = lastWaiter;</span><br><span class=\"line\">    <span class=\"comment\">// If lastWaiter is cancelled, clean out.</span></span><br><span class=\"line\">    <span class=\"comment\">//如果尾节点被cancel了，则先遍历整个链表，清除所有被cancel的节点</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (t != <span class=\"keyword\">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class=\"line\">        unlinkCancelledWaiters();</span><br><span class=\"line\">        t = lastWaiter;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//当前节点入条件队列</span></span><br><span class=\"line\">    Node node = <span class=\"keyword\">new</span> Node(Thread.currentThread(), Node.CONDITION);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (t == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        firstWaiter = node;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        t.nextWaiter = node;</span><br><span class=\"line\">    lastWaiter = node;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里看到代码中没有任何加锁操作，那么这个会存在并发问题吗？不存在，因为能进入到await方法中的线程一定是已经获得了锁的，而能获得锁的线程只有一个，也就不会存在并发，所以不需要加锁操作。在这个方法中，我们就是简单的将当前线程封装成Node加到条件队列的末尾。</p>\n<p>这里面有三个点需要注意一下：</p>\n<ol>\n<li>节点加入sync queue是waitStatus的值是0，但节点加入condition queue是waitStatus的值为Node.CONDITION（-2）。</li>\n<li>sync queue的头节点是虚节点，如果队列为空，会先创建一个dummy节点，再创建一个代表当前节点的Node添加在dummy节点的后面。condition queue没有dummy节点，初始化时，直接将firstWaiter和lastWaiter直接指向新建的节点。</li>\n<li>sync queue是一个双向队列，在节点入队后，需要同时修改当前节点的前驱和后继。在condition queue中，节点入队，只需要修改前驱节点的nextWaiter，也就是说条件队列是当单项队列使用的。</li>\n</ol>\n<p>如果入队的时候，发现尾节点已经取消等待了，那么就不应该把新的node放到取消的尾节点后面，此时调用unlinkCancelledWaiters来剔除那些已经取消等待的线程：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">unlinkCancelledWaiters</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Node t = firstWaiter;</span><br><span class=\"line\">    Node trail = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (t != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        Node next = t.nextWaiter;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (t.waitStatus != Node.CONDITION) &#123;</span><br><span class=\"line\">            t.nextWaiter = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (trail == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                firstWaiter = next;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                trail.nextWaiter = next;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (next == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                lastWaiter = trail;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            trail = t;</span><br><span class=\"line\">        t = next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个方法就是从头部开始遍历队列，剔除waitStatus不是Node.CONDITION的节点。</p>\n<h5 id=\"fullyRelease\"><a href=\"#fullyRelease\" class=\"headerlink\" title=\"fullyRelease\"></a>fullyRelease</h5><p>节点被成功添加到队列末尾后，将调用fullyRelease来释放当前线程所占用的锁：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">fullyRelease</span><span class=\"params\">(Node node)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> failed = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> savedState = getState();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (release(savedState)) &#123;</span><br><span class=\"line\">            failed = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> savedState;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalMonitorStateException();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (failed)</span><br><span class=\"line\">            node.waitStatus = Node.CANCELLED;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个方法中，通过release方法去释放锁。但是这里需要注意，这里对于可重入锁而言，是一次性释放所有的锁，因为getState()拿到的是重入的次数。然后这里还需要注意，这里会抛出IllegalMonitorStateException异常，这是因为当前线程可能不是持有锁的线程，前面说执行await方法的时候一定是拿到锁的线程才能调用await方法。但是我们并没有去判断当前拿到锁的线程是不是exclusiveOwnerThread这个线程。这个检测其实是在AQS子类实现tryRelease方法来做的。ReentrantLock对tryRelease方法的实现如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryRelease</span><span class=\"params\">(<span class=\"keyword\">int</span> releases)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> c = getState() - releases;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalMonitorStateException();</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> free = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        free = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        setExclusiveOwnerThread(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    setState(c);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> free;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当发现当前线程不是持有锁的线程时，就会进入fullyRelease的finally语句块中，将当前node的waitStatus改为Node.CANCELLED，这也是为什么添加新节点的时候，都会检查尾节点是否已经被取消了。因为会抛出IllegalMonitorStateException异常。</p>\n<p>在当前线程的锁被释放后，就可以调用LockSupport.park(this)把当前线程挂起，等待signal了。但是源码中还调用了isOnSyncQueue来检查当前线程不在sync queue中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isOnSyncQueue</span><span class=\"params\">(Node node)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node.waitStatus == Node.CONDITION || node.prev == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node.next != <span class=\"keyword\">null</span>) <span class=\"comment\">// If has successor, it must be on queue</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> findNodeFromTail(node);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">findNodeFromTail</span><span class=\"params\">(Node node)</span> </span>&#123;</span><br><span class=\"line\">    Node t = tail;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (t == node)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (t == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        t = t.prev;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当前线程应该在一个独立的和sync queue无关的队列中，怎么会出现在sync queue中呢？这个要结合signal方法来看。</p>\n<h5 id=\"signalAll\"><a href=\"#signalAll\" class=\"headerlink\" title=\"signalAll\"></a>signalAll</h5><p>调用signalAll方法的线程本身时已经持有了锁，并且准备释放锁的线程。在条件队列里的线程是已经在对应条件上挂起了，等待被signal唤醒，然后去争夺。</p>\n<p>与调用notify时线程必须时已经持有了监视器锁类似，在调用condition的signal方法时，线程必须是已经持有了lock锁：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">signalAll</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isHeldExclusively())</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalMonitorStateException();</span><br><span class=\"line\">    Node first = firstWaiter;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (first != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        doSignalAll(first);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>isHeldExclusively这个方法是检查当前线程是不是持有锁的线程，这个方法通常由AQS的子类来实现。ReentrantLock对该方法的实现为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isHeldExclusively</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> getExclusiveOwnerThread() == Thread.currentThread();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>拿到firstWaiter判断条件队列是否为空，如果条件队列不为空，则调用doSignalAll方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">doSignalAll</span><span class=\"params\">(Node first)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//清空整个队列</span></span><br><span class=\"line\">    lastWaiter = firstWaiter = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        Node next = first.nextWaiter;</span><br><span class=\"line\">        first.nextWaiter = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        transferForSignal(first);</span><br><span class=\"line\">        first = next;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (first != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过lastWaiter = firstWaiter = null;将整个队列清空掉，然后通过循环将原来的队列的节点拿出来，通过transferForSignal方法将线程一个一个放到sync queue末尾。注意这里是一个一个放进去的，可以看下transferForSignal：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">transferForSignal</span><span class=\"params\">(Node node)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"comment\">//如果这个节点在signal前被取消，那么直接返回</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class=\"number\">0</span>))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//节点插入到sync queue中</span></span><br><span class=\"line\">    Node p = enq(node);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ws = p.waitStatus;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ws &gt; <span class=\"number\">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class=\"line\">        LockSupport.unpark(node.thread);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在transferForSignal方法中，先通过CAS操作将当前节点的waitStatus状态由CONDITION设为0，修改失败，则认为该节点已经被取消了，直接返回，操作下一个节点。如果修改成功插入到同步队列中去，这里需要注意enq返回的是node的前驱节点。sync queue中的节点需要靠前驱节点唤醒，所以需要把前驱节点waitStatus设为Node.SIGNAL。这里只要前驱节点被取消或者无法将前驱节点状态修改为Node.SIGNAL，那我们就将Node所代表的线程唤醒，但是这个不意味着lock是可以被获取的，只是唤醒这个线程去获取锁，如果获取失败，继续进入同步队列等待。</p>\n<p>总结一下signalAll方法：</p>\n<ol>\n<li>清空条件队列（只是把lastWaiter、firstWaiter设为null，队列中节点的关系还存在）</li>\n<li>将条件队列中的头节点取出，将它和后面的节点断开连接，然后调用transferForSignal方法</li>\n<li>判断该节点处于被取消状态，直接跳过该节点（该节点会被GC回收）。节点状态自由，则通过enq方法，将节点放到sync queue的末尾</li>\n<li>根据当前节点的前驱节点的waitStatus状态判断是否要唤醒当前节点，如果前驱节点被取消，或者前驱节点设置SIGNAL状态失败，直接唤醒该节点的线程</li>\n<li>重复2到4的过程，直到整个条件队列中的节点都被处理完成</li>\n</ol>\n<h5 id=\"signal\"><a href=\"#signal\" class=\"headerlink\" title=\"signal\"></a>signal</h5><p>signal只是唤醒一个节点，对于AQS的实现来说，只是唤醒条件队列中第一个没有被取消的节点。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">signal</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isHeldExclusively())</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalMonitorStateException();</span><br><span class=\"line\">    Node first = firstWaiter;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (first != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        doSignal(first);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>isHeldExclusively方法已经分析过，检查当前线程是不是持有锁的线程。然后看doSignal方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">doSignal</span><span class=\"params\">(Node first)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( (firstWaiter = first.nextWaiter) == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            lastWaiter = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        first.nextWaiter = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (!transferForSignal(first) &amp;&amp;</span><br><span class=\"line\">             (first = firstWaiter) != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个看到是一个循环，也是为了找队列中第一个没有被取消的节点，然后将这个节点放到同步队列中去。也是将first取出来，然后将nextWaiter设置为null，调用transferForSignal方法，这个方法的返回值将决定循环是否继续。如果返回true，那么while循环的条件就不满足了，所以只会唤醒一个线程。</p>\n<p>唤醒已经讲完了，我们再来看await方法。因为唤醒的时候，会让线程回到原来阻塞的地方继续执行。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">await</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Thread.interrupted())</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> InterruptedException();</span><br><span class=\"line\">    Node node = addConditionWaiter();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> savedState = fullyRelease(node);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> interruptMode = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class=\"line\">        LockSupport.park(<span class=\"keyword\">this</span>); </span><br><span class=\"line\">        <span class=\"comment\">// 这里就是阻塞回来的位置</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class=\"line\">        interruptMode = REINTERRUPT;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node.nextWaiter != <span class=\"keyword\">null</span>) </span><br><span class=\"line\">        unlinkCancelledWaiters();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (interruptMode != <span class=\"number\">0</span>)</span><br><span class=\"line\">        reportInterruptAfterWait(interruptMode);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是线程被唤醒，并不知道是什么原因被唤醒的。但是既然唤醒了，那么就需要acquireQueued方法进行“阻塞式”获取锁，抢到锁就返回，抢不到锁就继续被挂起。当await方法返回时，当前线程一定已经持有了lock锁。</p>\n<p>如果从线程被唤醒，到线程获取到锁这段过程中发生过中断，应该如何处理呢？</p>\n<p>中断对当前线程只是个建议，有当前线程决定怎么对其做出处理。acquireQueued方法对中断是不响应的，只是简单的记录抢锁过程中的中断状态，并在抢到锁后将这个中断状态返回，交给上层调用函数处理，此时也就是await方法。await方法如何处理这个中断，<strong>取决于这个中断发生时，线程是否已经被signal</strong>。</p>\n<p>在调用await方法时，就会检查当前线程的中断状态，如果线程还未阻塞就被中断，那么直接抛出InterruptedException。如果中断发生时，线程没有被signal过，那么等待中的线程就会被打断，也就是一个意料之外的唤醒，所以线程被唤醒后，需要抛出InterruptedException，表示当前线程因为中断而被唤醒。如果中断发生时，当前线程已经被signal过了，它就已经正常地从condition queue中唤醒了，那么这个中断来的就比较晚了，因为已经是正常唤醒之后才来的中断，那么就在await方法中补一下这个中断，调用Thread.interrupted()方法检测是否发生中断时也会将中断状态清除，因此如果忽略中断，则应该在await方法将线程恢复成原来的样子。</p>\n<p>在await方法中，用变量interruptMode记录中断事件：</p>\n<ol>\n<li>0：没有中断发生</li>\n<li>1：REINTERRUPT 表示中断发生在signal之后，需要再次自我中断</li>\n<li>-1:THROW_IE 表示中断发生在signal之前，需要抛出InterruptedException</li>\n</ol>\n<p>acquireQueued这个方法两个参数，我们前面说了释放锁的时候是释放所有的可重入锁，现在加锁的时候也是原来释放多少，这次就加多少锁。unlinkCancelledWaiters这个方法已经讲过了，就是遍历链表，然后把waitStatus不为CONDITION的节点从队列中移除。reportInterruptAfterWait是用来汇报中断的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">reportInterruptAfterWait</span><span class=\"params\">(<span class=\"keyword\">int</span> interruptMode)</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (interruptMode == THROW_IE)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> InterruptedException();</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (interruptMode == REINTERRUPT)</span><br><span class=\"line\">        selfInterrupt();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果interruptMode=THROW_IE，则直接抛出异常，报告等待的时候被中断异常唤醒。</p>\n<p>来总结一下：</p>\n<p><strong>中断发生在signal之前</strong></p>\n<ol>\n<li>线程因为中断被唤醒，通过checkInterruptWhileWaiting方法调用transferAfterCancelledWait方法来确认线程的waitStatus的值为Node.CONDITION，说明线程没有被signal</li>\n<li>修改线程的waitStatus为0，通过enq(node)将其添加到sync queue中</li>\n<li>线程获取锁，如果获取不到，则被再次挂起</li>\n<li>线程获取到锁后，调用unlinkCancelledWaiters方法将自己从条件队列中移除，该方法顺便移除其他取消等待的锁</li>\n<li>通过reportInterruptAfterWait抛出InterruptedException</li>\n</ol>\n<p>一个调用await方法挂起的线程在被中断后不会立即抛出InterruptedException，而是进入同步队列去竞争锁，争不到，挂起，如果争到锁了，从同步队列和条件队列移除，抛出InterruptedException。</p>\n<p><strong>中断发生在signal之后</strong></p>\n<p>这种情况其实就是线程被唤醒后，然后产生的中断，并没有影响到我们线程正常的阻塞到被signal唤醒的流程，所以，我们并不需要抛出InterruptedException异常，我们可以忽略这个中断，在await方法返回的时候，将这个线程重新中断一下，对忽略的中断进行一个补偿。</p>\n<h5 id=\"await总结\"><a href=\"#await总结\" class=\"headerlink\" title=\"await总结\"></a>await总结</h5><p>我们对整个await方法进行一个总结：</p>\n<ol>\n<li>进入await()时必须已经持有了锁</li>\n<li>离开await()时必须已经持有了锁</li>\n<li>调用await()会使当前线程被封装成Node扔进条件队列，并且释放所有持有的锁</li>\n<li>释放锁后，当前线程被挂起，等待signal或者中断唤醒线程</li>\n<li>线程被唤醒后，进入同步队列进行抢锁</li>\n<li>线程在抢到锁之前发生过中断，则根据中断发生在signal之前还是之后记录中断模式，体现在interruptMode</li>\n<li>线程在抢到锁后进行售后工作（离开条件队列，处理中断异常）</li>\n</ol>\n<h5 id=\"awaitUninterruptibly\"><a href=\"#awaitUninterruptibly\" class=\"headerlink\" title=\"awaitUninterruptibly\"></a>awaitUninterruptibly</h5><p>中断和signal都可以把线程唤醒，但是中断是一种异常唤醒，唤醒以后线程发现等待的条件并为满足，还是需要将线程挂起。当不希望await方法被中断时，可以使用awaitUninterruptibly方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">awaitUninterruptibly</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Node node = addConditionWaiter();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> savedState = fullyRelease(node);</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> interrupted = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class=\"line\">        LockSupport.park(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Thread.interrupted())</span><br><span class=\"line\">            interrupted = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (acquireQueued(node, savedState) || interrupted)</span><br><span class=\"line\">        selfInterrupt();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到就算中断唤醒了线程，也仅仅是记录interrupted状态为true，然后继续阻塞，等到signal才会唤醒线程去获取锁，当发生中断，不管什么时候的中断，都是最终补偿中断一次，并且不会抛出InterruptedException</p>\n<h5 id=\"awaitNanos\"><a href=\"#awaitNanos\" class=\"headerlink\" title=\"awaitNanos\"></a>awaitNanos</h5><p>前面的await和awaitUninterruptibly，它们在抢锁的过程中都是阻塞式的，一直抢到锁才能返回，否则线程一直挂起，这样的话就是线程如果长时间抢不到锁，就会一直被阻塞，因此有时候更需要带超时机制的去抢锁，和wait(long timeout)很像。看下源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> <span class=\"title\">awaitNanos</span><span class=\"params\">(<span class=\"keyword\">long</span> nanosTimeout)</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Thread.interrupted())</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> InterruptedException();</span><br><span class=\"line\">    Node node = addConditionWaiter();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> savedState = fullyRelease(node);</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> deadline = System.nanoTime() + nanosTimeout;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> interruptMode = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nanosTimeout &lt;= <span class=\"number\">0L</span>) &#123;</span><br><span class=\"line\">            transferAfterCancelledWait(node);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nanosTimeout &gt;= spinForTimeoutThreshold)</span><br><span class=\"line\">            LockSupport.parkNanos(<span class=\"keyword\">this</span>, nanosTimeout);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        nanosTimeout = deadline - System.nanoTime();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class=\"line\">        interruptMode = REINTERRUPT;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node.nextWaiter != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        unlinkCancelledWaiters();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (interruptMode != <span class=\"number\">0</span>)</span><br><span class=\"line\">        reportInterruptAfterWait(interruptMode);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> deadline - System.nanoTime();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个方法基本上和await方法一样，只是多了超时时间的处理。上面这段代码的意思是，如果超时时间没到，那么就将线程挂起，超过等待时间了，将线程从条件队列转移到同步队列中。这里对超时时间很短的时间做了一个优化，当超时时间小于spinForTimeoutThreshold(1000L ns)时，通过自旋的方式等待唤醒，而不是将线程挂起。</p>\n<p>wait(0)表示无限期等待，那么如果awaitNanos我们传0是一样的吗？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (nanosTimeout &lt;= <span class=\"number\">0L</span>) &#123;</span><br><span class=\"line\">    transferAfterCancelledWait(node);</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中已经有这段了，我这里单独提出来再来看下。这里可以看到当nanosTimeout&lt;=0的时候，就会将线程从条件等待队列转移到同步队列中，并不会被挂起，也不需要signal。</p>\n<h5 id=\"await-long-time-TimeUnit-unit\"><a href=\"#await-long-time-TimeUnit-unit\" class=\"headerlink\" title=\"await(long time, TimeUnit unit)\"></a>await(long time, TimeUnit unit)</h5><p>这个方法就是在awaitNanos方法基础上多了对超时时间单位的设置，但是在内部实现上还是会把时间转成纳秒去执行</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">await</span><span class=\"params\">(<span class=\"keyword\">long</span> time, TimeUnit unit)</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> nanosTimeout = unit.toNanos(time);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Thread.interrupted())</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> InterruptedException();</span><br><span class=\"line\">    Node node = addConditionWaiter();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> savedState = fullyRelease(node);</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> deadline = System.nanoTime() + nanosTimeout;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> timedout = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> interruptMode = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nanosTimeout &lt;= <span class=\"number\">0L</span>) &#123;</span><br><span class=\"line\">            timedout = transferAfterCancelledWait(node);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nanosTimeout &gt;= spinForTimeoutThreshold)</span><br><span class=\"line\">            LockSupport.parkNanos(<span class=\"keyword\">this</span>, nanosTimeout);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        nanosTimeout = deadline - System.nanoTime();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class=\"line\">        interruptMode = REINTERRUPT;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node.nextWaiter != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        unlinkCancelledWaiters();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (interruptMode != <span class=\"number\">0</span>)</span><br><span class=\"line\">        reportInterruptAfterWait(interruptMode);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> !timedout;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>awaitNanos(long nanosTimeout)的返回值是剩余的超时时间，如果该值大于0，说明超时时间还没到，则说明该返回是由signal行为导致的，而await(long time,TimeUnit unit)的返回值是transferAfterCancelledWait(node)的值决定的，调用该方法时，如果node还没有被signal过则返回true，否则返回false。其实这个方法就等价于调用awaitNanos(unit.toNanos(time)) &gt; 0。</p>\n<h3 id=\"awaitUntil-Date-deadline\"><a href=\"#awaitUntil-Date-deadline\" class=\"headerlink\" title=\"awaitUntil(Date deadline)\"></a>awaitUntil(Date deadline)</h3><p>awaitUntil方法和上面几个方法类似，只不过这个参数是一个绝对时间</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">awaitUntil</span><span class=\"params\">(Date deadline)</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> abstime = deadline.getTime();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Thread.interrupted())</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> InterruptedException();</span><br><span class=\"line\">    Node node = addConditionWaiter();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> savedState = fullyRelease(node);</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> timedout = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> interruptMode = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (System.currentTimeMillis() &gt; abstime) &#123;</span><br><span class=\"line\">            timedout = transferAfterCancelledWait(node);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        LockSupport.parkUntil(<span class=\"keyword\">this</span>, abstime);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class=\"line\">        interruptMode = REINTERRUPT;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node.nextWaiter != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        unlinkCancelledWaiters();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (interruptMode != <span class=\"number\">0</span>)</span><br><span class=\"line\">        reportInterruptAfterWait(interruptMode);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> !timedout;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个方法仅仅就是时间用成了绝对时间，并且没有使用spinForTimeoutThreshold进行自旋优化，因为调用这个方法，目的就是设一个较长的等待时间，不然上面的其他方法用起来更方便一些。</p>\n"},{"layout":"post","title":"AQS源码分析之独占锁的获取","description":"AQS源码分析之独占锁的获取","date":"2021-08-17T04:08:10.000Z","_content":"\n锁从不同的维度去区分，可以分成很多中类别的锁。比如可以根据一个线程中的多个流程能不能获取同一把锁来区分可重入锁和不可重入锁，可以根据多个线程能不能共享同一把锁来区分共享锁和排他锁可以根据多个线程竞争锁时要不要排队来区分公平锁和非公平锁。可重入锁就是一个线程中多个流程能获取同一把锁，不可重入锁就是一个线程中多个流程不能获取同一把锁。共享锁就是多个线程能共享同一把锁，排他锁就是锁只能被一个线程持有的锁。多个线程竞争锁时要排队就是公平锁，先尝试插队插队失败再排队的就是非公平锁。\n\n我想学习ReentrantLock主要目的就是为了知道它是怎么支持可重入的吧。ReentrantLock类中有Sync对象，这个对象继承了AbstractQueuedSynchronizer，也就是AQS（队列同步器）。AQS为线程的同步和等待等操作提供一个基础模板类。虽然为抽象类，但是没有抽象方法，将需要子类重写的方法定义成protect方法，将默认实现为抛出`UnsupportedOperationException`异常，如果子类用到，没有重写，将会抛出异常，如果子类没用用到，则不需要做任何操作。尽可能多的实现可重入锁，读写锁同步器所有需要的功能。队列同步器内部实现了线程的同步队列，独占或是共享的获取方式等，使其只需要少量的代码便可以实现目标功能。\n\n一般来说，AQS的子类应以其他类的内部类的形式存在，然后使用代理模式调用子类和AQS本身的方法实现线程的同步。\n\n本文源码基于JDK1.8。\n\njava并发工具的设计套路，分为三个重要组成部分，分别是状态、队列、CAS。\n\n- 状态：一般是一个state属性，是整个工具的核心，通常整个工具都是在设置和修改状态，很多方法的操作都依赖于当前状态是什么，由于状态是全局共享的，一般会使用volatile修饰，保证其修改的可见性。\n- 队列：队列通常是一个等待的集合，大多数以链表形式实现。队列采用的是悲观锁思想，表示当前所等待的资源，状态或者条件短时间内可能无法满足。因此，它会将当前线程包装成某种数据结构，扔到一个等待队列中，当条件满足后，再从等待队列中取出。\n- CAS：CAS操作是最轻量级的并发处理，通常对于状态的修改都会用到CAS操作，因为状态可能被多个线程同时修改，CAS操作保证了同一个时刻，只有一个线程能修改成功，从而保证了线程安全，CAS操作基本是由Unsafe工具类的`compareAndSwapXXX`来实现的。CAS采用的是乐观锁的思想，因此常常伴随着自旋，如果发现当前无法成功地执行CAS，则不断重试，直到成功为止，自旋的表现形式通常是一个死循环。\n\n#### AQS核心实现\n\n##### 状态\n\n在AQS中，状态是由state属性来表示的\n\n```java\nprivate volatile int state;\n```\n\n该属性值表示了锁的状态，state为0表示锁没有被占用，state大于0表示当前已经有线程持有该锁。这里说大于0，是因为可能有可重入的情况，那时候state就是持有该锁的线程数。\n\n独占锁的话，同一时刻，锁只能被一个线程持有。通过state变量是否为0，可以分辨当前锁是否被占用，但光知道锁是不是被占用是不够的，并不知道占用锁的线程是哪一个。在监视器锁中，我们用objectMonitor对象的_owner属性记录了当前拥有监视器锁的线程，而在AQS中，我们将通过exclusiveOwnerThread属性来记录占用锁的线程。\n\n```java\nprivate transient Thread exclusiveOwnerThread;\n```\n\n`exclusiveOwnerThread`属性的值就是当前持有锁的线程。\n\n##### 队列\n\nAQS中，队列的实现是一个双向链表，被称为`sync queue`，它表示所有等待锁的线程的集合，与synchronized中的wait set。\n\n并发编程在线程拿不到锁的时候，通常是把当前线程包装成某种类型的数据结构扔到等待队列中。我把重要的部分粘出来\n\n```java\nstatic final class Node {\n    //节点所带表的线程\n    volatile Thread thread;\n    \n    //双向链表\n    volatile Node prev;\n    volatile Node next;\n        \n    //线程所处的等待锁的状态，初始化时，该值为0\n    volatile int waitStatue;\n    static final int CANCELLED =  1;\n\tstatic final int SIGNAL    = -1;\n\tstatic final int CONDITION = -2;\n\tstatic final int PROPAGATE = -3;\n    \n    //该属性用于条件队列或者共享锁\n}\n```\n\n**tips** 在Node类中也有一个`waitStatus`，它表示了当前Node所代表的线程的等待锁的状态，在独占锁模式下，我们只需要关注`CANCELED`、`SIGNAL`两种状态即可。这里还有一个`nextWaiter`属性，它在独占锁模式下永远为null，仅仅起到一个标记作用，没有实际意义。\n\nAQS怎么去使用这个队列呢，既然是双向链表，那么肯定要有一个头节点和尾节点。\n\n```java\n//头结点，不代表任何线程，只是一个哑节点\nprivate transient volatile Node head;\n//尾节点，每一个请求锁的线程都会被加到尾节点\nprivate transient volatile Node tail;\n```\n\n在AQS中的队列是一个CLH队列，它的head节点永远是一个哑节点(dummy node)，它不代表任何线程（某些情况下可以看做是代表了当前持有锁的线程），**因此head所指向的Node的thread属性永远是null**。只有从次节点往后的所有节点才代表了所有等待锁的线程。也就是说，在当前线程没有抢到锁被包装成Node扔到队列中时，即使队列是空的，它也会排在第二个，我们会在它的前面新建一个dummy节点。为了便于描述，除去head节点的队列称作等待队列，这个队列中的节点代表等待锁的线程。\n\n![](https://vqianxiao.github.io/blog/images/aqs/syncqueue.png)\n\n结合图片，总结下Node节点各个属性的含义：\n\n- thread：当前Node所代表的线程\n- waitStatus：表示节点所处的等待状态，共享锁模式状态下只需关注三种状态：`SIGNAL`、`CANCELED`、`初始状态(0)`\n- prev next：节点的前驱和后继\n- nextWaiter：仅作为标记，值为null表示当前处于独占锁模式\n\n##### CAS\n\nCAS操作大多数都是用来改变状态的，在AQS中也不例外。我们一般在静态代码块中初始化需要CAS操作的属性的偏移量。\n\n```java\nprivate static final Unsafe unsafe = Unsafe.getUnsafe();\nprivate static final long stateOffset;\nprivate static final long headOffset;\nprivate static final long tailOffset;\nprivate static final long waitStatusOffset;\nprivate static final long nextOffset;\n\nstatic {\n    try {\n        stateOffset = unsafe.objectFieldOffset\n            (AbstractQueuedSynchronizer.class.getDeclaredField(\"state\"));\n        headOffset = unsafe.objectFieldOffset\n            (AbstractQueuedSynchronizer.class.getDeclaredField(\"head\"));\n        tailOffset = unsafe.objectFieldOffset\n            (AbstractQueuedSynchronizer.class.getDeclaredField(\"tail\"));\n        waitStatusOffset = unsafe.objectFieldOffset\n            (Node.class.getDeclaredField(\"waitStatus\"));\n        nextOffset = unsafe.objectFieldOffset\n            (Node.class.getDeclaredField(\"next\"));\n\n    } catch (Exception ex) { throw new Error(ex); }\n}\n```\n\n从静态代码块可以看出，CAS操作主要针对五个属性，包括AQS的3个属性state、head、tail和Node对象的两个属性waitStatus、next。说明这5个属性基本是会被多个线程同时访问的。\n\n看下实际CAS操作有哪些\n\n```java\nprotected final boolean compareAndSetState(int expect, int update) {\n    return unsafe.compareAndSwapInt(this, stateOffset, expect, update);\n}\nprivate final boolean compareAndSetHead(Node update) {\n    return unsafe.compareAndSwapObject(this, headOffset, null, update);\n}\nprivate final boolean compareAndSetTail(Node expect, Node update) {\n    return unsafe.compareAndSwapObject(this, tailOffset, expect, update);\n}\nprivate static final boolean compareAndSetWaitStatus(Node node, int expect,int update) {\n    return unsafe.compareAndSwapInt(node, waitStatusOffset, expect, update);\n}\nprivate static final boolean compareAndSetNext(Node node, Node expect, Node update) {\n    return unsafe.compareAndSwapObject(node, nextOffset, expect, update);\n}\n```\n\n然后就是不断自旋调用CAS操作来保证操作成功了。\n\nReentrantLock有公平锁和非公平锁两种实现，默认为非公平锁，体现在默认构造函数中。\n\n```java\npublic ReentrantLock() {\n    sync = new NonfairSync();\n}\n\npublic ReentrantLock(boolean fair) {\n    sync = fair ? new FairSync() : new NonfairSync();\n}\n\n// 获取锁\npublic void lock() {\n    sync.lock();\n}\n```\n\nFairSync继承自Sync，而Sync继承自AQS，ReentrantLocak获取锁的逻辑是直接调用了FairSync或者NonfairSync的逻辑。\n\n#### 获取锁\n\n看下ReentrantLock里的NonFairSync代码\n\n```java\nstatic final class NonfairSync extends Sync {\n    private static final long serialVersionUID = 7316153563782823691L;\n\n   /**\n     * Performs lock.  Try immediate barge, backing up to normal\n     * acquire on failure.\n     */\n    final void lock() {\n        if (compareAndSetState(0, 1))\n            //这个方法下面贴出来了 其实就是把当前线程赋值给exclusiveOwnerThread\n            setExclusiveOwnerThread(Thread.currentThread());\n        else\n            acquire(1);\n    }\n\n    protected final boolean tryAcquire(int acquires) {\n        return nonfairTryAcquire(acquires);\n    }\n}\n\nprotected final void setExclusiveOwnerThread(Thread thread) {\n    exclusiveOwnerThread = thread;\n}\n```\n\n可以看到在执行lock()的时候，上来就先假设没有锁，先去通过CAS修改锁的状态，如果修改成功，将当前线程赋值给exclusiveOwnerThread，也就是表明当前线程持有了锁。否则就去尝试获取锁，进入acquire(1)。\n\n```java\npublic final void acquire(int arg) {\n    if (!tryAcquire(arg) &&\n        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n        selfInterrupt();\n}\n```\n\n#### acquire\n\nacquire定义在AQS类中，描述了获取锁的流程。包含了四个方法调用：\n\n**1.tryAcquire(arg)**\n\n该方法由继承AQS的子类实现，为获取锁的具体逻辑。\n\n**2.addWaiter(Node mode)**\n\n该方法由AQS实现，负责在获取锁失败后调用，将当前请求锁的线程包装成Node扔到sync queue中去，并返回这个Node。\n\n**3.acquireQueued(final Node node,int arg)**\n\n该方法由AQS实现，主要对上面刚加入队列的Node不断尝试以下两种操作之一：\n\n- 在前驱节点就是head节点时，继续尝试获取锁\n- 将当前线程挂起，使CPU不再调度它\n\n**4.selfInterrupt**\n\n该方法由AQS实现，用于中断当前线程。由于在整个抢锁过程中，我们都是不响应中断的。那如果在抢锁过程中发生了中断怎么办呢，总不能假装没看见。AQS的做法就是简单的记录有没有发生过中断，如果返回的时候发现曾经发生过中断，则在退出acquire方法之前，就调用selfInterrupt自我中断一下，就好像将这个发生在抢锁过程中的中断“推迟”到抢锁结束以后再发生一样。\n\n从上面的介绍可以看出，除了获取锁的逻辑tryAcquire(arg)由子类实现之外，其余方法均由AQS实现。\n\ntryAcquire在ReentrantLock.Sync类中实现，根据调用链追踪下来，发现就是调用ReentrantLock.Sync中的nonfairTryAcquire()方法。\n\n```java\nfinal boolean nonfairTryAcquire(int acquires) {\n    final Thread current = Thread.currentThread();\n    int c = getState();\n    if (c == 0) {\n        if (compareAndSetState(0, acquires)) {\n            setExclusiveOwnerThread(current);\n            return true;\n        }\n    }\n    else if (current == getExclusiveOwnerThread()) {\n        int nextc = c + acquires;\n        if (nextc < 0) // overflow\n            throw new Error(\"Maximum lock count exceeded\");\n        setState(nextc);\n        return true;\n    }\n    return false;\n}\n```\n\n这里可以看到，如果state==0继续CAS去改变state的值为1然后更新持有锁的线程。当当前线程与持有锁的线程是同一个线程时，将state和acquires相加，得到一共加了多少次锁，这个很关键，因为需要相同次解锁这个资源才可以被别的线程持有。否则，直接返回false。\n\n这里两个更新state的操作，一个用了CAS方法，一个用了普通的setState方法， 这是因为CAS操作的时候，线程还没获取到锁，所以可能存在多个线程同时在竞争锁的情况，而调用setState方法时，是在当前线程已经是持有锁的情况下，因此对state的修改是安全的，只需要调用普通的方法即可。\n\nacquire方法中还调用了acquireQueued()方法，还有addWaiter()方法。`Node.EXCLUSIVE`参数表明这是独占模式。\n\n##### addWaiter\n\n如果调用到此方法，说明前面尝试获取锁的tryAcquire已经失败了，既然获取锁失败，就要将当前线程包装成Node，加到等待队列中去，因为是FIFO队列，所以自然是直接加在队尾。\n\n```java\nprivate Node addWaiter(Node mode) {\n    //这里看到独占锁模式下的节点，它的nextWaiter一定是null\n    Node node = new Node(Thread.currentThread(), mode);\n    // Try the fast path of enq; backup to full enq on failure\n    Node pred = tail;\n    //当队列尾部不为空的时候 并且cas将队列尾部node更新为当前node 将node插入等待队列的尾部\n    if (pred != null) {\n        node.prev = pred;\n        if (compareAndSetTail(pred, node)) {\n            pred.next = node;\n            return node;\n        }\n    }\n    //代码执行到这里只会有两种情况\n    //1.队列为空\n    //2.CAS失败\n    //并发条件下，什么都有可能发生，要注意CAS失败的话，也会走到这里来\n    enq(node);\n    return node;\n}\n```\n\n这个方法中，我们会尝试直接入队，但是因为并发条件下，所以同一时刻可能有别的线程也在入队，导致我们compareAnsSetTail(pred,node)操作失败，因为可能其他线程已经成为了新的尾节点，导致尾节点已经不是我们看到的那个了pred了。\n\n如果入队失败，就需要调用enq(node)方法，在enq方法中，我们通过自旋加CAS来保证当前节点入队。\n\n##### enq\n\n执行到这个方法，说明当前线程已经获取锁失败了，我们已经把它包装成了一个Node，准备把它放到等待队列中去。但是这一步又失败了，失败原因可能是一下两个之一：\n\n​\t1.等待线程现在是空的，没有线程在等待\n\n​\t2.其他线程在当前线程入队的过程中率先完成了入队，导致尾节点的值已经改变了，CAS操作失败。\n\n在这个方法中，通过自旋的方式，将当前节点插入队列，如果失败则不停尝试，直到成功为止。这个方法也负责在队列为空时，初始化队列，这也说明，队列时延迟初始化的。\n\n```java\nprivate Node enq(final Node node) {\n    for (;;) {\n        Node t = tail;\n        if (t == null) { // Must initialize\n            //队列为空 进行初始化 也可以看出队列不是在构造的时候初始化的，而是延迟到需要用的时候再初始化\n            //新建了一个dummy 节点\n            if (compareAndSetHead(new Node()))\n                tail = head;\n        } else {\n            node.prev = t;\n            if (compareAndSetTail(t, node)) {\n                t.next = node;\n                return t;\n            }\n        }\n    }\n}\n```\n\n当队列为空，初始化队列并没有使用传进来的节点，而是**新建了一个空节点**，在新建完空节点之后，没有返回，而是将尾节点指向当前的头节点。在下一轮循环中，尾节点已经不为null了，此时再将包装好的当前线程的Node加到这个空节点后面。这也就意味着，在这个等待队列中，头节点是一个“哑节点”，不代表任何等待的线程。\n\n##### 尾分叉\n\n在enq方法中有这么个逻辑。\n\n```java\n} else {\n    node.prev = t;\n    if (compareAndSetTail(t, node)) {\n        t.next = node;\n        return t;\n    }\n}\n```\n\n将一个节点添加到队列的末尾需要三步：\n\n​\t1.设置node的前驱节点为当前的尾节点 node.prev = t\n\n​\t2.修改tail的属性，使它指向当前节点\n\n​\t3.修改原来的尾节点，使它的next指向当前节点\n\n但是需要注意，这三步并不是一个原子操作，第一步很容易成功，第二步由于是一个CAS操作，在并发条件下有可能失败，第三步在第二步成功的条件下才执行。这里的CAS保证同一时刻，只有一个节点能成为尾节点，其他节点将失败，失败后通过for循环不断重试。\n\n所以，当有大量的线程在同时入队的时候，同一时刻，只有一个线程能完整的完成这三步，而其他线程只能完成第一步。所以就会出现尾分叉。\n\n![](https://vqianxiao.github.io/blog/images/aqs/tailfork.png)\n\n这里第三步是在第二步成功执行之后才执行的，这就意味着，有可能即使完成了第二步，将新的节点设置成了尾节点，此时原来旧的尾节点的next值可能还是null（因为第三步还没来得及执行），所以如果此时有线程恰好从头节点开始向后遍历整个链表，则它是遍历不到新加进来的尾节点的，但是这样是不合理的，因为现在的tail已经指向了新的尾节点。\n\n另一方面，当我们完成第二步之后，第一步一定是完成了的，所以如果我们从尾节点向前遍历，已经可以遍历到所有的节点。这也是为什么AQS相关的源码中，常常会从尾节点开始逆向遍历链表。因为一个节点要能入队，则它的prev属性一定是有值的，但是它的next属性可能暂时还没有值。\n\n至于那些“分叉”的入队失败的其他节点，在下一轮的循环中，它们的prev属性会重新指向新的尾节点，继续尝试新的CAS操作，最终所有的节点都会通过自旋不断的尝试入队，直到成功为止。\n\n##### acquireQueued\n\n再来看acquireQueued()，这个方法比较复杂，主要对上面刚加入队列的Node不断尝试2种操作：\n\n1.在前驱节点就是head节点的时候，继续尝试获取锁\n\n2.将当前线程挂起，让CPU不再调度它\n\n```java\nfinal boolean acquireQueued(final Node node, int arg) {\n    boolean failed = true;\n    try {\n        boolean interrupted = false;\n        for (;;) {\n            final Node p = node.predecessor();\n            //p == head 说明当前node已经是第一个节点了 所以再尝试获取一下锁 拿到锁，将node赋值给head 返回false\n            if (p == head && tryAcquire(arg)) {\n                setHead(node);\n                p.next = null; // help GC\n                failed = false;\n                return interrupted;\n            }\n            //shouldParkAfterFailedAcquire这个放回返回true 将会调用parkAndCheckInterrupt进入阻塞状态\n            if (shouldParkAfterFailedAcquire(p, node) &&\n                parkAndCheckInterrupt())\n                interrupted = true;\n        }\n    } finally {\n        if (failed)\n            cancelAcquire(node);\n    }\n}\n\n//获取前一个节点\nfinal Node predecessor() throws NullPointerException {\n    Node p = prev;\n    if (p == null)\n        throw new NullPointerException();\n    else\n        return p;\n}\n\nprivate static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {\n    //获取前置节点的waitStatus\n    //CANCELLED 1 取消\n    //SIGNAL -1 表明后续线程需要运行 indicate successor's thread needs unparking\n    //CONDITION -2 处于等待条件 indicate thread is waiting on condition\n    //PROPAGATE -3 indicate the next acquireShared should unconditionally propagate\n    int ws = pred.waitStatus;\n    if (ws == Node.SIGNAL)\n        /*\n             * This node has already set status asking a release\n             * to signal it, so it can safely park.\n             */\n        return true;\n    if (ws > 0) {\n        //前面的节点被取消 跳过已经取消等待锁的节点 往前找直到找到排队的节点\n        /*\n             * Predecessor was cancelled. Skip over predecessors and\n             * indicate retry.\n             */\n        do {\n            node.prev = pred = pred.prev;\n        } while (pred.waitStatus > 0);\n        pred.next = node;\n    } else {\n        /*\n             * waitStatus must be 0 or PROPAGATE.  Indicate that we\n             * need a signal, but don't park yet.  Caller will need to\n             * retry to make sure it cannot acquire before parking.\n             */\n        //waitStatus必须为0或者-3。表明我们需要一个信号，但是不要阻塞。调用者需要重试来确认暂停前无法获得锁\n        //把前一个节点状态赋值成SIGNAL 让线程重试获取锁，避免不必要的阻塞\n        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);\n    }\n    return false;\n}\n\n//将线程挂起然后等待唤醒并返回当前线程是否被中断\nprivate final boolean parkAndCheckInterrupt() {\n    LockSupport.park(this);\n    return Thread.interrupted();\n}\n```\n\n这里需要注意SIGNAL这个状态不是为线程自己设置的，是为前一个节点设置的。\n\n#### 获取锁总结\n\n1.先尝试CAS修改state，如果改成功，说明当前线程获取锁成功，然后将持有锁的线程更新成当前线程（exclusiveOwnerThread）。如果没有修改成功，调用acquire()\n\n2.在acquire()方法中，再次通过tryAcquire()获取锁，获取失败，会调用addWaiter方法，将当前等待的线程包装成Node，并成功添加到队列的末尾，这个操作由enq()方法来保证，enq()方法同时还负责在队列为空时初始化队列。\n\n3.acquireQueued方法用于Node成功入队后，继续尝试获取锁（取决于Node的前驱节点是不是head），或者将线程挂起。\n\n4.shouldParkAfterFailedAcquire方法用于保证当前线程的前驱节点的waitStatus属性值为SIGNAL，从而保证了自己挂起后，前驱节点会负责在合适的时候唤醒自己。\n\n5.parkAndCheckInterrupt方法用于挂起当前线程，并检查中断状态。\n\n6.如果最终成功获取了锁，线程会从lock()方法返回，继续往下执行，否则，线程会阻塞等待。","source":"_posts/AQS源码分析之独占锁的获取.md","raw":"---\nlayout:    post\ntitle:     AQS源码分析之独占锁的获取\ncategory:  JUC\ndescription: AQS源码分析之独占锁的获取\ntags: \n    - JDK\n    - JUC\n    - AQS\ndate: 2021/08/17 12:08:10\n\n---\n\n锁从不同的维度去区分，可以分成很多中类别的锁。比如可以根据一个线程中的多个流程能不能获取同一把锁来区分可重入锁和不可重入锁，可以根据多个线程能不能共享同一把锁来区分共享锁和排他锁可以根据多个线程竞争锁时要不要排队来区分公平锁和非公平锁。可重入锁就是一个线程中多个流程能获取同一把锁，不可重入锁就是一个线程中多个流程不能获取同一把锁。共享锁就是多个线程能共享同一把锁，排他锁就是锁只能被一个线程持有的锁。多个线程竞争锁时要排队就是公平锁，先尝试插队插队失败再排队的就是非公平锁。\n\n我想学习ReentrantLock主要目的就是为了知道它是怎么支持可重入的吧。ReentrantLock类中有Sync对象，这个对象继承了AbstractQueuedSynchronizer，也就是AQS（队列同步器）。AQS为线程的同步和等待等操作提供一个基础模板类。虽然为抽象类，但是没有抽象方法，将需要子类重写的方法定义成protect方法，将默认实现为抛出`UnsupportedOperationException`异常，如果子类用到，没有重写，将会抛出异常，如果子类没用用到，则不需要做任何操作。尽可能多的实现可重入锁，读写锁同步器所有需要的功能。队列同步器内部实现了线程的同步队列，独占或是共享的获取方式等，使其只需要少量的代码便可以实现目标功能。\n\n一般来说，AQS的子类应以其他类的内部类的形式存在，然后使用代理模式调用子类和AQS本身的方法实现线程的同步。\n\n本文源码基于JDK1.8。\n\njava并发工具的设计套路，分为三个重要组成部分，分别是状态、队列、CAS。\n\n- 状态：一般是一个state属性，是整个工具的核心，通常整个工具都是在设置和修改状态，很多方法的操作都依赖于当前状态是什么，由于状态是全局共享的，一般会使用volatile修饰，保证其修改的可见性。\n- 队列：队列通常是一个等待的集合，大多数以链表形式实现。队列采用的是悲观锁思想，表示当前所等待的资源，状态或者条件短时间内可能无法满足。因此，它会将当前线程包装成某种数据结构，扔到一个等待队列中，当条件满足后，再从等待队列中取出。\n- CAS：CAS操作是最轻量级的并发处理，通常对于状态的修改都会用到CAS操作，因为状态可能被多个线程同时修改，CAS操作保证了同一个时刻，只有一个线程能修改成功，从而保证了线程安全，CAS操作基本是由Unsafe工具类的`compareAndSwapXXX`来实现的。CAS采用的是乐观锁的思想，因此常常伴随着自旋，如果发现当前无法成功地执行CAS，则不断重试，直到成功为止，自旋的表现形式通常是一个死循环。\n\n#### AQS核心实现\n\n##### 状态\n\n在AQS中，状态是由state属性来表示的\n\n```java\nprivate volatile int state;\n```\n\n该属性值表示了锁的状态，state为0表示锁没有被占用，state大于0表示当前已经有线程持有该锁。这里说大于0，是因为可能有可重入的情况，那时候state就是持有该锁的线程数。\n\n独占锁的话，同一时刻，锁只能被一个线程持有。通过state变量是否为0，可以分辨当前锁是否被占用，但光知道锁是不是被占用是不够的，并不知道占用锁的线程是哪一个。在监视器锁中，我们用objectMonitor对象的_owner属性记录了当前拥有监视器锁的线程，而在AQS中，我们将通过exclusiveOwnerThread属性来记录占用锁的线程。\n\n```java\nprivate transient Thread exclusiveOwnerThread;\n```\n\n`exclusiveOwnerThread`属性的值就是当前持有锁的线程。\n\n##### 队列\n\nAQS中，队列的实现是一个双向链表，被称为`sync queue`，它表示所有等待锁的线程的集合，与synchronized中的wait set。\n\n并发编程在线程拿不到锁的时候，通常是把当前线程包装成某种类型的数据结构扔到等待队列中。我把重要的部分粘出来\n\n```java\nstatic final class Node {\n    //节点所带表的线程\n    volatile Thread thread;\n    \n    //双向链表\n    volatile Node prev;\n    volatile Node next;\n        \n    //线程所处的等待锁的状态，初始化时，该值为0\n    volatile int waitStatue;\n    static final int CANCELLED =  1;\n\tstatic final int SIGNAL    = -1;\n\tstatic final int CONDITION = -2;\n\tstatic final int PROPAGATE = -3;\n    \n    //该属性用于条件队列或者共享锁\n}\n```\n\n**tips** 在Node类中也有一个`waitStatus`，它表示了当前Node所代表的线程的等待锁的状态，在独占锁模式下，我们只需要关注`CANCELED`、`SIGNAL`两种状态即可。这里还有一个`nextWaiter`属性，它在独占锁模式下永远为null，仅仅起到一个标记作用，没有实际意义。\n\nAQS怎么去使用这个队列呢，既然是双向链表，那么肯定要有一个头节点和尾节点。\n\n```java\n//头结点，不代表任何线程，只是一个哑节点\nprivate transient volatile Node head;\n//尾节点，每一个请求锁的线程都会被加到尾节点\nprivate transient volatile Node tail;\n```\n\n在AQS中的队列是一个CLH队列，它的head节点永远是一个哑节点(dummy node)，它不代表任何线程（某些情况下可以看做是代表了当前持有锁的线程），**因此head所指向的Node的thread属性永远是null**。只有从次节点往后的所有节点才代表了所有等待锁的线程。也就是说，在当前线程没有抢到锁被包装成Node扔到队列中时，即使队列是空的，它也会排在第二个，我们会在它的前面新建一个dummy节点。为了便于描述，除去head节点的队列称作等待队列，这个队列中的节点代表等待锁的线程。\n\n![](https://vqianxiao.github.io/blog/images/aqs/syncqueue.png)\n\n结合图片，总结下Node节点各个属性的含义：\n\n- thread：当前Node所代表的线程\n- waitStatus：表示节点所处的等待状态，共享锁模式状态下只需关注三种状态：`SIGNAL`、`CANCELED`、`初始状态(0)`\n- prev next：节点的前驱和后继\n- nextWaiter：仅作为标记，值为null表示当前处于独占锁模式\n\n##### CAS\n\nCAS操作大多数都是用来改变状态的，在AQS中也不例外。我们一般在静态代码块中初始化需要CAS操作的属性的偏移量。\n\n```java\nprivate static final Unsafe unsafe = Unsafe.getUnsafe();\nprivate static final long stateOffset;\nprivate static final long headOffset;\nprivate static final long tailOffset;\nprivate static final long waitStatusOffset;\nprivate static final long nextOffset;\n\nstatic {\n    try {\n        stateOffset = unsafe.objectFieldOffset\n            (AbstractQueuedSynchronizer.class.getDeclaredField(\"state\"));\n        headOffset = unsafe.objectFieldOffset\n            (AbstractQueuedSynchronizer.class.getDeclaredField(\"head\"));\n        tailOffset = unsafe.objectFieldOffset\n            (AbstractQueuedSynchronizer.class.getDeclaredField(\"tail\"));\n        waitStatusOffset = unsafe.objectFieldOffset\n            (Node.class.getDeclaredField(\"waitStatus\"));\n        nextOffset = unsafe.objectFieldOffset\n            (Node.class.getDeclaredField(\"next\"));\n\n    } catch (Exception ex) { throw new Error(ex); }\n}\n```\n\n从静态代码块可以看出，CAS操作主要针对五个属性，包括AQS的3个属性state、head、tail和Node对象的两个属性waitStatus、next。说明这5个属性基本是会被多个线程同时访问的。\n\n看下实际CAS操作有哪些\n\n```java\nprotected final boolean compareAndSetState(int expect, int update) {\n    return unsafe.compareAndSwapInt(this, stateOffset, expect, update);\n}\nprivate final boolean compareAndSetHead(Node update) {\n    return unsafe.compareAndSwapObject(this, headOffset, null, update);\n}\nprivate final boolean compareAndSetTail(Node expect, Node update) {\n    return unsafe.compareAndSwapObject(this, tailOffset, expect, update);\n}\nprivate static final boolean compareAndSetWaitStatus(Node node, int expect,int update) {\n    return unsafe.compareAndSwapInt(node, waitStatusOffset, expect, update);\n}\nprivate static final boolean compareAndSetNext(Node node, Node expect, Node update) {\n    return unsafe.compareAndSwapObject(node, nextOffset, expect, update);\n}\n```\n\n然后就是不断自旋调用CAS操作来保证操作成功了。\n\nReentrantLock有公平锁和非公平锁两种实现，默认为非公平锁，体现在默认构造函数中。\n\n```java\npublic ReentrantLock() {\n    sync = new NonfairSync();\n}\n\npublic ReentrantLock(boolean fair) {\n    sync = fair ? new FairSync() : new NonfairSync();\n}\n\n// 获取锁\npublic void lock() {\n    sync.lock();\n}\n```\n\nFairSync继承自Sync，而Sync继承自AQS，ReentrantLocak获取锁的逻辑是直接调用了FairSync或者NonfairSync的逻辑。\n\n#### 获取锁\n\n看下ReentrantLock里的NonFairSync代码\n\n```java\nstatic final class NonfairSync extends Sync {\n    private static final long serialVersionUID = 7316153563782823691L;\n\n   /**\n     * Performs lock.  Try immediate barge, backing up to normal\n     * acquire on failure.\n     */\n    final void lock() {\n        if (compareAndSetState(0, 1))\n            //这个方法下面贴出来了 其实就是把当前线程赋值给exclusiveOwnerThread\n            setExclusiveOwnerThread(Thread.currentThread());\n        else\n            acquire(1);\n    }\n\n    protected final boolean tryAcquire(int acquires) {\n        return nonfairTryAcquire(acquires);\n    }\n}\n\nprotected final void setExclusiveOwnerThread(Thread thread) {\n    exclusiveOwnerThread = thread;\n}\n```\n\n可以看到在执行lock()的时候，上来就先假设没有锁，先去通过CAS修改锁的状态，如果修改成功，将当前线程赋值给exclusiveOwnerThread，也就是表明当前线程持有了锁。否则就去尝试获取锁，进入acquire(1)。\n\n```java\npublic final void acquire(int arg) {\n    if (!tryAcquire(arg) &&\n        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n        selfInterrupt();\n}\n```\n\n#### acquire\n\nacquire定义在AQS类中，描述了获取锁的流程。包含了四个方法调用：\n\n**1.tryAcquire(arg)**\n\n该方法由继承AQS的子类实现，为获取锁的具体逻辑。\n\n**2.addWaiter(Node mode)**\n\n该方法由AQS实现，负责在获取锁失败后调用，将当前请求锁的线程包装成Node扔到sync queue中去，并返回这个Node。\n\n**3.acquireQueued(final Node node,int arg)**\n\n该方法由AQS实现，主要对上面刚加入队列的Node不断尝试以下两种操作之一：\n\n- 在前驱节点就是head节点时，继续尝试获取锁\n- 将当前线程挂起，使CPU不再调度它\n\n**4.selfInterrupt**\n\n该方法由AQS实现，用于中断当前线程。由于在整个抢锁过程中，我们都是不响应中断的。那如果在抢锁过程中发生了中断怎么办呢，总不能假装没看见。AQS的做法就是简单的记录有没有发生过中断，如果返回的时候发现曾经发生过中断，则在退出acquire方法之前，就调用selfInterrupt自我中断一下，就好像将这个发生在抢锁过程中的中断“推迟”到抢锁结束以后再发生一样。\n\n从上面的介绍可以看出，除了获取锁的逻辑tryAcquire(arg)由子类实现之外，其余方法均由AQS实现。\n\ntryAcquire在ReentrantLock.Sync类中实现，根据调用链追踪下来，发现就是调用ReentrantLock.Sync中的nonfairTryAcquire()方法。\n\n```java\nfinal boolean nonfairTryAcquire(int acquires) {\n    final Thread current = Thread.currentThread();\n    int c = getState();\n    if (c == 0) {\n        if (compareAndSetState(0, acquires)) {\n            setExclusiveOwnerThread(current);\n            return true;\n        }\n    }\n    else if (current == getExclusiveOwnerThread()) {\n        int nextc = c + acquires;\n        if (nextc < 0) // overflow\n            throw new Error(\"Maximum lock count exceeded\");\n        setState(nextc);\n        return true;\n    }\n    return false;\n}\n```\n\n这里可以看到，如果state==0继续CAS去改变state的值为1然后更新持有锁的线程。当当前线程与持有锁的线程是同一个线程时，将state和acquires相加，得到一共加了多少次锁，这个很关键，因为需要相同次解锁这个资源才可以被别的线程持有。否则，直接返回false。\n\n这里两个更新state的操作，一个用了CAS方法，一个用了普通的setState方法， 这是因为CAS操作的时候，线程还没获取到锁，所以可能存在多个线程同时在竞争锁的情况，而调用setState方法时，是在当前线程已经是持有锁的情况下，因此对state的修改是安全的，只需要调用普通的方法即可。\n\nacquire方法中还调用了acquireQueued()方法，还有addWaiter()方法。`Node.EXCLUSIVE`参数表明这是独占模式。\n\n##### addWaiter\n\n如果调用到此方法，说明前面尝试获取锁的tryAcquire已经失败了，既然获取锁失败，就要将当前线程包装成Node，加到等待队列中去，因为是FIFO队列，所以自然是直接加在队尾。\n\n```java\nprivate Node addWaiter(Node mode) {\n    //这里看到独占锁模式下的节点，它的nextWaiter一定是null\n    Node node = new Node(Thread.currentThread(), mode);\n    // Try the fast path of enq; backup to full enq on failure\n    Node pred = tail;\n    //当队列尾部不为空的时候 并且cas将队列尾部node更新为当前node 将node插入等待队列的尾部\n    if (pred != null) {\n        node.prev = pred;\n        if (compareAndSetTail(pred, node)) {\n            pred.next = node;\n            return node;\n        }\n    }\n    //代码执行到这里只会有两种情况\n    //1.队列为空\n    //2.CAS失败\n    //并发条件下，什么都有可能发生，要注意CAS失败的话，也会走到这里来\n    enq(node);\n    return node;\n}\n```\n\n这个方法中，我们会尝试直接入队，但是因为并发条件下，所以同一时刻可能有别的线程也在入队，导致我们compareAnsSetTail(pred,node)操作失败，因为可能其他线程已经成为了新的尾节点，导致尾节点已经不是我们看到的那个了pred了。\n\n如果入队失败，就需要调用enq(node)方法，在enq方法中，我们通过自旋加CAS来保证当前节点入队。\n\n##### enq\n\n执行到这个方法，说明当前线程已经获取锁失败了，我们已经把它包装成了一个Node，准备把它放到等待队列中去。但是这一步又失败了，失败原因可能是一下两个之一：\n\n​\t1.等待线程现在是空的，没有线程在等待\n\n​\t2.其他线程在当前线程入队的过程中率先完成了入队，导致尾节点的值已经改变了，CAS操作失败。\n\n在这个方法中，通过自旋的方式，将当前节点插入队列，如果失败则不停尝试，直到成功为止。这个方法也负责在队列为空时，初始化队列，这也说明，队列时延迟初始化的。\n\n```java\nprivate Node enq(final Node node) {\n    for (;;) {\n        Node t = tail;\n        if (t == null) { // Must initialize\n            //队列为空 进行初始化 也可以看出队列不是在构造的时候初始化的，而是延迟到需要用的时候再初始化\n            //新建了一个dummy 节点\n            if (compareAndSetHead(new Node()))\n                tail = head;\n        } else {\n            node.prev = t;\n            if (compareAndSetTail(t, node)) {\n                t.next = node;\n                return t;\n            }\n        }\n    }\n}\n```\n\n当队列为空，初始化队列并没有使用传进来的节点，而是**新建了一个空节点**，在新建完空节点之后，没有返回，而是将尾节点指向当前的头节点。在下一轮循环中，尾节点已经不为null了，此时再将包装好的当前线程的Node加到这个空节点后面。这也就意味着，在这个等待队列中，头节点是一个“哑节点”，不代表任何等待的线程。\n\n##### 尾分叉\n\n在enq方法中有这么个逻辑。\n\n```java\n} else {\n    node.prev = t;\n    if (compareAndSetTail(t, node)) {\n        t.next = node;\n        return t;\n    }\n}\n```\n\n将一个节点添加到队列的末尾需要三步：\n\n​\t1.设置node的前驱节点为当前的尾节点 node.prev = t\n\n​\t2.修改tail的属性，使它指向当前节点\n\n​\t3.修改原来的尾节点，使它的next指向当前节点\n\n但是需要注意，这三步并不是一个原子操作，第一步很容易成功，第二步由于是一个CAS操作，在并发条件下有可能失败，第三步在第二步成功的条件下才执行。这里的CAS保证同一时刻，只有一个节点能成为尾节点，其他节点将失败，失败后通过for循环不断重试。\n\n所以，当有大量的线程在同时入队的时候，同一时刻，只有一个线程能完整的完成这三步，而其他线程只能完成第一步。所以就会出现尾分叉。\n\n![](https://vqianxiao.github.io/blog/images/aqs/tailfork.png)\n\n这里第三步是在第二步成功执行之后才执行的，这就意味着，有可能即使完成了第二步，将新的节点设置成了尾节点，此时原来旧的尾节点的next值可能还是null（因为第三步还没来得及执行），所以如果此时有线程恰好从头节点开始向后遍历整个链表，则它是遍历不到新加进来的尾节点的，但是这样是不合理的，因为现在的tail已经指向了新的尾节点。\n\n另一方面，当我们完成第二步之后，第一步一定是完成了的，所以如果我们从尾节点向前遍历，已经可以遍历到所有的节点。这也是为什么AQS相关的源码中，常常会从尾节点开始逆向遍历链表。因为一个节点要能入队，则它的prev属性一定是有值的，但是它的next属性可能暂时还没有值。\n\n至于那些“分叉”的入队失败的其他节点，在下一轮的循环中，它们的prev属性会重新指向新的尾节点，继续尝试新的CAS操作，最终所有的节点都会通过自旋不断的尝试入队，直到成功为止。\n\n##### acquireQueued\n\n再来看acquireQueued()，这个方法比较复杂，主要对上面刚加入队列的Node不断尝试2种操作：\n\n1.在前驱节点就是head节点的时候，继续尝试获取锁\n\n2.将当前线程挂起，让CPU不再调度它\n\n```java\nfinal boolean acquireQueued(final Node node, int arg) {\n    boolean failed = true;\n    try {\n        boolean interrupted = false;\n        for (;;) {\n            final Node p = node.predecessor();\n            //p == head 说明当前node已经是第一个节点了 所以再尝试获取一下锁 拿到锁，将node赋值给head 返回false\n            if (p == head && tryAcquire(arg)) {\n                setHead(node);\n                p.next = null; // help GC\n                failed = false;\n                return interrupted;\n            }\n            //shouldParkAfterFailedAcquire这个放回返回true 将会调用parkAndCheckInterrupt进入阻塞状态\n            if (shouldParkAfterFailedAcquire(p, node) &&\n                parkAndCheckInterrupt())\n                interrupted = true;\n        }\n    } finally {\n        if (failed)\n            cancelAcquire(node);\n    }\n}\n\n//获取前一个节点\nfinal Node predecessor() throws NullPointerException {\n    Node p = prev;\n    if (p == null)\n        throw new NullPointerException();\n    else\n        return p;\n}\n\nprivate static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {\n    //获取前置节点的waitStatus\n    //CANCELLED 1 取消\n    //SIGNAL -1 表明后续线程需要运行 indicate successor's thread needs unparking\n    //CONDITION -2 处于等待条件 indicate thread is waiting on condition\n    //PROPAGATE -3 indicate the next acquireShared should unconditionally propagate\n    int ws = pred.waitStatus;\n    if (ws == Node.SIGNAL)\n        /*\n             * This node has already set status asking a release\n             * to signal it, so it can safely park.\n             */\n        return true;\n    if (ws > 0) {\n        //前面的节点被取消 跳过已经取消等待锁的节点 往前找直到找到排队的节点\n        /*\n             * Predecessor was cancelled. Skip over predecessors and\n             * indicate retry.\n             */\n        do {\n            node.prev = pred = pred.prev;\n        } while (pred.waitStatus > 0);\n        pred.next = node;\n    } else {\n        /*\n             * waitStatus must be 0 or PROPAGATE.  Indicate that we\n             * need a signal, but don't park yet.  Caller will need to\n             * retry to make sure it cannot acquire before parking.\n             */\n        //waitStatus必须为0或者-3。表明我们需要一个信号，但是不要阻塞。调用者需要重试来确认暂停前无法获得锁\n        //把前一个节点状态赋值成SIGNAL 让线程重试获取锁，避免不必要的阻塞\n        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);\n    }\n    return false;\n}\n\n//将线程挂起然后等待唤醒并返回当前线程是否被中断\nprivate final boolean parkAndCheckInterrupt() {\n    LockSupport.park(this);\n    return Thread.interrupted();\n}\n```\n\n这里需要注意SIGNAL这个状态不是为线程自己设置的，是为前一个节点设置的。\n\n#### 获取锁总结\n\n1.先尝试CAS修改state，如果改成功，说明当前线程获取锁成功，然后将持有锁的线程更新成当前线程（exclusiveOwnerThread）。如果没有修改成功，调用acquire()\n\n2.在acquire()方法中，再次通过tryAcquire()获取锁，获取失败，会调用addWaiter方法，将当前等待的线程包装成Node，并成功添加到队列的末尾，这个操作由enq()方法来保证，enq()方法同时还负责在队列为空时初始化队列。\n\n3.acquireQueued方法用于Node成功入队后，继续尝试获取锁（取决于Node的前驱节点是不是head），或者将线程挂起。\n\n4.shouldParkAfterFailedAcquire方法用于保证当前线程的前驱节点的waitStatus属性值为SIGNAL，从而保证了自己挂起后，前驱节点会负责在合适的时候唤醒自己。\n\n5.parkAndCheckInterrupt方法用于挂起当前线程，并检查中断状态。\n\n6.如果最终成功获取了锁，线程会从lock()方法返回，继续往下执行，否则，线程会阻塞等待。","slug":"AQS源码分析之独占锁的获取","published":1,"updated":"2021-08-17T04:08:10.000Z","comments":1,"photos":[],"link":"","_id":"cm1m304y8003n31b43edt3ult","content":"<p>锁从不同的维度去区分，可以分成很多中类别的锁。比如可以根据一个线程中的多个流程能不能获取同一把锁来区分可重入锁和不可重入锁，可以根据多个线程能不能共享同一把锁来区分共享锁和排他锁可以根据多个线程竞争锁时要不要排队来区分公平锁和非公平锁。可重入锁就是一个线程中多个流程能获取同一把锁，不可重入锁就是一个线程中多个流程不能获取同一把锁。共享锁就是多个线程能共享同一把锁，排他锁就是锁只能被一个线程持有的锁。多个线程竞争锁时要排队就是公平锁，先尝试插队插队失败再排队的就是非公平锁。</p>\n<p>我想学习ReentrantLock主要目的就是为了知道它是怎么支持可重入的吧。ReentrantLock类中有Sync对象，这个对象继承了AbstractQueuedSynchronizer，也就是AQS（队列同步器）。AQS为线程的同步和等待等操作提供一个基础模板类。虽然为抽象类，但是没有抽象方法，将需要子类重写的方法定义成protect方法，将默认实现为抛出<code>UnsupportedOperationException</code>异常，如果子类用到，没有重写，将会抛出异常，如果子类没用用到，则不需要做任何操作。尽可能多的实现可重入锁，读写锁同步器所有需要的功能。队列同步器内部实现了线程的同步队列，独占或是共享的获取方式等，使其只需要少量的代码便可以实现目标功能。</p>\n<p>一般来说，AQS的子类应以其他类的内部类的形式存在，然后使用代理模式调用子类和AQS本身的方法实现线程的同步。</p>\n<p>本文源码基于JDK1.8。</p>\n<p>java并发工具的设计套路，分为三个重要组成部分，分别是状态、队列、CAS。</p>\n<ul>\n<li>状态：一般是一个state属性，是整个工具的核心，通常整个工具都是在设置和修改状态，很多方法的操作都依赖于当前状态是什么，由于状态是全局共享的，一般会使用volatile修饰，保证其修改的可见性。</li>\n<li>队列：队列通常是一个等待的集合，大多数以链表形式实现。队列采用的是悲观锁思想，表示当前所等待的资源，状态或者条件短时间内可能无法满足。因此，它会将当前线程包装成某种数据结构，扔到一个等待队列中，当条件满足后，再从等待队列中取出。</li>\n<li>CAS：CAS操作是最轻量级的并发处理，通常对于状态的修改都会用到CAS操作，因为状态可能被多个线程同时修改，CAS操作保证了同一个时刻，只有一个线程能修改成功，从而保证了线程安全，CAS操作基本是由Unsafe工具类的<code>compareAndSwapXXX</code>来实现的。CAS采用的是乐观锁的思想，因此常常伴随着自旋，如果发现当前无法成功地执行CAS，则不断重试，直到成功为止，自旋的表现形式通常是一个死循环。</li>\n</ul>\n<h4 id=\"AQS核心实现\"><a href=\"#AQS核心实现\" class=\"headerlink\" title=\"AQS核心实现\"></a>AQS核心实现</h4><h5 id=\"状态\"><a href=\"#状态\" class=\"headerlink\" title=\"状态\"></a>状态</h5><p>在AQS中，状态是由state属性来表示的</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> state;</span><br></pre></td></tr></table></figure>\n\n<p>该属性值表示了锁的状态，state为0表示锁没有被占用，state大于0表示当前已经有线程持有该锁。这里说大于0，是因为可能有可重入的情况，那时候state就是持有该锁的线程数。</p>\n<p>独占锁的话，同一时刻，锁只能被一个线程持有。通过state变量是否为0，可以分辨当前锁是否被占用，但光知道锁是不是被占用是不够的，并不知道占用锁的线程是哪一个。在监视器锁中，我们用objectMonitor对象的_owner属性记录了当前拥有监视器锁的线程，而在AQS中，我们将通过exclusiveOwnerThread属性来记录占用锁的线程。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> Thread exclusiveOwnerThread;</span><br></pre></td></tr></table></figure>\n\n<p><code>exclusiveOwnerThread</code>属性的值就是当前持有锁的线程。</p>\n<h5 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h5><p>AQS中，队列的实现是一个双向链表，被称为<code>sync queue</code>，它表示所有等待锁的线程的集合，与synchronized中的wait set。</p>\n<p>并发编程在线程拿不到锁的时候，通常是把当前线程包装成某种类型的数据结构扔到等待队列中。我把重要的部分粘出来</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//节点所带表的线程</span></span><br><span class=\"line\">    <span class=\"keyword\">volatile</span> Thread thread;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//双向链表</span></span><br><span class=\"line\">    <span class=\"keyword\">volatile</span> Node prev;</span><br><span class=\"line\">    <span class=\"keyword\">volatile</span> Node next;</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"comment\">//线程所处的等待锁的状态，初始化时，该值为0</span></span><br><span class=\"line\">    <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> waitStatue;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> CANCELLED =  <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> SIGNAL    = -<span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> CONDITION = -<span class=\"number\">2</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> PROPAGATE = -<span class=\"number\">3</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//该属性用于条件队列或者共享锁</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>tips</strong> 在Node类中也有一个<code>waitStatus</code>，它表示了当前Node所代表的线程的等待锁的状态，在独占锁模式下，我们只需要关注<code>CANCELED</code>、<code>SIGNAL</code>两种状态即可。这里还有一个<code>nextWaiter</code>属性，它在独占锁模式下永远为null，仅仅起到一个标记作用，没有实际意义。</p>\n<p>AQS怎么去使用这个队列呢，既然是双向链表，那么肯定要有一个头节点和尾节点。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//头结点，不代表任何线程，只是一个哑节点</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> <span class=\"keyword\">volatile</span> Node head;</span><br><span class=\"line\"><span class=\"comment\">//尾节点，每一个请求锁的线程都会被加到尾节点</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> <span class=\"keyword\">volatile</span> Node tail;</span><br></pre></td></tr></table></figure>\n\n<p>在AQS中的队列是一个CLH队列，它的head节点永远是一个哑节点(dummy node)，它不代表任何线程（某些情况下可以看做是代表了当前持有锁的线程），<strong>因此head所指向的Node的thread属性永远是null</strong>。只有从次节点往后的所有节点才代表了所有等待锁的线程。也就是说，在当前线程没有抢到锁被包装成Node扔到队列中时，即使队列是空的，它也会排在第二个，我们会在它的前面新建一个dummy节点。为了便于描述，除去head节点的队列称作等待队列，这个队列中的节点代表等待锁的线程。</p>\n<p><img src=\"https://vqianxiao.github.io/blog/images/aqs/syncqueue.png\"></p>\n<p>结合图片，总结下Node节点各个属性的含义：</p>\n<ul>\n<li>thread：当前Node所代表的线程</li>\n<li>waitStatus：表示节点所处的等待状态，共享锁模式状态下只需关注三种状态：<code>SIGNAL</code>、<code>CANCELED</code>、<code>初始状态(0)</code></li>\n<li>prev next：节点的前驱和后继</li>\n<li>nextWaiter：仅作为标记，值为null表示当前处于独占锁模式</li>\n</ul>\n<h5 id=\"CAS\"><a href=\"#CAS\" class=\"headerlink\" title=\"CAS\"></a>CAS</h5><p>CAS操作大多数都是用来改变状态的，在AQS中也不例外。我们一般在静态代码块中初始化需要CAS操作的属性的偏移量。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> stateOffset;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> headOffset;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> tailOffset;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> waitStatusOffset;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> nextOffset;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        stateOffset = unsafe.objectFieldOffset</span><br><span class=\"line\">            (AbstractQueuedSynchronizer.class.getDeclaredField(<span class=\"string\">&quot;state&quot;</span>));</span><br><span class=\"line\">        headOffset = unsafe.objectFieldOffset</span><br><span class=\"line\">            (AbstractQueuedSynchronizer.class.getDeclaredField(<span class=\"string\">&quot;head&quot;</span>));</span><br><span class=\"line\">        tailOffset = unsafe.objectFieldOffset</span><br><span class=\"line\">            (AbstractQueuedSynchronizer.class.getDeclaredField(<span class=\"string\">&quot;tail&quot;</span>));</span><br><span class=\"line\">        waitStatusOffset = unsafe.objectFieldOffset</span><br><span class=\"line\">            (Node.class.getDeclaredField(<span class=\"string\">&quot;waitStatus&quot;</span>));</span><br><span class=\"line\">        nextOffset = unsafe.objectFieldOffset</span><br><span class=\"line\">            (Node.class.getDeclaredField(<span class=\"string\">&quot;next&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception ex) &#123; <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(ex); &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从静态代码块可以看出，CAS操作主要针对五个属性，包括AQS的3个属性state、head、tail和Node对象的两个属性waitStatus、next。说明这5个属性基本是会被多个线程同时访问的。</p>\n<p>看下实际CAS操作有哪些</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">compareAndSetState</span><span class=\"params\">(<span class=\"keyword\">int</span> expect, <span class=\"keyword\">int</span> update)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> unsafe.compareAndSwapInt(<span class=\"keyword\">this</span>, stateOffset, expect, update);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">compareAndSetHead</span><span class=\"params\">(Node update)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> unsafe.compareAndSwapObject(<span class=\"keyword\">this</span>, headOffset, <span class=\"keyword\">null</span>, update);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">compareAndSetTail</span><span class=\"params\">(Node expect, Node update)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> unsafe.compareAndSwapObject(<span class=\"keyword\">this</span>, tailOffset, expect, update);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">compareAndSetWaitStatus</span><span class=\"params\">(Node node, <span class=\"keyword\">int</span> expect,<span class=\"keyword\">int</span> update)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> unsafe.compareAndSwapInt(node, waitStatusOffset, expect, update);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">compareAndSetNext</span><span class=\"params\">(Node node, Node expect, Node update)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> unsafe.compareAndSwapObject(node, nextOffset, expect, update);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后就是不断自旋调用CAS操作来保证操作成功了。</p>\n<p>ReentrantLock有公平锁和非公平锁两种实现，默认为非公平锁，体现在默认构造函数中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ReentrantLock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    sync = <span class=\"keyword\">new</span> NonfairSync();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ReentrantLock</span><span class=\"params\">(<span class=\"keyword\">boolean</span> fair)</span> </span>&#123;</span><br><span class=\"line\">    sync = fair ? <span class=\"keyword\">new</span> FairSync() : <span class=\"keyword\">new</span> NonfairSync();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取锁</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">lock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    sync.lock();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>FairSync继承自Sync，而Sync继承自AQS，ReentrantLocak获取锁的逻辑是直接调用了FairSync或者NonfairSync的逻辑。</p>\n<h4 id=\"获取锁\"><a href=\"#获取锁\" class=\"headerlink\" title=\"获取锁\"></a>获取锁</h4><p>看下ReentrantLock里的NonFairSync代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NonfairSync</span> <span class=\"keyword\">extends</span> <span class=\"title\">Sync</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = <span class=\"number\">7316153563782823691L</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Performs lock.  Try immediate barge, backing up to normal</span></span><br><span class=\"line\"><span class=\"comment\">     * acquire on failure.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">lock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (compareAndSetState(<span class=\"number\">0</span>, <span class=\"number\">1</span>))</span><br><span class=\"line\">            <span class=\"comment\">//这个方法下面贴出来了 其实就是把当前线程赋值给exclusiveOwnerThread</span></span><br><span class=\"line\">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            acquire(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryAcquire</span><span class=\"params\">(<span class=\"keyword\">int</span> acquires)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nonfairTryAcquire(acquires);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">setExclusiveOwnerThread</span><span class=\"params\">(Thread thread)</span> </span>&#123;</span><br><span class=\"line\">    exclusiveOwnerThread = thread;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到在执行lock()的时候，上来就先假设没有锁，先去通过CAS修改锁的状态，如果修改成功，将当前线程赋值给exclusiveOwnerThread，也就是表明当前线程持有了锁。否则就去尝试获取锁，进入acquire(1)。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">acquire</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class=\"line\">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class=\"line\">        selfInterrupt();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"acquire\"><a href=\"#acquire\" class=\"headerlink\" title=\"acquire\"></a>acquire</h4><p>acquire定义在AQS类中，描述了获取锁的流程。包含了四个方法调用：</p>\n<p><strong>1.tryAcquire(arg)</strong></p>\n<p>该方法由继承AQS的子类实现，为获取锁的具体逻辑。</p>\n<p><strong>2.addWaiter(Node mode)</strong></p>\n<p>该方法由AQS实现，负责在获取锁失败后调用，将当前请求锁的线程包装成Node扔到sync queue中去，并返回这个Node。</p>\n<p><strong>3.acquireQueued(final Node node,int arg)</strong></p>\n<p>该方法由AQS实现，主要对上面刚加入队列的Node不断尝试以下两种操作之一：</p>\n<ul>\n<li>在前驱节点就是head节点时，继续尝试获取锁</li>\n<li>将当前线程挂起，使CPU不再调度它</li>\n</ul>\n<p><strong>4.selfInterrupt</strong></p>\n<p>该方法由AQS实现，用于中断当前线程。由于在整个抢锁过程中，我们都是不响应中断的。那如果在抢锁过程中发生了中断怎么办呢，总不能假装没看见。AQS的做法就是简单的记录有没有发生过中断，如果返回的时候发现曾经发生过中断，则在退出acquire方法之前，就调用selfInterrupt自我中断一下，就好像将这个发生在抢锁过程中的中断“推迟”到抢锁结束以后再发生一样。</p>\n<p>从上面的介绍可以看出，除了获取锁的逻辑tryAcquire(arg)由子类实现之外，其余方法均由AQS实现。</p>\n<p>tryAcquire在ReentrantLock.Sync类中实现，根据调用链追踪下来，发现就是调用ReentrantLock.Sync中的nonfairTryAcquire()方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">nonfairTryAcquire</span><span class=\"params\">(<span class=\"keyword\">int</span> acquires)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Thread current = Thread.currentThread();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> c = getState();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (compareAndSetState(<span class=\"number\">0</span>, acquires)) &#123;</span><br><span class=\"line\">            setExclusiveOwnerThread(current);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> nextc = c + acquires;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nextc &lt; <span class=\"number\">0</span>) <span class=\"comment\">// overflow</span></span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(<span class=\"string\">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class=\"line\">        setState(nextc);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里可以看到，如果state==0继续CAS去改变state的值为1然后更新持有锁的线程。当当前线程与持有锁的线程是同一个线程时，将state和acquires相加，得到一共加了多少次锁，这个很关键，因为需要相同次解锁这个资源才可以被别的线程持有。否则，直接返回false。</p>\n<p>这里两个更新state的操作，一个用了CAS方法，一个用了普通的setState方法， 这是因为CAS操作的时候，线程还没获取到锁，所以可能存在多个线程同时在竞争锁的情况，而调用setState方法时，是在当前线程已经是持有锁的情况下，因此对state的修改是安全的，只需要调用普通的方法即可。</p>\n<p>acquire方法中还调用了acquireQueued()方法，还有addWaiter()方法。<code>Node.EXCLUSIVE</code>参数表明这是独占模式。</p>\n<h5 id=\"addWaiter\"><a href=\"#addWaiter\" class=\"headerlink\" title=\"addWaiter\"></a>addWaiter</h5><p>如果调用到此方法，说明前面尝试获取锁的tryAcquire已经失败了，既然获取锁失败，就要将当前线程包装成Node，加到等待队列中去，因为是FIFO队列，所以自然是直接加在队尾。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Node <span class=\"title\">addWaiter</span><span class=\"params\">(Node mode)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//这里看到独占锁模式下的节点，它的nextWaiter一定是null</span></span><br><span class=\"line\">    Node node = <span class=\"keyword\">new</span> Node(Thread.currentThread(), mode);</span><br><span class=\"line\">    <span class=\"comment\">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class=\"line\">    Node pred = tail;</span><br><span class=\"line\">    <span class=\"comment\">//当队列尾部不为空的时候 并且cas将队列尾部node更新为当前node 将node插入等待队列的尾部</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pred != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        node.prev = pred;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class=\"line\">            pred.next = node;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//代码执行到这里只会有两种情况</span></span><br><span class=\"line\">    <span class=\"comment\">//1.队列为空</span></span><br><span class=\"line\">    <span class=\"comment\">//2.CAS失败</span></span><br><span class=\"line\">    <span class=\"comment\">//并发条件下，什么都有可能发生，要注意CAS失败的话，也会走到这里来</span></span><br><span class=\"line\">    enq(node);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个方法中，我们会尝试直接入队，但是因为并发条件下，所以同一时刻可能有别的线程也在入队，导致我们compareAnsSetTail(pred,node)操作失败，因为可能其他线程已经成为了新的尾节点，导致尾节点已经不是我们看到的那个了pred了。</p>\n<p>如果入队失败，就需要调用enq(node)方法，在enq方法中，我们通过自旋加CAS来保证当前节点入队。</p>\n<h5 id=\"enq\"><a href=\"#enq\" class=\"headerlink\" title=\"enq\"></a>enq</h5><p>执行到这个方法，说明当前线程已经获取锁失败了，我们已经把它包装成了一个Node，准备把它放到等待队列中去。但是这一步又失败了，失败原因可能是一下两个之一：</p>\n<p>​    1.等待线程现在是空的，没有线程在等待</p>\n<p>​    2.其他线程在当前线程入队的过程中率先完成了入队，导致尾节点的值已经改变了，CAS操作失败。</p>\n<p>在这个方法中，通过自旋的方式，将当前节点插入队列，如果失败则不停尝试，直到成功为止。这个方法也负责在队列为空时，初始化队列，这也说明，队列时延迟初始化的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Node <span class=\"title\">enq</span><span class=\"params\">(<span class=\"keyword\">final</span> Node node)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        Node t = tail;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (t == <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// Must initialize</span></span><br><span class=\"line\">            <span class=\"comment\">//队列为空 进行初始化 也可以看出队列不是在构造的时候初始化的，而是延迟到需要用的时候再初始化</span></span><br><span class=\"line\">            <span class=\"comment\">//新建了一个dummy 节点</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (compareAndSetHead(<span class=\"keyword\">new</span> Node()))</span><br><span class=\"line\">                tail = head;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            node.prev = t;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class=\"line\">                t.next = node;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> t;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当队列为空，初始化队列并没有使用传进来的节点，而是<strong>新建了一个空节点</strong>，在新建完空节点之后，没有返回，而是将尾节点指向当前的头节点。在下一轮循环中，尾节点已经不为null了，此时再将包装好的当前线程的Node加到这个空节点后面。这也就意味着，在这个等待队列中，头节点是一个“哑节点”，不代表任何等待的线程。</p>\n<h5 id=\"尾分叉\"><a href=\"#尾分叉\" class=\"headerlink\" title=\"尾分叉\"></a>尾分叉</h5><p>在enq方法中有这么个逻辑。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    node.prev = t;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class=\"line\">        t.next = node;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> t;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>将一个节点添加到队列的末尾需要三步：</p>\n<p>​    1.设置node的前驱节点为当前的尾节点 node.prev = t</p>\n<p>​    2.修改tail的属性，使它指向当前节点</p>\n<p>​    3.修改原来的尾节点，使它的next指向当前节点</p>\n<p>但是需要注意，这三步并不是一个原子操作，第一步很容易成功，第二步由于是一个CAS操作，在并发条件下有可能失败，第三步在第二步成功的条件下才执行。这里的CAS保证同一时刻，只有一个节点能成为尾节点，其他节点将失败，失败后通过for循环不断重试。</p>\n<p>所以，当有大量的线程在同时入队的时候，同一时刻，只有一个线程能完整的完成这三步，而其他线程只能完成第一步。所以就会出现尾分叉。</p>\n<p><img src=\"https://vqianxiao.github.io/blog/images/aqs/tailfork.png\"></p>\n<p>这里第三步是在第二步成功执行之后才执行的，这就意味着，有可能即使完成了第二步，将新的节点设置成了尾节点，此时原来旧的尾节点的next值可能还是null（因为第三步还没来得及执行），所以如果此时有线程恰好从头节点开始向后遍历整个链表，则它是遍历不到新加进来的尾节点的，但是这样是不合理的，因为现在的tail已经指向了新的尾节点。</p>\n<p>另一方面，当我们完成第二步之后，第一步一定是完成了的，所以如果我们从尾节点向前遍历，已经可以遍历到所有的节点。这也是为什么AQS相关的源码中，常常会从尾节点开始逆向遍历链表。因为一个节点要能入队，则它的prev属性一定是有值的，但是它的next属性可能暂时还没有值。</p>\n<p>至于那些“分叉”的入队失败的其他节点，在下一轮的循环中，它们的prev属性会重新指向新的尾节点，继续尝试新的CAS操作，最终所有的节点都会通过自旋不断的尝试入队，直到成功为止。</p>\n<h5 id=\"acquireQueued\"><a href=\"#acquireQueued\" class=\"headerlink\" title=\"acquireQueued\"></a>acquireQueued</h5><p>再来看acquireQueued()，这个方法比较复杂，主要对上面刚加入队列的Node不断尝试2种操作：</p>\n<p>1.在前驱节点就是head节点的时候，继续尝试获取锁</p>\n<p>2.将当前线程挂起，让CPU不再调度它</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">acquireQueued</span><span class=\"params\">(<span class=\"keyword\">final</span> Node node, <span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> failed = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> interrupted = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> Node p = node.predecessor();</span><br><span class=\"line\">            <span class=\"comment\">//p == head 说明当前node已经是第一个节点了 所以再尝试获取一下锁 拿到锁，将node赋值给head 返回false</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class=\"line\">                setHead(node);</span><br><span class=\"line\">                p.next = <span class=\"keyword\">null</span>; <span class=\"comment\">// help GC</span></span><br><span class=\"line\">                failed = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> interrupted;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//shouldParkAfterFailedAcquire这个放回返回true 将会调用parkAndCheckInterrupt进入阻塞状态</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class=\"line\">                parkAndCheckInterrupt())</span><br><span class=\"line\">                interrupted = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (failed)</span><br><span class=\"line\">            cancelAcquire(node);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//获取前一个节点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> Node <span class=\"title\">predecessor</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> NullPointerException </span>&#123;</span><br><span class=\"line\">    Node p = prev;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">shouldParkAfterFailedAcquire</span><span class=\"params\">(Node pred, Node node)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//获取前置节点的waitStatus</span></span><br><span class=\"line\">    <span class=\"comment\">//CANCELLED 1 取消</span></span><br><span class=\"line\">    <span class=\"comment\">//SIGNAL -1 表明后续线程需要运行 indicate successor&#x27;s thread needs unparking</span></span><br><span class=\"line\">    <span class=\"comment\">//CONDITION -2 处于等待条件 indicate thread is waiting on condition</span></span><br><span class=\"line\">    <span class=\"comment\">//PROPAGATE -3 indicate the next acquireShared should unconditionally propagate</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> ws = pred.waitStatus;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ws == Node.SIGNAL)</span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">             * This node has already set status asking a release</span></span><br><span class=\"line\"><span class=\"comment\">             * to signal it, so it can safely park.</span></span><br><span class=\"line\"><span class=\"comment\">             */</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ws &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//前面的节点被取消 跳过已经取消等待锁的节点 往前找直到找到排队的节点</span></span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">             * Predecessor was cancelled. Skip over predecessors and</span></span><br><span class=\"line\"><span class=\"comment\">             * indicate retry.</span></span><br><span class=\"line\"><span class=\"comment\">             */</span></span><br><span class=\"line\">        <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">            node.prev = pred = pred.prev;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">while</span> (pred.waitStatus &gt; <span class=\"number\">0</span>);</span><br><span class=\"line\">        pred.next = node;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">             * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></span><br><span class=\"line\"><span class=\"comment\">             * need a signal, but don&#x27;t park yet.  Caller will need to</span></span><br><span class=\"line\"><span class=\"comment\">             * retry to make sure it cannot acquire before parking.</span></span><br><span class=\"line\"><span class=\"comment\">             */</span></span><br><span class=\"line\">        <span class=\"comment\">//waitStatus必须为0或者-3。表明我们需要一个信号，但是不要阻塞。调用者需要重试来确认暂停前无法获得锁</span></span><br><span class=\"line\">        <span class=\"comment\">//把前一个节点状态赋值成SIGNAL 让线程重试获取锁，避免不必要的阻塞</span></span><br><span class=\"line\">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//将线程挂起然后等待唤醒并返回当前线程是否被中断</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">parkAndCheckInterrupt</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    LockSupport.park(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Thread.interrupted();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里需要注意SIGNAL这个状态不是为线程自己设置的，是为前一个节点设置的。</p>\n<h4 id=\"获取锁总结\"><a href=\"#获取锁总结\" class=\"headerlink\" title=\"获取锁总结\"></a>获取锁总结</h4><p>1.先尝试CAS修改state，如果改成功，说明当前线程获取锁成功，然后将持有锁的线程更新成当前线程（exclusiveOwnerThread）。如果没有修改成功，调用acquire()</p>\n<p>2.在acquire()方法中，再次通过tryAcquire()获取锁，获取失败，会调用addWaiter方法，将当前等待的线程包装成Node，并成功添加到队列的末尾，这个操作由enq()方法来保证，enq()方法同时还负责在队列为空时初始化队列。</p>\n<p>3.acquireQueued方法用于Node成功入队后，继续尝试获取锁（取决于Node的前驱节点是不是head），或者将线程挂起。</p>\n<p>4.shouldParkAfterFailedAcquire方法用于保证当前线程的前驱节点的waitStatus属性值为SIGNAL，从而保证了自己挂起后，前驱节点会负责在合适的时候唤醒自己。</p>\n<p>5.parkAndCheckInterrupt方法用于挂起当前线程，并检查中断状态。</p>\n<p>6.如果最终成功获取了锁，线程会从lock()方法返回，继续往下执行，否则，线程会阻塞等待。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>锁从不同的维度去区分，可以分成很多中类别的锁。比如可以根据一个线程中的多个流程能不能获取同一把锁来区分可重入锁和不可重入锁，可以根据多个线程能不能共享同一把锁来区分共享锁和排他锁可以根据多个线程竞争锁时要不要排队来区分公平锁和非公平锁。可重入锁就是一个线程中多个流程能获取同一把锁，不可重入锁就是一个线程中多个流程不能获取同一把锁。共享锁就是多个线程能共享同一把锁，排他锁就是锁只能被一个线程持有的锁。多个线程竞争锁时要排队就是公平锁，先尝试插队插队失败再排队的就是非公平锁。</p>\n<p>我想学习ReentrantLock主要目的就是为了知道它是怎么支持可重入的吧。ReentrantLock类中有Sync对象，这个对象继承了AbstractQueuedSynchronizer，也就是AQS（队列同步器）。AQS为线程的同步和等待等操作提供一个基础模板类。虽然为抽象类，但是没有抽象方法，将需要子类重写的方法定义成protect方法，将默认实现为抛出<code>UnsupportedOperationException</code>异常，如果子类用到，没有重写，将会抛出异常，如果子类没用用到，则不需要做任何操作。尽可能多的实现可重入锁，读写锁同步器所有需要的功能。队列同步器内部实现了线程的同步队列，独占或是共享的获取方式等，使其只需要少量的代码便可以实现目标功能。</p>\n<p>一般来说，AQS的子类应以其他类的内部类的形式存在，然后使用代理模式调用子类和AQS本身的方法实现线程的同步。</p>\n<p>本文源码基于JDK1.8。</p>\n<p>java并发工具的设计套路，分为三个重要组成部分，分别是状态、队列、CAS。</p>\n<ul>\n<li>状态：一般是一个state属性，是整个工具的核心，通常整个工具都是在设置和修改状态，很多方法的操作都依赖于当前状态是什么，由于状态是全局共享的，一般会使用volatile修饰，保证其修改的可见性。</li>\n<li>队列：队列通常是一个等待的集合，大多数以链表形式实现。队列采用的是悲观锁思想，表示当前所等待的资源，状态或者条件短时间内可能无法满足。因此，它会将当前线程包装成某种数据结构，扔到一个等待队列中，当条件满足后，再从等待队列中取出。</li>\n<li>CAS：CAS操作是最轻量级的并发处理，通常对于状态的修改都会用到CAS操作，因为状态可能被多个线程同时修改，CAS操作保证了同一个时刻，只有一个线程能修改成功，从而保证了线程安全，CAS操作基本是由Unsafe工具类的<code>compareAndSwapXXX</code>来实现的。CAS采用的是乐观锁的思想，因此常常伴随着自旋，如果发现当前无法成功地执行CAS，则不断重试，直到成功为止，自旋的表现形式通常是一个死循环。</li>\n</ul>\n<h4 id=\"AQS核心实现\"><a href=\"#AQS核心实现\" class=\"headerlink\" title=\"AQS核心实现\"></a>AQS核心实现</h4><h5 id=\"状态\"><a href=\"#状态\" class=\"headerlink\" title=\"状态\"></a>状态</h5><p>在AQS中，状态是由state属性来表示的</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> state;</span><br></pre></td></tr></table></figure>\n\n<p>该属性值表示了锁的状态，state为0表示锁没有被占用，state大于0表示当前已经有线程持有该锁。这里说大于0，是因为可能有可重入的情况，那时候state就是持有该锁的线程数。</p>\n<p>独占锁的话，同一时刻，锁只能被一个线程持有。通过state变量是否为0，可以分辨当前锁是否被占用，但光知道锁是不是被占用是不够的，并不知道占用锁的线程是哪一个。在监视器锁中，我们用objectMonitor对象的_owner属性记录了当前拥有监视器锁的线程，而在AQS中，我们将通过exclusiveOwnerThread属性来记录占用锁的线程。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> Thread exclusiveOwnerThread;</span><br></pre></td></tr></table></figure>\n\n<p><code>exclusiveOwnerThread</code>属性的值就是当前持有锁的线程。</p>\n<h5 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h5><p>AQS中，队列的实现是一个双向链表，被称为<code>sync queue</code>，它表示所有等待锁的线程的集合，与synchronized中的wait set。</p>\n<p>并发编程在线程拿不到锁的时候，通常是把当前线程包装成某种类型的数据结构扔到等待队列中。我把重要的部分粘出来</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//节点所带表的线程</span></span><br><span class=\"line\">    <span class=\"keyword\">volatile</span> Thread thread;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//双向链表</span></span><br><span class=\"line\">    <span class=\"keyword\">volatile</span> Node prev;</span><br><span class=\"line\">    <span class=\"keyword\">volatile</span> Node next;</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"comment\">//线程所处的等待锁的状态，初始化时，该值为0</span></span><br><span class=\"line\">    <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> waitStatue;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> CANCELLED =  <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> SIGNAL    = -<span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> CONDITION = -<span class=\"number\">2</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> PROPAGATE = -<span class=\"number\">3</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//该属性用于条件队列或者共享锁</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>tips</strong> 在Node类中也有一个<code>waitStatus</code>，它表示了当前Node所代表的线程的等待锁的状态，在独占锁模式下，我们只需要关注<code>CANCELED</code>、<code>SIGNAL</code>两种状态即可。这里还有一个<code>nextWaiter</code>属性，它在独占锁模式下永远为null，仅仅起到一个标记作用，没有实际意义。</p>\n<p>AQS怎么去使用这个队列呢，既然是双向链表，那么肯定要有一个头节点和尾节点。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//头结点，不代表任何线程，只是一个哑节点</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> <span class=\"keyword\">volatile</span> Node head;</span><br><span class=\"line\"><span class=\"comment\">//尾节点，每一个请求锁的线程都会被加到尾节点</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> <span class=\"keyword\">volatile</span> Node tail;</span><br></pre></td></tr></table></figure>\n\n<p>在AQS中的队列是一个CLH队列，它的head节点永远是一个哑节点(dummy node)，它不代表任何线程（某些情况下可以看做是代表了当前持有锁的线程），<strong>因此head所指向的Node的thread属性永远是null</strong>。只有从次节点往后的所有节点才代表了所有等待锁的线程。也就是说，在当前线程没有抢到锁被包装成Node扔到队列中时，即使队列是空的，它也会排在第二个，我们会在它的前面新建一个dummy节点。为了便于描述，除去head节点的队列称作等待队列，这个队列中的节点代表等待锁的线程。</p>\n<p><img src=\"https://vqianxiao.github.io/blog/images/aqs/syncqueue.png\"></p>\n<p>结合图片，总结下Node节点各个属性的含义：</p>\n<ul>\n<li>thread：当前Node所代表的线程</li>\n<li>waitStatus：表示节点所处的等待状态，共享锁模式状态下只需关注三种状态：<code>SIGNAL</code>、<code>CANCELED</code>、<code>初始状态(0)</code></li>\n<li>prev next：节点的前驱和后继</li>\n<li>nextWaiter：仅作为标记，值为null表示当前处于独占锁模式</li>\n</ul>\n<h5 id=\"CAS\"><a href=\"#CAS\" class=\"headerlink\" title=\"CAS\"></a>CAS</h5><p>CAS操作大多数都是用来改变状态的，在AQS中也不例外。我们一般在静态代码块中初始化需要CAS操作的属性的偏移量。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> stateOffset;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> headOffset;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> tailOffset;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> waitStatusOffset;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> nextOffset;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        stateOffset = unsafe.objectFieldOffset</span><br><span class=\"line\">            (AbstractQueuedSynchronizer.class.getDeclaredField(<span class=\"string\">&quot;state&quot;</span>));</span><br><span class=\"line\">        headOffset = unsafe.objectFieldOffset</span><br><span class=\"line\">            (AbstractQueuedSynchronizer.class.getDeclaredField(<span class=\"string\">&quot;head&quot;</span>));</span><br><span class=\"line\">        tailOffset = unsafe.objectFieldOffset</span><br><span class=\"line\">            (AbstractQueuedSynchronizer.class.getDeclaredField(<span class=\"string\">&quot;tail&quot;</span>));</span><br><span class=\"line\">        waitStatusOffset = unsafe.objectFieldOffset</span><br><span class=\"line\">            (Node.class.getDeclaredField(<span class=\"string\">&quot;waitStatus&quot;</span>));</span><br><span class=\"line\">        nextOffset = unsafe.objectFieldOffset</span><br><span class=\"line\">            (Node.class.getDeclaredField(<span class=\"string\">&quot;next&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception ex) &#123; <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(ex); &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从静态代码块可以看出，CAS操作主要针对五个属性，包括AQS的3个属性state、head、tail和Node对象的两个属性waitStatus、next。说明这5个属性基本是会被多个线程同时访问的。</p>\n<p>看下实际CAS操作有哪些</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">compareAndSetState</span><span class=\"params\">(<span class=\"keyword\">int</span> expect, <span class=\"keyword\">int</span> update)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> unsafe.compareAndSwapInt(<span class=\"keyword\">this</span>, stateOffset, expect, update);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">compareAndSetHead</span><span class=\"params\">(Node update)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> unsafe.compareAndSwapObject(<span class=\"keyword\">this</span>, headOffset, <span class=\"keyword\">null</span>, update);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">compareAndSetTail</span><span class=\"params\">(Node expect, Node update)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> unsafe.compareAndSwapObject(<span class=\"keyword\">this</span>, tailOffset, expect, update);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">compareAndSetWaitStatus</span><span class=\"params\">(Node node, <span class=\"keyword\">int</span> expect,<span class=\"keyword\">int</span> update)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> unsafe.compareAndSwapInt(node, waitStatusOffset, expect, update);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">compareAndSetNext</span><span class=\"params\">(Node node, Node expect, Node update)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> unsafe.compareAndSwapObject(node, nextOffset, expect, update);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后就是不断自旋调用CAS操作来保证操作成功了。</p>\n<p>ReentrantLock有公平锁和非公平锁两种实现，默认为非公平锁，体现在默认构造函数中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ReentrantLock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    sync = <span class=\"keyword\">new</span> NonfairSync();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ReentrantLock</span><span class=\"params\">(<span class=\"keyword\">boolean</span> fair)</span> </span>&#123;</span><br><span class=\"line\">    sync = fair ? <span class=\"keyword\">new</span> FairSync() : <span class=\"keyword\">new</span> NonfairSync();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取锁</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">lock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    sync.lock();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>FairSync继承自Sync，而Sync继承自AQS，ReentrantLocak获取锁的逻辑是直接调用了FairSync或者NonfairSync的逻辑。</p>\n<h4 id=\"获取锁\"><a href=\"#获取锁\" class=\"headerlink\" title=\"获取锁\"></a>获取锁</h4><p>看下ReentrantLock里的NonFairSync代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NonfairSync</span> <span class=\"keyword\">extends</span> <span class=\"title\">Sync</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = <span class=\"number\">7316153563782823691L</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Performs lock.  Try immediate barge, backing up to normal</span></span><br><span class=\"line\"><span class=\"comment\">     * acquire on failure.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">lock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (compareAndSetState(<span class=\"number\">0</span>, <span class=\"number\">1</span>))</span><br><span class=\"line\">            <span class=\"comment\">//这个方法下面贴出来了 其实就是把当前线程赋值给exclusiveOwnerThread</span></span><br><span class=\"line\">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            acquire(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryAcquire</span><span class=\"params\">(<span class=\"keyword\">int</span> acquires)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nonfairTryAcquire(acquires);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">setExclusiveOwnerThread</span><span class=\"params\">(Thread thread)</span> </span>&#123;</span><br><span class=\"line\">    exclusiveOwnerThread = thread;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到在执行lock()的时候，上来就先假设没有锁，先去通过CAS修改锁的状态，如果修改成功，将当前线程赋值给exclusiveOwnerThread，也就是表明当前线程持有了锁。否则就去尝试获取锁，进入acquire(1)。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">acquire</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class=\"line\">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class=\"line\">        selfInterrupt();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"acquire\"><a href=\"#acquire\" class=\"headerlink\" title=\"acquire\"></a>acquire</h4><p>acquire定义在AQS类中，描述了获取锁的流程。包含了四个方法调用：</p>\n<p><strong>1.tryAcquire(arg)</strong></p>\n<p>该方法由继承AQS的子类实现，为获取锁的具体逻辑。</p>\n<p><strong>2.addWaiter(Node mode)</strong></p>\n<p>该方法由AQS实现，负责在获取锁失败后调用，将当前请求锁的线程包装成Node扔到sync queue中去，并返回这个Node。</p>\n<p><strong>3.acquireQueued(final Node node,int arg)</strong></p>\n<p>该方法由AQS实现，主要对上面刚加入队列的Node不断尝试以下两种操作之一：</p>\n<ul>\n<li>在前驱节点就是head节点时，继续尝试获取锁</li>\n<li>将当前线程挂起，使CPU不再调度它</li>\n</ul>\n<p><strong>4.selfInterrupt</strong></p>\n<p>该方法由AQS实现，用于中断当前线程。由于在整个抢锁过程中，我们都是不响应中断的。那如果在抢锁过程中发生了中断怎么办呢，总不能假装没看见。AQS的做法就是简单的记录有没有发生过中断，如果返回的时候发现曾经发生过中断，则在退出acquire方法之前，就调用selfInterrupt自我中断一下，就好像将这个发生在抢锁过程中的中断“推迟”到抢锁结束以后再发生一样。</p>\n<p>从上面的介绍可以看出，除了获取锁的逻辑tryAcquire(arg)由子类实现之外，其余方法均由AQS实现。</p>\n<p>tryAcquire在ReentrantLock.Sync类中实现，根据调用链追踪下来，发现就是调用ReentrantLock.Sync中的nonfairTryAcquire()方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">nonfairTryAcquire</span><span class=\"params\">(<span class=\"keyword\">int</span> acquires)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Thread current = Thread.currentThread();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> c = getState();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (compareAndSetState(<span class=\"number\">0</span>, acquires)) &#123;</span><br><span class=\"line\">            setExclusiveOwnerThread(current);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> nextc = c + acquires;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nextc &lt; <span class=\"number\">0</span>) <span class=\"comment\">// overflow</span></span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(<span class=\"string\">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class=\"line\">        setState(nextc);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里可以看到，如果state==0继续CAS去改变state的值为1然后更新持有锁的线程。当当前线程与持有锁的线程是同一个线程时，将state和acquires相加，得到一共加了多少次锁，这个很关键，因为需要相同次解锁这个资源才可以被别的线程持有。否则，直接返回false。</p>\n<p>这里两个更新state的操作，一个用了CAS方法，一个用了普通的setState方法， 这是因为CAS操作的时候，线程还没获取到锁，所以可能存在多个线程同时在竞争锁的情况，而调用setState方法时，是在当前线程已经是持有锁的情况下，因此对state的修改是安全的，只需要调用普通的方法即可。</p>\n<p>acquire方法中还调用了acquireQueued()方法，还有addWaiter()方法。<code>Node.EXCLUSIVE</code>参数表明这是独占模式。</p>\n<h5 id=\"addWaiter\"><a href=\"#addWaiter\" class=\"headerlink\" title=\"addWaiter\"></a>addWaiter</h5><p>如果调用到此方法，说明前面尝试获取锁的tryAcquire已经失败了，既然获取锁失败，就要将当前线程包装成Node，加到等待队列中去，因为是FIFO队列，所以自然是直接加在队尾。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Node <span class=\"title\">addWaiter</span><span class=\"params\">(Node mode)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//这里看到独占锁模式下的节点，它的nextWaiter一定是null</span></span><br><span class=\"line\">    Node node = <span class=\"keyword\">new</span> Node(Thread.currentThread(), mode);</span><br><span class=\"line\">    <span class=\"comment\">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class=\"line\">    Node pred = tail;</span><br><span class=\"line\">    <span class=\"comment\">//当队列尾部不为空的时候 并且cas将队列尾部node更新为当前node 将node插入等待队列的尾部</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pred != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        node.prev = pred;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class=\"line\">            pred.next = node;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//代码执行到这里只会有两种情况</span></span><br><span class=\"line\">    <span class=\"comment\">//1.队列为空</span></span><br><span class=\"line\">    <span class=\"comment\">//2.CAS失败</span></span><br><span class=\"line\">    <span class=\"comment\">//并发条件下，什么都有可能发生，要注意CAS失败的话，也会走到这里来</span></span><br><span class=\"line\">    enq(node);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个方法中，我们会尝试直接入队，但是因为并发条件下，所以同一时刻可能有别的线程也在入队，导致我们compareAnsSetTail(pred,node)操作失败，因为可能其他线程已经成为了新的尾节点，导致尾节点已经不是我们看到的那个了pred了。</p>\n<p>如果入队失败，就需要调用enq(node)方法，在enq方法中，我们通过自旋加CAS来保证当前节点入队。</p>\n<h5 id=\"enq\"><a href=\"#enq\" class=\"headerlink\" title=\"enq\"></a>enq</h5><p>执行到这个方法，说明当前线程已经获取锁失败了，我们已经把它包装成了一个Node，准备把它放到等待队列中去。但是这一步又失败了，失败原因可能是一下两个之一：</p>\n<p>​    1.等待线程现在是空的，没有线程在等待</p>\n<p>​    2.其他线程在当前线程入队的过程中率先完成了入队，导致尾节点的值已经改变了，CAS操作失败。</p>\n<p>在这个方法中，通过自旋的方式，将当前节点插入队列，如果失败则不停尝试，直到成功为止。这个方法也负责在队列为空时，初始化队列，这也说明，队列时延迟初始化的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Node <span class=\"title\">enq</span><span class=\"params\">(<span class=\"keyword\">final</span> Node node)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        Node t = tail;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (t == <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// Must initialize</span></span><br><span class=\"line\">            <span class=\"comment\">//队列为空 进行初始化 也可以看出队列不是在构造的时候初始化的，而是延迟到需要用的时候再初始化</span></span><br><span class=\"line\">            <span class=\"comment\">//新建了一个dummy 节点</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (compareAndSetHead(<span class=\"keyword\">new</span> Node()))</span><br><span class=\"line\">                tail = head;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            node.prev = t;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class=\"line\">                t.next = node;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> t;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当队列为空，初始化队列并没有使用传进来的节点，而是<strong>新建了一个空节点</strong>，在新建完空节点之后，没有返回，而是将尾节点指向当前的头节点。在下一轮循环中，尾节点已经不为null了，此时再将包装好的当前线程的Node加到这个空节点后面。这也就意味着，在这个等待队列中，头节点是一个“哑节点”，不代表任何等待的线程。</p>\n<h5 id=\"尾分叉\"><a href=\"#尾分叉\" class=\"headerlink\" title=\"尾分叉\"></a>尾分叉</h5><p>在enq方法中有这么个逻辑。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    node.prev = t;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class=\"line\">        t.next = node;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> t;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>将一个节点添加到队列的末尾需要三步：</p>\n<p>​    1.设置node的前驱节点为当前的尾节点 node.prev = t</p>\n<p>​    2.修改tail的属性，使它指向当前节点</p>\n<p>​    3.修改原来的尾节点，使它的next指向当前节点</p>\n<p>但是需要注意，这三步并不是一个原子操作，第一步很容易成功，第二步由于是一个CAS操作，在并发条件下有可能失败，第三步在第二步成功的条件下才执行。这里的CAS保证同一时刻，只有一个节点能成为尾节点，其他节点将失败，失败后通过for循环不断重试。</p>\n<p>所以，当有大量的线程在同时入队的时候，同一时刻，只有一个线程能完整的完成这三步，而其他线程只能完成第一步。所以就会出现尾分叉。</p>\n<p><img src=\"https://vqianxiao.github.io/blog/images/aqs/tailfork.png\"></p>\n<p>这里第三步是在第二步成功执行之后才执行的，这就意味着，有可能即使完成了第二步，将新的节点设置成了尾节点，此时原来旧的尾节点的next值可能还是null（因为第三步还没来得及执行），所以如果此时有线程恰好从头节点开始向后遍历整个链表，则它是遍历不到新加进来的尾节点的，但是这样是不合理的，因为现在的tail已经指向了新的尾节点。</p>\n<p>另一方面，当我们完成第二步之后，第一步一定是完成了的，所以如果我们从尾节点向前遍历，已经可以遍历到所有的节点。这也是为什么AQS相关的源码中，常常会从尾节点开始逆向遍历链表。因为一个节点要能入队，则它的prev属性一定是有值的，但是它的next属性可能暂时还没有值。</p>\n<p>至于那些“分叉”的入队失败的其他节点，在下一轮的循环中，它们的prev属性会重新指向新的尾节点，继续尝试新的CAS操作，最终所有的节点都会通过自旋不断的尝试入队，直到成功为止。</p>\n<h5 id=\"acquireQueued\"><a href=\"#acquireQueued\" class=\"headerlink\" title=\"acquireQueued\"></a>acquireQueued</h5><p>再来看acquireQueued()，这个方法比较复杂，主要对上面刚加入队列的Node不断尝试2种操作：</p>\n<p>1.在前驱节点就是head节点的时候，继续尝试获取锁</p>\n<p>2.将当前线程挂起，让CPU不再调度它</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">acquireQueued</span><span class=\"params\">(<span class=\"keyword\">final</span> Node node, <span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> failed = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> interrupted = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> Node p = node.predecessor();</span><br><span class=\"line\">            <span class=\"comment\">//p == head 说明当前node已经是第一个节点了 所以再尝试获取一下锁 拿到锁，将node赋值给head 返回false</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class=\"line\">                setHead(node);</span><br><span class=\"line\">                p.next = <span class=\"keyword\">null</span>; <span class=\"comment\">// help GC</span></span><br><span class=\"line\">                failed = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> interrupted;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//shouldParkAfterFailedAcquire这个放回返回true 将会调用parkAndCheckInterrupt进入阻塞状态</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class=\"line\">                parkAndCheckInterrupt())</span><br><span class=\"line\">                interrupted = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (failed)</span><br><span class=\"line\">            cancelAcquire(node);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//获取前一个节点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> Node <span class=\"title\">predecessor</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> NullPointerException </span>&#123;</span><br><span class=\"line\">    Node p = prev;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">shouldParkAfterFailedAcquire</span><span class=\"params\">(Node pred, Node node)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//获取前置节点的waitStatus</span></span><br><span class=\"line\">    <span class=\"comment\">//CANCELLED 1 取消</span></span><br><span class=\"line\">    <span class=\"comment\">//SIGNAL -1 表明后续线程需要运行 indicate successor&#x27;s thread needs unparking</span></span><br><span class=\"line\">    <span class=\"comment\">//CONDITION -2 处于等待条件 indicate thread is waiting on condition</span></span><br><span class=\"line\">    <span class=\"comment\">//PROPAGATE -3 indicate the next acquireShared should unconditionally propagate</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> ws = pred.waitStatus;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ws == Node.SIGNAL)</span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">             * This node has already set status asking a release</span></span><br><span class=\"line\"><span class=\"comment\">             * to signal it, so it can safely park.</span></span><br><span class=\"line\"><span class=\"comment\">             */</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ws &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//前面的节点被取消 跳过已经取消等待锁的节点 往前找直到找到排队的节点</span></span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">             * Predecessor was cancelled. Skip over predecessors and</span></span><br><span class=\"line\"><span class=\"comment\">             * indicate retry.</span></span><br><span class=\"line\"><span class=\"comment\">             */</span></span><br><span class=\"line\">        <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">            node.prev = pred = pred.prev;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">while</span> (pred.waitStatus &gt; <span class=\"number\">0</span>);</span><br><span class=\"line\">        pred.next = node;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">             * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></span><br><span class=\"line\"><span class=\"comment\">             * need a signal, but don&#x27;t park yet.  Caller will need to</span></span><br><span class=\"line\"><span class=\"comment\">             * retry to make sure it cannot acquire before parking.</span></span><br><span class=\"line\"><span class=\"comment\">             */</span></span><br><span class=\"line\">        <span class=\"comment\">//waitStatus必须为0或者-3。表明我们需要一个信号，但是不要阻塞。调用者需要重试来确认暂停前无法获得锁</span></span><br><span class=\"line\">        <span class=\"comment\">//把前一个节点状态赋值成SIGNAL 让线程重试获取锁，避免不必要的阻塞</span></span><br><span class=\"line\">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//将线程挂起然后等待唤醒并返回当前线程是否被中断</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">parkAndCheckInterrupt</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    LockSupport.park(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Thread.interrupted();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里需要注意SIGNAL这个状态不是为线程自己设置的，是为前一个节点设置的。</p>\n<h4 id=\"获取锁总结\"><a href=\"#获取锁总结\" class=\"headerlink\" title=\"获取锁总结\"></a>获取锁总结</h4><p>1.先尝试CAS修改state，如果改成功，说明当前线程获取锁成功，然后将持有锁的线程更新成当前线程（exclusiveOwnerThread）。如果没有修改成功，调用acquire()</p>\n<p>2.在acquire()方法中，再次通过tryAcquire()获取锁，获取失败，会调用addWaiter方法，将当前等待的线程包装成Node，并成功添加到队列的末尾，这个操作由enq()方法来保证，enq()方法同时还负责在队列为空时初始化队列。</p>\n<p>3.acquireQueued方法用于Node成功入队后，继续尝试获取锁（取决于Node的前驱节点是不是head），或者将线程挂起。</p>\n<p>4.shouldParkAfterFailedAcquire方法用于保证当前线程的前驱节点的waitStatus属性值为SIGNAL，从而保证了自己挂起后，前驱节点会负责在合适的时候唤醒自己。</p>\n<p>5.parkAndCheckInterrupt方法用于挂起当前线程，并检查中断状态。</p>\n<p>6.如果最终成功获取了锁，线程会从lock()方法返回，继续往下执行，否则，线程会阻塞等待。</p>\n"},{"layout":"post","title":"容器重启背后的思考","description":"docker容器重启背后的思考","date":"2022-04-14T03:27:10.000Z","_content":"前几天同事喊我说一个容器过一段时间就会重启，然后重启的原因是OOMKilled。第一反应是代码有问题，检查了下最近的提交，并没有发现可疑的代码。看了下jvm参数配置，发现并没有如下配置:\n```\n-XX:+HeapDumpOnOutOfMemoryError\n-XX:HeapDumpPath=/root/logs/java_heapdump.hprof\n```\n也没有办法证明是JVM发生OOM导致容器被重启。看了下Cat监控的GC情况，发现并没有出现GC以后，内存还在继续增长的情况，说明不太可能是因为JVM发生OOM导致的。然后加了上面的参数，等待复现。\n没多久就看到容器重启告警了，检查GC情况发现内存还是可以回收掉的，然后检查日志，日志中也没有出现OutOfMemoryError的错误，/root/logs目录下也并没有生成dump文件。那么问题明朗了，发生OOM的应该不是JVM。\n\n检查下JVM完整的启动参数，参数如下:\n```\n-javaagent:/root/org.jacoco.agent-5.9.9.jar=output=tcpserver,address=0.0.0.0,port=6300 \n## 堆内存最大大小\n-Xmx2g \n## 堆内存初始大小\n-Xms2g \n## 年轻代大小(eden+ 2 survivor)\n-Xmn1g \n## 元空间最大大小\n-XX:MaxMetaspaceSize=1g \n## 元空间大小\n-XX:MetaspaceSize=256m\n## 最大DirectMemory\n-XX:MaxDirectMemorySize=96m\n## 每个线程的栈大小\n-Xss256k\n## STW 工作线程数\n-XX:ParallelGCThreads=2 \n-DignoreCaptchaCheck=true \n-DmockLuckBag=true \n## 不省略异常(NullPointerException、ArithmeticException、ArrayIndexOutOfBoundsException、ArrayStoreException、ClassCastException)\n-XX:-OmitStackTraceInFastThrow \n## Does nothing. Provided for backward compatibility.\n-Xdebug \n## 远程调试参数\n-Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=1088\n```\n### 凶手是Docker？\nDocker的配置为2C 2G。会不会是Docker容器把我们的进程杀死了呢？因为我们设置堆的最大内存是2G，而整个Docker容器也仅仅只有2G的内存空间。对于Linux系统来说，一旦内核检测到没有足够的内存可以分配，就会扔出OOM，并开始杀死一些进程用于释放内存空间，但是糟糕的是任何进程都可能成为内核猎杀的对象，包括docker daemon和其它一些重要的进程。更危险的是如果某个支撑系统运行的重要进程被干掉了，整个系统也就宕掉了。如果大量的容器把主机的内存消耗殆尽，OOM被触发后系统内核立即开始杀进程释放内存。如果内核杀死的第一个进程就是docker daemon会怎么样？结果就是没办法管理运行中的容器，这是不可以接受的。\n\n针对这个问题，docker尝试通过调整docker daemon的OOM优先级来进行缓解。内核在选择要杀死的进程时会对所有的进程打分，直接杀死的分最高的进程，接着是下一个。当docker daemon的OOM优先级被降低后（注意容器进程的OOM优先级并没有被调整），docker daemon进程的得分不仅会低于容器进程的得分，还会低于其它一些进程的的分，这样docker daemon进程就安全多了。\n\n不过docker的官方文档中一直强调这只是一种缓解的方案，并且为我们提供了一些降低风险的建议：\n\n- 通过测试掌握应用对内存的需求\n- 保证运行容器的主机有充足的内存\n- 限制容器可以使用的内存\n- 为主机配置swap\n  \n其实说白了，就是通过限制容器使用的内存上限，来降低主机内存耗尽时带来的各种风险。\n\n### Docker相关知识\nDocker使用Google公司推出的Go语言进行开发实现，基于Linux内核的cgroup，namespace，以及OverlayFS类的Union FS等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术。\n\ncgroup，名称源自控制组群（control groups）的简写，是Linux内核的一个功能，用来限制、控制与分离一个进程组的资源（如CPU、内存、磁盘输入输出等）。cgroups的一个设计目标是为不同的应用情况提供统一的接口，从控制单一进程到操作系统层虚拟化。cgroups提供：\n\n- 资源限制：组可以被设置不超过设定的内存限制；也包括虚拟内存\n- 优先级：一些组可能会得到大量的CPU或磁盘IO吞吐量\n- 结算：用来度量系统实际用了多少资源\n- 控制：冻结组或检查点和重启动\n\n#### 更高效的利用系统资源\nDocker容器因为不需要硬件虚拟以及完整操作系统等额外开销，Docker对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。\n\n#### 更快速的启动时间\n传统的虚拟机技术启动应用服务往往需要数分钟，而Docker容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间，大大节约了时间。\n\n#### 一致的运行环境\n开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境不一致，导致有些bug并未在开发过程中被发现。而Docker的镜像提供了除内核外完整的运行时环境，确保了应用运行环境的一致。\n\n#### 持续交付和部署\n我们希望一次创建或者配置，可以在任意地方正常运行。使用Docker可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过Dockerfile来进行镜像构建，并结合持续集成系统进行集成测试，而运维人员可以直接在生产环境中快速部署该镜像，甚至结合持续部署系统进行自动化部署。\n\n使用Dockerfile使镜像构建透明化，不仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需条件，帮助更好的生产环境中部署该镜像。\n\n#### 更轻松的迁移\n由于Docker确保了执行环境的一致性，使得应用的迁移更加容易。Docker可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，运行结果都是一致的。用户可以很轻松的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。\n\n#### 更轻松的维护和扩展\nDocker使用的分层存储以及镜像的技术，使得应用重复部分的服用更为容易，也使得应用的维护更加更加简单，基于基础镜像进一步扩展镜像也变得非常简单。Docker团队同各个开源项目团队一起维护了一大批高质量的官方镜像，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。\n\n#### Docker容器对比虚拟机总结\n| 特性       | 容器               | 虚拟机     |\n| ---------- | ------------------ | ---------- |\n| 启动       | 秒级               | 分钟级     |\n| 硬盘使用   | 一般为MB           | 一般为GB   |\n| 性能       | 接近原生           | 弱于       |\n| 系统支持量 | 单机支持上千个容器 | 一般几十个 |\n\n#### JVM对资源的限制\n在不显式的指明一些参数的时候，JVM通常会读取一些数据作为默认值。那么JVM运行在Docker容器中，读取的内存，cpu数是用的物理机的还是Docker限制的cgroup的呢？\n\n#### CPU\n如果不显式的指定 *-XX:ParallelGCThreads* and *-XX:CICompilerCount*，那么JVM就会根据读到的CPU数目进行计算来设置数值。\n\n在计算Parallel GC的Threads数目的地方`runtime\\vm_version.cpp`  （基于1.8.0_121-b36）\n\n```c++\nif (FLAG_IS_DEFAULT(ParallelGCThreads)) {\n    assert(ParallelGCThreads == 0, \"Default ParallelGCThreads is not 0\");\n    // For very large machines, there are diminishing returns\n    // for large numbers of worker threads.  Instead of\n    // hogging the whole system, use a fraction of the workers for every\n    // processor after the first 8.  For example, on a 72 cpu machine\n    // and a chosen fraction of 5/8\n    // use 8 + (72 - 8) * (5/8) == 48 worker threads.\n    unsigned int ncpus = (unsigned int) os::initial_active_processor_count();\n    return (ncpus <= switch_pt) ?\n           ncpus :\n          (switch_pt + ((ncpus - switch_pt) * num) / den);\n  } else {\n    return ParallelGCThreads;\n  }\n```\n调用获取cpu数目的os::initial_active_processor_count()方法：\n```c++\nint os::active_processor_count() {\n  cpu_set_t cpus;  // can represent at most 1024 (CPU_SETSIZE) processors\n  int cpus_size = sizeof(cpu_set_t);\n  int cpu_count = 0;\n\n  // pid 0 means the current thread - which we have to assume represents the process\n  if (sched_getaffinity(0, cpus_size, &cpus) == 0) {\n    cpu_count = os_cpu_count(&cpus);\n    if (PrintActiveCpus) {\n      tty->print_cr(\"active_processor_count: sched_getaffinity processor count: %d\", cpu_count);\n    }\n  }\n  else {\n    cpu_count = ::sysconf(_SC_NPROCESSORS_ONLN);\n    warning(\"sched_getaffinity failed (%s)- using online processor count (%d) \"\n            \"which may exceed available processors\", strerror(errno), cpu_count);\n  }\n\n  assert(cpu_count > 0 && cpu_count <= processor_count(), \"sanity check\");\n  return cpu_count;\n}\n```\n\n可以看到上面的代码，其中有一个`sched_getaffinity()`获取cpu亲和力这个方法，这个方法看解释是获取进程的掩码写入到`cpu_set_t`中，进程的Cpu关联掩码决定了它有资格运行的Cpu集。成功返回0，错误返回-1或错误码。具体可以参考这个 https://linux.die.net/man/2/sched_getaffinity 。\n\n```c++\nstatic int os_cpu_count(const cpu_set_t* cpus) {\n  int count = 0;\n  // only look up to the number of configured processors\n  for (int i = 0; i < os::processor_count(); i++) {\n    if (CPU_ISSET(i, cpus)) {\n      count++;\n    }\n  }\n  return count;\n}\n```\n这里调用processor_count函数来获取所有的CPU核数。然后去检查是否在这个cpu是不是集合的成员，是成员则增加计数。\n\n_processor_count这个变量通过set_processor_count函数去赋值。\n\n```c++\nvoid os::Linux::initialize_system_info() {\n  set_processor_count(sysconf(_SC_NPROCESSORS_CONF));\n  if (processor_count() == 1) {\n    pid_t pid = os::Linux::gettid();\n    char fname[32];\n    jio_snprintf(fname, sizeof(fname), \"/proc/%d\", pid);\n    FILE *fp = fopen(fname, \"r\");\n    if (fp == NULL) {\n      unsafe_chroot_detected = true;\n    } else {\n      fclose(fp);\n    }\n  }\n  _physical_memory = (julong)sysconf(_SC_PHYS_PAGES) * (julong)sysconf(_SC_PAGESIZE);\n  assert(processor_count() > 0, \"linux error\");\n}\n```\n\n其实获取CPU核数都是通过调用系统sysconf函数来获取，只不过一个是`_SC_NPROCESSORS_CONF` 一个是 `_SC_NPROCESSORS_ONLN` 。\n\n**_SC_NPROCESSORS_CONF** ：返回系统所有的CPU核数，这个值也包括系统中禁止用户使用的CPU个数；\n\n**_SC_NPROCESSORS_ONLN**：返回系统中可用的CPU核数；\n\n#### 内存\n既然读取CPU会出错，那么内存应该也是一样的，在不显式的指定一些参数时如-Xmx(MaxHeapSize)、-Xms(InitialHeapSize)时，JVM会根据它读取到的机器的内存大小做一些默认的设置如：\n\n```c++\nvoid Arguments::set_heap_size() {\n  if (!FLAG_IS_DEFAULT(DefaultMaxRAMFraction)) {\n    // Deprecated flag\n    FLAG_SET_CMDLINE(uintx, MaxRAMFraction, DefaultMaxRAMFraction);\n  }\n  \n  julong phys_mem =\n    FLAG_IS_DEFAULT(MaxRAM) ? MIN2(os::physical_memory(), (julong)MaxRAM)\n                            : (julong)MaxRAM;\n  \n  // Experimental support for CGroup memory limits\n  if (UseCGroupMemoryLimitForHeap) {\n    // This is a rough indicator that a CGroup limit may be in force\n    // for this process\n    const char* lim_file = \"/sys/fs/cgroup/memory/memory.limit_in_bytes\";\n    FILE *fp = fopen(lim_file, \"r\");\n    if (fp != NULL) {\n      julong cgroup_max = 0;\n      int ret = fscanf(fp, JULONG_FORMAT, &cgroup_max);\n      if (ret == 1 && cgroup_max > 0) {\n        // If unlimited, cgroup_max will be a very large, but unspecified\n        // value, so use initial phys_mem as a limit\n        if (PrintGCDetails && Verbose) {\n          // Cannot use gclog_or_tty yet.\n          tty->print_cr(\"Setting phys_mem to the min of cgroup limit (\"\n                        JULONG_FORMAT \"MB) and initial phys_mem (\"\n                        JULONG_FORMAT \"MB)\", cgroup_max/M, phys_mem/M);\n        }\n        phys_mem = MIN2(cgroup_max, phys_mem);\n      } else {\n        warning(\"Unable to read/parse cgroup memory limit from %s: %s\",\n                lim_file, errno != 0 ? strerror(errno) : \"unknown error\");\n      }\n      fclose(fp);\n    } else {\n      warning(\"Unable to open cgroup memory limit file %s (%s)\", lim_file, strerror(errno));\n    }\n  }\n```\n意外发现竟然有对CGroup的支持，只不过是实验支持，可以使用-XX:+UseCGroupMemoryLimitForHeap开启这个支持，不过既然是实验支持可能还不太支持，最好还是手动指定一下比较稳妥。\n\n在 [JDK-8146115](\"https://bugs.openjdk.java.net/browse/JDK-8146115\") 中发现Docker的增强已经在JDK10中实现了，使用-XX:+UseContainerSupport可以开启容器支持，这一增强已经被Backports 到了JDK8的一些新版本中。\n\n最新版的os::active_processor_count()变成了：\n```c++\n// Determine the active processor count from one of\n// three different sources:\n//\n// 1. User option -XX:ActiveProcessorCount\n// 2. kernel os calls (sched_getaffinity or sysconf(_SC_NPROCESSORS_ONLN)\n// 3. extracted from cgroup cpu subsystem (shares and quotas)\n//\n// Option 1, if specified, will always override.\n// If the cgroup subsystem is active and configured, we\n// will return the min of the cgroup and option 2 results.\n// This is required since tools, such as numactl, that\n// alter cpu affinity do not update cgroup subsystem\n// cpuset configuration files.\nint os::active_processor_count() {\n  // User has overridden the number of active processors\n  if (ActiveProcessorCount > 0) {\n    if (PrintActiveCpus) {\n      tty->print_cr(\"active_processor_count: \"\n                    \"active processor count set by user : %d\",\n                    ActiveProcessorCount);\n    }\n    return ActiveProcessorCount;\n  }\n\n  int active_cpus;\n  if (OSContainer::is_containerized()) {\n    active_cpus = OSContainer::active_processor_count();\n    if (PrintActiveCpus) {\n      tty->print_cr(\"active_processor_count: determined by OSContainer: %d\",\n                     active_cpus);\n    }\n  } else {\n    active_cpus = os::Linux::active_processor_count();\n  }\n\n  return active_cpus;\n}\n```\n可以看到如果有-XX:ActiveProcessorCount参数则使用参数，如果没有就会去OSContainer::is_containerized()判断是否是容器，然后获取容器对资源的限制。\n\n```c++\ninline bool OSContainer::is_containerized() {\n  assert(_is_initialized, \"OSContainer not initialized\");\n  return _is_containerized;\n}\n```\n\n这里_is_containerized是由Threads::create_vm调用OSContainer::init()时检查虚拟机是否运行在容器中得来的。（osContainer_linux.hpp）\n\n```c++\n/* init\n *\n * Initialize the container support and determine if\n * we are running under cgroup control.\n */\nvoid OSContainer::init() {\n  FILE *mntinfo = NULL;\n  FILE *cgroup = NULL;\n  char buf[MAXPATHLEN+1];\n  char tmproot[MAXPATHLEN+1];\n  char tmpmount[MAXPATHLEN+1];\n  char *p;\n  jlong mem_limit;\n\n  assert(!_is_initialized, \"Initializing OSContainer more than once\");\n\n  _is_initialized = true;\n  _is_containerized = false;\n\n  _unlimited_memory = (LONG_MAX / os::vm_page_size()) * os::vm_page_size();\n\n  if (PrintContainerInfo) {\n    tty->print_cr(\"OSContainer::init: Initializing Container Support\");\n  }\n  if (!UseContainerSupport) {\n    if (PrintContainerInfo) {\n      tty->print_cr(\"Container Support not enabled\");\n    }\n    return;\n  }\n  \n  /*\n   * Find the cgroup mount point for memory and cpuset\n   * by reading /proc/self/mountinfo\n   *\n   * Example for docker:\n   * 219 214 0:29 /docker/7208cebd00fa5f2e342b1094f7bed87fa25661471a4637118e65f1c995be8a34 /sys/fs/cgroup/memory ro,nosuid,nodev,noexec,relatime - cgroup cgroup rw,memory\n   *\n   * Example for host:\n   * 34 28 0:29 / /sys/fs/cgroup/memory rw,nosuid,nodev,noexec,relatime shared:16 - cgroup cgroup rw,memory\n   */\n   mntinfo = fopen(\"/proc/self/mountinfo\", \"r\");\n  if (mntinfo == NULL) {\n      if (PrintContainerInfo) {\n        tty->print_cr(\"Can't open /proc/self/mountinfo, %s\",\n                       strerror(errno));\n      }\n      return;\n  }\n  ···\n    /*\n   * Read /proc/self/cgroup and map host mount point to\n   * local one via /proc/self/mountinfo content above\n   *\n   * Docker example:\n   * 5:memory:/docker/6558aed8fc662b194323ceab5b964f69cf36b3e8af877a14b80256e93aecb044\n   *\n   * Host example:\n   * 5:memory:/user.slice\n   *\n   * Construct a path to the process specific memory and cpuset\n   * cgroup directory.\n   *\n   * For a container running under Docker from memory example above\n   * the paths would be:\n   *\n   * /sys/fs/cgroup/memory\n   *\n   * For a Host from memory example above the path would be:\n   *\n   * /sys/fs/cgroup/memory/user.slice\n   *\n   */\n    cgroup = fopen(\"/proc/self/cgroup\", \"r\");\n  if (cgroup == NULL) {\n    if (PrintContainerInfo) {\n      tty->print_cr(\"Can't open /proc/self/cgroup, %s\",\n                     strerror(errno));\n      }\n    return;\n  }\n  ···\n  _is_containerized = true;\n}\n```\n可以看到这里初始化的时候会先判断-XX:+UseContainerSupport 是否开启，/proc/self/mountinfo 、/proc/self/cgroup 是否可读等，如果运行在容器中，那么就会调用OSContainer::active_processor_count获取容器限制的CPU数目（osContainer_linux.hpp）：\n\n```c++\n/* active_processor_count\n *\n * Calculate an appropriate number of active processors for the\n * VM to use based on these three inputs.\n *\n * cpu affinity\n * cgroup cpu quota & cpu period\n * cgroup cpu shares\n *\n * Algorithm:\n *\n * Determine the number of available CPUs from sched_getaffinity\n *\n * If user specified a quota (quota != -1), calculate the number of\n * required CPUs by dividing quota by period.\n *\n * If shares are in effect (shares != -1), calculate the number\n * of CPUs required for the shares by dividing the share value\n * by PER_CPU_SHARES.\n *\n * All results of division are rounded up to the next whole number.\n *\n * If neither shares or quotas have been specified, return the\n * number of active processors in the system.\n *\n * If both shares and quotas have been specified, the results are\n * based on the flag PreferContainerQuotaForCPUCount.  If true,\n * return the quota value.  If false return the smallest value\n * between shares or quotas.\n *\n * If shares and/or quotas have been specified, the resulting number\n * returned will never exceed the number of active processors.\n *\n * return:\n *    number of CPUs\n */\nint OSContainer::active_processor_count() {\n  int quota_count = 0, share_count = 0;\n  int cpu_count, limit_count;\n  int result;\n\n  // We use a cache with a timeout to avoid performing expensive\n  // computations in the event this function is called frequently.\n  // [See 8227006].\n  if (!cpu->cache_has_expired()) {\n    if (PrintContainerInfo) {\n      tty->print_cr(\"OSContainer::active_processor_count (cached): %d\", OSContainer::_active_processor_count);\n    }\n\n    return OSContainer::_active_processor_count;\n  }\n\n  cpu_count = limit_count = os::Linux::active_processor_count();\n  int quota  = cpu_quota();\n  int period = cpu_period();\n  int share  = cpu_shares();\n\n  if (quota > -1 && period > 0) {\n    quota_count = ceilf((float)quota / (float)period);\n    if (PrintContainerInfo) {\n      tty->print_cr(\"CPU Quota count based on quota/period: %d\", quota_count);\n    }\n  }\n  if (share > -1) {\n    share_count = ceilf((float)share / (float)PER_CPU_SHARES);\n    if (PrintContainerInfo) {\n      tty->print_cr(\"CPU Share count based on shares: %d\", share_count);\n    }\n  }\n\n  // If both shares and quotas are setup results depend\n  // on flag PreferContainerQuotaForCPUCount.\n  // If true, limit CPU count to quota\n  // If false, use minimum of shares and quotas\n  if (quota_count !=0 && share_count != 0) {\n    if (PreferContainerQuotaForCPUCount) {\n      limit_count = quota_count;\n    } else {\n      limit_count = MIN2(quota_count, share_count);\n    }\n  } else if (quota_count != 0) {\n    limit_count = quota_count;\n  } else if (share_count != 0) {\n    limit_count = share_count;\n  }\n\n  result = MIN2(cpu_count, limit_count);\n  if (PrintContainerInfo) {\n    tty->print_cr(\"OSContainer::active_processor_count: %d\", result);\n  }\n\n  // Update the value and reset the cache timeout\n  OSContainer::_active_processor_count = result;\n  cpu->set_cache_expiry_time(OSCONTAINER_CACHE_TIMEOUT);\n\n  return result;\n}\n```\n可以发现最终的结果和很多变量有关，如果同时设置了共享和配额，则设置结果取决于在首选容器QuotaForcpUCount标志上。\n\n如果为true，则将CPU计数限制为配额，如果为false，则使用最低份额和配额。Docker可以通过-cpu-period、-cpu-quato来进行相关参数的设置，具体可以参考 [Docker文档](https://docs.docker.com/config/containers/resource_constraints/#cpu) 。\n\n最终结果还会和物理机的cpu核数比较来获取较小的值。\n\n内存的获取并没有什么区别，思路基本上与获取cpu的一致。\n\n#### 总结\n使用JVM参数取来限制JVM使用容器的资源，可以更好的保护JVM的运行，不会因为超过容器的限制而被Kill掉，容器Kill掉超过限制的进程也是为了保护容器不会被操作系统Kill。\n\n\n\n","source":"_posts/容器重启背后的思考.md","raw":"---\nlayout:    post\ntitle:     容器重启背后的思考\ncategory:  问题排查\ndescription: docker容器重启背后的思考\ntags: 问题排查\ndate: 2022/04/14 11:27:10\n\n---\n前几天同事喊我说一个容器过一段时间就会重启，然后重启的原因是OOMKilled。第一反应是代码有问题，检查了下最近的提交，并没有发现可疑的代码。看了下jvm参数配置，发现并没有如下配置:\n```\n-XX:+HeapDumpOnOutOfMemoryError\n-XX:HeapDumpPath=/root/logs/java_heapdump.hprof\n```\n也没有办法证明是JVM发生OOM导致容器被重启。看了下Cat监控的GC情况，发现并没有出现GC以后，内存还在继续增长的情况，说明不太可能是因为JVM发生OOM导致的。然后加了上面的参数，等待复现。\n没多久就看到容器重启告警了，检查GC情况发现内存还是可以回收掉的，然后检查日志，日志中也没有出现OutOfMemoryError的错误，/root/logs目录下也并没有生成dump文件。那么问题明朗了，发生OOM的应该不是JVM。\n\n检查下JVM完整的启动参数，参数如下:\n```\n-javaagent:/root/org.jacoco.agent-5.9.9.jar=output=tcpserver,address=0.0.0.0,port=6300 \n## 堆内存最大大小\n-Xmx2g \n## 堆内存初始大小\n-Xms2g \n## 年轻代大小(eden+ 2 survivor)\n-Xmn1g \n## 元空间最大大小\n-XX:MaxMetaspaceSize=1g \n## 元空间大小\n-XX:MetaspaceSize=256m\n## 最大DirectMemory\n-XX:MaxDirectMemorySize=96m\n## 每个线程的栈大小\n-Xss256k\n## STW 工作线程数\n-XX:ParallelGCThreads=2 \n-DignoreCaptchaCheck=true \n-DmockLuckBag=true \n## 不省略异常(NullPointerException、ArithmeticException、ArrayIndexOutOfBoundsException、ArrayStoreException、ClassCastException)\n-XX:-OmitStackTraceInFastThrow \n## Does nothing. Provided for backward compatibility.\n-Xdebug \n## 远程调试参数\n-Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=1088\n```\n### 凶手是Docker？\nDocker的配置为2C 2G。会不会是Docker容器把我们的进程杀死了呢？因为我们设置堆的最大内存是2G，而整个Docker容器也仅仅只有2G的内存空间。对于Linux系统来说，一旦内核检测到没有足够的内存可以分配，就会扔出OOM，并开始杀死一些进程用于释放内存空间，但是糟糕的是任何进程都可能成为内核猎杀的对象，包括docker daemon和其它一些重要的进程。更危险的是如果某个支撑系统运行的重要进程被干掉了，整个系统也就宕掉了。如果大量的容器把主机的内存消耗殆尽，OOM被触发后系统内核立即开始杀进程释放内存。如果内核杀死的第一个进程就是docker daemon会怎么样？结果就是没办法管理运行中的容器，这是不可以接受的。\n\n针对这个问题，docker尝试通过调整docker daemon的OOM优先级来进行缓解。内核在选择要杀死的进程时会对所有的进程打分，直接杀死的分最高的进程，接着是下一个。当docker daemon的OOM优先级被降低后（注意容器进程的OOM优先级并没有被调整），docker daemon进程的得分不仅会低于容器进程的得分，还会低于其它一些进程的的分，这样docker daemon进程就安全多了。\n\n不过docker的官方文档中一直强调这只是一种缓解的方案，并且为我们提供了一些降低风险的建议：\n\n- 通过测试掌握应用对内存的需求\n- 保证运行容器的主机有充足的内存\n- 限制容器可以使用的内存\n- 为主机配置swap\n  \n其实说白了，就是通过限制容器使用的内存上限，来降低主机内存耗尽时带来的各种风险。\n\n### Docker相关知识\nDocker使用Google公司推出的Go语言进行开发实现，基于Linux内核的cgroup，namespace，以及OverlayFS类的Union FS等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术。\n\ncgroup，名称源自控制组群（control groups）的简写，是Linux内核的一个功能，用来限制、控制与分离一个进程组的资源（如CPU、内存、磁盘输入输出等）。cgroups的一个设计目标是为不同的应用情况提供统一的接口，从控制单一进程到操作系统层虚拟化。cgroups提供：\n\n- 资源限制：组可以被设置不超过设定的内存限制；也包括虚拟内存\n- 优先级：一些组可能会得到大量的CPU或磁盘IO吞吐量\n- 结算：用来度量系统实际用了多少资源\n- 控制：冻结组或检查点和重启动\n\n#### 更高效的利用系统资源\nDocker容器因为不需要硬件虚拟以及完整操作系统等额外开销，Docker对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。\n\n#### 更快速的启动时间\n传统的虚拟机技术启动应用服务往往需要数分钟，而Docker容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间，大大节约了时间。\n\n#### 一致的运行环境\n开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境不一致，导致有些bug并未在开发过程中被发现。而Docker的镜像提供了除内核外完整的运行时环境，确保了应用运行环境的一致。\n\n#### 持续交付和部署\n我们希望一次创建或者配置，可以在任意地方正常运行。使用Docker可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过Dockerfile来进行镜像构建，并结合持续集成系统进行集成测试，而运维人员可以直接在生产环境中快速部署该镜像，甚至结合持续部署系统进行自动化部署。\n\n使用Dockerfile使镜像构建透明化，不仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需条件，帮助更好的生产环境中部署该镜像。\n\n#### 更轻松的迁移\n由于Docker确保了执行环境的一致性，使得应用的迁移更加容易。Docker可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，运行结果都是一致的。用户可以很轻松的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。\n\n#### 更轻松的维护和扩展\nDocker使用的分层存储以及镜像的技术，使得应用重复部分的服用更为容易，也使得应用的维护更加更加简单，基于基础镜像进一步扩展镜像也变得非常简单。Docker团队同各个开源项目团队一起维护了一大批高质量的官方镜像，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。\n\n#### Docker容器对比虚拟机总结\n| 特性       | 容器               | 虚拟机     |\n| ---------- | ------------------ | ---------- |\n| 启动       | 秒级               | 分钟级     |\n| 硬盘使用   | 一般为MB           | 一般为GB   |\n| 性能       | 接近原生           | 弱于       |\n| 系统支持量 | 单机支持上千个容器 | 一般几十个 |\n\n#### JVM对资源的限制\n在不显式的指明一些参数的时候，JVM通常会读取一些数据作为默认值。那么JVM运行在Docker容器中，读取的内存，cpu数是用的物理机的还是Docker限制的cgroup的呢？\n\n#### CPU\n如果不显式的指定 *-XX:ParallelGCThreads* and *-XX:CICompilerCount*，那么JVM就会根据读到的CPU数目进行计算来设置数值。\n\n在计算Parallel GC的Threads数目的地方`runtime\\vm_version.cpp`  （基于1.8.0_121-b36）\n\n```c++\nif (FLAG_IS_DEFAULT(ParallelGCThreads)) {\n    assert(ParallelGCThreads == 0, \"Default ParallelGCThreads is not 0\");\n    // For very large machines, there are diminishing returns\n    // for large numbers of worker threads.  Instead of\n    // hogging the whole system, use a fraction of the workers for every\n    // processor after the first 8.  For example, on a 72 cpu machine\n    // and a chosen fraction of 5/8\n    // use 8 + (72 - 8) * (5/8) == 48 worker threads.\n    unsigned int ncpus = (unsigned int) os::initial_active_processor_count();\n    return (ncpus <= switch_pt) ?\n           ncpus :\n          (switch_pt + ((ncpus - switch_pt) * num) / den);\n  } else {\n    return ParallelGCThreads;\n  }\n```\n调用获取cpu数目的os::initial_active_processor_count()方法：\n```c++\nint os::active_processor_count() {\n  cpu_set_t cpus;  // can represent at most 1024 (CPU_SETSIZE) processors\n  int cpus_size = sizeof(cpu_set_t);\n  int cpu_count = 0;\n\n  // pid 0 means the current thread - which we have to assume represents the process\n  if (sched_getaffinity(0, cpus_size, &cpus) == 0) {\n    cpu_count = os_cpu_count(&cpus);\n    if (PrintActiveCpus) {\n      tty->print_cr(\"active_processor_count: sched_getaffinity processor count: %d\", cpu_count);\n    }\n  }\n  else {\n    cpu_count = ::sysconf(_SC_NPROCESSORS_ONLN);\n    warning(\"sched_getaffinity failed (%s)- using online processor count (%d) \"\n            \"which may exceed available processors\", strerror(errno), cpu_count);\n  }\n\n  assert(cpu_count > 0 && cpu_count <= processor_count(), \"sanity check\");\n  return cpu_count;\n}\n```\n\n可以看到上面的代码，其中有一个`sched_getaffinity()`获取cpu亲和力这个方法，这个方法看解释是获取进程的掩码写入到`cpu_set_t`中，进程的Cpu关联掩码决定了它有资格运行的Cpu集。成功返回0，错误返回-1或错误码。具体可以参考这个 https://linux.die.net/man/2/sched_getaffinity 。\n\n```c++\nstatic int os_cpu_count(const cpu_set_t* cpus) {\n  int count = 0;\n  // only look up to the number of configured processors\n  for (int i = 0; i < os::processor_count(); i++) {\n    if (CPU_ISSET(i, cpus)) {\n      count++;\n    }\n  }\n  return count;\n}\n```\n这里调用processor_count函数来获取所有的CPU核数。然后去检查是否在这个cpu是不是集合的成员，是成员则增加计数。\n\n_processor_count这个变量通过set_processor_count函数去赋值。\n\n```c++\nvoid os::Linux::initialize_system_info() {\n  set_processor_count(sysconf(_SC_NPROCESSORS_CONF));\n  if (processor_count() == 1) {\n    pid_t pid = os::Linux::gettid();\n    char fname[32];\n    jio_snprintf(fname, sizeof(fname), \"/proc/%d\", pid);\n    FILE *fp = fopen(fname, \"r\");\n    if (fp == NULL) {\n      unsafe_chroot_detected = true;\n    } else {\n      fclose(fp);\n    }\n  }\n  _physical_memory = (julong)sysconf(_SC_PHYS_PAGES) * (julong)sysconf(_SC_PAGESIZE);\n  assert(processor_count() > 0, \"linux error\");\n}\n```\n\n其实获取CPU核数都是通过调用系统sysconf函数来获取，只不过一个是`_SC_NPROCESSORS_CONF` 一个是 `_SC_NPROCESSORS_ONLN` 。\n\n**_SC_NPROCESSORS_CONF** ：返回系统所有的CPU核数，这个值也包括系统中禁止用户使用的CPU个数；\n\n**_SC_NPROCESSORS_ONLN**：返回系统中可用的CPU核数；\n\n#### 内存\n既然读取CPU会出错，那么内存应该也是一样的，在不显式的指定一些参数时如-Xmx(MaxHeapSize)、-Xms(InitialHeapSize)时，JVM会根据它读取到的机器的内存大小做一些默认的设置如：\n\n```c++\nvoid Arguments::set_heap_size() {\n  if (!FLAG_IS_DEFAULT(DefaultMaxRAMFraction)) {\n    // Deprecated flag\n    FLAG_SET_CMDLINE(uintx, MaxRAMFraction, DefaultMaxRAMFraction);\n  }\n  \n  julong phys_mem =\n    FLAG_IS_DEFAULT(MaxRAM) ? MIN2(os::physical_memory(), (julong)MaxRAM)\n                            : (julong)MaxRAM;\n  \n  // Experimental support for CGroup memory limits\n  if (UseCGroupMemoryLimitForHeap) {\n    // This is a rough indicator that a CGroup limit may be in force\n    // for this process\n    const char* lim_file = \"/sys/fs/cgroup/memory/memory.limit_in_bytes\";\n    FILE *fp = fopen(lim_file, \"r\");\n    if (fp != NULL) {\n      julong cgroup_max = 0;\n      int ret = fscanf(fp, JULONG_FORMAT, &cgroup_max);\n      if (ret == 1 && cgroup_max > 0) {\n        // If unlimited, cgroup_max will be a very large, but unspecified\n        // value, so use initial phys_mem as a limit\n        if (PrintGCDetails && Verbose) {\n          // Cannot use gclog_or_tty yet.\n          tty->print_cr(\"Setting phys_mem to the min of cgroup limit (\"\n                        JULONG_FORMAT \"MB) and initial phys_mem (\"\n                        JULONG_FORMAT \"MB)\", cgroup_max/M, phys_mem/M);\n        }\n        phys_mem = MIN2(cgroup_max, phys_mem);\n      } else {\n        warning(\"Unable to read/parse cgroup memory limit from %s: %s\",\n                lim_file, errno != 0 ? strerror(errno) : \"unknown error\");\n      }\n      fclose(fp);\n    } else {\n      warning(\"Unable to open cgroup memory limit file %s (%s)\", lim_file, strerror(errno));\n    }\n  }\n```\n意外发现竟然有对CGroup的支持，只不过是实验支持，可以使用-XX:+UseCGroupMemoryLimitForHeap开启这个支持，不过既然是实验支持可能还不太支持，最好还是手动指定一下比较稳妥。\n\n在 [JDK-8146115](\"https://bugs.openjdk.java.net/browse/JDK-8146115\") 中发现Docker的增强已经在JDK10中实现了，使用-XX:+UseContainerSupport可以开启容器支持，这一增强已经被Backports 到了JDK8的一些新版本中。\n\n最新版的os::active_processor_count()变成了：\n```c++\n// Determine the active processor count from one of\n// three different sources:\n//\n// 1. User option -XX:ActiveProcessorCount\n// 2. kernel os calls (sched_getaffinity or sysconf(_SC_NPROCESSORS_ONLN)\n// 3. extracted from cgroup cpu subsystem (shares and quotas)\n//\n// Option 1, if specified, will always override.\n// If the cgroup subsystem is active and configured, we\n// will return the min of the cgroup and option 2 results.\n// This is required since tools, such as numactl, that\n// alter cpu affinity do not update cgroup subsystem\n// cpuset configuration files.\nint os::active_processor_count() {\n  // User has overridden the number of active processors\n  if (ActiveProcessorCount > 0) {\n    if (PrintActiveCpus) {\n      tty->print_cr(\"active_processor_count: \"\n                    \"active processor count set by user : %d\",\n                    ActiveProcessorCount);\n    }\n    return ActiveProcessorCount;\n  }\n\n  int active_cpus;\n  if (OSContainer::is_containerized()) {\n    active_cpus = OSContainer::active_processor_count();\n    if (PrintActiveCpus) {\n      tty->print_cr(\"active_processor_count: determined by OSContainer: %d\",\n                     active_cpus);\n    }\n  } else {\n    active_cpus = os::Linux::active_processor_count();\n  }\n\n  return active_cpus;\n}\n```\n可以看到如果有-XX:ActiveProcessorCount参数则使用参数，如果没有就会去OSContainer::is_containerized()判断是否是容器，然后获取容器对资源的限制。\n\n```c++\ninline bool OSContainer::is_containerized() {\n  assert(_is_initialized, \"OSContainer not initialized\");\n  return _is_containerized;\n}\n```\n\n这里_is_containerized是由Threads::create_vm调用OSContainer::init()时检查虚拟机是否运行在容器中得来的。（osContainer_linux.hpp）\n\n```c++\n/* init\n *\n * Initialize the container support and determine if\n * we are running under cgroup control.\n */\nvoid OSContainer::init() {\n  FILE *mntinfo = NULL;\n  FILE *cgroup = NULL;\n  char buf[MAXPATHLEN+1];\n  char tmproot[MAXPATHLEN+1];\n  char tmpmount[MAXPATHLEN+1];\n  char *p;\n  jlong mem_limit;\n\n  assert(!_is_initialized, \"Initializing OSContainer more than once\");\n\n  _is_initialized = true;\n  _is_containerized = false;\n\n  _unlimited_memory = (LONG_MAX / os::vm_page_size()) * os::vm_page_size();\n\n  if (PrintContainerInfo) {\n    tty->print_cr(\"OSContainer::init: Initializing Container Support\");\n  }\n  if (!UseContainerSupport) {\n    if (PrintContainerInfo) {\n      tty->print_cr(\"Container Support not enabled\");\n    }\n    return;\n  }\n  \n  /*\n   * Find the cgroup mount point for memory and cpuset\n   * by reading /proc/self/mountinfo\n   *\n   * Example for docker:\n   * 219 214 0:29 /docker/7208cebd00fa5f2e342b1094f7bed87fa25661471a4637118e65f1c995be8a34 /sys/fs/cgroup/memory ro,nosuid,nodev,noexec,relatime - cgroup cgroup rw,memory\n   *\n   * Example for host:\n   * 34 28 0:29 / /sys/fs/cgroup/memory rw,nosuid,nodev,noexec,relatime shared:16 - cgroup cgroup rw,memory\n   */\n   mntinfo = fopen(\"/proc/self/mountinfo\", \"r\");\n  if (mntinfo == NULL) {\n      if (PrintContainerInfo) {\n        tty->print_cr(\"Can't open /proc/self/mountinfo, %s\",\n                       strerror(errno));\n      }\n      return;\n  }\n  ···\n    /*\n   * Read /proc/self/cgroup and map host mount point to\n   * local one via /proc/self/mountinfo content above\n   *\n   * Docker example:\n   * 5:memory:/docker/6558aed8fc662b194323ceab5b964f69cf36b3e8af877a14b80256e93aecb044\n   *\n   * Host example:\n   * 5:memory:/user.slice\n   *\n   * Construct a path to the process specific memory and cpuset\n   * cgroup directory.\n   *\n   * For a container running under Docker from memory example above\n   * the paths would be:\n   *\n   * /sys/fs/cgroup/memory\n   *\n   * For a Host from memory example above the path would be:\n   *\n   * /sys/fs/cgroup/memory/user.slice\n   *\n   */\n    cgroup = fopen(\"/proc/self/cgroup\", \"r\");\n  if (cgroup == NULL) {\n    if (PrintContainerInfo) {\n      tty->print_cr(\"Can't open /proc/self/cgroup, %s\",\n                     strerror(errno));\n      }\n    return;\n  }\n  ···\n  _is_containerized = true;\n}\n```\n可以看到这里初始化的时候会先判断-XX:+UseContainerSupport 是否开启，/proc/self/mountinfo 、/proc/self/cgroup 是否可读等，如果运行在容器中，那么就会调用OSContainer::active_processor_count获取容器限制的CPU数目（osContainer_linux.hpp）：\n\n```c++\n/* active_processor_count\n *\n * Calculate an appropriate number of active processors for the\n * VM to use based on these three inputs.\n *\n * cpu affinity\n * cgroup cpu quota & cpu period\n * cgroup cpu shares\n *\n * Algorithm:\n *\n * Determine the number of available CPUs from sched_getaffinity\n *\n * If user specified a quota (quota != -1), calculate the number of\n * required CPUs by dividing quota by period.\n *\n * If shares are in effect (shares != -1), calculate the number\n * of CPUs required for the shares by dividing the share value\n * by PER_CPU_SHARES.\n *\n * All results of division are rounded up to the next whole number.\n *\n * If neither shares or quotas have been specified, return the\n * number of active processors in the system.\n *\n * If both shares and quotas have been specified, the results are\n * based on the flag PreferContainerQuotaForCPUCount.  If true,\n * return the quota value.  If false return the smallest value\n * between shares or quotas.\n *\n * If shares and/or quotas have been specified, the resulting number\n * returned will never exceed the number of active processors.\n *\n * return:\n *    number of CPUs\n */\nint OSContainer::active_processor_count() {\n  int quota_count = 0, share_count = 0;\n  int cpu_count, limit_count;\n  int result;\n\n  // We use a cache with a timeout to avoid performing expensive\n  // computations in the event this function is called frequently.\n  // [See 8227006].\n  if (!cpu->cache_has_expired()) {\n    if (PrintContainerInfo) {\n      tty->print_cr(\"OSContainer::active_processor_count (cached): %d\", OSContainer::_active_processor_count);\n    }\n\n    return OSContainer::_active_processor_count;\n  }\n\n  cpu_count = limit_count = os::Linux::active_processor_count();\n  int quota  = cpu_quota();\n  int period = cpu_period();\n  int share  = cpu_shares();\n\n  if (quota > -1 && period > 0) {\n    quota_count = ceilf((float)quota / (float)period);\n    if (PrintContainerInfo) {\n      tty->print_cr(\"CPU Quota count based on quota/period: %d\", quota_count);\n    }\n  }\n  if (share > -1) {\n    share_count = ceilf((float)share / (float)PER_CPU_SHARES);\n    if (PrintContainerInfo) {\n      tty->print_cr(\"CPU Share count based on shares: %d\", share_count);\n    }\n  }\n\n  // If both shares and quotas are setup results depend\n  // on flag PreferContainerQuotaForCPUCount.\n  // If true, limit CPU count to quota\n  // If false, use minimum of shares and quotas\n  if (quota_count !=0 && share_count != 0) {\n    if (PreferContainerQuotaForCPUCount) {\n      limit_count = quota_count;\n    } else {\n      limit_count = MIN2(quota_count, share_count);\n    }\n  } else if (quota_count != 0) {\n    limit_count = quota_count;\n  } else if (share_count != 0) {\n    limit_count = share_count;\n  }\n\n  result = MIN2(cpu_count, limit_count);\n  if (PrintContainerInfo) {\n    tty->print_cr(\"OSContainer::active_processor_count: %d\", result);\n  }\n\n  // Update the value and reset the cache timeout\n  OSContainer::_active_processor_count = result;\n  cpu->set_cache_expiry_time(OSCONTAINER_CACHE_TIMEOUT);\n\n  return result;\n}\n```\n可以发现最终的结果和很多变量有关，如果同时设置了共享和配额，则设置结果取决于在首选容器QuotaForcpUCount标志上。\n\n如果为true，则将CPU计数限制为配额，如果为false，则使用最低份额和配额。Docker可以通过-cpu-period、-cpu-quato来进行相关参数的设置，具体可以参考 [Docker文档](https://docs.docker.com/config/containers/resource_constraints/#cpu) 。\n\n最终结果还会和物理机的cpu核数比较来获取较小的值。\n\n内存的获取并没有什么区别，思路基本上与获取cpu的一致。\n\n#### 总结\n使用JVM参数取来限制JVM使用容器的资源，可以更好的保护JVM的运行，不会因为超过容器的限制而被Kill掉，容器Kill掉超过限制的进程也是为了保护容器不会被操作系统Kill。\n\n\n\n","slug":"容器重启背后的思考","published":1,"updated":"2022-04-14T03:27:10.000Z","comments":1,"photos":[],"link":"","_id":"cm1m304y9003q31b470pi3tfy","content":"<p>前几天同事喊我说一个容器过一段时间就会重启，然后重启的原因是OOMKilled。第一反应是代码有问题，检查了下最近的提交，并没有发现可疑的代码。看了下jvm参数配置，发现并没有如下配置:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-XX:+HeapDumpOnOutOfMemoryError</span><br><span class=\"line\">-XX:HeapDumpPath=/root/logs/java_heapdump.hprof</span><br></pre></td></tr></table></figure>\n<p>也没有办法证明是JVM发生OOM导致容器被重启。看了下Cat监控的GC情况，发现并没有出现GC以后，内存还在继续增长的情况，说明不太可能是因为JVM发生OOM导致的。然后加了上面的参数，等待复现。<br>没多久就看到容器重启告警了，检查GC情况发现内存还是可以回收掉的，然后检查日志，日志中也没有出现OutOfMemoryError的错误，/root/logs目录下也并没有生成dump文件。那么问题明朗了，发生OOM的应该不是JVM。</p>\n<p>检查下JVM完整的启动参数，参数如下:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-javaagent:/root/org.jacoco.agent-5.9.9.jar=output=tcpserver,address=0.0.0.0,port=6300 </span><br><span class=\"line\">## 堆内存最大大小</span><br><span class=\"line\">-Xmx2g </span><br><span class=\"line\">## 堆内存初始大小</span><br><span class=\"line\">-Xms2g </span><br><span class=\"line\">## 年轻代大小(eden+ 2 survivor)</span><br><span class=\"line\">-Xmn1g </span><br><span class=\"line\">## 元空间最大大小</span><br><span class=\"line\">-XX:MaxMetaspaceSize=1g </span><br><span class=\"line\">## 元空间大小</span><br><span class=\"line\">-XX:MetaspaceSize=256m</span><br><span class=\"line\">## 最大DirectMemory</span><br><span class=\"line\">-XX:MaxDirectMemorySize=96m</span><br><span class=\"line\">## 每个线程的栈大小</span><br><span class=\"line\">-Xss256k</span><br><span class=\"line\">## STW 工作线程数</span><br><span class=\"line\">-XX:ParallelGCThreads=2 </span><br><span class=\"line\">-DignoreCaptchaCheck=true </span><br><span class=\"line\">-DmockLuckBag=true </span><br><span class=\"line\">## 不省略异常(NullPointerException、ArithmeticException、ArrayIndexOutOfBoundsException、ArrayStoreException、ClassCastException)</span><br><span class=\"line\">-XX:-OmitStackTraceInFastThrow </span><br><span class=\"line\">## Does nothing. Provided for backward compatibility.</span><br><span class=\"line\">-Xdebug </span><br><span class=\"line\">## 远程调试参数</span><br><span class=\"line\">-Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=1088</span><br></pre></td></tr></table></figure>\n<h3 id=\"凶手是Docker？\"><a href=\"#凶手是Docker？\" class=\"headerlink\" title=\"凶手是Docker？\"></a>凶手是Docker？</h3><p>Docker的配置为2C 2G。会不会是Docker容器把我们的进程杀死了呢？因为我们设置堆的最大内存是2G，而整个Docker容器也仅仅只有2G的内存空间。对于Linux系统来说，一旦内核检测到没有足够的内存可以分配，就会扔出OOM，并开始杀死一些进程用于释放内存空间，但是糟糕的是任何进程都可能成为内核猎杀的对象，包括docker daemon和其它一些重要的进程。更危险的是如果某个支撑系统运行的重要进程被干掉了，整个系统也就宕掉了。如果大量的容器把主机的内存消耗殆尽，OOM被触发后系统内核立即开始杀进程释放内存。如果内核杀死的第一个进程就是docker daemon会怎么样？结果就是没办法管理运行中的容器，这是不可以接受的。</p>\n<p>针对这个问题，docker尝试通过调整docker daemon的OOM优先级来进行缓解。内核在选择要杀死的进程时会对所有的进程打分，直接杀死的分最高的进程，接着是下一个。当docker daemon的OOM优先级被降低后（注意容器进程的OOM优先级并没有被调整），docker daemon进程的得分不仅会低于容器进程的得分，还会低于其它一些进程的的分，这样docker daemon进程就安全多了。</p>\n<p>不过docker的官方文档中一直强调这只是一种缓解的方案，并且为我们提供了一些降低风险的建议：</p>\n<ul>\n<li>通过测试掌握应用对内存的需求</li>\n<li>保证运行容器的主机有充足的内存</li>\n<li>限制容器可以使用的内存</li>\n<li>为主机配置swap</li>\n</ul>\n<p>其实说白了，就是通过限制容器使用的内存上限，来降低主机内存耗尽时带来的各种风险。</p>\n<h3 id=\"Docker相关知识\"><a href=\"#Docker相关知识\" class=\"headerlink\" title=\"Docker相关知识\"></a>Docker相关知识</h3><p>Docker使用Google公司推出的Go语言进行开发实现，基于Linux内核的cgroup，namespace，以及OverlayFS类的Union FS等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术。</p>\n<p>cgroup，名称源自控制组群（control groups）的简写，是Linux内核的一个功能，用来限制、控制与分离一个进程组的资源（如CPU、内存、磁盘输入输出等）。cgroups的一个设计目标是为不同的应用情况提供统一的接口，从控制单一进程到操作系统层虚拟化。cgroups提供：</p>\n<ul>\n<li>资源限制：组可以被设置不超过设定的内存限制；也包括虚拟内存</li>\n<li>优先级：一些组可能会得到大量的CPU或磁盘IO吞吐量</li>\n<li>结算：用来度量系统实际用了多少资源</li>\n<li>控制：冻结组或检查点和重启动</li>\n</ul>\n<h4 id=\"更高效的利用系统资源\"><a href=\"#更高效的利用系统资源\" class=\"headerlink\" title=\"更高效的利用系统资源\"></a>更高效的利用系统资源</h4><p>Docker容器因为不需要硬件虚拟以及完整操作系统等额外开销，Docker对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。</p>\n<h4 id=\"更快速的启动时间\"><a href=\"#更快速的启动时间\" class=\"headerlink\" title=\"更快速的启动时间\"></a>更快速的启动时间</h4><p>传统的虚拟机技术启动应用服务往往需要数分钟，而Docker容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间，大大节约了时间。</p>\n<h4 id=\"一致的运行环境\"><a href=\"#一致的运行环境\" class=\"headerlink\" title=\"一致的运行环境\"></a>一致的运行环境</h4><p>开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境不一致，导致有些bug并未在开发过程中被发现。而Docker的镜像提供了除内核外完整的运行时环境，确保了应用运行环境的一致。</p>\n<h4 id=\"持续交付和部署\"><a href=\"#持续交付和部署\" class=\"headerlink\" title=\"持续交付和部署\"></a>持续交付和部署</h4><p>我们希望一次创建或者配置，可以在任意地方正常运行。使用Docker可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过Dockerfile来进行镜像构建，并结合持续集成系统进行集成测试，而运维人员可以直接在生产环境中快速部署该镜像，甚至结合持续部署系统进行自动化部署。</p>\n<p>使用Dockerfile使镜像构建透明化，不仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需条件，帮助更好的生产环境中部署该镜像。</p>\n<h4 id=\"更轻松的迁移\"><a href=\"#更轻松的迁移\" class=\"headerlink\" title=\"更轻松的迁移\"></a>更轻松的迁移</h4><p>由于Docker确保了执行环境的一致性，使得应用的迁移更加容易。Docker可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，运行结果都是一致的。用户可以很轻松的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。</p>\n<h4 id=\"更轻松的维护和扩展\"><a href=\"#更轻松的维护和扩展\" class=\"headerlink\" title=\"更轻松的维护和扩展\"></a>更轻松的维护和扩展</h4><p>Docker使用的分层存储以及镜像的技术，使得应用重复部分的服用更为容易，也使得应用的维护更加更加简单，基于基础镜像进一步扩展镜像也变得非常简单。Docker团队同各个开源项目团队一起维护了一大批高质量的官方镜像，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。</p>\n<h4 id=\"Docker容器对比虚拟机总结\"><a href=\"#Docker容器对比虚拟机总结\" class=\"headerlink\" title=\"Docker容器对比虚拟机总结\"></a>Docker容器对比虚拟机总结</h4><table>\n<thead>\n<tr>\n<th>特性</th>\n<th>容器</th>\n<th>虚拟机</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>启动</td>\n<td>秒级</td>\n<td>分钟级</td>\n</tr>\n<tr>\n<td>硬盘使用</td>\n<td>一般为MB</td>\n<td>一般为GB</td>\n</tr>\n<tr>\n<td>性能</td>\n<td>接近原生</td>\n<td>弱于</td>\n</tr>\n<tr>\n<td>系统支持量</td>\n<td>单机支持上千个容器</td>\n<td>一般几十个</td>\n</tr>\n</tbody></table>\n<h4 id=\"JVM对资源的限制\"><a href=\"#JVM对资源的限制\" class=\"headerlink\" title=\"JVM对资源的限制\"></a>JVM对资源的限制</h4><p>在不显式的指明一些参数的时候，JVM通常会读取一些数据作为默认值。那么JVM运行在Docker容器中，读取的内存，cpu数是用的物理机的还是Docker限制的cgroup的呢？</p>\n<h4 id=\"CPU\"><a href=\"#CPU\" class=\"headerlink\" title=\"CPU\"></a>CPU</h4><p>如果不显式的指定 <em>-XX:ParallelGCThreads</em> and <em>-XX:CICompilerCount</em>，那么JVM就会根据读到的CPU数目进行计算来设置数值。</p>\n<p>在计算Parallel GC的Threads数目的地方<code>runtime\\vm_version.cpp</code>  （基于1.8.0_121-b36）</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"built_in\">FLAG_IS_DEFAULT</span>(ParallelGCThreads)) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(ParallelGCThreads == <span class=\"number\">0</span>, <span class=\"string\">&quot;Default ParallelGCThreads is not 0&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">// For very large machines, there are diminishing returns</span></span><br><span class=\"line\">    <span class=\"comment\">// for large numbers of worker threads.  Instead of</span></span><br><span class=\"line\">    <span class=\"comment\">// hogging the whole system, use a fraction of the workers for every</span></span><br><span class=\"line\">    <span class=\"comment\">// processor after the first 8.  For example, on a 72 cpu machine</span></span><br><span class=\"line\">    <span class=\"comment\">// and a chosen fraction of 5/8</span></span><br><span class=\"line\">    <span class=\"comment\">// use 8 + (72 - 8) * (5/8) == 48 worker threads.</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> ncpus = (<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>) os::<span class=\"built_in\">initial_active_processor_count</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (ncpus &lt;= switch_pt) ?</span><br><span class=\"line\">           ncpus :</span><br><span class=\"line\">          (switch_pt + ((ncpus - switch_pt) * num) / den);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ParallelGCThreads;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>调用获取cpu数目的os::initial_active_processor_count()方法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">os::active_processor_count</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">cpu_set_t</span> cpus;  <span class=\"comment\">// can represent at most 1024 (CPU_SETSIZE) processors</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> cpus_size = <span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(<span class=\"keyword\">cpu_set_t</span>);</span><br><span class=\"line\">  <span class=\"keyword\">int</span> cpu_count = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// pid 0 means the current thread - which we have to assume represents the process</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">sched_getaffinity</span>(<span class=\"number\">0</span>, cpus_size, &amp;cpus) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    cpu_count = <span class=\"built_in\">os_cpu_count</span>(&amp;cpus);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (PrintActiveCpus) &#123;</span><br><span class=\"line\">      tty-&gt;<span class=\"built_in\">print_cr</span>(<span class=\"string\">&quot;active_processor_count: sched_getaffinity processor count: %d&quot;</span>, cpu_count);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    cpu_count = ::<span class=\"built_in\">sysconf</span>(_SC_NPROCESSORS_ONLN);</span><br><span class=\"line\">    <span class=\"built_in\">warning</span>(<span class=\"string\">&quot;sched_getaffinity failed (%s)- using online processor count (%d) &quot;</span></span><br><span class=\"line\">            <span class=\"string\">&quot;which may exceed available processors&quot;</span>, <span class=\"built_in\">strerror</span>(errno), cpu_count);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">assert</span>(cpu_count &gt; <span class=\"number\">0</span> &amp;&amp; cpu_count &lt;= <span class=\"built_in\">processor_count</span>(), <span class=\"string\">&quot;sanity check&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> cpu_count;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到上面的代码，其中有一个<code>sched_getaffinity()</code>获取cpu亲和力这个方法，这个方法看解释是获取进程的掩码写入到<code>cpu_set_t</code>中，进程的Cpu关联掩码决定了它有资格运行的Cpu集。成功返回0，错误返回-1或错误码。具体可以参考这个 <a href=\"https://linux.die.net/man/2/sched_getaffinity\">https://linux.die.net/man/2/sched_getaffinity</a> 。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">os_cpu_count</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">cpu_set_t</span>* cpus)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"comment\">// only look up to the number of configured processors</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; os::<span class=\"built_in\">processor_count</span>(); i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">CPU_ISSET</span>(i, cpus)) &#123;</span><br><span class=\"line\">      count++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里调用processor_count函数来获取所有的CPU核数。然后去检查是否在这个cpu是不是集合的成员，是成员则增加计数。</p>\n<p>_processor_count这个变量通过set_processor_count函数去赋值。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> os::Linux::<span class=\"built_in\">initialize_system_info</span>() &#123;</span><br><span class=\"line\">  <span class=\"built_in\">set_processor_count</span>(<span class=\"built_in\">sysconf</span>(_SC_NPROCESSORS_CONF));</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">processor_count</span>() == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">pid_t</span> pid = os::Linux::<span class=\"built_in\">gettid</span>();</span><br><span class=\"line\">    <span class=\"keyword\">char</span> fname[<span class=\"number\">32</span>];</span><br><span class=\"line\">    <span class=\"built_in\">jio_snprintf</span>(fname, <span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(fname), <span class=\"string\">&quot;/proc/%d&quot;</span>, pid);</span><br><span class=\"line\">    FILE *fp = <span class=\"built_in\">fopen</span>(fname, <span class=\"string\">&quot;r&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fp == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">      unsafe_chroot_detected = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">fclose</span>(fp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  _physical_memory = (julong)<span class=\"built_in\">sysconf</span>(_SC_PHYS_PAGES) * (julong)<span class=\"built_in\">sysconf</span>(_SC_PAGESIZE);</span><br><span class=\"line\">  <span class=\"built_in\">assert</span>(<span class=\"built_in\">processor_count</span>() &gt; <span class=\"number\">0</span>, <span class=\"string\">&quot;linux error&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其实获取CPU核数都是通过调用系统sysconf函数来获取，只不过一个是<code>_SC_NPROCESSORS_CONF</code> 一个是 <code>_SC_NPROCESSORS_ONLN</code> 。</p>\n<p><strong>_SC_NPROCESSORS_CONF</strong> ：返回系统所有的CPU核数，这个值也包括系统中禁止用户使用的CPU个数；</p>\n<p><strong>_SC_NPROCESSORS_ONLN</strong>：返回系统中可用的CPU核数；</p>\n<h4 id=\"内存\"><a href=\"#内存\" class=\"headerlink\" title=\"内存\"></a>内存</h4><p>既然读取CPU会出错，那么内存应该也是一样的，在不显式的指定一些参数时如-Xmx(MaxHeapSize)、-Xms(InitialHeapSize)时，JVM会根据它读取到的机器的内存大小做一些默认的设置如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Arguments::set_heap_size</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!<span class=\"built_in\">FLAG_IS_DEFAULT</span>(DefaultMaxRAMFraction)) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Deprecated flag</span></span><br><span class=\"line\">    <span class=\"built_in\">FLAG_SET_CMDLINE</span>(uintx, MaxRAMFraction, DefaultMaxRAMFraction);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  julong phys_mem =</span><br><span class=\"line\">    <span class=\"built_in\">FLAG_IS_DEFAULT</span>(MaxRAM) ? <span class=\"built_in\">MIN2</span>(os::<span class=\"built_in\">physical_memory</span>(), (julong)MaxRAM)</span><br><span class=\"line\">                            : (julong)MaxRAM;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// Experimental support for CGroup memory limits</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (UseCGroupMemoryLimitForHeap) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// This is a rough indicator that a CGroup limit may be in force</span></span><br><span class=\"line\">    <span class=\"comment\">// for this process</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* lim_file = <span class=\"string\">&quot;/sys/fs/cgroup/memory/memory.limit_in_bytes&quot;</span>;</span><br><span class=\"line\">    FILE *fp = <span class=\"built_in\">fopen</span>(lim_file, <span class=\"string\">&quot;r&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fp != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">      julong cgroup_max = <span class=\"number\">0</span>;</span><br><span class=\"line\">      <span class=\"keyword\">int</span> ret = <span class=\"built_in\">fscanf</span>(fp, JULONG_FORMAT, &amp;cgroup_max);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (ret == <span class=\"number\">1</span> &amp;&amp; cgroup_max &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// If unlimited, cgroup_max will be a very large, but unspecified</span></span><br><span class=\"line\">        <span class=\"comment\">// value, so use initial phys_mem as a limit</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (PrintGCDetails &amp;&amp; Verbose) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// Cannot use gclog_or_tty yet.</span></span><br><span class=\"line\">          tty-&gt;<span class=\"built_in\">print_cr</span>(<span class=\"string\">&quot;Setting phys_mem to the min of cgroup limit (&quot;</span></span><br><span class=\"line\">                        JULONG_FORMAT <span class=\"string\">&quot;MB) and initial phys_mem (&quot;</span></span><br><span class=\"line\">                        JULONG_FORMAT <span class=\"string\">&quot;MB)&quot;</span>, cgroup_max/M, phys_mem/M);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        phys_mem = <span class=\"built_in\">MIN2</span>(cgroup_max, phys_mem);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">warning</span>(<span class=\"string\">&quot;Unable to read/parse cgroup memory limit from %s: %s&quot;</span>,</span><br><span class=\"line\">                lim_file, errno != <span class=\"number\">0</span> ? <span class=\"built_in\">strerror</span>(errno) : <span class=\"string\">&quot;unknown error&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"built_in\">fclose</span>(fp);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">warning</span>(<span class=\"string\">&quot;Unable to open cgroup memory limit file %s (%s)&quot;</span>, lim_file, <span class=\"built_in\">strerror</span>(errno));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>意外发现竟然有对CGroup的支持，只不过是实验支持，可以使用-XX:+UseCGroupMemoryLimitForHeap开启这个支持，不过既然是实验支持可能还不太支持，最好还是手动指定一下比较稳妥。</p>\n<p>在 <a href=\"%22https://bugs.openjdk.java.net/browse/JDK-8146115%22\">JDK-8146115</a> 中发现Docker的增强已经在JDK10中实现了，使用-XX:+UseContainerSupport可以开启容器支持，这一增强已经被Backports 到了JDK8的一些新版本中。</p>\n<p>最新版的os::active_processor_count()变成了：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Determine the active processor count from one of</span></span><br><span class=\"line\"><span class=\"comment\">// three different sources:</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// 1. User option -XX:ActiveProcessorCount</span></span><br><span class=\"line\"><span class=\"comment\">// 2. kernel os calls (sched_getaffinity or sysconf(_SC_NPROCESSORS_ONLN)</span></span><br><span class=\"line\"><span class=\"comment\">// 3. extracted from cgroup cpu subsystem (shares and quotas)</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// Option 1, if specified, will always override.</span></span><br><span class=\"line\"><span class=\"comment\">// If the cgroup subsystem is active and configured, we</span></span><br><span class=\"line\"><span class=\"comment\">// will return the min of the cgroup and option 2 results.</span></span><br><span class=\"line\"><span class=\"comment\">// This is required since tools, such as numactl, that</span></span><br><span class=\"line\"><span class=\"comment\">// alter cpu affinity do not update cgroup subsystem</span></span><br><span class=\"line\"><span class=\"comment\">// cpuset configuration files.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">os::active_processor_count</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// User has overridden the number of active processors</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (ActiveProcessorCount &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (PrintActiveCpus) &#123;</span><br><span class=\"line\">      tty-&gt;<span class=\"built_in\">print_cr</span>(<span class=\"string\">&quot;active_processor_count: &quot;</span></span><br><span class=\"line\">                    <span class=\"string\">&quot;active processor count set by user : %d&quot;</span>,</span><br><span class=\"line\">                    ActiveProcessorCount);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ActiveProcessorCount;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">int</span> active_cpus;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (OSContainer::<span class=\"built_in\">is_containerized</span>()) &#123;</span><br><span class=\"line\">    active_cpus = OSContainer::<span class=\"built_in\">active_processor_count</span>();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (PrintActiveCpus) &#123;</span><br><span class=\"line\">      tty-&gt;<span class=\"built_in\">print_cr</span>(<span class=\"string\">&quot;active_processor_count: determined by OSContainer: %d&quot;</span>,</span><br><span class=\"line\">                     active_cpus);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    active_cpus = os::Linux::<span class=\"built_in\">active_processor_count</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> active_cpus;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到如果有-XX:ActiveProcessorCount参数则使用参数，如果没有就会去OSContainer::is_containerized()判断是否是容器，然后获取容器对资源的限制。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">bool</span> <span class=\"title\">OSContainer::is_containerized</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">assert</span>(_is_initialized, <span class=\"string\">&quot;OSContainer not initialized&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> _is_containerized;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里_is_containerized是由Threads::create_vm调用OSContainer::init()时检查虚拟机是否运行在容器中得来的。（osContainer_linux.hpp）</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* init</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Initialize the container support and determine if</span></span><br><span class=\"line\"><span class=\"comment\"> * we are running under cgroup control.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">OSContainer::init</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  FILE *mntinfo = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">  FILE *cgroup = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">  <span class=\"keyword\">char</span> buf[MAXPATHLEN+<span class=\"number\">1</span>];</span><br><span class=\"line\">  <span class=\"keyword\">char</span> tmproot[MAXPATHLEN+<span class=\"number\">1</span>];</span><br><span class=\"line\">  <span class=\"keyword\">char</span> tmpmount[MAXPATHLEN+<span class=\"number\">1</span>];</span><br><span class=\"line\">  <span class=\"keyword\">char</span> *p;</span><br><span class=\"line\">  jlong mem_limit;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">assert</span>(!_is_initialized, <span class=\"string\">&quot;Initializing OSContainer more than once&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  _is_initialized = <span class=\"literal\">true</span>;</span><br><span class=\"line\">  _is_containerized = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  _unlimited_memory = (LONG_MAX / os::<span class=\"built_in\">vm_page_size</span>()) * os::<span class=\"built_in\">vm_page_size</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (PrintContainerInfo) &#123;</span><br><span class=\"line\">    tty-&gt;<span class=\"built_in\">print_cr</span>(<span class=\"string\">&quot;OSContainer::init: Initializing Container Support&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!UseContainerSupport) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (PrintContainerInfo) &#123;</span><br><span class=\"line\">      tty-&gt;<span class=\"built_in\">print_cr</span>(<span class=\"string\">&quot;Container Support not enabled&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">   * Find the cgroup mount point for memory and cpuset</span></span><br><span class=\"line\"><span class=\"comment\">   * by reading /proc/self/mountinfo</span></span><br><span class=\"line\"><span class=\"comment\">   *</span></span><br><span class=\"line\"><span class=\"comment\">   * Example for docker:</span></span><br><span class=\"line\"><span class=\"comment\">   * 219 214 0:29 /docker/7208cebd00fa5f2e342b1094f7bed87fa25661471a4637118e65f1c995be8a34 /sys/fs/cgroup/memory ro,nosuid,nodev,noexec,relatime - cgroup cgroup rw,memory</span></span><br><span class=\"line\"><span class=\"comment\">   *</span></span><br><span class=\"line\"><span class=\"comment\">   * Example for host:</span></span><br><span class=\"line\"><span class=\"comment\">   * 34 28 0:29 / /sys/fs/cgroup/memory rw,nosuid,nodev,noexec,relatime shared:16 - cgroup cgroup rw,memory</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">   mntinfo = <span class=\"built_in\">fopen</span>(<span class=\"string\">&quot;/proc/self/mountinfo&quot;</span>, <span class=\"string\">&quot;r&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (mntinfo == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (PrintContainerInfo) &#123;</span><br><span class=\"line\">        tty-&gt;<span class=\"built_in\">print_cr</span>(<span class=\"string\">&quot;Can&#x27;t open /proc/self/mountinfo, %s&quot;</span>,</span><br><span class=\"line\">                       <span class=\"built_in\">strerror</span>(errno));</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ···</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">   * Read /proc/self/cgroup and map host mount point to</span></span><br><span class=\"line\"><span class=\"comment\">   * local one via /proc/self/mountinfo content above</span></span><br><span class=\"line\"><span class=\"comment\">   *</span></span><br><span class=\"line\"><span class=\"comment\">   * Docker example:</span></span><br><span class=\"line\"><span class=\"comment\">   * 5:memory:/docker/6558aed8fc662b194323ceab5b964f69cf36b3e8af877a14b80256e93aecb044</span></span><br><span class=\"line\"><span class=\"comment\">   *</span></span><br><span class=\"line\"><span class=\"comment\">   * Host example:</span></span><br><span class=\"line\"><span class=\"comment\">   * 5:memory:/user.slice</span></span><br><span class=\"line\"><span class=\"comment\">   *</span></span><br><span class=\"line\"><span class=\"comment\">   * Construct a path to the process specific memory and cpuset</span></span><br><span class=\"line\"><span class=\"comment\">   * cgroup directory.</span></span><br><span class=\"line\"><span class=\"comment\">   *</span></span><br><span class=\"line\"><span class=\"comment\">   * For a container running under Docker from memory example above</span></span><br><span class=\"line\"><span class=\"comment\">   * the paths would be:</span></span><br><span class=\"line\"><span class=\"comment\">   *</span></span><br><span class=\"line\"><span class=\"comment\">   * /sys/fs/cgroup/memory</span></span><br><span class=\"line\"><span class=\"comment\">   *</span></span><br><span class=\"line\"><span class=\"comment\">   * For a Host from memory example above the path would be:</span></span><br><span class=\"line\"><span class=\"comment\">   *</span></span><br><span class=\"line\"><span class=\"comment\">   * /sys/fs/cgroup/memory/user.slice</span></span><br><span class=\"line\"><span class=\"comment\">   *</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">    cgroup = <span class=\"built_in\">fopen</span>(<span class=\"string\">&quot;/proc/self/cgroup&quot;</span>, <span class=\"string\">&quot;r&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (cgroup == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (PrintContainerInfo) &#123;</span><br><span class=\"line\">      tty-&gt;<span class=\"built_in\">print_cr</span>(<span class=\"string\">&quot;Can&#x27;t open /proc/self/cgroup, %s&quot;</span>,</span><br><span class=\"line\">                     <span class=\"built_in\">strerror</span>(errno));</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ···</span><br><span class=\"line\">  _is_containerized = <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到这里初始化的时候会先判断-XX:+UseContainerSupport 是否开启，/proc/self/mountinfo 、/proc/self/cgroup 是否可读等，如果运行在容器中，那么就会调用OSContainer::active_processor_count获取容器限制的CPU数目（osContainer_linux.hpp）：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* active_processor_count</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Calculate an appropriate number of active processors for the</span></span><br><span class=\"line\"><span class=\"comment\"> * VM to use based on these three inputs.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * cpu affinity</span></span><br><span class=\"line\"><span class=\"comment\"> * cgroup cpu quota &amp; cpu period</span></span><br><span class=\"line\"><span class=\"comment\"> * cgroup cpu shares</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Algorithm:</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Determine the number of available CPUs from sched_getaffinity</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * If user specified a quota (quota != -1), calculate the number of</span></span><br><span class=\"line\"><span class=\"comment\"> * required CPUs by dividing quota by period.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * If shares are in effect (shares != -1), calculate the number</span></span><br><span class=\"line\"><span class=\"comment\"> * of CPUs required for the shares by dividing the share value</span></span><br><span class=\"line\"><span class=\"comment\"> * by PER_CPU_SHARES.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * All results of division are rounded up to the next whole number.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * If neither shares or quotas have been specified, return the</span></span><br><span class=\"line\"><span class=\"comment\"> * number of active processors in the system.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * If both shares and quotas have been specified, the results are</span></span><br><span class=\"line\"><span class=\"comment\"> * based on the flag PreferContainerQuotaForCPUCount.  If true,</span></span><br><span class=\"line\"><span class=\"comment\"> * return the quota value.  If false return the smallest value</span></span><br><span class=\"line\"><span class=\"comment\"> * between shares or quotas.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * If shares and/or quotas have been specified, the resulting number</span></span><br><span class=\"line\"><span class=\"comment\"> * returned will never exceed the number of active processors.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * return:</span></span><br><span class=\"line\"><span class=\"comment\"> *    number of CPUs</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">OSContainer::active_processor_count</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> quota_count = <span class=\"number\">0</span>, share_count = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> cpu_count, limit_count;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> result;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// We use a cache with a timeout to avoid performing expensive</span></span><br><span class=\"line\">  <span class=\"comment\">// computations in the event this function is called frequently.</span></span><br><span class=\"line\">  <span class=\"comment\">// [See 8227006].</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!cpu-&gt;<span class=\"built_in\">cache_has_expired</span>()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (PrintContainerInfo) &#123;</span><br><span class=\"line\">      tty-&gt;<span class=\"built_in\">print_cr</span>(<span class=\"string\">&quot;OSContainer::active_processor_count (cached): %d&quot;</span>, OSContainer::_active_processor_count);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> OSContainer::_active_processor_count;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  cpu_count = limit_count = os::Linux::<span class=\"built_in\">active_processor_count</span>();</span><br><span class=\"line\">  <span class=\"keyword\">int</span> quota  = <span class=\"built_in\">cpu_quota</span>();</span><br><span class=\"line\">  <span class=\"keyword\">int</span> period = <span class=\"built_in\">cpu_period</span>();</span><br><span class=\"line\">  <span class=\"keyword\">int</span> share  = <span class=\"built_in\">cpu_shares</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (quota &gt; <span class=\"number\">-1</span> &amp;&amp; period &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    quota_count = <span class=\"built_in\">ceilf</span>((<span class=\"keyword\">float</span>)quota / (<span class=\"keyword\">float</span>)period);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (PrintContainerInfo) &#123;</span><br><span class=\"line\">      tty-&gt;<span class=\"built_in\">print_cr</span>(<span class=\"string\">&quot;CPU Quota count based on quota/period: %d&quot;</span>, quota_count);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (share &gt; <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">    share_count = <span class=\"built_in\">ceilf</span>((<span class=\"keyword\">float</span>)share / (<span class=\"keyword\">float</span>)PER_CPU_SHARES);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (PrintContainerInfo) &#123;</span><br><span class=\"line\">      tty-&gt;<span class=\"built_in\">print_cr</span>(<span class=\"string\">&quot;CPU Share count based on shares: %d&quot;</span>, share_count);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// If both shares and quotas are setup results depend</span></span><br><span class=\"line\">  <span class=\"comment\">// on flag PreferContainerQuotaForCPUCount.</span></span><br><span class=\"line\">  <span class=\"comment\">// If true, limit CPU count to quota</span></span><br><span class=\"line\">  <span class=\"comment\">// If false, use minimum of shares and quotas</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (quota_count !=<span class=\"number\">0</span> &amp;&amp; share_count != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (PreferContainerQuotaForCPUCount) &#123;</span><br><span class=\"line\">      limit_count = quota_count;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      limit_count = <span class=\"built_in\">MIN2</span>(quota_count, share_count);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (quota_count != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    limit_count = quota_count;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (share_count != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    limit_count = share_count;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  result = <span class=\"built_in\">MIN2</span>(cpu_count, limit_count);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (PrintContainerInfo) &#123;</span><br><span class=\"line\">    tty-&gt;<span class=\"built_in\">print_cr</span>(<span class=\"string\">&quot;OSContainer::active_processor_count: %d&quot;</span>, result);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Update the value and reset the cache timeout</span></span><br><span class=\"line\">  OSContainer::_active_processor_count = result;</span><br><span class=\"line\">  cpu-&gt;<span class=\"built_in\">set_cache_expiry_time</span>(OSCONTAINER_CACHE_TIMEOUT);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以发现最终的结果和很多变量有关，如果同时设置了共享和配额，则设置结果取决于在首选容器QuotaForcpUCount标志上。</p>\n<p>如果为true，则将CPU计数限制为配额，如果为false，则使用最低份额和配额。Docker可以通过-cpu-period、-cpu-quato来进行相关参数的设置，具体可以参考 <a href=\"https://docs.docker.com/config/containers/resource_constraints/#cpu\">Docker文档</a> 。</p>\n<p>最终结果还会和物理机的cpu核数比较来获取较小的值。</p>\n<p>内存的获取并没有什么区别，思路基本上与获取cpu的一致。</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>使用JVM参数取来限制JVM使用容器的资源，可以更好的保护JVM的运行，不会因为超过容器的限制而被Kill掉，容器Kill掉超过限制的进程也是为了保护容器不会被操作系统Kill。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>前几天同事喊我说一个容器过一段时间就会重启，然后重启的原因是OOMKilled。第一反应是代码有问题，检查了下最近的提交，并没有发现可疑的代码。看了下jvm参数配置，发现并没有如下配置:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-XX:+HeapDumpOnOutOfMemoryError</span><br><span class=\"line\">-XX:HeapDumpPath=/root/logs/java_heapdump.hprof</span><br></pre></td></tr></table></figure>\n<p>也没有办法证明是JVM发生OOM导致容器被重启。看了下Cat监控的GC情况，发现并没有出现GC以后，内存还在继续增长的情况，说明不太可能是因为JVM发生OOM导致的。然后加了上面的参数，等待复现。<br>没多久就看到容器重启告警了，检查GC情况发现内存还是可以回收掉的，然后检查日志，日志中也没有出现OutOfMemoryError的错误，/root/logs目录下也并没有生成dump文件。那么问题明朗了，发生OOM的应该不是JVM。</p>\n<p>检查下JVM完整的启动参数，参数如下:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-javaagent:/root/org.jacoco.agent-5.9.9.jar=output=tcpserver,address=0.0.0.0,port=6300 </span><br><span class=\"line\">## 堆内存最大大小</span><br><span class=\"line\">-Xmx2g </span><br><span class=\"line\">## 堆内存初始大小</span><br><span class=\"line\">-Xms2g </span><br><span class=\"line\">## 年轻代大小(eden+ 2 survivor)</span><br><span class=\"line\">-Xmn1g </span><br><span class=\"line\">## 元空间最大大小</span><br><span class=\"line\">-XX:MaxMetaspaceSize=1g </span><br><span class=\"line\">## 元空间大小</span><br><span class=\"line\">-XX:MetaspaceSize=256m</span><br><span class=\"line\">## 最大DirectMemory</span><br><span class=\"line\">-XX:MaxDirectMemorySize=96m</span><br><span class=\"line\">## 每个线程的栈大小</span><br><span class=\"line\">-Xss256k</span><br><span class=\"line\">## STW 工作线程数</span><br><span class=\"line\">-XX:ParallelGCThreads=2 </span><br><span class=\"line\">-DignoreCaptchaCheck=true </span><br><span class=\"line\">-DmockLuckBag=true </span><br><span class=\"line\">## 不省略异常(NullPointerException、ArithmeticException、ArrayIndexOutOfBoundsException、ArrayStoreException、ClassCastException)</span><br><span class=\"line\">-XX:-OmitStackTraceInFastThrow </span><br><span class=\"line\">## Does nothing. Provided for backward compatibility.</span><br><span class=\"line\">-Xdebug </span><br><span class=\"line\">## 远程调试参数</span><br><span class=\"line\">-Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=1088</span><br></pre></td></tr></table></figure>\n<h3 id=\"凶手是Docker？\"><a href=\"#凶手是Docker？\" class=\"headerlink\" title=\"凶手是Docker？\"></a>凶手是Docker？</h3><p>Docker的配置为2C 2G。会不会是Docker容器把我们的进程杀死了呢？因为我们设置堆的最大内存是2G，而整个Docker容器也仅仅只有2G的内存空间。对于Linux系统来说，一旦内核检测到没有足够的内存可以分配，就会扔出OOM，并开始杀死一些进程用于释放内存空间，但是糟糕的是任何进程都可能成为内核猎杀的对象，包括docker daemon和其它一些重要的进程。更危险的是如果某个支撑系统运行的重要进程被干掉了，整个系统也就宕掉了。如果大量的容器把主机的内存消耗殆尽，OOM被触发后系统内核立即开始杀进程释放内存。如果内核杀死的第一个进程就是docker daemon会怎么样？结果就是没办法管理运行中的容器，这是不可以接受的。</p>\n<p>针对这个问题，docker尝试通过调整docker daemon的OOM优先级来进行缓解。内核在选择要杀死的进程时会对所有的进程打分，直接杀死的分最高的进程，接着是下一个。当docker daemon的OOM优先级被降低后（注意容器进程的OOM优先级并没有被调整），docker daemon进程的得分不仅会低于容器进程的得分，还会低于其它一些进程的的分，这样docker daemon进程就安全多了。</p>\n<p>不过docker的官方文档中一直强调这只是一种缓解的方案，并且为我们提供了一些降低风险的建议：</p>\n<ul>\n<li>通过测试掌握应用对内存的需求</li>\n<li>保证运行容器的主机有充足的内存</li>\n<li>限制容器可以使用的内存</li>\n<li>为主机配置swap</li>\n</ul>\n<p>其实说白了，就是通过限制容器使用的内存上限，来降低主机内存耗尽时带来的各种风险。</p>\n<h3 id=\"Docker相关知识\"><a href=\"#Docker相关知识\" class=\"headerlink\" title=\"Docker相关知识\"></a>Docker相关知识</h3><p>Docker使用Google公司推出的Go语言进行开发实现，基于Linux内核的cgroup，namespace，以及OverlayFS类的Union FS等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术。</p>\n<p>cgroup，名称源自控制组群（control groups）的简写，是Linux内核的一个功能，用来限制、控制与分离一个进程组的资源（如CPU、内存、磁盘输入输出等）。cgroups的一个设计目标是为不同的应用情况提供统一的接口，从控制单一进程到操作系统层虚拟化。cgroups提供：</p>\n<ul>\n<li>资源限制：组可以被设置不超过设定的内存限制；也包括虚拟内存</li>\n<li>优先级：一些组可能会得到大量的CPU或磁盘IO吞吐量</li>\n<li>结算：用来度量系统实际用了多少资源</li>\n<li>控制：冻结组或检查点和重启动</li>\n</ul>\n<h4 id=\"更高效的利用系统资源\"><a href=\"#更高效的利用系统资源\" class=\"headerlink\" title=\"更高效的利用系统资源\"></a>更高效的利用系统资源</h4><p>Docker容器因为不需要硬件虚拟以及完整操作系统等额外开销，Docker对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。</p>\n<h4 id=\"更快速的启动时间\"><a href=\"#更快速的启动时间\" class=\"headerlink\" title=\"更快速的启动时间\"></a>更快速的启动时间</h4><p>传统的虚拟机技术启动应用服务往往需要数分钟，而Docker容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间，大大节约了时间。</p>\n<h4 id=\"一致的运行环境\"><a href=\"#一致的运行环境\" class=\"headerlink\" title=\"一致的运行环境\"></a>一致的运行环境</h4><p>开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境不一致，导致有些bug并未在开发过程中被发现。而Docker的镜像提供了除内核外完整的运行时环境，确保了应用运行环境的一致。</p>\n<h4 id=\"持续交付和部署\"><a href=\"#持续交付和部署\" class=\"headerlink\" title=\"持续交付和部署\"></a>持续交付和部署</h4><p>我们希望一次创建或者配置，可以在任意地方正常运行。使用Docker可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过Dockerfile来进行镜像构建，并结合持续集成系统进行集成测试，而运维人员可以直接在生产环境中快速部署该镜像，甚至结合持续部署系统进行自动化部署。</p>\n<p>使用Dockerfile使镜像构建透明化，不仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需条件，帮助更好的生产环境中部署该镜像。</p>\n<h4 id=\"更轻松的迁移\"><a href=\"#更轻松的迁移\" class=\"headerlink\" title=\"更轻松的迁移\"></a>更轻松的迁移</h4><p>由于Docker确保了执行环境的一致性，使得应用的迁移更加容易。Docker可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，运行结果都是一致的。用户可以很轻松的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。</p>\n<h4 id=\"更轻松的维护和扩展\"><a href=\"#更轻松的维护和扩展\" class=\"headerlink\" title=\"更轻松的维护和扩展\"></a>更轻松的维护和扩展</h4><p>Docker使用的分层存储以及镜像的技术，使得应用重复部分的服用更为容易，也使得应用的维护更加更加简单，基于基础镜像进一步扩展镜像也变得非常简单。Docker团队同各个开源项目团队一起维护了一大批高质量的官方镜像，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。</p>\n<h4 id=\"Docker容器对比虚拟机总结\"><a href=\"#Docker容器对比虚拟机总结\" class=\"headerlink\" title=\"Docker容器对比虚拟机总结\"></a>Docker容器对比虚拟机总结</h4><table>\n<thead>\n<tr>\n<th>特性</th>\n<th>容器</th>\n<th>虚拟机</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>启动</td>\n<td>秒级</td>\n<td>分钟级</td>\n</tr>\n<tr>\n<td>硬盘使用</td>\n<td>一般为MB</td>\n<td>一般为GB</td>\n</tr>\n<tr>\n<td>性能</td>\n<td>接近原生</td>\n<td>弱于</td>\n</tr>\n<tr>\n<td>系统支持量</td>\n<td>单机支持上千个容器</td>\n<td>一般几十个</td>\n</tr>\n</tbody></table>\n<h4 id=\"JVM对资源的限制\"><a href=\"#JVM对资源的限制\" class=\"headerlink\" title=\"JVM对资源的限制\"></a>JVM对资源的限制</h4><p>在不显式的指明一些参数的时候，JVM通常会读取一些数据作为默认值。那么JVM运行在Docker容器中，读取的内存，cpu数是用的物理机的还是Docker限制的cgroup的呢？</p>\n<h4 id=\"CPU\"><a href=\"#CPU\" class=\"headerlink\" title=\"CPU\"></a>CPU</h4><p>如果不显式的指定 <em>-XX:ParallelGCThreads</em> and <em>-XX:CICompilerCount</em>，那么JVM就会根据读到的CPU数目进行计算来设置数值。</p>\n<p>在计算Parallel GC的Threads数目的地方<code>runtime\\vm_version.cpp</code>  （基于1.8.0_121-b36）</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"built_in\">FLAG_IS_DEFAULT</span>(ParallelGCThreads)) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(ParallelGCThreads == <span class=\"number\">0</span>, <span class=\"string\">&quot;Default ParallelGCThreads is not 0&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">// For very large machines, there are diminishing returns</span></span><br><span class=\"line\">    <span class=\"comment\">// for large numbers of worker threads.  Instead of</span></span><br><span class=\"line\">    <span class=\"comment\">// hogging the whole system, use a fraction of the workers for every</span></span><br><span class=\"line\">    <span class=\"comment\">// processor after the first 8.  For example, on a 72 cpu machine</span></span><br><span class=\"line\">    <span class=\"comment\">// and a chosen fraction of 5/8</span></span><br><span class=\"line\">    <span class=\"comment\">// use 8 + (72 - 8) * (5/8) == 48 worker threads.</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> ncpus = (<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>) os::<span class=\"built_in\">initial_active_processor_count</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (ncpus &lt;= switch_pt) ?</span><br><span class=\"line\">           ncpus :</span><br><span class=\"line\">          (switch_pt + ((ncpus - switch_pt) * num) / den);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ParallelGCThreads;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>调用获取cpu数目的os::initial_active_processor_count()方法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">os::active_processor_count</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">cpu_set_t</span> cpus;  <span class=\"comment\">// can represent at most 1024 (CPU_SETSIZE) processors</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> cpus_size = <span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(<span class=\"keyword\">cpu_set_t</span>);</span><br><span class=\"line\">  <span class=\"keyword\">int</span> cpu_count = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// pid 0 means the current thread - which we have to assume represents the process</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">sched_getaffinity</span>(<span class=\"number\">0</span>, cpus_size, &amp;cpus) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    cpu_count = <span class=\"built_in\">os_cpu_count</span>(&amp;cpus);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (PrintActiveCpus) &#123;</span><br><span class=\"line\">      tty-&gt;<span class=\"built_in\">print_cr</span>(<span class=\"string\">&quot;active_processor_count: sched_getaffinity processor count: %d&quot;</span>, cpu_count);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    cpu_count = ::<span class=\"built_in\">sysconf</span>(_SC_NPROCESSORS_ONLN);</span><br><span class=\"line\">    <span class=\"built_in\">warning</span>(<span class=\"string\">&quot;sched_getaffinity failed (%s)- using online processor count (%d) &quot;</span></span><br><span class=\"line\">            <span class=\"string\">&quot;which may exceed available processors&quot;</span>, <span class=\"built_in\">strerror</span>(errno), cpu_count);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">assert</span>(cpu_count &gt; <span class=\"number\">0</span> &amp;&amp; cpu_count &lt;= <span class=\"built_in\">processor_count</span>(), <span class=\"string\">&quot;sanity check&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> cpu_count;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到上面的代码，其中有一个<code>sched_getaffinity()</code>获取cpu亲和力这个方法，这个方法看解释是获取进程的掩码写入到<code>cpu_set_t</code>中，进程的Cpu关联掩码决定了它有资格运行的Cpu集。成功返回0，错误返回-1或错误码。具体可以参考这个 <a href=\"https://linux.die.net/man/2/sched_getaffinity\">https://linux.die.net/man/2/sched_getaffinity</a> 。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">os_cpu_count</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">cpu_set_t</span>* cpus)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"comment\">// only look up to the number of configured processors</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; os::<span class=\"built_in\">processor_count</span>(); i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">CPU_ISSET</span>(i, cpus)) &#123;</span><br><span class=\"line\">      count++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里调用processor_count函数来获取所有的CPU核数。然后去检查是否在这个cpu是不是集合的成员，是成员则增加计数。</p>\n<p>_processor_count这个变量通过set_processor_count函数去赋值。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> os::Linux::<span class=\"built_in\">initialize_system_info</span>() &#123;</span><br><span class=\"line\">  <span class=\"built_in\">set_processor_count</span>(<span class=\"built_in\">sysconf</span>(_SC_NPROCESSORS_CONF));</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">processor_count</span>() == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">pid_t</span> pid = os::Linux::<span class=\"built_in\">gettid</span>();</span><br><span class=\"line\">    <span class=\"keyword\">char</span> fname[<span class=\"number\">32</span>];</span><br><span class=\"line\">    <span class=\"built_in\">jio_snprintf</span>(fname, <span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(fname), <span class=\"string\">&quot;/proc/%d&quot;</span>, pid);</span><br><span class=\"line\">    FILE *fp = <span class=\"built_in\">fopen</span>(fname, <span class=\"string\">&quot;r&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fp == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">      unsafe_chroot_detected = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">fclose</span>(fp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  _physical_memory = (julong)<span class=\"built_in\">sysconf</span>(_SC_PHYS_PAGES) * (julong)<span class=\"built_in\">sysconf</span>(_SC_PAGESIZE);</span><br><span class=\"line\">  <span class=\"built_in\">assert</span>(<span class=\"built_in\">processor_count</span>() &gt; <span class=\"number\">0</span>, <span class=\"string\">&quot;linux error&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其实获取CPU核数都是通过调用系统sysconf函数来获取，只不过一个是<code>_SC_NPROCESSORS_CONF</code> 一个是 <code>_SC_NPROCESSORS_ONLN</code> 。</p>\n<p><strong>_SC_NPROCESSORS_CONF</strong> ：返回系统所有的CPU核数，这个值也包括系统中禁止用户使用的CPU个数；</p>\n<p><strong>_SC_NPROCESSORS_ONLN</strong>：返回系统中可用的CPU核数；</p>\n<h4 id=\"内存\"><a href=\"#内存\" class=\"headerlink\" title=\"内存\"></a>内存</h4><p>既然读取CPU会出错，那么内存应该也是一样的，在不显式的指定一些参数时如-Xmx(MaxHeapSize)、-Xms(InitialHeapSize)时，JVM会根据它读取到的机器的内存大小做一些默认的设置如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Arguments::set_heap_size</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!<span class=\"built_in\">FLAG_IS_DEFAULT</span>(DefaultMaxRAMFraction)) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Deprecated flag</span></span><br><span class=\"line\">    <span class=\"built_in\">FLAG_SET_CMDLINE</span>(uintx, MaxRAMFraction, DefaultMaxRAMFraction);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  julong phys_mem =</span><br><span class=\"line\">    <span class=\"built_in\">FLAG_IS_DEFAULT</span>(MaxRAM) ? <span class=\"built_in\">MIN2</span>(os::<span class=\"built_in\">physical_memory</span>(), (julong)MaxRAM)</span><br><span class=\"line\">                            : (julong)MaxRAM;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// Experimental support for CGroup memory limits</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (UseCGroupMemoryLimitForHeap) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// This is a rough indicator that a CGroup limit may be in force</span></span><br><span class=\"line\">    <span class=\"comment\">// for this process</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* lim_file = <span class=\"string\">&quot;/sys/fs/cgroup/memory/memory.limit_in_bytes&quot;</span>;</span><br><span class=\"line\">    FILE *fp = <span class=\"built_in\">fopen</span>(lim_file, <span class=\"string\">&quot;r&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fp != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">      julong cgroup_max = <span class=\"number\">0</span>;</span><br><span class=\"line\">      <span class=\"keyword\">int</span> ret = <span class=\"built_in\">fscanf</span>(fp, JULONG_FORMAT, &amp;cgroup_max);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (ret == <span class=\"number\">1</span> &amp;&amp; cgroup_max &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// If unlimited, cgroup_max will be a very large, but unspecified</span></span><br><span class=\"line\">        <span class=\"comment\">// value, so use initial phys_mem as a limit</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (PrintGCDetails &amp;&amp; Verbose) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// Cannot use gclog_or_tty yet.</span></span><br><span class=\"line\">          tty-&gt;<span class=\"built_in\">print_cr</span>(<span class=\"string\">&quot;Setting phys_mem to the min of cgroup limit (&quot;</span></span><br><span class=\"line\">                        JULONG_FORMAT <span class=\"string\">&quot;MB) and initial phys_mem (&quot;</span></span><br><span class=\"line\">                        JULONG_FORMAT <span class=\"string\">&quot;MB)&quot;</span>, cgroup_max/M, phys_mem/M);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        phys_mem = <span class=\"built_in\">MIN2</span>(cgroup_max, phys_mem);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">warning</span>(<span class=\"string\">&quot;Unable to read/parse cgroup memory limit from %s: %s&quot;</span>,</span><br><span class=\"line\">                lim_file, errno != <span class=\"number\">0</span> ? <span class=\"built_in\">strerror</span>(errno) : <span class=\"string\">&quot;unknown error&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"built_in\">fclose</span>(fp);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">warning</span>(<span class=\"string\">&quot;Unable to open cgroup memory limit file %s (%s)&quot;</span>, lim_file, <span class=\"built_in\">strerror</span>(errno));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>意外发现竟然有对CGroup的支持，只不过是实验支持，可以使用-XX:+UseCGroupMemoryLimitForHeap开启这个支持，不过既然是实验支持可能还不太支持，最好还是手动指定一下比较稳妥。</p>\n<p>在 <a href=\"%22https://bugs.openjdk.java.net/browse/JDK-8146115%22\">JDK-8146115</a> 中发现Docker的增强已经在JDK10中实现了，使用-XX:+UseContainerSupport可以开启容器支持，这一增强已经被Backports 到了JDK8的一些新版本中。</p>\n<p>最新版的os::active_processor_count()变成了：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Determine the active processor count from one of</span></span><br><span class=\"line\"><span class=\"comment\">// three different sources:</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// 1. User option -XX:ActiveProcessorCount</span></span><br><span class=\"line\"><span class=\"comment\">// 2. kernel os calls (sched_getaffinity or sysconf(_SC_NPROCESSORS_ONLN)</span></span><br><span class=\"line\"><span class=\"comment\">// 3. extracted from cgroup cpu subsystem (shares and quotas)</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// Option 1, if specified, will always override.</span></span><br><span class=\"line\"><span class=\"comment\">// If the cgroup subsystem is active and configured, we</span></span><br><span class=\"line\"><span class=\"comment\">// will return the min of the cgroup and option 2 results.</span></span><br><span class=\"line\"><span class=\"comment\">// This is required since tools, such as numactl, that</span></span><br><span class=\"line\"><span class=\"comment\">// alter cpu affinity do not update cgroup subsystem</span></span><br><span class=\"line\"><span class=\"comment\">// cpuset configuration files.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">os::active_processor_count</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// User has overridden the number of active processors</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (ActiveProcessorCount &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (PrintActiveCpus) &#123;</span><br><span class=\"line\">      tty-&gt;<span class=\"built_in\">print_cr</span>(<span class=\"string\">&quot;active_processor_count: &quot;</span></span><br><span class=\"line\">                    <span class=\"string\">&quot;active processor count set by user : %d&quot;</span>,</span><br><span class=\"line\">                    ActiveProcessorCount);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ActiveProcessorCount;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">int</span> active_cpus;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (OSContainer::<span class=\"built_in\">is_containerized</span>()) &#123;</span><br><span class=\"line\">    active_cpus = OSContainer::<span class=\"built_in\">active_processor_count</span>();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (PrintActiveCpus) &#123;</span><br><span class=\"line\">      tty-&gt;<span class=\"built_in\">print_cr</span>(<span class=\"string\">&quot;active_processor_count: determined by OSContainer: %d&quot;</span>,</span><br><span class=\"line\">                     active_cpus);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    active_cpus = os::Linux::<span class=\"built_in\">active_processor_count</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> active_cpus;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到如果有-XX:ActiveProcessorCount参数则使用参数，如果没有就会去OSContainer::is_containerized()判断是否是容器，然后获取容器对资源的限制。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">bool</span> <span class=\"title\">OSContainer::is_containerized</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">assert</span>(_is_initialized, <span class=\"string\">&quot;OSContainer not initialized&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> _is_containerized;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里_is_containerized是由Threads::create_vm调用OSContainer::init()时检查虚拟机是否运行在容器中得来的。（osContainer_linux.hpp）</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* init</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Initialize the container support and determine if</span></span><br><span class=\"line\"><span class=\"comment\"> * we are running under cgroup control.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">OSContainer::init</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  FILE *mntinfo = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">  FILE *cgroup = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">  <span class=\"keyword\">char</span> buf[MAXPATHLEN+<span class=\"number\">1</span>];</span><br><span class=\"line\">  <span class=\"keyword\">char</span> tmproot[MAXPATHLEN+<span class=\"number\">1</span>];</span><br><span class=\"line\">  <span class=\"keyword\">char</span> tmpmount[MAXPATHLEN+<span class=\"number\">1</span>];</span><br><span class=\"line\">  <span class=\"keyword\">char</span> *p;</span><br><span class=\"line\">  jlong mem_limit;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">assert</span>(!_is_initialized, <span class=\"string\">&quot;Initializing OSContainer more than once&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  _is_initialized = <span class=\"literal\">true</span>;</span><br><span class=\"line\">  _is_containerized = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  _unlimited_memory = (LONG_MAX / os::<span class=\"built_in\">vm_page_size</span>()) * os::<span class=\"built_in\">vm_page_size</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (PrintContainerInfo) &#123;</span><br><span class=\"line\">    tty-&gt;<span class=\"built_in\">print_cr</span>(<span class=\"string\">&quot;OSContainer::init: Initializing Container Support&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!UseContainerSupport) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (PrintContainerInfo) &#123;</span><br><span class=\"line\">      tty-&gt;<span class=\"built_in\">print_cr</span>(<span class=\"string\">&quot;Container Support not enabled&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">   * Find the cgroup mount point for memory and cpuset</span></span><br><span class=\"line\"><span class=\"comment\">   * by reading /proc/self/mountinfo</span></span><br><span class=\"line\"><span class=\"comment\">   *</span></span><br><span class=\"line\"><span class=\"comment\">   * Example for docker:</span></span><br><span class=\"line\"><span class=\"comment\">   * 219 214 0:29 /docker/7208cebd00fa5f2e342b1094f7bed87fa25661471a4637118e65f1c995be8a34 /sys/fs/cgroup/memory ro,nosuid,nodev,noexec,relatime - cgroup cgroup rw,memory</span></span><br><span class=\"line\"><span class=\"comment\">   *</span></span><br><span class=\"line\"><span class=\"comment\">   * Example for host:</span></span><br><span class=\"line\"><span class=\"comment\">   * 34 28 0:29 / /sys/fs/cgroup/memory rw,nosuid,nodev,noexec,relatime shared:16 - cgroup cgroup rw,memory</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">   mntinfo = <span class=\"built_in\">fopen</span>(<span class=\"string\">&quot;/proc/self/mountinfo&quot;</span>, <span class=\"string\">&quot;r&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (mntinfo == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (PrintContainerInfo) &#123;</span><br><span class=\"line\">        tty-&gt;<span class=\"built_in\">print_cr</span>(<span class=\"string\">&quot;Can&#x27;t open /proc/self/mountinfo, %s&quot;</span>,</span><br><span class=\"line\">                       <span class=\"built_in\">strerror</span>(errno));</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ···</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">   * Read /proc/self/cgroup and map host mount point to</span></span><br><span class=\"line\"><span class=\"comment\">   * local one via /proc/self/mountinfo content above</span></span><br><span class=\"line\"><span class=\"comment\">   *</span></span><br><span class=\"line\"><span class=\"comment\">   * Docker example:</span></span><br><span class=\"line\"><span class=\"comment\">   * 5:memory:/docker/6558aed8fc662b194323ceab5b964f69cf36b3e8af877a14b80256e93aecb044</span></span><br><span class=\"line\"><span class=\"comment\">   *</span></span><br><span class=\"line\"><span class=\"comment\">   * Host example:</span></span><br><span class=\"line\"><span class=\"comment\">   * 5:memory:/user.slice</span></span><br><span class=\"line\"><span class=\"comment\">   *</span></span><br><span class=\"line\"><span class=\"comment\">   * Construct a path to the process specific memory and cpuset</span></span><br><span class=\"line\"><span class=\"comment\">   * cgroup directory.</span></span><br><span class=\"line\"><span class=\"comment\">   *</span></span><br><span class=\"line\"><span class=\"comment\">   * For a container running under Docker from memory example above</span></span><br><span class=\"line\"><span class=\"comment\">   * the paths would be:</span></span><br><span class=\"line\"><span class=\"comment\">   *</span></span><br><span class=\"line\"><span class=\"comment\">   * /sys/fs/cgroup/memory</span></span><br><span class=\"line\"><span class=\"comment\">   *</span></span><br><span class=\"line\"><span class=\"comment\">   * For a Host from memory example above the path would be:</span></span><br><span class=\"line\"><span class=\"comment\">   *</span></span><br><span class=\"line\"><span class=\"comment\">   * /sys/fs/cgroup/memory/user.slice</span></span><br><span class=\"line\"><span class=\"comment\">   *</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">    cgroup = <span class=\"built_in\">fopen</span>(<span class=\"string\">&quot;/proc/self/cgroup&quot;</span>, <span class=\"string\">&quot;r&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (cgroup == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (PrintContainerInfo) &#123;</span><br><span class=\"line\">      tty-&gt;<span class=\"built_in\">print_cr</span>(<span class=\"string\">&quot;Can&#x27;t open /proc/self/cgroup, %s&quot;</span>,</span><br><span class=\"line\">                     <span class=\"built_in\">strerror</span>(errno));</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ···</span><br><span class=\"line\">  _is_containerized = <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到这里初始化的时候会先判断-XX:+UseContainerSupport 是否开启，/proc/self/mountinfo 、/proc/self/cgroup 是否可读等，如果运行在容器中，那么就会调用OSContainer::active_processor_count获取容器限制的CPU数目（osContainer_linux.hpp）：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* active_processor_count</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Calculate an appropriate number of active processors for the</span></span><br><span class=\"line\"><span class=\"comment\"> * VM to use based on these three inputs.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * cpu affinity</span></span><br><span class=\"line\"><span class=\"comment\"> * cgroup cpu quota &amp; cpu period</span></span><br><span class=\"line\"><span class=\"comment\"> * cgroup cpu shares</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Algorithm:</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Determine the number of available CPUs from sched_getaffinity</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * If user specified a quota (quota != -1), calculate the number of</span></span><br><span class=\"line\"><span class=\"comment\"> * required CPUs by dividing quota by period.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * If shares are in effect (shares != -1), calculate the number</span></span><br><span class=\"line\"><span class=\"comment\"> * of CPUs required for the shares by dividing the share value</span></span><br><span class=\"line\"><span class=\"comment\"> * by PER_CPU_SHARES.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * All results of division are rounded up to the next whole number.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * If neither shares or quotas have been specified, return the</span></span><br><span class=\"line\"><span class=\"comment\"> * number of active processors in the system.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * If both shares and quotas have been specified, the results are</span></span><br><span class=\"line\"><span class=\"comment\"> * based on the flag PreferContainerQuotaForCPUCount.  If true,</span></span><br><span class=\"line\"><span class=\"comment\"> * return the quota value.  If false return the smallest value</span></span><br><span class=\"line\"><span class=\"comment\"> * between shares or quotas.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * If shares and/or quotas have been specified, the resulting number</span></span><br><span class=\"line\"><span class=\"comment\"> * returned will never exceed the number of active processors.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * return:</span></span><br><span class=\"line\"><span class=\"comment\"> *    number of CPUs</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">OSContainer::active_processor_count</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> quota_count = <span class=\"number\">0</span>, share_count = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> cpu_count, limit_count;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> result;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// We use a cache with a timeout to avoid performing expensive</span></span><br><span class=\"line\">  <span class=\"comment\">// computations in the event this function is called frequently.</span></span><br><span class=\"line\">  <span class=\"comment\">// [See 8227006].</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!cpu-&gt;<span class=\"built_in\">cache_has_expired</span>()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (PrintContainerInfo) &#123;</span><br><span class=\"line\">      tty-&gt;<span class=\"built_in\">print_cr</span>(<span class=\"string\">&quot;OSContainer::active_processor_count (cached): %d&quot;</span>, OSContainer::_active_processor_count);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> OSContainer::_active_processor_count;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  cpu_count = limit_count = os::Linux::<span class=\"built_in\">active_processor_count</span>();</span><br><span class=\"line\">  <span class=\"keyword\">int</span> quota  = <span class=\"built_in\">cpu_quota</span>();</span><br><span class=\"line\">  <span class=\"keyword\">int</span> period = <span class=\"built_in\">cpu_period</span>();</span><br><span class=\"line\">  <span class=\"keyword\">int</span> share  = <span class=\"built_in\">cpu_shares</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (quota &gt; <span class=\"number\">-1</span> &amp;&amp; period &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    quota_count = <span class=\"built_in\">ceilf</span>((<span class=\"keyword\">float</span>)quota / (<span class=\"keyword\">float</span>)period);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (PrintContainerInfo) &#123;</span><br><span class=\"line\">      tty-&gt;<span class=\"built_in\">print_cr</span>(<span class=\"string\">&quot;CPU Quota count based on quota/period: %d&quot;</span>, quota_count);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (share &gt; <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">    share_count = <span class=\"built_in\">ceilf</span>((<span class=\"keyword\">float</span>)share / (<span class=\"keyword\">float</span>)PER_CPU_SHARES);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (PrintContainerInfo) &#123;</span><br><span class=\"line\">      tty-&gt;<span class=\"built_in\">print_cr</span>(<span class=\"string\">&quot;CPU Share count based on shares: %d&quot;</span>, share_count);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// If both shares and quotas are setup results depend</span></span><br><span class=\"line\">  <span class=\"comment\">// on flag PreferContainerQuotaForCPUCount.</span></span><br><span class=\"line\">  <span class=\"comment\">// If true, limit CPU count to quota</span></span><br><span class=\"line\">  <span class=\"comment\">// If false, use minimum of shares and quotas</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (quota_count !=<span class=\"number\">0</span> &amp;&amp; share_count != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (PreferContainerQuotaForCPUCount) &#123;</span><br><span class=\"line\">      limit_count = quota_count;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      limit_count = <span class=\"built_in\">MIN2</span>(quota_count, share_count);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (quota_count != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    limit_count = quota_count;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (share_count != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    limit_count = share_count;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  result = <span class=\"built_in\">MIN2</span>(cpu_count, limit_count);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (PrintContainerInfo) &#123;</span><br><span class=\"line\">    tty-&gt;<span class=\"built_in\">print_cr</span>(<span class=\"string\">&quot;OSContainer::active_processor_count: %d&quot;</span>, result);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Update the value and reset the cache timeout</span></span><br><span class=\"line\">  OSContainer::_active_processor_count = result;</span><br><span class=\"line\">  cpu-&gt;<span class=\"built_in\">set_cache_expiry_time</span>(OSCONTAINER_CACHE_TIMEOUT);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以发现最终的结果和很多变量有关，如果同时设置了共享和配额，则设置结果取决于在首选容器QuotaForcpUCount标志上。</p>\n<p>如果为true，则将CPU计数限制为配额，如果为false，则使用最低份额和配额。Docker可以通过-cpu-period、-cpu-quato来进行相关参数的设置，具体可以参考 <a href=\"https://docs.docker.com/config/containers/resource_constraints/#cpu\">Docker文档</a> 。</p>\n<p>最终结果还会和物理机的cpu核数比较来获取较小的值。</p>\n<p>内存的获取并没有什么区别，思路基本上与获取cpu的一致。</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>使用JVM参数取来限制JVM使用容器的资源，可以更好的保护JVM的运行，不会因为超过容器的限制而被Kill掉，容器Kill掉超过限制的进程也是为了保护容器不会被操作系统Kill。</p>\n"},{"layout":"post","title":"死磕HashMap源码(二)","description":"死磕HashMap源码(二) 红黑树相关的操作","date":"2021-08-12T11:42:10.000Z","_content":"\nJdk8以前，使用的是链表去解决hash冲突的，这样就会导致一个问题，如果这个链表很长，那么从链表中定位到数据的时间复杂度就是O(n)，链表越长性能越差。因此Jdk8对HashMap进行了优化，引入了自平衡的红黑树结构，让定位元素的时间复杂度优化成O(logn)，这样就可以提升元素的查找效率，但是也不是完全摒弃了链表，因为元素不多的情况下，链表的插入速度更快。\n\n看下树化的源码\n\n```java\nfinal void treeifyBin(Node<K,V>[] tab, int hash) {\n    int n, index; Node<K,V> e;\n    //这里还要进行判断 如果桶容量小于64还是会进行扩容\n    if (tab == null || (n = tab.length) < MIN_TREEIFY_CAPACITY)\n        resize();\n    else if ((e = tab[index = (n - 1) & hash]) != null) {\n        TreeNode<K,V> hd = null, tl = null;\n        do {\n            //这里只是将原来的Node替换成了TreeNode\n            TreeNode<K,V> p = replacementTreeNode(e, null);\n            if (tl == null)\n                hd = p;\n            else {\n                p.prev = tl;\n                tl.next = p;\n            }\n            tl = p;\n        } while ((e = e.next) != null);\n        if ((tab[index] = hd) != null)\n            //这里进行红黑树的转化\n            hd.treeify(tab);\n    }\n}\n\nTreeNode<K,V> replacementTreeNode(Node<K,V> p, Node<K,V> next) {\n    return new TreeNode<>(p.hash, p.key, p.value, next);\n}\n```\n\n通过上面的代码可以看到，链表转红黑树其实是有两个条件的，一个是链表长度大于8，还有一个就是桶容量要大于64，否则，就只会扩容不会树化。\n\n然后treeifyBin方法中将Node节点转化为TreeNode，此时只是节点类型转化，并没有实际的树化，并且记录了链表的顺序。\n\n然后来看下TreeNode的结构，方法我没粘，需要的时候再看。\n\n```java\n static final class TreeNode<K,V> extends LinkedHashMap.Entry<K,V> {\n     TreeNode<K,V> parent;  // red-black tree links\n     TreeNode<K,V> left;\n     TreeNode<K,V> right;\n     TreeNode<K,V> prev;    // needed to unlink next upon deletion\n     boolean red;\n     TreeNode(int hash, K key, V val, Node<K,V> next) {\n         super(hash, key, val, next);\n     }\n }\n```\n\n上面看了链表树化的操作，然后来看下树转链表的操作。\n\n```java\nfinal Node<K,V> untreeify(HashMap<K,V> map) {\n    Node<K,V> hd = null, tl = null;\n    //这里遍历树节点 然后转化成Node节点 hd是头 tl是尾 根据树节点保存的顺序恢复链表的顺序\n    for (Node<K,V> q = this; q != null; q = q.next) {\n        Node<K,V> p = map.replacementNode(q, null);\n        if (tl == null)\n            hd = p;\n        else\n            tl.next = p;\n        tl = p;\n    }\n    return hd;\n}\n\nNode<K,V> replacementNode(Node<K,V> p, Node<K,V> next) {\n    return new Node<>(p.hash, p.key, p.value, next);\n}\n```\n\n我们已经知道了链表转树的条件，那么树是什么时候转成链表呢？其实可以猜个大概，因为扩容和删除节点的都会让树节点变少。\n\n1.扩容的时候。如果扩容那部分仔细看的话，就知道扩容的时候，其实就是把桶里的元素的index进行重新分配，让它们更分散，也包括树。这个时候就需要把树像链表一样拆开，然后去看这些元素哪些该喊0哪些该喊1，进而给它们重新分配桶，这样一个大树可能就变成了一颗小树，如果小于等于非树化阈值，那么就转成链表。\n\n2.删除节点的时候。\n\n扩容的时候判断条件就是小于等于`UNTREEIFY_THRESHOLD`就会将树转成链表。但是删除的时候不是通过这个阈值控制的，可以看下条件。\n\n```java\n//movable 这个参数删除的时候是写死的为true 所以只要root.right == null 或者root.left == null 或者 root.left.left == null\n//可以根据红黑树的性质去推断，当根节点的右节点为空时，从根节点出发路径有一个黑色节点。那么此时从根节点出发，到左边的NIL节点应该只有一个红色节点\n//此时树只有2个元素。从根出发左节点为空同理。也是只有2个元素。\n//如果左节点的左节点为空那么左节点为黑色，右节点为红色及它的两个子节点为黑色，那么此时最多5个元素。\n//但是为什么不用UNTREEIFY_THRESHOLD去计算 我还是没有想明白。不过作用是类似的，只是少了个树里6个元素的情况\nif (root == null\n    || (movable\n        && (root.right == null\n            || (rl = root.left) == null\n            || rl.left == null))) {\n    tab[index] = first.untreeify(map);  // too small\n    return;\n}\n```\n\n\n\n为了深入理解红黑树，需要先从二叉查找树说起。\n\n#### BST\n\n二叉查找树（Binary Search Tree 简称BST）是一颗二叉树，它的左子节点的值比父节点的值要小，右节点的值要比父节点的值大。它的高度决定了它的查找效率。在理想的情况下，二叉查找树增删改查的时间复杂度为O(logN)（其中N为节点数），最坏的情况下为O(N)。当它的高度为logN+1时，我们就说二叉查找树是平衡的。\n\n![](https://vqianxiao.github.io/blog/images/hashmap/bst.png)\n\nBST的查找\n\n```java\nT  key = a search key\nNode root = point to the root of a BST\n\n //其实思路就是找到根 然后去判断 相等返回。小于就从左子树查找，大于就从右子树查找 直到当前节点指针为空或者找到对应的节点\nwhile(true){\n    if(root==null){\n    \tbreak;\n    }\n    if(root.value.equals(key)){\n    \treturn root;\n    }\n    else if(key.compareTo(root.value)<0){\n    \troot = root.left;\n    }\n    else{\n    \troot = root.right;\n    }\n}\nreturn null;\n```\n\nBST的插入\n\n```java\nNode node = create a new node with specify value\nNode root = point the root node of a BST\nNode parent = null;\n\n//find the parent node to append the new node\nwhile(true){\n   if(root==null)break;\n   parent = root;\n   if(node.value.compareTo(root.value)<=0){\n      root = root.left;  \n   }else{\n      root = root.right;\n   } \n}\nif(parent!=null){\n   if(node.value.compareTo(parent.value)<=0){//append to left\n      parent.left = node;\n   }else{//append to right\n\t  parent.right = node;\n   }\n}\n\n```\n\n插入操作先通过循环找到要插入的节点的父节点，然后对比父节点，小的就插入到父节点的左节点，大的就插入到父节点的右节点。\n\nBST的删除\n\n删除步骤如下：\n\n1.查找要删除的节点\n\n2.如果待删除的节点是叶子节点，则直接删除\n\n3.如果删除的节点不是叶子节点，则先找到待删除节点的中序遍历的后继节点，用该后继节点的值替换待删除的节点的值，然后删除后继节点。\n\n![](https://vqianxiao.github.io/blog/images/hashmap/bstdel.png)\n\nBST的缺陷\n\nBST的主要问题，数据在插入的时候，会导致树倾斜，不同的插入顺序会导致树的高度不一样，而树的高度直接影响了树的查找效率。理想的高度是logN，最坏的情况就是所有的节点都在一条斜线上，这样的树的高度为N。\n\n#### RBTREE\n\n基于BST的问题，一种新的树——平衡二叉查找树产生了。平衡树在插入和删除的时候，会通过旋转操作将高度保持在logN。其中两款具有代表性的平衡树分别为AVL树和红黑树。AVL树由于实现比较复杂，而且插入和删除性能差，在实际环境下的应用不如红黑树。红黑树应用非常广泛，在Linux内核中的完全公平调度器、高精度计时器、ext3文件系统等等，各种语言的函数库如Java的TreeMap和TreeSet，C++ STL的map、multimap、multiset等。值得一提的是，Java8中HashMap的实现也因为用RBTree取代链表，性能有所提升。\n\n> 1.任何一个节点都有颜色，节点是红色或者黑色\n>\n> 2.根节点是黑色的\n>\n> 3.父子节点之间不能出现两个连续的红节点（红色节点的子节点只能是黑色节点） \n>\n> 4.从任意节点到叶子节点的所有路径都包含相同数目的黑色节点\n>\n> 5.所有叶子节点都是黑色节点（叶子是NIL结点，默认省略）\n\nRBTree理论上还是一颗BST树，但是在对BST的插入和删除操作时为维持树的平衡，即保证树的高度在[logN,logN+1]（理论上，极端情况下可以持续爱你RBTree的高度达到2*logN，但实际上很难遇到）。这样RBTree的查找时间复杂度始终保持在O(logN)从而接近于理想的BST。RBTree的删除和插入操作的时间复杂度也是O(logN)，RBTree的查找操作和BST的查找操作一致。\n\nRBTree的旋转操作\n\n旋转操作（Rotate）的目的是使节点颜色符合定义，让RBTree的高度达到平衡。Rotate分为left-rotate（左旋）和right-rotate（右旋），区分左旋和右旋的方法是：待旋转的节点从左边上升到父节点就是右旋，待旋转的节点从右边上升到父节点就是左旋。\n\n![](https://vqianxiao.github.io/blog/images/hashmap/rotateRBTree.png)\n\nRBTree的查找操作\n\nRBTree的查找操作和BST的查找操作是一样的。\n\n#### RBTree的插入操作\n\nRBTree的插入操作和BST的插入方式一致，不过在插入后，可能会导致树的不平衡，这时就需要对树进行旋转操作和颜色修复（也叫变色），使得它符合RBTree的定义。\n\n新插入的节点是红色的，插入修复操作如果遇到父节点的颜色为黑则修复操作结束。也就是说，只有在父节点为红色结点的时候需要插入修复操作。\n\n插入修复操作分为以下三种情况，而且新插入的结点的父节点都是红色的：\n\n1.叔叔结点也为红色\n\n2.叔叔结点为空，且祖父结点、父节点和新节点处于一条斜线上\n\n3.叔叔结点为空，且祖父结点、父节点和新节点不出与一条斜线上\n\n##### 插入操作-case1 第一种情况（叔叔节点也为红色）\n\n将父节点和叔叔节点与祖父节点的颜色互换，这样就符合了RBTree的定义。即维持了高度的平衡，修复后颜色也符合RBTree定义的第三条和第四条。下图中，操作完成后A节点变成了新的节点。如果A节点的父节点不是黑色的话，则继续做修复操作。\n\n![](https://vqianxiao.github.io/blog/images/hashmap/insertcase1.png)\n\n##### 插入操作-case2 第二种情况（叔叔节点为空，且祖父节点、父节点和新节点处于一条斜线上）\n\n将B节点进行右旋操作，并且和父节点A互换颜色，通过该修复操作BRTree的高度和颜色都符合红黑树的定义。如果B和C节点都是右节点的话，只要将操作变成左旋就可以了。\n\n![](https://vqianxiao.github.io/blog/images/hashmap/insertcase2.png)\n\n##### 插入操作-case3 第三种情况（叔叔结点为空，且祖父结点、父节点和新节点不出与一条斜线上）\n\n将C节点进行左旋，这样就将第三种情况转换成第二种情况了，然后针对第二种情况进行操作处理就可以了。case2操作做了一个右旋操作和颜色互换来达到目的。如果树的结构是下图的镜像结，则只需要将对应的左旋变成右旋，右旋变成左旋即可。\n\n![](https://vqianxiao.github.io/blog/images/hashmap/insertcase3.png)\n\n**插入操作的总结**\n\n插入后的修复操作时一个向root节点回溯的操作，一旦涉及的节点都符合了红黑树的定义，修复操作结束。之所以会向上回溯是由于case1操作会将父节点、叔叔节点和祖父节点进行变色，有可能会导致祖父节点不平衡（红黑树定义三）。这个时候需要对祖父节点为起点进行调节（向上回溯）。\n\n祖父节点调节后如果还是遇到它的祖父颜色问题，操作就会继续向上回溯，直到root节点为止，根据定义root节点永远是黑色的。在向上的回溯过程中，针对插入的3种情况进行调节，直到符合红黑树的定义为止。直到涉及的节点都符合了红黑树的定义，修复操作结束。\n\n如果上面的3种情况对应的操作是在右子树上，对对应的镜像操作就可以了。\n\n#### RBTree的删除操作\n\n删除操作首先要做的也是BST的删除操作，删除操作会删除对应的节点，如果是叶子结点就直接删除，如果是非叶子结点，会用对应的中序遍历的后继节点来顶替要删除节点的位置。删除后就需要做删除修复操作，使树符合红黑树的定义，符合定义的红黑树高度是平衡的。\n\n删除修复操作在遇到被删除的节点是红色节点或者到达root节点时，修复操作完毕。\n\n删除修复操作时针对删除黑色节点才有的，当黑色节点被删除后会让整个树不符合RBTree的定义的第四条。需要做的处理时从兄弟节点上借调黑色的节点过来，如果兄弟节点没有黑色节点可以借调的话，就只能向上追溯，将每一级的黑色节点数减去一个，使得整棵树符合红黑树的定义。\n\n删除操作总体思想时从兄弟节点借调黑色节点使树保持局部的平衡，如果局部的平衡达到了，就看整体的树是否是平衡的，如果不平衡就接着向上追溯调整。\n\n删除修复操作分为四种情况，并且只针对黑色节点的删除：\n\n1.待删除的节点的兄弟节点是红色的节点\n\n2.待删除的节点的兄弟节点是黑色的节点，且兄弟节点的子节点都是黑色的\n\n3.待调整的节点的兄弟节点是黑色的节点，且兄弟节点的左子节点是红色的，右节点是黑色的（兄弟节点在右边），如果兄弟节点在左边的话，就是兄弟节点的右子节点是红色的，左节点是黑色的\n\n4.待调整的节点的兄弟节点是黑色的节点，且右子节点是红色的（兄弟节点在右边），如果兄弟节点在左边，则对应的就是左节点是红色的\n\n##### 删除操作-case1（待删除的节点的兄弟节点是红色的节点）\n\n由于兄弟节点是红色结点的时候，无法借调黑色节点，所以需要将兄弟节点提升到父节点，由于兄弟节点是红色的，根据RBTree的定义，兄弟节点的子节点是黑色的，就可以从它的子节点借调了。\n\ncase1这样转换以后就会变成后面的case2，case3，或者case4进行处理了。上升操作需要对C做一个左旋操作，如果是镜像结构的树只需要做对应的右旋操作即可。\n\n之所以要做case1操作是因为兄弟节点是红色的，无法借到一个黑色节点来填补删除的黑色节点。\n\n![](https://vqianxiao.github.io/blog/images/hashmap/delcase1.png)\n\n##### 删除操作-case2 （待删除的节点的兄弟节点是黑色的节点，且兄弟节点的子节点都是黑色的）\n\ncase2的删除操作是由于兄弟节点可以消除一个黑色节点，因为兄弟节点和兄弟节点之间的子节点都是黑色的，所以可以将兄弟节点变红，这样就可以保证树的局部的颜色符合定义了。这个时候需要将父节点A变成新的节点，继续向上调整，直到整棵树的颜色符合RBTree的定义为止。\n\ncase2这种情况下之所以要将兄弟节点变红，是因为如果把兄弟节点借调过来，会导致兄弟的结构不符合RBTree的定义，这样的情况下只能是将兄弟节点也变成红色来达到颜色的平衡。当将兄弟节点也变红之后，达到了局部的平衡了，但是对于祖父节点来说是不符合定义4的（因为了个黑色的节点）。这样就需要回溯到父节点，接着进行修复操作。\n\n![](https://vqianxiao.github.io/blog/images/hashmap/delcase2.png)\n\n##### 删除操作-case3（待调整的节点的兄弟节点是黑色的节点，且兄弟节点的左子节点是红色的，右节点是黑色的（兄弟节点在右边），如果兄弟节点在左边的话，就是兄弟节点的右子节点是红色的，左节点是黑色的）\n\ncase3的删除操作是一个中间步骤，它的目的是将左边的红色节点借调过来，这样就可以转换成case4状态了，在case4状态下可以将D、E节点都借调过来，通过将两个节点变成黑色来保证红黑树的整体平衡。\n\n之所以说case3是一个中间状态，是因为根据红黑树的定义来说，下图并不是平衡的，它是通过case2操作完后向上回溯出现的状态。之所以会出现case3和后面的case4的情况，是因为可以通过借调侄子节点的红色，变成黑色来符合定义4。\n\n![](https://vqianxiao.github.io/blog/images/hashmap/delcase3.png)\n\n##### 删除操作-case4 （待调整的节点的兄弟节点是黑色的节点，且右子节点是红色的（兄弟节点在右边），如果兄弟节点在左边，则对应的就是左节点是红色的）\n\ncase4的操作是真正的节点借调操作，通过将兄弟节点以及兄弟节点的右节点借调过来，并将兄弟节点的右子节点变成红色来达到借调两个黑色节点的目的，这样的话，整棵树还是符合RBTree定义的。\n\ncase4这种情况的发生只有在待删除的节点的兄弟节点为黑，且子节点不全部为黑，才有可能借调到两个节点来做黑色节点使用，从而保持整棵树都符合红黑树的定义。\n\n![](https://vqianxiao.github.io/blog/images/hashmap/delcase4.png)\n\n**删除操作的总结**\n\n红黑树的删除操作是最复杂的操作，复杂的地方就在于当删除了黑色节点的时候，如何从兄弟节点去借调节点，以保证树的颜色符合定义。由于红色的兄弟节点是没法借调出黑色节点的，这样只能通过旋转操作让他上升到父节点，而由于它是红节点，所以它的子节点就是黑的，可以借调。\n\n对于兄弟节点是黑色节点的可以分成3种情况来处理，当所有的兄弟节点的子节点都是黑色节点时，可以直接将兄弟节点变红，这样局部的红黑树颜色是符合定义的。但是整棵树不一定是符合红黑树定义的，需要向上追溯继续调整。\n\n对于兄弟节点的子节点为左红右黑或者（全部为红）右红左黑这两种情况，可以先将前面的情况通过选择转换为后一种情况，在后一种情况下，因为兄弟节点为黑，兄弟节点的右节点为红，可以借调出两个节点出来做黑节点，这样就可以保证删除了黑节点，整棵树还是符合红黑树的定义的，因为黑色节点的个数没有改变。\n\n红黑树的删除操作是遇到删除的节点为红色，或者追溯调整到了root节点，这时删除的修复工作完毕。\n\n**红黑树总结**\n\n作为平衡二叉查找树里面众多的实现之一，红黑树无疑是最简洁、实现最为简单的。红黑树通过引入颜色的概念，通过颜色这个约束条件的使用来保持树的高度稳定。作为平衡二叉查找树，旋转是一个必不可少的操作，通过旋转可以降低树的高度，在红黑树里面还可以转换颜色。\n\n红黑树里面的插入和删除的操作比较难理解，这是要注意记住一点：操作之前红黑树是平衡的，颜色是符合定义的，在操作的时候就需要向兄弟节点、父节点、侄子节点借调和互换颜色，要达到这个目的，就需要不断的进行旋转。所以红黑树的插入删除操作需要不停的旋转，一旦借调了别的节点，删除和插入的节点就会达到局部的平衡（局部符合红黑树的定义），但是被借调的节点就不会平衡了，这时就需要以被借调的节点为起点继续进行调整，直到整棵树都是平衡的。在整个修复的过程中，插入可以分3种情况，删除分4种情况。\n\n整个红黑树的查找，插入和删除都是O(logN)的，原因就是整个红黑树的高度是logN，查找从根到叶，走过的路径是树的高度，删除和插入操作是从根到叶的，所以经过的路径都是logN。\n\n>参考自 https://tech.meituan.com/2016/12/02/redblack-tree.html","source":"_posts/死磕HashMap源码(二).md","raw":"---\nlayout:    post\ntitle:     死磕HashMap源码(二)\ncategory:  源码解析\ndescription: 死磕HashMap源码(二) 红黑树相关的操作\ntags: JDK\ndate: 2021/08/12 19:42:10\n\n\n---\n\nJdk8以前，使用的是链表去解决hash冲突的，这样就会导致一个问题，如果这个链表很长，那么从链表中定位到数据的时间复杂度就是O(n)，链表越长性能越差。因此Jdk8对HashMap进行了优化，引入了自平衡的红黑树结构，让定位元素的时间复杂度优化成O(logn)，这样就可以提升元素的查找效率，但是也不是完全摒弃了链表，因为元素不多的情况下，链表的插入速度更快。\n\n看下树化的源码\n\n```java\nfinal void treeifyBin(Node<K,V>[] tab, int hash) {\n    int n, index; Node<K,V> e;\n    //这里还要进行判断 如果桶容量小于64还是会进行扩容\n    if (tab == null || (n = tab.length) < MIN_TREEIFY_CAPACITY)\n        resize();\n    else if ((e = tab[index = (n - 1) & hash]) != null) {\n        TreeNode<K,V> hd = null, tl = null;\n        do {\n            //这里只是将原来的Node替换成了TreeNode\n            TreeNode<K,V> p = replacementTreeNode(e, null);\n            if (tl == null)\n                hd = p;\n            else {\n                p.prev = tl;\n                tl.next = p;\n            }\n            tl = p;\n        } while ((e = e.next) != null);\n        if ((tab[index] = hd) != null)\n            //这里进行红黑树的转化\n            hd.treeify(tab);\n    }\n}\n\nTreeNode<K,V> replacementTreeNode(Node<K,V> p, Node<K,V> next) {\n    return new TreeNode<>(p.hash, p.key, p.value, next);\n}\n```\n\n通过上面的代码可以看到，链表转红黑树其实是有两个条件的，一个是链表长度大于8，还有一个就是桶容量要大于64，否则，就只会扩容不会树化。\n\n然后treeifyBin方法中将Node节点转化为TreeNode，此时只是节点类型转化，并没有实际的树化，并且记录了链表的顺序。\n\n然后来看下TreeNode的结构，方法我没粘，需要的时候再看。\n\n```java\n static final class TreeNode<K,V> extends LinkedHashMap.Entry<K,V> {\n     TreeNode<K,V> parent;  // red-black tree links\n     TreeNode<K,V> left;\n     TreeNode<K,V> right;\n     TreeNode<K,V> prev;    // needed to unlink next upon deletion\n     boolean red;\n     TreeNode(int hash, K key, V val, Node<K,V> next) {\n         super(hash, key, val, next);\n     }\n }\n```\n\n上面看了链表树化的操作，然后来看下树转链表的操作。\n\n```java\nfinal Node<K,V> untreeify(HashMap<K,V> map) {\n    Node<K,V> hd = null, tl = null;\n    //这里遍历树节点 然后转化成Node节点 hd是头 tl是尾 根据树节点保存的顺序恢复链表的顺序\n    for (Node<K,V> q = this; q != null; q = q.next) {\n        Node<K,V> p = map.replacementNode(q, null);\n        if (tl == null)\n            hd = p;\n        else\n            tl.next = p;\n        tl = p;\n    }\n    return hd;\n}\n\nNode<K,V> replacementNode(Node<K,V> p, Node<K,V> next) {\n    return new Node<>(p.hash, p.key, p.value, next);\n}\n```\n\n我们已经知道了链表转树的条件，那么树是什么时候转成链表呢？其实可以猜个大概，因为扩容和删除节点的都会让树节点变少。\n\n1.扩容的时候。如果扩容那部分仔细看的话，就知道扩容的时候，其实就是把桶里的元素的index进行重新分配，让它们更分散，也包括树。这个时候就需要把树像链表一样拆开，然后去看这些元素哪些该喊0哪些该喊1，进而给它们重新分配桶，这样一个大树可能就变成了一颗小树，如果小于等于非树化阈值，那么就转成链表。\n\n2.删除节点的时候。\n\n扩容的时候判断条件就是小于等于`UNTREEIFY_THRESHOLD`就会将树转成链表。但是删除的时候不是通过这个阈值控制的，可以看下条件。\n\n```java\n//movable 这个参数删除的时候是写死的为true 所以只要root.right == null 或者root.left == null 或者 root.left.left == null\n//可以根据红黑树的性质去推断，当根节点的右节点为空时，从根节点出发路径有一个黑色节点。那么此时从根节点出发，到左边的NIL节点应该只有一个红色节点\n//此时树只有2个元素。从根出发左节点为空同理。也是只有2个元素。\n//如果左节点的左节点为空那么左节点为黑色，右节点为红色及它的两个子节点为黑色，那么此时最多5个元素。\n//但是为什么不用UNTREEIFY_THRESHOLD去计算 我还是没有想明白。不过作用是类似的，只是少了个树里6个元素的情况\nif (root == null\n    || (movable\n        && (root.right == null\n            || (rl = root.left) == null\n            || rl.left == null))) {\n    tab[index] = first.untreeify(map);  // too small\n    return;\n}\n```\n\n\n\n为了深入理解红黑树，需要先从二叉查找树说起。\n\n#### BST\n\n二叉查找树（Binary Search Tree 简称BST）是一颗二叉树，它的左子节点的值比父节点的值要小，右节点的值要比父节点的值大。它的高度决定了它的查找效率。在理想的情况下，二叉查找树增删改查的时间复杂度为O(logN)（其中N为节点数），最坏的情况下为O(N)。当它的高度为logN+1时，我们就说二叉查找树是平衡的。\n\n![](https://vqianxiao.github.io/blog/images/hashmap/bst.png)\n\nBST的查找\n\n```java\nT  key = a search key\nNode root = point to the root of a BST\n\n //其实思路就是找到根 然后去判断 相等返回。小于就从左子树查找，大于就从右子树查找 直到当前节点指针为空或者找到对应的节点\nwhile(true){\n    if(root==null){\n    \tbreak;\n    }\n    if(root.value.equals(key)){\n    \treturn root;\n    }\n    else if(key.compareTo(root.value)<0){\n    \troot = root.left;\n    }\n    else{\n    \troot = root.right;\n    }\n}\nreturn null;\n```\n\nBST的插入\n\n```java\nNode node = create a new node with specify value\nNode root = point the root node of a BST\nNode parent = null;\n\n//find the parent node to append the new node\nwhile(true){\n   if(root==null)break;\n   parent = root;\n   if(node.value.compareTo(root.value)<=0){\n      root = root.left;  \n   }else{\n      root = root.right;\n   } \n}\nif(parent!=null){\n   if(node.value.compareTo(parent.value)<=0){//append to left\n      parent.left = node;\n   }else{//append to right\n\t  parent.right = node;\n   }\n}\n\n```\n\n插入操作先通过循环找到要插入的节点的父节点，然后对比父节点，小的就插入到父节点的左节点，大的就插入到父节点的右节点。\n\nBST的删除\n\n删除步骤如下：\n\n1.查找要删除的节点\n\n2.如果待删除的节点是叶子节点，则直接删除\n\n3.如果删除的节点不是叶子节点，则先找到待删除节点的中序遍历的后继节点，用该后继节点的值替换待删除的节点的值，然后删除后继节点。\n\n![](https://vqianxiao.github.io/blog/images/hashmap/bstdel.png)\n\nBST的缺陷\n\nBST的主要问题，数据在插入的时候，会导致树倾斜，不同的插入顺序会导致树的高度不一样，而树的高度直接影响了树的查找效率。理想的高度是logN，最坏的情况就是所有的节点都在一条斜线上，这样的树的高度为N。\n\n#### RBTREE\n\n基于BST的问题，一种新的树——平衡二叉查找树产生了。平衡树在插入和删除的时候，会通过旋转操作将高度保持在logN。其中两款具有代表性的平衡树分别为AVL树和红黑树。AVL树由于实现比较复杂，而且插入和删除性能差，在实际环境下的应用不如红黑树。红黑树应用非常广泛，在Linux内核中的完全公平调度器、高精度计时器、ext3文件系统等等，各种语言的函数库如Java的TreeMap和TreeSet，C++ STL的map、multimap、multiset等。值得一提的是，Java8中HashMap的实现也因为用RBTree取代链表，性能有所提升。\n\n> 1.任何一个节点都有颜色，节点是红色或者黑色\n>\n> 2.根节点是黑色的\n>\n> 3.父子节点之间不能出现两个连续的红节点（红色节点的子节点只能是黑色节点） \n>\n> 4.从任意节点到叶子节点的所有路径都包含相同数目的黑色节点\n>\n> 5.所有叶子节点都是黑色节点（叶子是NIL结点，默认省略）\n\nRBTree理论上还是一颗BST树，但是在对BST的插入和删除操作时为维持树的平衡，即保证树的高度在[logN,logN+1]（理论上，极端情况下可以持续爱你RBTree的高度达到2*logN，但实际上很难遇到）。这样RBTree的查找时间复杂度始终保持在O(logN)从而接近于理想的BST。RBTree的删除和插入操作的时间复杂度也是O(logN)，RBTree的查找操作和BST的查找操作一致。\n\nRBTree的旋转操作\n\n旋转操作（Rotate）的目的是使节点颜色符合定义，让RBTree的高度达到平衡。Rotate分为left-rotate（左旋）和right-rotate（右旋），区分左旋和右旋的方法是：待旋转的节点从左边上升到父节点就是右旋，待旋转的节点从右边上升到父节点就是左旋。\n\n![](https://vqianxiao.github.io/blog/images/hashmap/rotateRBTree.png)\n\nRBTree的查找操作\n\nRBTree的查找操作和BST的查找操作是一样的。\n\n#### RBTree的插入操作\n\nRBTree的插入操作和BST的插入方式一致，不过在插入后，可能会导致树的不平衡，这时就需要对树进行旋转操作和颜色修复（也叫变色），使得它符合RBTree的定义。\n\n新插入的节点是红色的，插入修复操作如果遇到父节点的颜色为黑则修复操作结束。也就是说，只有在父节点为红色结点的时候需要插入修复操作。\n\n插入修复操作分为以下三种情况，而且新插入的结点的父节点都是红色的：\n\n1.叔叔结点也为红色\n\n2.叔叔结点为空，且祖父结点、父节点和新节点处于一条斜线上\n\n3.叔叔结点为空，且祖父结点、父节点和新节点不出与一条斜线上\n\n##### 插入操作-case1 第一种情况（叔叔节点也为红色）\n\n将父节点和叔叔节点与祖父节点的颜色互换，这样就符合了RBTree的定义。即维持了高度的平衡，修复后颜色也符合RBTree定义的第三条和第四条。下图中，操作完成后A节点变成了新的节点。如果A节点的父节点不是黑色的话，则继续做修复操作。\n\n![](https://vqianxiao.github.io/blog/images/hashmap/insertcase1.png)\n\n##### 插入操作-case2 第二种情况（叔叔节点为空，且祖父节点、父节点和新节点处于一条斜线上）\n\n将B节点进行右旋操作，并且和父节点A互换颜色，通过该修复操作BRTree的高度和颜色都符合红黑树的定义。如果B和C节点都是右节点的话，只要将操作变成左旋就可以了。\n\n![](https://vqianxiao.github.io/blog/images/hashmap/insertcase2.png)\n\n##### 插入操作-case3 第三种情况（叔叔结点为空，且祖父结点、父节点和新节点不出与一条斜线上）\n\n将C节点进行左旋，这样就将第三种情况转换成第二种情况了，然后针对第二种情况进行操作处理就可以了。case2操作做了一个右旋操作和颜色互换来达到目的。如果树的结构是下图的镜像结，则只需要将对应的左旋变成右旋，右旋变成左旋即可。\n\n![](https://vqianxiao.github.io/blog/images/hashmap/insertcase3.png)\n\n**插入操作的总结**\n\n插入后的修复操作时一个向root节点回溯的操作，一旦涉及的节点都符合了红黑树的定义，修复操作结束。之所以会向上回溯是由于case1操作会将父节点、叔叔节点和祖父节点进行变色，有可能会导致祖父节点不平衡（红黑树定义三）。这个时候需要对祖父节点为起点进行调节（向上回溯）。\n\n祖父节点调节后如果还是遇到它的祖父颜色问题，操作就会继续向上回溯，直到root节点为止，根据定义root节点永远是黑色的。在向上的回溯过程中，针对插入的3种情况进行调节，直到符合红黑树的定义为止。直到涉及的节点都符合了红黑树的定义，修复操作结束。\n\n如果上面的3种情况对应的操作是在右子树上，对对应的镜像操作就可以了。\n\n#### RBTree的删除操作\n\n删除操作首先要做的也是BST的删除操作，删除操作会删除对应的节点，如果是叶子结点就直接删除，如果是非叶子结点，会用对应的中序遍历的后继节点来顶替要删除节点的位置。删除后就需要做删除修复操作，使树符合红黑树的定义，符合定义的红黑树高度是平衡的。\n\n删除修复操作在遇到被删除的节点是红色节点或者到达root节点时，修复操作完毕。\n\n删除修复操作时针对删除黑色节点才有的，当黑色节点被删除后会让整个树不符合RBTree的定义的第四条。需要做的处理时从兄弟节点上借调黑色的节点过来，如果兄弟节点没有黑色节点可以借调的话，就只能向上追溯，将每一级的黑色节点数减去一个，使得整棵树符合红黑树的定义。\n\n删除操作总体思想时从兄弟节点借调黑色节点使树保持局部的平衡，如果局部的平衡达到了，就看整体的树是否是平衡的，如果不平衡就接着向上追溯调整。\n\n删除修复操作分为四种情况，并且只针对黑色节点的删除：\n\n1.待删除的节点的兄弟节点是红色的节点\n\n2.待删除的节点的兄弟节点是黑色的节点，且兄弟节点的子节点都是黑色的\n\n3.待调整的节点的兄弟节点是黑色的节点，且兄弟节点的左子节点是红色的，右节点是黑色的（兄弟节点在右边），如果兄弟节点在左边的话，就是兄弟节点的右子节点是红色的，左节点是黑色的\n\n4.待调整的节点的兄弟节点是黑色的节点，且右子节点是红色的（兄弟节点在右边），如果兄弟节点在左边，则对应的就是左节点是红色的\n\n##### 删除操作-case1（待删除的节点的兄弟节点是红色的节点）\n\n由于兄弟节点是红色结点的时候，无法借调黑色节点，所以需要将兄弟节点提升到父节点，由于兄弟节点是红色的，根据RBTree的定义，兄弟节点的子节点是黑色的，就可以从它的子节点借调了。\n\ncase1这样转换以后就会变成后面的case2，case3，或者case4进行处理了。上升操作需要对C做一个左旋操作，如果是镜像结构的树只需要做对应的右旋操作即可。\n\n之所以要做case1操作是因为兄弟节点是红色的，无法借到一个黑色节点来填补删除的黑色节点。\n\n![](https://vqianxiao.github.io/blog/images/hashmap/delcase1.png)\n\n##### 删除操作-case2 （待删除的节点的兄弟节点是黑色的节点，且兄弟节点的子节点都是黑色的）\n\ncase2的删除操作是由于兄弟节点可以消除一个黑色节点，因为兄弟节点和兄弟节点之间的子节点都是黑色的，所以可以将兄弟节点变红，这样就可以保证树的局部的颜色符合定义了。这个时候需要将父节点A变成新的节点，继续向上调整，直到整棵树的颜色符合RBTree的定义为止。\n\ncase2这种情况下之所以要将兄弟节点变红，是因为如果把兄弟节点借调过来，会导致兄弟的结构不符合RBTree的定义，这样的情况下只能是将兄弟节点也变成红色来达到颜色的平衡。当将兄弟节点也变红之后，达到了局部的平衡了，但是对于祖父节点来说是不符合定义4的（因为了个黑色的节点）。这样就需要回溯到父节点，接着进行修复操作。\n\n![](https://vqianxiao.github.io/blog/images/hashmap/delcase2.png)\n\n##### 删除操作-case3（待调整的节点的兄弟节点是黑色的节点，且兄弟节点的左子节点是红色的，右节点是黑色的（兄弟节点在右边），如果兄弟节点在左边的话，就是兄弟节点的右子节点是红色的，左节点是黑色的）\n\ncase3的删除操作是一个中间步骤，它的目的是将左边的红色节点借调过来，这样就可以转换成case4状态了，在case4状态下可以将D、E节点都借调过来，通过将两个节点变成黑色来保证红黑树的整体平衡。\n\n之所以说case3是一个中间状态，是因为根据红黑树的定义来说，下图并不是平衡的，它是通过case2操作完后向上回溯出现的状态。之所以会出现case3和后面的case4的情况，是因为可以通过借调侄子节点的红色，变成黑色来符合定义4。\n\n![](https://vqianxiao.github.io/blog/images/hashmap/delcase3.png)\n\n##### 删除操作-case4 （待调整的节点的兄弟节点是黑色的节点，且右子节点是红色的（兄弟节点在右边），如果兄弟节点在左边，则对应的就是左节点是红色的）\n\ncase4的操作是真正的节点借调操作，通过将兄弟节点以及兄弟节点的右节点借调过来，并将兄弟节点的右子节点变成红色来达到借调两个黑色节点的目的，这样的话，整棵树还是符合RBTree定义的。\n\ncase4这种情况的发生只有在待删除的节点的兄弟节点为黑，且子节点不全部为黑，才有可能借调到两个节点来做黑色节点使用，从而保持整棵树都符合红黑树的定义。\n\n![](https://vqianxiao.github.io/blog/images/hashmap/delcase4.png)\n\n**删除操作的总结**\n\n红黑树的删除操作是最复杂的操作，复杂的地方就在于当删除了黑色节点的时候，如何从兄弟节点去借调节点，以保证树的颜色符合定义。由于红色的兄弟节点是没法借调出黑色节点的，这样只能通过旋转操作让他上升到父节点，而由于它是红节点，所以它的子节点就是黑的，可以借调。\n\n对于兄弟节点是黑色节点的可以分成3种情况来处理，当所有的兄弟节点的子节点都是黑色节点时，可以直接将兄弟节点变红，这样局部的红黑树颜色是符合定义的。但是整棵树不一定是符合红黑树定义的，需要向上追溯继续调整。\n\n对于兄弟节点的子节点为左红右黑或者（全部为红）右红左黑这两种情况，可以先将前面的情况通过选择转换为后一种情况，在后一种情况下，因为兄弟节点为黑，兄弟节点的右节点为红，可以借调出两个节点出来做黑节点，这样就可以保证删除了黑节点，整棵树还是符合红黑树的定义的，因为黑色节点的个数没有改变。\n\n红黑树的删除操作是遇到删除的节点为红色，或者追溯调整到了root节点，这时删除的修复工作完毕。\n\n**红黑树总结**\n\n作为平衡二叉查找树里面众多的实现之一，红黑树无疑是最简洁、实现最为简单的。红黑树通过引入颜色的概念，通过颜色这个约束条件的使用来保持树的高度稳定。作为平衡二叉查找树，旋转是一个必不可少的操作，通过旋转可以降低树的高度，在红黑树里面还可以转换颜色。\n\n红黑树里面的插入和删除的操作比较难理解，这是要注意记住一点：操作之前红黑树是平衡的，颜色是符合定义的，在操作的时候就需要向兄弟节点、父节点、侄子节点借调和互换颜色，要达到这个目的，就需要不断的进行旋转。所以红黑树的插入删除操作需要不停的旋转，一旦借调了别的节点，删除和插入的节点就会达到局部的平衡（局部符合红黑树的定义），但是被借调的节点就不会平衡了，这时就需要以被借调的节点为起点继续进行调整，直到整棵树都是平衡的。在整个修复的过程中，插入可以分3种情况，删除分4种情况。\n\n整个红黑树的查找，插入和删除都是O(logN)的，原因就是整个红黑树的高度是logN，查找从根到叶，走过的路径是树的高度，删除和插入操作是从根到叶的，所以经过的路径都是logN。\n\n>参考自 https://tech.meituan.com/2016/12/02/redblack-tree.html","slug":"死磕HashMap源码(二)","published":1,"updated":"2021-08-12T11:42:10.000Z","comments":1,"photos":[],"link":"","_id":"cm1m304y9003t31b43wrm8bau","content":"<p>Jdk8以前，使用的是链表去解决hash冲突的，这样就会导致一个问题，如果这个链表很长，那么从链表中定位到数据的时间复杂度就是O(n)，链表越长性能越差。因此Jdk8对HashMap进行了优化，引入了自平衡的红黑树结构，让定位元素的时间复杂度优化成O(logn)，这样就可以提升元素的查找效率，但是也不是完全摒弃了链表，因为元素不多的情况下，链表的插入速度更快。</p>\n<p>看下树化的源码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">treeifyBin</span><span class=\"params\">(Node&lt;K,V&gt;[] tab, <span class=\"keyword\">int</span> hash)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class=\"line\">    <span class=\"comment\">//这里还要进行判断 如果桶容量小于64还是会进行扩容</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tab == <span class=\"keyword\">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class=\"line\">        resize();</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((e = tab[index = (n - <span class=\"number\">1</span>) &amp; hash]) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        TreeNode&lt;K,V&gt; hd = <span class=\"keyword\">null</span>, tl = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//这里只是将原来的Node替换成了TreeNode</span></span><br><span class=\"line\">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (tl == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                hd = p;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                p.prev = tl;</span><br><span class=\"line\">                tl.next = p;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            tl = p;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">while</span> ((e = e.next) != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((tab[index] = hd) != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"comment\">//这里进行红黑树的转化</span></span><br><span class=\"line\">            hd.treeify(tab);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">TreeNode&lt;K,V&gt; <span class=\"title\">replacementTreeNode</span><span class=\"params\">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> TreeNode&lt;&gt;(p.hash, p.key, p.value, next);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过上面的代码可以看到，链表转红黑树其实是有两个条件的，一个是链表长度大于8，还有一个就是桶容量要大于64，否则，就只会扩容不会树化。</p>\n<p>然后treeifyBin方法中将Node节点转化为TreeNode，此时只是节点类型转化，并没有实际的树化，并且记录了链表的顺序。</p>\n<p>然后来看下TreeNode的结构，方法我没粘，需要的时候再看。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TreeNode</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">LinkedHashMap</span>.<span class=\"title\">Entry</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">    TreeNode&lt;K,V&gt; parent;  <span class=\"comment\">// red-black tree links</span></span><br><span class=\"line\">    TreeNode&lt;K,V&gt; left;</span><br><span class=\"line\">    TreeNode&lt;K,V&gt; right;</span><br><span class=\"line\">    TreeNode&lt;K,V&gt; prev;    <span class=\"comment\">// needed to unlink next upon deletion</span></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> red;</span><br><span class=\"line\">    TreeNode(<span class=\"keyword\">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(hash, key, val, next);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面看了链表树化的操作，然后来看下树转链表的操作。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> Node&lt;K,V&gt; <span class=\"title\">untreeify</span><span class=\"params\">(HashMap&lt;K,V&gt; map)</span> </span>&#123;</span><br><span class=\"line\">    Node&lt;K,V&gt; hd = <span class=\"keyword\">null</span>, tl = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"comment\">//这里遍历树节点 然后转化成Node节点 hd是头 tl是尾 根据树节点保存的顺序恢复链表的顺序</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Node&lt;K,V&gt; q = <span class=\"keyword\">this</span>; q != <span class=\"keyword\">null</span>; q = q.next) &#123;</span><br><span class=\"line\">        Node&lt;K,V&gt; p = map.replacementNode(q, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (tl == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            hd = p;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            tl.next = p;</span><br><span class=\"line\">        tl = p;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> hd;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Node&lt;K,V&gt; <span class=\"title\">replacementNode</span><span class=\"params\">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Node&lt;&gt;(p.hash, p.key, p.value, next);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们已经知道了链表转树的条件，那么树是什么时候转成链表呢？其实可以猜个大概，因为扩容和删除节点的都会让树节点变少。</p>\n<p>1.扩容的时候。如果扩容那部分仔细看的话，就知道扩容的时候，其实就是把桶里的元素的index进行重新分配，让它们更分散，也包括树。这个时候就需要把树像链表一样拆开，然后去看这些元素哪些该喊0哪些该喊1，进而给它们重新分配桶，这样一个大树可能就变成了一颗小树，如果小于等于非树化阈值，那么就转成链表。</p>\n<p>2.删除节点的时候。</p>\n<p>扩容的时候判断条件就是小于等于<code>UNTREEIFY_THRESHOLD</code>就会将树转成链表。但是删除的时候不是通过这个阈值控制的，可以看下条件。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//movable 这个参数删除的时候是写死的为true 所以只要root.right == null 或者root.left == null 或者 root.left.left == null</span></span><br><span class=\"line\"><span class=\"comment\">//可以根据红黑树的性质去推断，当根节点的右节点为空时，从根节点出发路径有一个黑色节点。那么此时从根节点出发，到左边的NIL节点应该只有一个红色节点</span></span><br><span class=\"line\"><span class=\"comment\">//此时树只有2个元素。从根出发左节点为空同理。也是只有2个元素。</span></span><br><span class=\"line\"><span class=\"comment\">//如果左节点的左节点为空那么左节点为黑色，右节点为红色及它的两个子节点为黑色，那么此时最多5个元素。</span></span><br><span class=\"line\"><span class=\"comment\">//但是为什么不用UNTREEIFY_THRESHOLD去计算 我还是没有想明白。不过作用是类似的，只是少了个树里6个元素的情况</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span></span><br><span class=\"line\">    || (movable</span><br><span class=\"line\">        &amp;&amp; (root.right == <span class=\"keyword\">null</span></span><br><span class=\"line\">            || (rl = root.left) == <span class=\"keyword\">null</span></span><br><span class=\"line\">            || rl.left == <span class=\"keyword\">null</span>))) &#123;</span><br><span class=\"line\">    tab[index] = first.untreeify(map);  <span class=\"comment\">// too small</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>为了深入理解红黑树，需要先从二叉查找树说起。</p>\n<h4 id=\"BST\"><a href=\"#BST\" class=\"headerlink\" title=\"BST\"></a>BST</h4><p>二叉查找树（Binary Search Tree 简称BST）是一颗二叉树，它的左子节点的值比父节点的值要小，右节点的值要比父节点的值大。它的高度决定了它的查找效率。在理想的情况下，二叉查找树增删改查的时间复杂度为O(logN)（其中N为节点数），最坏的情况下为O(N)。当它的高度为logN+1时，我们就说二叉查找树是平衡的。</p>\n<p><img src=\"https://vqianxiao.github.io/blog/images/hashmap/bst.png\"></p>\n<p>BST的查找</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">T  key = a search key</span><br><span class=\"line\">Node root = point to the root of a BST</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">//其实思路就是找到根 然后去判断 相等返回。小于就从左子树查找，大于就从右子树查找 直到当前节点指针为空或者找到对应的节点</span></span><br><span class=\"line\"><span class=\"keyword\">while</span>(<span class=\"keyword\">true</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(root==<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(root.value.equals(key))&#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(key.compareTo(root.value)&lt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">    \troot = root.left;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    \troot = root.right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br></pre></td></tr></table></figure>\n\n<p>BST的插入</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Node node = create a <span class=\"keyword\">new</span> node with specify value</span><br><span class=\"line\">Node root = point the root node of a BST</span><br><span class=\"line\">Node parent = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//find the parent node to append the new node</span></span><br><span class=\"line\"><span class=\"keyword\">while</span>(<span class=\"keyword\">true</span>)&#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span>(root==<span class=\"keyword\">null</span>)<span class=\"keyword\">break</span>;</span><br><span class=\"line\">   parent = root;</span><br><span class=\"line\">   <span class=\"keyword\">if</span>(node.value.compareTo(root.value)&lt;=<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">      root = root.left;  </span><br><span class=\"line\">   &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">      root = root.right;</span><br><span class=\"line\">   &#125; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(parent!=<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span>(node.value.compareTo(parent.value)&lt;=<span class=\"number\">0</span>)&#123;<span class=\"comment\">//append to left</span></span><br><span class=\"line\">      parent.left = node;</span><br><span class=\"line\">   &#125;<span class=\"keyword\">else</span>&#123;<span class=\"comment\">//append to right</span></span><br><span class=\"line\">\t  parent.right = node;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>插入操作先通过循环找到要插入的节点的父节点，然后对比父节点，小的就插入到父节点的左节点，大的就插入到父节点的右节点。</p>\n<p>BST的删除</p>\n<p>删除步骤如下：</p>\n<p>1.查找要删除的节点</p>\n<p>2.如果待删除的节点是叶子节点，则直接删除</p>\n<p>3.如果删除的节点不是叶子节点，则先找到待删除节点的中序遍历的后继节点，用该后继节点的值替换待删除的节点的值，然后删除后继节点。</p>\n<p><img src=\"https://vqianxiao.github.io/blog/images/hashmap/bstdel.png\"></p>\n<p>BST的缺陷</p>\n<p>BST的主要问题，数据在插入的时候，会导致树倾斜，不同的插入顺序会导致树的高度不一样，而树的高度直接影响了树的查找效率。理想的高度是logN，最坏的情况就是所有的节点都在一条斜线上，这样的树的高度为N。</p>\n<h4 id=\"RBTREE\"><a href=\"#RBTREE\" class=\"headerlink\" title=\"RBTREE\"></a>RBTREE</h4><p>基于BST的问题，一种新的树——平衡二叉查找树产生了。平衡树在插入和删除的时候，会通过旋转操作将高度保持在logN。其中两款具有代表性的平衡树分别为AVL树和红黑树。AVL树由于实现比较复杂，而且插入和删除性能差，在实际环境下的应用不如红黑树。红黑树应用非常广泛，在Linux内核中的完全公平调度器、高精度计时器、ext3文件系统等等，各种语言的函数库如Java的TreeMap和TreeSet，C++ STL的map、multimap、multiset等。值得一提的是，Java8中HashMap的实现也因为用RBTree取代链表，性能有所提升。</p>\n<blockquote>\n<p>1.任何一个节点都有颜色，节点是红色或者黑色</p>\n<p>2.根节点是黑色的</p>\n<p>3.父子节点之间不能出现两个连续的红节点（红色节点的子节点只能是黑色节点） </p>\n<p>4.从任意节点到叶子节点的所有路径都包含相同数目的黑色节点</p>\n<p>5.所有叶子节点都是黑色节点（叶子是NIL结点，默认省略）</p>\n</blockquote>\n<p>RBTree理论上还是一颗BST树，但是在对BST的插入和删除操作时为维持树的平衡，即保证树的高度在[logN,logN+1]（理论上，极端情况下可以持续爱你RBTree的高度达到2*logN，但实际上很难遇到）。这样RBTree的查找时间复杂度始终保持在O(logN)从而接近于理想的BST。RBTree的删除和插入操作的时间复杂度也是O(logN)，RBTree的查找操作和BST的查找操作一致。</p>\n<p>RBTree的旋转操作</p>\n<p>旋转操作（Rotate）的目的是使节点颜色符合定义，让RBTree的高度达到平衡。Rotate分为left-rotate（左旋）和right-rotate（右旋），区分左旋和右旋的方法是：待旋转的节点从左边上升到父节点就是右旋，待旋转的节点从右边上升到父节点就是左旋。</p>\n<p><img src=\"https://vqianxiao.github.io/blog/images/hashmap/rotateRBTree.png\"></p>\n<p>RBTree的查找操作</p>\n<p>RBTree的查找操作和BST的查找操作是一样的。</p>\n<h4 id=\"RBTree的插入操作\"><a href=\"#RBTree的插入操作\" class=\"headerlink\" title=\"RBTree的插入操作\"></a>RBTree的插入操作</h4><p>RBTree的插入操作和BST的插入方式一致，不过在插入后，可能会导致树的不平衡，这时就需要对树进行旋转操作和颜色修复（也叫变色），使得它符合RBTree的定义。</p>\n<p>新插入的节点是红色的，插入修复操作如果遇到父节点的颜色为黑则修复操作结束。也就是说，只有在父节点为红色结点的时候需要插入修复操作。</p>\n<p>插入修复操作分为以下三种情况，而且新插入的结点的父节点都是红色的：</p>\n<p>1.叔叔结点也为红色</p>\n<p>2.叔叔结点为空，且祖父结点、父节点和新节点处于一条斜线上</p>\n<p>3.叔叔结点为空，且祖父结点、父节点和新节点不出与一条斜线上</p>\n<h5 id=\"插入操作-case1-第一种情况（叔叔节点也为红色）\"><a href=\"#插入操作-case1-第一种情况（叔叔节点也为红色）\" class=\"headerlink\" title=\"插入操作-case1 第一种情况（叔叔节点也为红色）\"></a>插入操作-case1 第一种情况（叔叔节点也为红色）</h5><p>将父节点和叔叔节点与祖父节点的颜色互换，这样就符合了RBTree的定义。即维持了高度的平衡，修复后颜色也符合RBTree定义的第三条和第四条。下图中，操作完成后A节点变成了新的节点。如果A节点的父节点不是黑色的话，则继续做修复操作。</p>\n<p><img src=\"https://vqianxiao.github.io/blog/images/hashmap/insertcase1.png\"></p>\n<h5 id=\"插入操作-case2-第二种情况（叔叔节点为空，且祖父节点、父节点和新节点处于一条斜线上）\"><a href=\"#插入操作-case2-第二种情况（叔叔节点为空，且祖父节点、父节点和新节点处于一条斜线上）\" class=\"headerlink\" title=\"插入操作-case2 第二种情况（叔叔节点为空，且祖父节点、父节点和新节点处于一条斜线上）\"></a>插入操作-case2 第二种情况（叔叔节点为空，且祖父节点、父节点和新节点处于一条斜线上）</h5><p>将B节点进行右旋操作，并且和父节点A互换颜色，通过该修复操作BRTree的高度和颜色都符合红黑树的定义。如果B和C节点都是右节点的话，只要将操作变成左旋就可以了。</p>\n<p><img src=\"https://vqianxiao.github.io/blog/images/hashmap/insertcase2.png\"></p>\n<h5 id=\"插入操作-case3-第三种情况（叔叔结点为空，且祖父结点、父节点和新节点不出与一条斜线上）\"><a href=\"#插入操作-case3-第三种情况（叔叔结点为空，且祖父结点、父节点和新节点不出与一条斜线上）\" class=\"headerlink\" title=\"插入操作-case3 第三种情况（叔叔结点为空，且祖父结点、父节点和新节点不出与一条斜线上）\"></a>插入操作-case3 第三种情况（叔叔结点为空，且祖父结点、父节点和新节点不出与一条斜线上）</h5><p>将C节点进行左旋，这样就将第三种情况转换成第二种情况了，然后针对第二种情况进行操作处理就可以了。case2操作做了一个右旋操作和颜色互换来达到目的。如果树的结构是下图的镜像结，则只需要将对应的左旋变成右旋，右旋变成左旋即可。</p>\n<p><img src=\"https://vqianxiao.github.io/blog/images/hashmap/insertcase3.png\"></p>\n<p><strong>插入操作的总结</strong></p>\n<p>插入后的修复操作时一个向root节点回溯的操作，一旦涉及的节点都符合了红黑树的定义，修复操作结束。之所以会向上回溯是由于case1操作会将父节点、叔叔节点和祖父节点进行变色，有可能会导致祖父节点不平衡（红黑树定义三）。这个时候需要对祖父节点为起点进行调节（向上回溯）。</p>\n<p>祖父节点调节后如果还是遇到它的祖父颜色问题，操作就会继续向上回溯，直到root节点为止，根据定义root节点永远是黑色的。在向上的回溯过程中，针对插入的3种情况进行调节，直到符合红黑树的定义为止。直到涉及的节点都符合了红黑树的定义，修复操作结束。</p>\n<p>如果上面的3种情况对应的操作是在右子树上，对对应的镜像操作就可以了。</p>\n<h4 id=\"RBTree的删除操作\"><a href=\"#RBTree的删除操作\" class=\"headerlink\" title=\"RBTree的删除操作\"></a>RBTree的删除操作</h4><p>删除操作首先要做的也是BST的删除操作，删除操作会删除对应的节点，如果是叶子结点就直接删除，如果是非叶子结点，会用对应的中序遍历的后继节点来顶替要删除节点的位置。删除后就需要做删除修复操作，使树符合红黑树的定义，符合定义的红黑树高度是平衡的。</p>\n<p>删除修复操作在遇到被删除的节点是红色节点或者到达root节点时，修复操作完毕。</p>\n<p>删除修复操作时针对删除黑色节点才有的，当黑色节点被删除后会让整个树不符合RBTree的定义的第四条。需要做的处理时从兄弟节点上借调黑色的节点过来，如果兄弟节点没有黑色节点可以借调的话，就只能向上追溯，将每一级的黑色节点数减去一个，使得整棵树符合红黑树的定义。</p>\n<p>删除操作总体思想时从兄弟节点借调黑色节点使树保持局部的平衡，如果局部的平衡达到了，就看整体的树是否是平衡的，如果不平衡就接着向上追溯调整。</p>\n<p>删除修复操作分为四种情况，并且只针对黑色节点的删除：</p>\n<p>1.待删除的节点的兄弟节点是红色的节点</p>\n<p>2.待删除的节点的兄弟节点是黑色的节点，且兄弟节点的子节点都是黑色的</p>\n<p>3.待调整的节点的兄弟节点是黑色的节点，且兄弟节点的左子节点是红色的，右节点是黑色的（兄弟节点在右边），如果兄弟节点在左边的话，就是兄弟节点的右子节点是红色的，左节点是黑色的</p>\n<p>4.待调整的节点的兄弟节点是黑色的节点，且右子节点是红色的（兄弟节点在右边），如果兄弟节点在左边，则对应的就是左节点是红色的</p>\n<h5 id=\"删除操作-case1（待删除的节点的兄弟节点是红色的节点）\"><a href=\"#删除操作-case1（待删除的节点的兄弟节点是红色的节点）\" class=\"headerlink\" title=\"删除操作-case1（待删除的节点的兄弟节点是红色的节点）\"></a>删除操作-case1（待删除的节点的兄弟节点是红色的节点）</h5><p>由于兄弟节点是红色结点的时候，无法借调黑色节点，所以需要将兄弟节点提升到父节点，由于兄弟节点是红色的，根据RBTree的定义，兄弟节点的子节点是黑色的，就可以从它的子节点借调了。</p>\n<p>case1这样转换以后就会变成后面的case2，case3，或者case4进行处理了。上升操作需要对C做一个左旋操作，如果是镜像结构的树只需要做对应的右旋操作即可。</p>\n<p>之所以要做case1操作是因为兄弟节点是红色的，无法借到一个黑色节点来填补删除的黑色节点。</p>\n<p><img src=\"https://vqianxiao.github.io/blog/images/hashmap/delcase1.png\"></p>\n<h5 id=\"删除操作-case2-（待删除的节点的兄弟节点是黑色的节点，且兄弟节点的子节点都是黑色的）\"><a href=\"#删除操作-case2-（待删除的节点的兄弟节点是黑色的节点，且兄弟节点的子节点都是黑色的）\" class=\"headerlink\" title=\"删除操作-case2 （待删除的节点的兄弟节点是黑色的节点，且兄弟节点的子节点都是黑色的）\"></a>删除操作-case2 （待删除的节点的兄弟节点是黑色的节点，且兄弟节点的子节点都是黑色的）</h5><p>case2的删除操作是由于兄弟节点可以消除一个黑色节点，因为兄弟节点和兄弟节点之间的子节点都是黑色的，所以可以将兄弟节点变红，这样就可以保证树的局部的颜色符合定义了。这个时候需要将父节点A变成新的节点，继续向上调整，直到整棵树的颜色符合RBTree的定义为止。</p>\n<p>case2这种情况下之所以要将兄弟节点变红，是因为如果把兄弟节点借调过来，会导致兄弟的结构不符合RBTree的定义，这样的情况下只能是将兄弟节点也变成红色来达到颜色的平衡。当将兄弟节点也变红之后，达到了局部的平衡了，但是对于祖父节点来说是不符合定义4的（因为了个黑色的节点）。这样就需要回溯到父节点，接着进行修复操作。</p>\n<p><img src=\"https://vqianxiao.github.io/blog/images/hashmap/delcase2.png\"></p>\n<h5 id=\"删除操作-case3（待调整的节点的兄弟节点是黑色的节点，且兄弟节点的左子节点是红色的，右节点是黑色的（兄弟节点在右边），如果兄弟节点在左边的话，就是兄弟节点的右子节点是红色的，左节点是黑色的）\"><a href=\"#删除操作-case3（待调整的节点的兄弟节点是黑色的节点，且兄弟节点的左子节点是红色的，右节点是黑色的（兄弟节点在右边），如果兄弟节点在左边的话，就是兄弟节点的右子节点是红色的，左节点是黑色的）\" class=\"headerlink\" title=\"删除操作-case3（待调整的节点的兄弟节点是黑色的节点，且兄弟节点的左子节点是红色的，右节点是黑色的（兄弟节点在右边），如果兄弟节点在左边的话，就是兄弟节点的右子节点是红色的，左节点是黑色的）\"></a>删除操作-case3（待调整的节点的兄弟节点是黑色的节点，且兄弟节点的左子节点是红色的，右节点是黑色的（兄弟节点在右边），如果兄弟节点在左边的话，就是兄弟节点的右子节点是红色的，左节点是黑色的）</h5><p>case3的删除操作是一个中间步骤，它的目的是将左边的红色节点借调过来，这样就可以转换成case4状态了，在case4状态下可以将D、E节点都借调过来，通过将两个节点变成黑色来保证红黑树的整体平衡。</p>\n<p>之所以说case3是一个中间状态，是因为根据红黑树的定义来说，下图并不是平衡的，它是通过case2操作完后向上回溯出现的状态。之所以会出现case3和后面的case4的情况，是因为可以通过借调侄子节点的红色，变成黑色来符合定义4。</p>\n<p><img src=\"https://vqianxiao.github.io/blog/images/hashmap/delcase3.png\"></p>\n<h5 id=\"删除操作-case4-（待调整的节点的兄弟节点是黑色的节点，且右子节点是红色的（兄弟节点在右边），如果兄弟节点在左边，则对应的就是左节点是红色的）\"><a href=\"#删除操作-case4-（待调整的节点的兄弟节点是黑色的节点，且右子节点是红色的（兄弟节点在右边），如果兄弟节点在左边，则对应的就是左节点是红色的）\" class=\"headerlink\" title=\"删除操作-case4 （待调整的节点的兄弟节点是黑色的节点，且右子节点是红色的（兄弟节点在右边），如果兄弟节点在左边，则对应的就是左节点是红色的）\"></a>删除操作-case4 （待调整的节点的兄弟节点是黑色的节点，且右子节点是红色的（兄弟节点在右边），如果兄弟节点在左边，则对应的就是左节点是红色的）</h5><p>case4的操作是真正的节点借调操作，通过将兄弟节点以及兄弟节点的右节点借调过来，并将兄弟节点的右子节点变成红色来达到借调两个黑色节点的目的，这样的话，整棵树还是符合RBTree定义的。</p>\n<p>case4这种情况的发生只有在待删除的节点的兄弟节点为黑，且子节点不全部为黑，才有可能借调到两个节点来做黑色节点使用，从而保持整棵树都符合红黑树的定义。</p>\n<p><img src=\"https://vqianxiao.github.io/blog/images/hashmap/delcase4.png\"></p>\n<p><strong>删除操作的总结</strong></p>\n<p>红黑树的删除操作是最复杂的操作，复杂的地方就在于当删除了黑色节点的时候，如何从兄弟节点去借调节点，以保证树的颜色符合定义。由于红色的兄弟节点是没法借调出黑色节点的，这样只能通过旋转操作让他上升到父节点，而由于它是红节点，所以它的子节点就是黑的，可以借调。</p>\n<p>对于兄弟节点是黑色节点的可以分成3种情况来处理，当所有的兄弟节点的子节点都是黑色节点时，可以直接将兄弟节点变红，这样局部的红黑树颜色是符合定义的。但是整棵树不一定是符合红黑树定义的，需要向上追溯继续调整。</p>\n<p>对于兄弟节点的子节点为左红右黑或者（全部为红）右红左黑这两种情况，可以先将前面的情况通过选择转换为后一种情况，在后一种情况下，因为兄弟节点为黑，兄弟节点的右节点为红，可以借调出两个节点出来做黑节点，这样就可以保证删除了黑节点，整棵树还是符合红黑树的定义的，因为黑色节点的个数没有改变。</p>\n<p>红黑树的删除操作是遇到删除的节点为红色，或者追溯调整到了root节点，这时删除的修复工作完毕。</p>\n<p><strong>红黑树总结</strong></p>\n<p>作为平衡二叉查找树里面众多的实现之一，红黑树无疑是最简洁、实现最为简单的。红黑树通过引入颜色的概念，通过颜色这个约束条件的使用来保持树的高度稳定。作为平衡二叉查找树，旋转是一个必不可少的操作，通过旋转可以降低树的高度，在红黑树里面还可以转换颜色。</p>\n<p>红黑树里面的插入和删除的操作比较难理解，这是要注意记住一点：操作之前红黑树是平衡的，颜色是符合定义的，在操作的时候就需要向兄弟节点、父节点、侄子节点借调和互换颜色，要达到这个目的，就需要不断的进行旋转。所以红黑树的插入删除操作需要不停的旋转，一旦借调了别的节点，删除和插入的节点就会达到局部的平衡（局部符合红黑树的定义），但是被借调的节点就不会平衡了，这时就需要以被借调的节点为起点继续进行调整，直到整棵树都是平衡的。在整个修复的过程中，插入可以分3种情况，删除分4种情况。</p>\n<p>整个红黑树的查找，插入和删除都是O(logN)的，原因就是整个红黑树的高度是logN，查找从根到叶，走过的路径是树的高度，删除和插入操作是从根到叶的，所以经过的路径都是logN。</p>\n<blockquote>\n<p>参考自 <a href=\"https://tech.meituan.com/2016/12/02/redblack-tree.html\">https://tech.meituan.com/2016/12/02/redblack-tree.html</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<p>Jdk8以前，使用的是链表去解决hash冲突的，这样就会导致一个问题，如果这个链表很长，那么从链表中定位到数据的时间复杂度就是O(n)，链表越长性能越差。因此Jdk8对HashMap进行了优化，引入了自平衡的红黑树结构，让定位元素的时间复杂度优化成O(logn)，这样就可以提升元素的查找效率，但是也不是完全摒弃了链表，因为元素不多的情况下，链表的插入速度更快。</p>\n<p>看下树化的源码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">treeifyBin</span><span class=\"params\">(Node&lt;K,V&gt;[] tab, <span class=\"keyword\">int</span> hash)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class=\"line\">    <span class=\"comment\">//这里还要进行判断 如果桶容量小于64还是会进行扩容</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tab == <span class=\"keyword\">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class=\"line\">        resize();</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((e = tab[index = (n - <span class=\"number\">1</span>) &amp; hash]) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        TreeNode&lt;K,V&gt; hd = <span class=\"keyword\">null</span>, tl = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//这里只是将原来的Node替换成了TreeNode</span></span><br><span class=\"line\">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (tl == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                hd = p;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                p.prev = tl;</span><br><span class=\"line\">                tl.next = p;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            tl = p;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">while</span> ((e = e.next) != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((tab[index] = hd) != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"comment\">//这里进行红黑树的转化</span></span><br><span class=\"line\">            hd.treeify(tab);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">TreeNode&lt;K,V&gt; <span class=\"title\">replacementTreeNode</span><span class=\"params\">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> TreeNode&lt;&gt;(p.hash, p.key, p.value, next);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过上面的代码可以看到，链表转红黑树其实是有两个条件的，一个是链表长度大于8，还有一个就是桶容量要大于64，否则，就只会扩容不会树化。</p>\n<p>然后treeifyBin方法中将Node节点转化为TreeNode，此时只是节点类型转化，并没有实际的树化，并且记录了链表的顺序。</p>\n<p>然后来看下TreeNode的结构，方法我没粘，需要的时候再看。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TreeNode</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">LinkedHashMap</span>.<span class=\"title\">Entry</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">    TreeNode&lt;K,V&gt; parent;  <span class=\"comment\">// red-black tree links</span></span><br><span class=\"line\">    TreeNode&lt;K,V&gt; left;</span><br><span class=\"line\">    TreeNode&lt;K,V&gt; right;</span><br><span class=\"line\">    TreeNode&lt;K,V&gt; prev;    <span class=\"comment\">// needed to unlink next upon deletion</span></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> red;</span><br><span class=\"line\">    TreeNode(<span class=\"keyword\">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(hash, key, val, next);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面看了链表树化的操作，然后来看下树转链表的操作。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> Node&lt;K,V&gt; <span class=\"title\">untreeify</span><span class=\"params\">(HashMap&lt;K,V&gt; map)</span> </span>&#123;</span><br><span class=\"line\">    Node&lt;K,V&gt; hd = <span class=\"keyword\">null</span>, tl = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"comment\">//这里遍历树节点 然后转化成Node节点 hd是头 tl是尾 根据树节点保存的顺序恢复链表的顺序</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Node&lt;K,V&gt; q = <span class=\"keyword\">this</span>; q != <span class=\"keyword\">null</span>; q = q.next) &#123;</span><br><span class=\"line\">        Node&lt;K,V&gt; p = map.replacementNode(q, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (tl == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            hd = p;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            tl.next = p;</span><br><span class=\"line\">        tl = p;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> hd;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Node&lt;K,V&gt; <span class=\"title\">replacementNode</span><span class=\"params\">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Node&lt;&gt;(p.hash, p.key, p.value, next);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们已经知道了链表转树的条件，那么树是什么时候转成链表呢？其实可以猜个大概，因为扩容和删除节点的都会让树节点变少。</p>\n<p>1.扩容的时候。如果扩容那部分仔细看的话，就知道扩容的时候，其实就是把桶里的元素的index进行重新分配，让它们更分散，也包括树。这个时候就需要把树像链表一样拆开，然后去看这些元素哪些该喊0哪些该喊1，进而给它们重新分配桶，这样一个大树可能就变成了一颗小树，如果小于等于非树化阈值，那么就转成链表。</p>\n<p>2.删除节点的时候。</p>\n<p>扩容的时候判断条件就是小于等于<code>UNTREEIFY_THRESHOLD</code>就会将树转成链表。但是删除的时候不是通过这个阈值控制的，可以看下条件。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//movable 这个参数删除的时候是写死的为true 所以只要root.right == null 或者root.left == null 或者 root.left.left == null</span></span><br><span class=\"line\"><span class=\"comment\">//可以根据红黑树的性质去推断，当根节点的右节点为空时，从根节点出发路径有一个黑色节点。那么此时从根节点出发，到左边的NIL节点应该只有一个红色节点</span></span><br><span class=\"line\"><span class=\"comment\">//此时树只有2个元素。从根出发左节点为空同理。也是只有2个元素。</span></span><br><span class=\"line\"><span class=\"comment\">//如果左节点的左节点为空那么左节点为黑色，右节点为红色及它的两个子节点为黑色，那么此时最多5个元素。</span></span><br><span class=\"line\"><span class=\"comment\">//但是为什么不用UNTREEIFY_THRESHOLD去计算 我还是没有想明白。不过作用是类似的，只是少了个树里6个元素的情况</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span></span><br><span class=\"line\">    || (movable</span><br><span class=\"line\">        &amp;&amp; (root.right == <span class=\"keyword\">null</span></span><br><span class=\"line\">            || (rl = root.left) == <span class=\"keyword\">null</span></span><br><span class=\"line\">            || rl.left == <span class=\"keyword\">null</span>))) &#123;</span><br><span class=\"line\">    tab[index] = first.untreeify(map);  <span class=\"comment\">// too small</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>为了深入理解红黑树，需要先从二叉查找树说起。</p>\n<h4 id=\"BST\"><a href=\"#BST\" class=\"headerlink\" title=\"BST\"></a>BST</h4><p>二叉查找树（Binary Search Tree 简称BST）是一颗二叉树，它的左子节点的值比父节点的值要小，右节点的值要比父节点的值大。它的高度决定了它的查找效率。在理想的情况下，二叉查找树增删改查的时间复杂度为O(logN)（其中N为节点数），最坏的情况下为O(N)。当它的高度为logN+1时，我们就说二叉查找树是平衡的。</p>\n<p><img src=\"https://vqianxiao.github.io/blog/images/hashmap/bst.png\"></p>\n<p>BST的查找</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">T  key = a search key</span><br><span class=\"line\">Node root = point to the root of a BST</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">//其实思路就是找到根 然后去判断 相等返回。小于就从左子树查找，大于就从右子树查找 直到当前节点指针为空或者找到对应的节点</span></span><br><span class=\"line\"><span class=\"keyword\">while</span>(<span class=\"keyword\">true</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(root==<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(root.value.equals(key))&#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(key.compareTo(root.value)&lt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">    \troot = root.left;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    \troot = root.right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br></pre></td></tr></table></figure>\n\n<p>BST的插入</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Node node = create a <span class=\"keyword\">new</span> node with specify value</span><br><span class=\"line\">Node root = point the root node of a BST</span><br><span class=\"line\">Node parent = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//find the parent node to append the new node</span></span><br><span class=\"line\"><span class=\"keyword\">while</span>(<span class=\"keyword\">true</span>)&#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span>(root==<span class=\"keyword\">null</span>)<span class=\"keyword\">break</span>;</span><br><span class=\"line\">   parent = root;</span><br><span class=\"line\">   <span class=\"keyword\">if</span>(node.value.compareTo(root.value)&lt;=<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">      root = root.left;  </span><br><span class=\"line\">   &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">      root = root.right;</span><br><span class=\"line\">   &#125; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(parent!=<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span>(node.value.compareTo(parent.value)&lt;=<span class=\"number\">0</span>)&#123;<span class=\"comment\">//append to left</span></span><br><span class=\"line\">      parent.left = node;</span><br><span class=\"line\">   &#125;<span class=\"keyword\">else</span>&#123;<span class=\"comment\">//append to right</span></span><br><span class=\"line\">\t  parent.right = node;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>插入操作先通过循环找到要插入的节点的父节点，然后对比父节点，小的就插入到父节点的左节点，大的就插入到父节点的右节点。</p>\n<p>BST的删除</p>\n<p>删除步骤如下：</p>\n<p>1.查找要删除的节点</p>\n<p>2.如果待删除的节点是叶子节点，则直接删除</p>\n<p>3.如果删除的节点不是叶子节点，则先找到待删除节点的中序遍历的后继节点，用该后继节点的值替换待删除的节点的值，然后删除后继节点。</p>\n<p><img src=\"https://vqianxiao.github.io/blog/images/hashmap/bstdel.png\"></p>\n<p>BST的缺陷</p>\n<p>BST的主要问题，数据在插入的时候，会导致树倾斜，不同的插入顺序会导致树的高度不一样，而树的高度直接影响了树的查找效率。理想的高度是logN，最坏的情况就是所有的节点都在一条斜线上，这样的树的高度为N。</p>\n<h4 id=\"RBTREE\"><a href=\"#RBTREE\" class=\"headerlink\" title=\"RBTREE\"></a>RBTREE</h4><p>基于BST的问题，一种新的树——平衡二叉查找树产生了。平衡树在插入和删除的时候，会通过旋转操作将高度保持在logN。其中两款具有代表性的平衡树分别为AVL树和红黑树。AVL树由于实现比较复杂，而且插入和删除性能差，在实际环境下的应用不如红黑树。红黑树应用非常广泛，在Linux内核中的完全公平调度器、高精度计时器、ext3文件系统等等，各种语言的函数库如Java的TreeMap和TreeSet，C++ STL的map、multimap、multiset等。值得一提的是，Java8中HashMap的实现也因为用RBTree取代链表，性能有所提升。</p>\n<blockquote>\n<p>1.任何一个节点都有颜色，节点是红色或者黑色</p>\n<p>2.根节点是黑色的</p>\n<p>3.父子节点之间不能出现两个连续的红节点（红色节点的子节点只能是黑色节点） </p>\n<p>4.从任意节点到叶子节点的所有路径都包含相同数目的黑色节点</p>\n<p>5.所有叶子节点都是黑色节点（叶子是NIL结点，默认省略）</p>\n</blockquote>\n<p>RBTree理论上还是一颗BST树，但是在对BST的插入和删除操作时为维持树的平衡，即保证树的高度在[logN,logN+1]（理论上，极端情况下可以持续爱你RBTree的高度达到2*logN，但实际上很难遇到）。这样RBTree的查找时间复杂度始终保持在O(logN)从而接近于理想的BST。RBTree的删除和插入操作的时间复杂度也是O(logN)，RBTree的查找操作和BST的查找操作一致。</p>\n<p>RBTree的旋转操作</p>\n<p>旋转操作（Rotate）的目的是使节点颜色符合定义，让RBTree的高度达到平衡。Rotate分为left-rotate（左旋）和right-rotate（右旋），区分左旋和右旋的方法是：待旋转的节点从左边上升到父节点就是右旋，待旋转的节点从右边上升到父节点就是左旋。</p>\n<p><img src=\"https://vqianxiao.github.io/blog/images/hashmap/rotateRBTree.png\"></p>\n<p>RBTree的查找操作</p>\n<p>RBTree的查找操作和BST的查找操作是一样的。</p>\n<h4 id=\"RBTree的插入操作\"><a href=\"#RBTree的插入操作\" class=\"headerlink\" title=\"RBTree的插入操作\"></a>RBTree的插入操作</h4><p>RBTree的插入操作和BST的插入方式一致，不过在插入后，可能会导致树的不平衡，这时就需要对树进行旋转操作和颜色修复（也叫变色），使得它符合RBTree的定义。</p>\n<p>新插入的节点是红色的，插入修复操作如果遇到父节点的颜色为黑则修复操作结束。也就是说，只有在父节点为红色结点的时候需要插入修复操作。</p>\n<p>插入修复操作分为以下三种情况，而且新插入的结点的父节点都是红色的：</p>\n<p>1.叔叔结点也为红色</p>\n<p>2.叔叔结点为空，且祖父结点、父节点和新节点处于一条斜线上</p>\n<p>3.叔叔结点为空，且祖父结点、父节点和新节点不出与一条斜线上</p>\n<h5 id=\"插入操作-case1-第一种情况（叔叔节点也为红色）\"><a href=\"#插入操作-case1-第一种情况（叔叔节点也为红色）\" class=\"headerlink\" title=\"插入操作-case1 第一种情况（叔叔节点也为红色）\"></a>插入操作-case1 第一种情况（叔叔节点也为红色）</h5><p>将父节点和叔叔节点与祖父节点的颜色互换，这样就符合了RBTree的定义。即维持了高度的平衡，修复后颜色也符合RBTree定义的第三条和第四条。下图中，操作完成后A节点变成了新的节点。如果A节点的父节点不是黑色的话，则继续做修复操作。</p>\n<p><img src=\"https://vqianxiao.github.io/blog/images/hashmap/insertcase1.png\"></p>\n<h5 id=\"插入操作-case2-第二种情况（叔叔节点为空，且祖父节点、父节点和新节点处于一条斜线上）\"><a href=\"#插入操作-case2-第二种情况（叔叔节点为空，且祖父节点、父节点和新节点处于一条斜线上）\" class=\"headerlink\" title=\"插入操作-case2 第二种情况（叔叔节点为空，且祖父节点、父节点和新节点处于一条斜线上）\"></a>插入操作-case2 第二种情况（叔叔节点为空，且祖父节点、父节点和新节点处于一条斜线上）</h5><p>将B节点进行右旋操作，并且和父节点A互换颜色，通过该修复操作BRTree的高度和颜色都符合红黑树的定义。如果B和C节点都是右节点的话，只要将操作变成左旋就可以了。</p>\n<p><img src=\"https://vqianxiao.github.io/blog/images/hashmap/insertcase2.png\"></p>\n<h5 id=\"插入操作-case3-第三种情况（叔叔结点为空，且祖父结点、父节点和新节点不出与一条斜线上）\"><a href=\"#插入操作-case3-第三种情况（叔叔结点为空，且祖父结点、父节点和新节点不出与一条斜线上）\" class=\"headerlink\" title=\"插入操作-case3 第三种情况（叔叔结点为空，且祖父结点、父节点和新节点不出与一条斜线上）\"></a>插入操作-case3 第三种情况（叔叔结点为空，且祖父结点、父节点和新节点不出与一条斜线上）</h5><p>将C节点进行左旋，这样就将第三种情况转换成第二种情况了，然后针对第二种情况进行操作处理就可以了。case2操作做了一个右旋操作和颜色互换来达到目的。如果树的结构是下图的镜像结，则只需要将对应的左旋变成右旋，右旋变成左旋即可。</p>\n<p><img src=\"https://vqianxiao.github.io/blog/images/hashmap/insertcase3.png\"></p>\n<p><strong>插入操作的总结</strong></p>\n<p>插入后的修复操作时一个向root节点回溯的操作，一旦涉及的节点都符合了红黑树的定义，修复操作结束。之所以会向上回溯是由于case1操作会将父节点、叔叔节点和祖父节点进行变色，有可能会导致祖父节点不平衡（红黑树定义三）。这个时候需要对祖父节点为起点进行调节（向上回溯）。</p>\n<p>祖父节点调节后如果还是遇到它的祖父颜色问题，操作就会继续向上回溯，直到root节点为止，根据定义root节点永远是黑色的。在向上的回溯过程中，针对插入的3种情况进行调节，直到符合红黑树的定义为止。直到涉及的节点都符合了红黑树的定义，修复操作结束。</p>\n<p>如果上面的3种情况对应的操作是在右子树上，对对应的镜像操作就可以了。</p>\n<h4 id=\"RBTree的删除操作\"><a href=\"#RBTree的删除操作\" class=\"headerlink\" title=\"RBTree的删除操作\"></a>RBTree的删除操作</h4><p>删除操作首先要做的也是BST的删除操作，删除操作会删除对应的节点，如果是叶子结点就直接删除，如果是非叶子结点，会用对应的中序遍历的后继节点来顶替要删除节点的位置。删除后就需要做删除修复操作，使树符合红黑树的定义，符合定义的红黑树高度是平衡的。</p>\n<p>删除修复操作在遇到被删除的节点是红色节点或者到达root节点时，修复操作完毕。</p>\n<p>删除修复操作时针对删除黑色节点才有的，当黑色节点被删除后会让整个树不符合RBTree的定义的第四条。需要做的处理时从兄弟节点上借调黑色的节点过来，如果兄弟节点没有黑色节点可以借调的话，就只能向上追溯，将每一级的黑色节点数减去一个，使得整棵树符合红黑树的定义。</p>\n<p>删除操作总体思想时从兄弟节点借调黑色节点使树保持局部的平衡，如果局部的平衡达到了，就看整体的树是否是平衡的，如果不平衡就接着向上追溯调整。</p>\n<p>删除修复操作分为四种情况，并且只针对黑色节点的删除：</p>\n<p>1.待删除的节点的兄弟节点是红色的节点</p>\n<p>2.待删除的节点的兄弟节点是黑色的节点，且兄弟节点的子节点都是黑色的</p>\n<p>3.待调整的节点的兄弟节点是黑色的节点，且兄弟节点的左子节点是红色的，右节点是黑色的（兄弟节点在右边），如果兄弟节点在左边的话，就是兄弟节点的右子节点是红色的，左节点是黑色的</p>\n<p>4.待调整的节点的兄弟节点是黑色的节点，且右子节点是红色的（兄弟节点在右边），如果兄弟节点在左边，则对应的就是左节点是红色的</p>\n<h5 id=\"删除操作-case1（待删除的节点的兄弟节点是红色的节点）\"><a href=\"#删除操作-case1（待删除的节点的兄弟节点是红色的节点）\" class=\"headerlink\" title=\"删除操作-case1（待删除的节点的兄弟节点是红色的节点）\"></a>删除操作-case1（待删除的节点的兄弟节点是红色的节点）</h5><p>由于兄弟节点是红色结点的时候，无法借调黑色节点，所以需要将兄弟节点提升到父节点，由于兄弟节点是红色的，根据RBTree的定义，兄弟节点的子节点是黑色的，就可以从它的子节点借调了。</p>\n<p>case1这样转换以后就会变成后面的case2，case3，或者case4进行处理了。上升操作需要对C做一个左旋操作，如果是镜像结构的树只需要做对应的右旋操作即可。</p>\n<p>之所以要做case1操作是因为兄弟节点是红色的，无法借到一个黑色节点来填补删除的黑色节点。</p>\n<p><img src=\"https://vqianxiao.github.io/blog/images/hashmap/delcase1.png\"></p>\n<h5 id=\"删除操作-case2-（待删除的节点的兄弟节点是黑色的节点，且兄弟节点的子节点都是黑色的）\"><a href=\"#删除操作-case2-（待删除的节点的兄弟节点是黑色的节点，且兄弟节点的子节点都是黑色的）\" class=\"headerlink\" title=\"删除操作-case2 （待删除的节点的兄弟节点是黑色的节点，且兄弟节点的子节点都是黑色的）\"></a>删除操作-case2 （待删除的节点的兄弟节点是黑色的节点，且兄弟节点的子节点都是黑色的）</h5><p>case2的删除操作是由于兄弟节点可以消除一个黑色节点，因为兄弟节点和兄弟节点之间的子节点都是黑色的，所以可以将兄弟节点变红，这样就可以保证树的局部的颜色符合定义了。这个时候需要将父节点A变成新的节点，继续向上调整，直到整棵树的颜色符合RBTree的定义为止。</p>\n<p>case2这种情况下之所以要将兄弟节点变红，是因为如果把兄弟节点借调过来，会导致兄弟的结构不符合RBTree的定义，这样的情况下只能是将兄弟节点也变成红色来达到颜色的平衡。当将兄弟节点也变红之后，达到了局部的平衡了，但是对于祖父节点来说是不符合定义4的（因为了个黑色的节点）。这样就需要回溯到父节点，接着进行修复操作。</p>\n<p><img src=\"https://vqianxiao.github.io/blog/images/hashmap/delcase2.png\"></p>\n<h5 id=\"删除操作-case3（待调整的节点的兄弟节点是黑色的节点，且兄弟节点的左子节点是红色的，右节点是黑色的（兄弟节点在右边），如果兄弟节点在左边的话，就是兄弟节点的右子节点是红色的，左节点是黑色的）\"><a href=\"#删除操作-case3（待调整的节点的兄弟节点是黑色的节点，且兄弟节点的左子节点是红色的，右节点是黑色的（兄弟节点在右边），如果兄弟节点在左边的话，就是兄弟节点的右子节点是红色的，左节点是黑色的）\" class=\"headerlink\" title=\"删除操作-case3（待调整的节点的兄弟节点是黑色的节点，且兄弟节点的左子节点是红色的，右节点是黑色的（兄弟节点在右边），如果兄弟节点在左边的话，就是兄弟节点的右子节点是红色的，左节点是黑色的）\"></a>删除操作-case3（待调整的节点的兄弟节点是黑色的节点，且兄弟节点的左子节点是红色的，右节点是黑色的（兄弟节点在右边），如果兄弟节点在左边的话，就是兄弟节点的右子节点是红色的，左节点是黑色的）</h5><p>case3的删除操作是一个中间步骤，它的目的是将左边的红色节点借调过来，这样就可以转换成case4状态了，在case4状态下可以将D、E节点都借调过来，通过将两个节点变成黑色来保证红黑树的整体平衡。</p>\n<p>之所以说case3是一个中间状态，是因为根据红黑树的定义来说，下图并不是平衡的，它是通过case2操作完后向上回溯出现的状态。之所以会出现case3和后面的case4的情况，是因为可以通过借调侄子节点的红色，变成黑色来符合定义4。</p>\n<p><img src=\"https://vqianxiao.github.io/blog/images/hashmap/delcase3.png\"></p>\n<h5 id=\"删除操作-case4-（待调整的节点的兄弟节点是黑色的节点，且右子节点是红色的（兄弟节点在右边），如果兄弟节点在左边，则对应的就是左节点是红色的）\"><a href=\"#删除操作-case4-（待调整的节点的兄弟节点是黑色的节点，且右子节点是红色的（兄弟节点在右边），如果兄弟节点在左边，则对应的就是左节点是红色的）\" class=\"headerlink\" title=\"删除操作-case4 （待调整的节点的兄弟节点是黑色的节点，且右子节点是红色的（兄弟节点在右边），如果兄弟节点在左边，则对应的就是左节点是红色的）\"></a>删除操作-case4 （待调整的节点的兄弟节点是黑色的节点，且右子节点是红色的（兄弟节点在右边），如果兄弟节点在左边，则对应的就是左节点是红色的）</h5><p>case4的操作是真正的节点借调操作，通过将兄弟节点以及兄弟节点的右节点借调过来，并将兄弟节点的右子节点变成红色来达到借调两个黑色节点的目的，这样的话，整棵树还是符合RBTree定义的。</p>\n<p>case4这种情况的发生只有在待删除的节点的兄弟节点为黑，且子节点不全部为黑，才有可能借调到两个节点来做黑色节点使用，从而保持整棵树都符合红黑树的定义。</p>\n<p><img src=\"https://vqianxiao.github.io/blog/images/hashmap/delcase4.png\"></p>\n<p><strong>删除操作的总结</strong></p>\n<p>红黑树的删除操作是最复杂的操作，复杂的地方就在于当删除了黑色节点的时候，如何从兄弟节点去借调节点，以保证树的颜色符合定义。由于红色的兄弟节点是没法借调出黑色节点的，这样只能通过旋转操作让他上升到父节点，而由于它是红节点，所以它的子节点就是黑的，可以借调。</p>\n<p>对于兄弟节点是黑色节点的可以分成3种情况来处理，当所有的兄弟节点的子节点都是黑色节点时，可以直接将兄弟节点变红，这样局部的红黑树颜色是符合定义的。但是整棵树不一定是符合红黑树定义的，需要向上追溯继续调整。</p>\n<p>对于兄弟节点的子节点为左红右黑或者（全部为红）右红左黑这两种情况，可以先将前面的情况通过选择转换为后一种情况，在后一种情况下，因为兄弟节点为黑，兄弟节点的右节点为红，可以借调出两个节点出来做黑节点，这样就可以保证删除了黑节点，整棵树还是符合红黑树的定义的，因为黑色节点的个数没有改变。</p>\n<p>红黑树的删除操作是遇到删除的节点为红色，或者追溯调整到了root节点，这时删除的修复工作完毕。</p>\n<p><strong>红黑树总结</strong></p>\n<p>作为平衡二叉查找树里面众多的实现之一，红黑树无疑是最简洁、实现最为简单的。红黑树通过引入颜色的概念，通过颜色这个约束条件的使用来保持树的高度稳定。作为平衡二叉查找树，旋转是一个必不可少的操作，通过旋转可以降低树的高度，在红黑树里面还可以转换颜色。</p>\n<p>红黑树里面的插入和删除的操作比较难理解，这是要注意记住一点：操作之前红黑树是平衡的，颜色是符合定义的，在操作的时候就需要向兄弟节点、父节点、侄子节点借调和互换颜色，要达到这个目的，就需要不断的进行旋转。所以红黑树的插入删除操作需要不停的旋转，一旦借调了别的节点，删除和插入的节点就会达到局部的平衡（局部符合红黑树的定义），但是被借调的节点就不会平衡了，这时就需要以被借调的节点为起点继续进行调整，直到整棵树都是平衡的。在整个修复的过程中，插入可以分3种情况，删除分4种情况。</p>\n<p>整个红黑树的查找，插入和删除都是O(logN)的，原因就是整个红黑树的高度是logN，查找从根到叶，走过的路径是树的高度，删除和插入操作是从根到叶的，所以经过的路径都是logN。</p>\n<blockquote>\n<p>参考自 <a href=\"https://tech.meituan.com/2016/12/02/redblack-tree.html\">https://tech.meituan.com/2016/12/02/redblack-tree.html</a></p>\n</blockquote>\n"},{"layout":"post","title":"设计模式之模版模式","description":"设计模式之模版模式","date":"2021-06-03T05:26:10.000Z","_content":"\n模版模式主要是用来解决复用和扩展两个问题。模版模式，全称模版方法设计模式，因为是Template Method Design Pattern。在GoF的《设计模式》中，定义如下:\n\n> Define the skeleton of an algorithm in an operation,deferring some steps to subclasses.Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm's structure.\n\n翻译成中文就是：模版方法模式在一个方法中定义一个算法骨架，并将某些步骤推迟到子类中实现。模版方法模式可以让子类在不改变算法整体结构的情况下，重新定义算法中的某些步骤。\n\n这里的“算法”可以理解为广义上的“业务逻辑”。先看一个示例\n\n```java\npublic abstract class AbstractClass {\n  public final void templateMethod() {\n    // ...\n    method1();\n    // ...\n    method2();\n    // ...\n  }\n  \n  protected abstract void method1();\n  protected abstract void method2();\n}\n\npublic class ConcreteClass1 extends AbstractClass {\n  @Override\n  protected void method1() {\n    // ...\n  }\n  \n  @Override\n  protected void method2() {\n    // ...\n  }\n  \n  public class ConcreteClass2 extends AbstractClass {\n  @Override\n  protected void method1() {\n    // ...\n  }\n  \n  @Override\n  protected void method2() {\n    // ...\n  }\n    \n    AbstractClass demo = new ConcreteClass1();\n    demo.templateMethod();\n}\n```\n\n##### 模版模式的作用：\n\n##### 1.复用\n\n模版模式把一个算法中不变的流程抽象到父类的模版方法templateMethod()中，将可变的部分method1()、method2()留给子类来实现。所有的子类都可以复用父类中模版方法定义的流程代码。\n\nJava InputStream \n\nJava IO类库中，很多类的设计用到了模版模式，比如InputStream、OutputStream、Reader、Writer。\n\n看下InputStream代码，在代码中，read()函数是一个模版方法，定义了读取数据的整个流程，并且暴露了可以由子类来定制的抽象方法。\n\n```java\npublic abstract class InputStream implements Closeable {\n  // ...省略其他代码...\n  \n  public int read(byte[] b,int off,int len) throws IOException {\n    if(b == null) {\n      throw new NullPointException();\n    }else if (off < 0 || len <0 || len > b.length - off) {\n      throw new IndexOutOfBoundsException();\n    }else if (len == 0) {\n      return 0;\n    }\n    \n    int c = read();\n    if(c == -1) {\n      return -1;\n    }\n    b[off] = (byte) c;\n    \n    int i = 1;\n    try {\n      for(; i < len ; i++) {\n        c = read();\n        if(c == -1) {\n          break;\n        }\n        b[off + i] = (byte)c;\n      }\n    } catch(IOException ee) {\n      \n    }\n    return i;\n  }\n  \n  public abstract int read() throws IOException;\n}\n\npublic class ByteArrayinputStream extends InputStream {\n  //... 省略其他代码\n  \n  @Override\n  public synchronized int read() {\n    retunr (pos < count) ? (buf[pos++] & 0xff) : -1;\n  }\n}\n```\n\nJava AbstractList\n\n在Java AbstractList类中，addAll()函数可以看作模版方法，add()是子类需要重写的方法，尽管没有声明为abstract的，但是函数直接抛出异常。前提是，如果子类不重写是不能使用的。\n\n```java\npublic boolean addAll(int index,Collection<? extends E> c) {\n  rangeCheckForAdd(index);\n  boolean modified = false;\n  for(E e : c) {\n    add(index++, e);\n    modified = true;\n  }\n  return modified;\n}\n\npublic void add(int index,E element) {\n  //这里直接抛出异常，当子类不重写直接调用父类的add()函数直接抛出异常\n  throw new UnsupportedOperationException();\n}\n```\n\n\n\n##### 2.扩展\n\n这里说的扩展，并不是代码的扩展性，而是框架的扩展性，有点类似控制反转。通过Java Servlet、Junit TestCase来学习下。\n\nJava Servlet\n\n在没有SpringMVC的时候，使用比较底层的Servlet来开发Web项目，只需要定义一个继承HttpServlet的类，并且重写其中的doGet()或doPost()方法，分别来处理get和post请求。\n\n```java\npublic class HelloServlet extends HttpServlet {\n  @Override\n  protected void doGet(HttpServletRequest req,HttpServletResponse resp) throws ServletException, IOException {\n    this.doPost(req,resp);\n  }\n  \n   @Override\n  protected void doPost(HttpServletRequest req,HttpServletResponse resp) throws ServletException, IOException {\n    resp.getWriter().write(\"Hello World.\");\n  }\n}\n```\n\n除此之外，还需要在配置文件web.xml中配置下URL和Servlet的关系。Tomcat、Jetty等Servlet容器启动的时候，会自动加载这个配置文件中的对应关系。\n\n```xml\n\n<servlet>\n    <servlet-name>HelloServlet</servlet-name>\n    <servlet-class>com.xzg.cd.HelloServlet</servlet-class>\n</servlet>\n\n<servlet-mapping>\n    <servlet-name>HelloServlet</servlet-name>\n    <url-pattern>/hello</url-pattern>\n</servlet-mapping>\n```\n\n在浏览器输入网址，Servlet容器会接收到相应的请求，并且根据URL和Servlet的对应关系，找对对应的Servlet执行它的service()方法。service()方法定义在父类HttpServlet中，它会调用doGet()或doPost()方法，然后输出数据到网页。\n\n看下HttpServlet的service()的函数\n\n```java\n\npublic void service(ServletRequest req, ServletResponse res)\n    throws ServletException, IOException\n{\n    HttpServletRequest  request;\n    HttpServletResponse response;\n    if (!(req instanceof HttpServletRequest &&\n            res instanceof HttpServletResponse)) {\n        throw new ServletException(\"non-HTTP request or response\");\n    }\n    request = (HttpServletRequest) req;\n    response = (HttpServletResponse) res;\n    service(request, response);\n}\n\nprotected void service(HttpServletRequest req, HttpServletResponse resp)\n    throws ServletException, IOException\n{\n    String method = req.getMethod();\n    if (method.equals(METHOD_GET)) {\n        long lastModified = getLastModified(req);\n        if (lastModified == -1) {\n            // servlet doesn't support if-modified-since, no reason\n            // to go through further expensive logic\n            doGet(req, resp);\n        } else {\n            long ifModifiedSince = req.getDateHeader(HEADER_IFMODSINCE);\n            if (ifModifiedSince < lastModified) {\n                // If the servlet mod time is later, call doGet()\n                // Round down to the nearest second for a proper compare\n                // A ifModifiedSince of -1 will always be less\n                maybeSetLastModified(resp, lastModified);\n                doGet(req, resp);\n            } else {\n                resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED);\n            }\n        }\n    } else if (method.equals(METHOD_HEAD)) {\n        long lastModified = getLastModified(req);\n        maybeSetLastModified(resp, lastModified);\n        doHead(req, resp);\n    } else if (method.equals(METHOD_POST)) {\n        doPost(req, resp);\n    } else if (method.equals(METHOD_PUT)) {\n        doPut(req, resp);\n    } else if (method.equals(METHOD_DELETE)) {\n        doDelete(req, resp);\n    } else if (method.equals(METHOD_OPTIONS)) {\n        doOptions(req,resp);\n    } else if (method.equals(METHOD_TRACE)) {\n        doTrace(req,resp);\n    } else {\n        String errMsg = lStrings.getString(\"http.method_not_implemented\");\n        Object[] errArgs = new Object[1];\n        errArgs[0] = method;\n        errMsg = MessageFormat.format(errMsg, errArgs);\n        resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg);\n    }\n}\n```\n\nHttpServlet的service()方法就是一个模版方法，它实现了整个HTTP请求的执行流程，doGet()，doPost()是模版中可以由子类定制的部分。相当于Servlet框架提供了扩展点（doGet()，doPost()）,框架用户在不修改Servlet框架源码的情况下，将业务代码通过扩展点镶嵌到框架中执行。\n\nJUnit TestCase\n\nJUnit框架通过模版模式提供了一些功能扩展点（setUp()、teadDown()等），让框架用户可以在这些扩展点上扩展功能。在使用JUnit测试框架来编写单元测试的时候，编写的测试类都要继承框架提供的TestCase类。TestCase类中，runBare()函数是模版方法，它定义了执行测试用例的流程：先执行setUp()做准备工作，执行runTest()运行真正的测试代码，最后执行tearDown()做扫尾工作。\n\n```java\n\npublic abstract class TestCase extends Assert implements Test {\n  public void runBare() throws Throwable {\n    Throwable exception = null;\n    setUp();\n    try {\n      runTest();\n    } catch (Throwable running) {\n      exception = running;\n    } finally {\n      try {\n        tearDown();\n      } catch (Throwable tearingDown) {\n        if (exception == null) exception = tearingDown;\n      }\n    }\n    if (exception != null) throw exception;\n  }\n  \n  /**\n  * Sets up the fixture, for example, open a network connection.\n  * This method is called before a test is executed.\n  */\n  protected void setUp() throws Exception {\n  }\n\n  /**\n  * Tears down the fixture, for example, close a network connection.\n  * This method is called after a test is executed.\n  */\n  protected void tearDown() throws Exception {\n  }\n}\n```\n\n回调也能起到跟模版模式相同的作用。\n\n##### 回调的原理解析\n\nA调用B，B反过来又调用A，这种调用机制就叫“回调”。举个现实中的例子就是，张三去超市买牛奶，结果牛奶卖完了，张三给超市留了电话，让到货通知他，超市到货后通知张三，这就是回调。\n\n```java\npublic interface ICallback {\n  void methodToCallback();\n}\n\npublic class BClass {\n  public void process(ICallback callback) {\n    //...\n    callback.methodToCallback();\n    //...\n  }\n}\n\npublic class AClass {\n  public static void main(String[] args) {\n    BClass b = new BClass();\n    b.process(new ICallback() { //回调对象\n      @Override\n      public void methodToCallback() {\n        System.out.println(\"Call back me.\");\n      }\n    });\n  }\n}\n```\n\n回调不仅可以应用在代码设计上，在更高层次的架构设计上也比较常用。比如，通过三方支付系统来实现支付功能，用户在发起支付请求之后，一般不会一直阻塞到支付结果返回，而是注册回调接口（类似回调函数，一般是一个回调用的URL）给三方支付系统，等三方支付系统执行完成之后，将结果通过回调接口返回给用户。\n\n回调可以分为同步回调和异步回调（或延迟回调）。同步回调指在函数返回之前执行回调函数；异步回调指的是在函数返回之后执行回调函数。上面的代码是同步回调的实现方式，在process()函数返回之前，执行完回调函数methodToCallback()。支付回调的例子是异步回调的实现方式，发起支付之后不需要等待回调接口被调用就直接返回。从应用场景来看，同步回调看起来更像模版模式，异步回调更像观察者模式。\n\n应用举例：JdbcTemplate\n\nSpring提供了很多Template类，JdbcTemplate、RedisTemplate、RestTemplate。\n\nJava提供了JDBC类库来封装不同类型的数据库操作。不过，直接直接使用JDBC来编写操作数据库的代码，还是比较复杂的。\n\n```java\npublic class JdbcDemo {\n  public User queryUser(long id) {\n    Connection conn = null;\n    Statement stmt = null;\n    try {\n      //1.加载驱动\n      Class.forName(\"com.mysql.jdbc.Driver\");\n      conn = DriverManager.getConnectin(\"jdbc:mysql://localhost:3306/demo\",\"root\",\"123456\");\n      \n      //2.创建statement类对象，用来执行SQL语句\n      stmt = conn.createStatement();\n      \n      //3.ResultSet类，用来存放获取的结果集\n      String sql = \"select * from user where id = \" + id;\n      ResultSet result = stmt.executeQuery(sql);\n      \n      String eid = null,ename = null,price = null;\n      \n      while(resultSet.next()) {\n        User user = new User();\n        user.setId(resultSet.getLong(\"id\"));\n        user.setName(resultSet.getString(\"name\"));\n        user.setTelephone(resultSet.getString(\"telephone\"));\n        return user;\n      }\n    } catch(ClassnotFountException e) {\n      // log...\n    } catch(SQLException e) {\n      // log...\n    }finally {\n      if(conn != null) \n        try{\n          conn.close();\n        }catch(SQLException e) {\n          //log...\n        }\n      if(stmt != null) \n        try{\n          stmt.close();\n        } catch (SQLException e) {\n          //log...\n        }\n    }\n    return null;\n  }\n}\n```\n\nqueryUser()函数包含很多流程性质的代码，跟业务无关。比如，加载驱动、创建数据库连接、创建statement、关闭连接、关闭statement、处理异常。针对不同SQL执行请求，这些流程性质的代码是相同的、可以复用的。\n\nSpring提供了JdbcTemplate，对JDBC进一步封装，来简化数据库编程。\n\n```java\npublic class JdbcTemplateDemo {\n  private JdbcTemplate jdbcTemplate;\n  \n  public User queryUser(long id) {\n    String sql = \"select * from user where id =\" + id;\n    return jdbcTemplate.query(sql,new UserRowWrapper()).get(0);\n  }\n  \n  class UserRowMapper implements RowMapper<User> {\n    public User mapRow(ResultSet rs,int rowNum) throws SQLException {\n      User user = new User();\n      user.setId(rs.getLong(\"id\"));\n      user.setName(rs.getString(\"name\"));\n      user.setTelephone(rs.getString(\"telephone\"));\n      return user;\n    }\n  }\n}\n```\n\nJdbcTemplate代码较多，只摘抄部分相关代码。JdbcTemplate通过回调机制，将不变的流程抽离出来，放到模版方法execute()中，将可变的部分设计成回调StatementCallback，由用户来定制。query()是对execute()函数的二次封装，让接口用起来更加方便。\n\n```java\n@Override\npublic <T> List<T> query(String sql, RowMapper<T> rowMapper) throws DataAccessException {\n return query(sql, new RowMapperResultSetExtractor<T>(rowMapper));\n}\n\n@Override\npublic <T> T query(final String sql, final ResultSetExtractor<T> rse) throws DataAccessException {\n Assert.notNull(sql, \"SQL must not be null\");\n Assert.notNull(rse, \"ResultSetExtractor must not be null\");\n if (logger.isDebugEnabled()) {\n  logger.debug(\"Executing SQL query [\" + sql + \"]\");\n }\n\n class QueryStatementCallback implements StatementCallback<T>, SqlProvider {\n  @Override\n  public T doInStatement(Statement stmt) throws SQLException {\n   ResultSet rs = null;\n   try {\n    rs = stmt.executeQuery(sql);\n    ResultSet rsToUse = rs;\n    if (nativeJdbcExtractor != null) {\n     rsToUse = nativeJdbcExtractor.getNativeResultSet(rs);\n    }\n    return rse.extractData(rsToUse);\n   }\n   finally {\n    JdbcUtils.closeResultSet(rs);\n   }\n  }\n  @Override\n  public String getSql() {\n   return sql;\n  }\n }\n\n return execute(new QueryStatementCallback());\n}\n\n@Override\npublic <T> T execute(StatementCallback<T> action) throws DataAccessException {\n Assert.notNull(action, \"Callback object must not be null\");\n\n Connection con = DataSourceUtils.getConnection(getDataSource());\n Statement stmt = null;\n try {\n  Connection conToUse = con;\n  if (this.nativeJdbcExtractor != null &&\n    this.nativeJdbcExtractor.isNativeConnectionNecessaryForNativeStatements()) {\n   conToUse = this.nativeJdbcExtractor.getNativeConnection(con);\n  }\n  stmt = conToUse.createStatement();\n  applyStatementSettings(stmt);\n  Statement stmtToUse = stmt;\n  if (this.nativeJdbcExtractor != null) {\n   stmtToUse = this.nativeJdbcExtractor.getNativeStatement(stmt);\n  }\n  T result = action.doInStatement(stmtToUse);\n  handleWarnings(stmt);\n  return result;\n }\n catch (SQLException ex) {\n  // Release Connection early, to avoid potential connection pool deadlock\n  // in the case when the exception translator hasn't been initialized yet.\n  JdbcUtils.closeStatement(stmt);\n  stmt = null;\n  DataSourceUtils.releaseConnection(con, getDataSource());\n  con = null;\n  throw getExceptionTranslator().translate(\"StatementCallback\", getSql(action), ex);\n }\n finally {\n  JdbcUtils.closeStatement(stmt);\n  DataSourceUtils.releaseConnection(con, getDataSource());\n }\n}\n```\n\n应用举例 addShutdownHook()\n\nHook可以翻译成“钩子”。有人说Hook就是Callback，是一回事。Callback更侧重语法机制的描述，Hook更加侧重应用场景的描述。Hook比较经典的场景就是Tomcat和JVM的shutdown hook。JVM提供了Runtime.addShutdownHook(Thread hook)方法，可以注册一个JVM关闭的Hook。当应用程序关闭的时候，JVM会自动调用Hook代码。代码示例如下：\n\n```java\npublic class ShutdownHookDemo {\n  private static class ShutdownHook extends Thread {\n    public void run() {\n      System.out.println(\"I an called during shutting down.\");\n    }\n  }\n  \n  public static void main(String[] args) {\n    Runtime.getRuntime().addShutdownHook(new ShutdownHook()));\n  }\n}\n```\n\naddShutdownHook()代码部分相关实现如下：\n\n```java\npublic class Runtime {\n  public void addShutdownHook(Thread hook) {\n    Securitymanager sm = System.getSecurityManager();\n    if(sm != null) {\n      sm.checkPermission(new RuntimePermission(\"shutdownHooks\"));\n    }\n    ApplicationShutdownHooks.add(hook);\n  }\n}\n\nclass ApplicationShutdownHooks {\n  /* The set of registered hooks */\n  private static IdentityHashMap<Thread,Thread> hooks;\n  static {\n    hooks = new IdentityHashMap<>();\n  } catch (IllegalStateException e) {\n    hooks = null;\n  }\n}\n\nstatic synchronized void add(Thread hook) {\n  if(hooks == null) {\n    throw new IllegalStateException(\"Shutdown in progress\");\n  }\n  if(hook.isAlive()) {\n    throw new IllegalArgumentException(\"Hook already running\");\n  }\n  if(hooks.containsKey(hook)) {\n    throw new IllegalArgumentException(\"Hook previously registered\");\n  }\n  hooks.put(hook,hook);\n}\n\nstatic void runHooks() {\n  Collection<Thread> threads;\n  synchronized(ApplicationShutdownHooks.class) {\n    threads = hooks.keySet();\n    hooks = null;\n  }\n  \n  for (Thread hook : threads) {\n    hook.start();\n  }\n  for (Thread hook : threads) {\n    while(true) {\n      try {\n        hook.join();\n        break;\n      } catch (InterruptedException ignored) {}\n    }\n  }\n}\n```\n\n有关Hook的逻辑都封装到ApplicationShutdownHooks类中，应用程序关闭的时候，JVM会调用这个类的runHooks()方法，创建多个线程，并发地执行多个Hook。我们注册完Hook之后，并不需要等待Hook执行完成，所以也是一种异步回调。\n\n模版模式VS回调\n\n从应用场景上来看，同步回调和模版模式几乎一致。它们都是在一个大的算法骨架中，自由替换其中的某个步骤，起到代码复用和扩展的目的。异步回调跟模版模式有较大区别，更像观察者模式。\n\n从代码实现来看，回调和模版模式完全不同。回调基于组合关系来实现，把一个对象传递给另一个对象，是一种对象之间的关系；模版模式基于继承关系来实现，子类重写父类的抽象方法，是一种类之间的关系。\n\n回调相对于模版模式会更加灵活，主要体现在以下几点：\n\n- Java只支持单继承的语言，基于模版模式编写的子类，已经继承了一个父类，不再具有继承的能力\n- 回调可以使用匿名类来创建回调对象，可以不用实现定义类；而模版模式针对不同的实现都要定义不同的子类。\n- 如果某个类中定义了多个模版方法，每个方法都有对应的抽象方法，那即便只用到其中的一个模版方法，子类也必须实现所有的抽象方法。而回调就更加灵活，只需要往用的模版方法中注入回调对象即可。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/设计模式之模版模式.md","raw":"---\nlayout:    post\ntitle:     设计模式之模版模式\ncategory:  设计模式之美\ndescription: 设计模式之模版模式\ntags: 设计模式之美\ndate: 2021/06/03 13:26:10\n---\n\n模版模式主要是用来解决复用和扩展两个问题。模版模式，全称模版方法设计模式，因为是Template Method Design Pattern。在GoF的《设计模式》中，定义如下:\n\n> Define the skeleton of an algorithm in an operation,deferring some steps to subclasses.Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm's structure.\n\n翻译成中文就是：模版方法模式在一个方法中定义一个算法骨架，并将某些步骤推迟到子类中实现。模版方法模式可以让子类在不改变算法整体结构的情况下，重新定义算法中的某些步骤。\n\n这里的“算法”可以理解为广义上的“业务逻辑”。先看一个示例\n\n```java\npublic abstract class AbstractClass {\n  public final void templateMethod() {\n    // ...\n    method1();\n    // ...\n    method2();\n    // ...\n  }\n  \n  protected abstract void method1();\n  protected abstract void method2();\n}\n\npublic class ConcreteClass1 extends AbstractClass {\n  @Override\n  protected void method1() {\n    // ...\n  }\n  \n  @Override\n  protected void method2() {\n    // ...\n  }\n  \n  public class ConcreteClass2 extends AbstractClass {\n  @Override\n  protected void method1() {\n    // ...\n  }\n  \n  @Override\n  protected void method2() {\n    // ...\n  }\n    \n    AbstractClass demo = new ConcreteClass1();\n    demo.templateMethod();\n}\n```\n\n##### 模版模式的作用：\n\n##### 1.复用\n\n模版模式把一个算法中不变的流程抽象到父类的模版方法templateMethod()中，将可变的部分method1()、method2()留给子类来实现。所有的子类都可以复用父类中模版方法定义的流程代码。\n\nJava InputStream \n\nJava IO类库中，很多类的设计用到了模版模式，比如InputStream、OutputStream、Reader、Writer。\n\n看下InputStream代码，在代码中，read()函数是一个模版方法，定义了读取数据的整个流程，并且暴露了可以由子类来定制的抽象方法。\n\n```java\npublic abstract class InputStream implements Closeable {\n  // ...省略其他代码...\n  \n  public int read(byte[] b,int off,int len) throws IOException {\n    if(b == null) {\n      throw new NullPointException();\n    }else if (off < 0 || len <0 || len > b.length - off) {\n      throw new IndexOutOfBoundsException();\n    }else if (len == 0) {\n      return 0;\n    }\n    \n    int c = read();\n    if(c == -1) {\n      return -1;\n    }\n    b[off] = (byte) c;\n    \n    int i = 1;\n    try {\n      for(; i < len ; i++) {\n        c = read();\n        if(c == -1) {\n          break;\n        }\n        b[off + i] = (byte)c;\n      }\n    } catch(IOException ee) {\n      \n    }\n    return i;\n  }\n  \n  public abstract int read() throws IOException;\n}\n\npublic class ByteArrayinputStream extends InputStream {\n  //... 省略其他代码\n  \n  @Override\n  public synchronized int read() {\n    retunr (pos < count) ? (buf[pos++] & 0xff) : -1;\n  }\n}\n```\n\nJava AbstractList\n\n在Java AbstractList类中，addAll()函数可以看作模版方法，add()是子类需要重写的方法，尽管没有声明为abstract的，但是函数直接抛出异常。前提是，如果子类不重写是不能使用的。\n\n```java\npublic boolean addAll(int index,Collection<? extends E> c) {\n  rangeCheckForAdd(index);\n  boolean modified = false;\n  for(E e : c) {\n    add(index++, e);\n    modified = true;\n  }\n  return modified;\n}\n\npublic void add(int index,E element) {\n  //这里直接抛出异常，当子类不重写直接调用父类的add()函数直接抛出异常\n  throw new UnsupportedOperationException();\n}\n```\n\n\n\n##### 2.扩展\n\n这里说的扩展，并不是代码的扩展性，而是框架的扩展性，有点类似控制反转。通过Java Servlet、Junit TestCase来学习下。\n\nJava Servlet\n\n在没有SpringMVC的时候，使用比较底层的Servlet来开发Web项目，只需要定义一个继承HttpServlet的类，并且重写其中的doGet()或doPost()方法，分别来处理get和post请求。\n\n```java\npublic class HelloServlet extends HttpServlet {\n  @Override\n  protected void doGet(HttpServletRequest req,HttpServletResponse resp) throws ServletException, IOException {\n    this.doPost(req,resp);\n  }\n  \n   @Override\n  protected void doPost(HttpServletRequest req,HttpServletResponse resp) throws ServletException, IOException {\n    resp.getWriter().write(\"Hello World.\");\n  }\n}\n```\n\n除此之外，还需要在配置文件web.xml中配置下URL和Servlet的关系。Tomcat、Jetty等Servlet容器启动的时候，会自动加载这个配置文件中的对应关系。\n\n```xml\n\n<servlet>\n    <servlet-name>HelloServlet</servlet-name>\n    <servlet-class>com.xzg.cd.HelloServlet</servlet-class>\n</servlet>\n\n<servlet-mapping>\n    <servlet-name>HelloServlet</servlet-name>\n    <url-pattern>/hello</url-pattern>\n</servlet-mapping>\n```\n\n在浏览器输入网址，Servlet容器会接收到相应的请求，并且根据URL和Servlet的对应关系，找对对应的Servlet执行它的service()方法。service()方法定义在父类HttpServlet中，它会调用doGet()或doPost()方法，然后输出数据到网页。\n\n看下HttpServlet的service()的函数\n\n```java\n\npublic void service(ServletRequest req, ServletResponse res)\n    throws ServletException, IOException\n{\n    HttpServletRequest  request;\n    HttpServletResponse response;\n    if (!(req instanceof HttpServletRequest &&\n            res instanceof HttpServletResponse)) {\n        throw new ServletException(\"non-HTTP request or response\");\n    }\n    request = (HttpServletRequest) req;\n    response = (HttpServletResponse) res;\n    service(request, response);\n}\n\nprotected void service(HttpServletRequest req, HttpServletResponse resp)\n    throws ServletException, IOException\n{\n    String method = req.getMethod();\n    if (method.equals(METHOD_GET)) {\n        long lastModified = getLastModified(req);\n        if (lastModified == -1) {\n            // servlet doesn't support if-modified-since, no reason\n            // to go through further expensive logic\n            doGet(req, resp);\n        } else {\n            long ifModifiedSince = req.getDateHeader(HEADER_IFMODSINCE);\n            if (ifModifiedSince < lastModified) {\n                // If the servlet mod time is later, call doGet()\n                // Round down to the nearest second for a proper compare\n                // A ifModifiedSince of -1 will always be less\n                maybeSetLastModified(resp, lastModified);\n                doGet(req, resp);\n            } else {\n                resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED);\n            }\n        }\n    } else if (method.equals(METHOD_HEAD)) {\n        long lastModified = getLastModified(req);\n        maybeSetLastModified(resp, lastModified);\n        doHead(req, resp);\n    } else if (method.equals(METHOD_POST)) {\n        doPost(req, resp);\n    } else if (method.equals(METHOD_PUT)) {\n        doPut(req, resp);\n    } else if (method.equals(METHOD_DELETE)) {\n        doDelete(req, resp);\n    } else if (method.equals(METHOD_OPTIONS)) {\n        doOptions(req,resp);\n    } else if (method.equals(METHOD_TRACE)) {\n        doTrace(req,resp);\n    } else {\n        String errMsg = lStrings.getString(\"http.method_not_implemented\");\n        Object[] errArgs = new Object[1];\n        errArgs[0] = method;\n        errMsg = MessageFormat.format(errMsg, errArgs);\n        resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg);\n    }\n}\n```\n\nHttpServlet的service()方法就是一个模版方法，它实现了整个HTTP请求的执行流程，doGet()，doPost()是模版中可以由子类定制的部分。相当于Servlet框架提供了扩展点（doGet()，doPost()）,框架用户在不修改Servlet框架源码的情况下，将业务代码通过扩展点镶嵌到框架中执行。\n\nJUnit TestCase\n\nJUnit框架通过模版模式提供了一些功能扩展点（setUp()、teadDown()等），让框架用户可以在这些扩展点上扩展功能。在使用JUnit测试框架来编写单元测试的时候，编写的测试类都要继承框架提供的TestCase类。TestCase类中，runBare()函数是模版方法，它定义了执行测试用例的流程：先执行setUp()做准备工作，执行runTest()运行真正的测试代码，最后执行tearDown()做扫尾工作。\n\n```java\n\npublic abstract class TestCase extends Assert implements Test {\n  public void runBare() throws Throwable {\n    Throwable exception = null;\n    setUp();\n    try {\n      runTest();\n    } catch (Throwable running) {\n      exception = running;\n    } finally {\n      try {\n        tearDown();\n      } catch (Throwable tearingDown) {\n        if (exception == null) exception = tearingDown;\n      }\n    }\n    if (exception != null) throw exception;\n  }\n  \n  /**\n  * Sets up the fixture, for example, open a network connection.\n  * This method is called before a test is executed.\n  */\n  protected void setUp() throws Exception {\n  }\n\n  /**\n  * Tears down the fixture, for example, close a network connection.\n  * This method is called after a test is executed.\n  */\n  protected void tearDown() throws Exception {\n  }\n}\n```\n\n回调也能起到跟模版模式相同的作用。\n\n##### 回调的原理解析\n\nA调用B，B反过来又调用A，这种调用机制就叫“回调”。举个现实中的例子就是，张三去超市买牛奶，结果牛奶卖完了，张三给超市留了电话，让到货通知他，超市到货后通知张三，这就是回调。\n\n```java\npublic interface ICallback {\n  void methodToCallback();\n}\n\npublic class BClass {\n  public void process(ICallback callback) {\n    //...\n    callback.methodToCallback();\n    //...\n  }\n}\n\npublic class AClass {\n  public static void main(String[] args) {\n    BClass b = new BClass();\n    b.process(new ICallback() { //回调对象\n      @Override\n      public void methodToCallback() {\n        System.out.println(\"Call back me.\");\n      }\n    });\n  }\n}\n```\n\n回调不仅可以应用在代码设计上，在更高层次的架构设计上也比较常用。比如，通过三方支付系统来实现支付功能，用户在发起支付请求之后，一般不会一直阻塞到支付结果返回，而是注册回调接口（类似回调函数，一般是一个回调用的URL）给三方支付系统，等三方支付系统执行完成之后，将结果通过回调接口返回给用户。\n\n回调可以分为同步回调和异步回调（或延迟回调）。同步回调指在函数返回之前执行回调函数；异步回调指的是在函数返回之后执行回调函数。上面的代码是同步回调的实现方式，在process()函数返回之前，执行完回调函数methodToCallback()。支付回调的例子是异步回调的实现方式，发起支付之后不需要等待回调接口被调用就直接返回。从应用场景来看，同步回调看起来更像模版模式，异步回调更像观察者模式。\n\n应用举例：JdbcTemplate\n\nSpring提供了很多Template类，JdbcTemplate、RedisTemplate、RestTemplate。\n\nJava提供了JDBC类库来封装不同类型的数据库操作。不过，直接直接使用JDBC来编写操作数据库的代码，还是比较复杂的。\n\n```java\npublic class JdbcDemo {\n  public User queryUser(long id) {\n    Connection conn = null;\n    Statement stmt = null;\n    try {\n      //1.加载驱动\n      Class.forName(\"com.mysql.jdbc.Driver\");\n      conn = DriverManager.getConnectin(\"jdbc:mysql://localhost:3306/demo\",\"root\",\"123456\");\n      \n      //2.创建statement类对象，用来执行SQL语句\n      stmt = conn.createStatement();\n      \n      //3.ResultSet类，用来存放获取的结果集\n      String sql = \"select * from user where id = \" + id;\n      ResultSet result = stmt.executeQuery(sql);\n      \n      String eid = null,ename = null,price = null;\n      \n      while(resultSet.next()) {\n        User user = new User();\n        user.setId(resultSet.getLong(\"id\"));\n        user.setName(resultSet.getString(\"name\"));\n        user.setTelephone(resultSet.getString(\"telephone\"));\n        return user;\n      }\n    } catch(ClassnotFountException e) {\n      // log...\n    } catch(SQLException e) {\n      // log...\n    }finally {\n      if(conn != null) \n        try{\n          conn.close();\n        }catch(SQLException e) {\n          //log...\n        }\n      if(stmt != null) \n        try{\n          stmt.close();\n        } catch (SQLException e) {\n          //log...\n        }\n    }\n    return null;\n  }\n}\n```\n\nqueryUser()函数包含很多流程性质的代码，跟业务无关。比如，加载驱动、创建数据库连接、创建statement、关闭连接、关闭statement、处理异常。针对不同SQL执行请求，这些流程性质的代码是相同的、可以复用的。\n\nSpring提供了JdbcTemplate，对JDBC进一步封装，来简化数据库编程。\n\n```java\npublic class JdbcTemplateDemo {\n  private JdbcTemplate jdbcTemplate;\n  \n  public User queryUser(long id) {\n    String sql = \"select * from user where id =\" + id;\n    return jdbcTemplate.query(sql,new UserRowWrapper()).get(0);\n  }\n  \n  class UserRowMapper implements RowMapper<User> {\n    public User mapRow(ResultSet rs,int rowNum) throws SQLException {\n      User user = new User();\n      user.setId(rs.getLong(\"id\"));\n      user.setName(rs.getString(\"name\"));\n      user.setTelephone(rs.getString(\"telephone\"));\n      return user;\n    }\n  }\n}\n```\n\nJdbcTemplate代码较多，只摘抄部分相关代码。JdbcTemplate通过回调机制，将不变的流程抽离出来，放到模版方法execute()中，将可变的部分设计成回调StatementCallback，由用户来定制。query()是对execute()函数的二次封装，让接口用起来更加方便。\n\n```java\n@Override\npublic <T> List<T> query(String sql, RowMapper<T> rowMapper) throws DataAccessException {\n return query(sql, new RowMapperResultSetExtractor<T>(rowMapper));\n}\n\n@Override\npublic <T> T query(final String sql, final ResultSetExtractor<T> rse) throws DataAccessException {\n Assert.notNull(sql, \"SQL must not be null\");\n Assert.notNull(rse, \"ResultSetExtractor must not be null\");\n if (logger.isDebugEnabled()) {\n  logger.debug(\"Executing SQL query [\" + sql + \"]\");\n }\n\n class QueryStatementCallback implements StatementCallback<T>, SqlProvider {\n  @Override\n  public T doInStatement(Statement stmt) throws SQLException {\n   ResultSet rs = null;\n   try {\n    rs = stmt.executeQuery(sql);\n    ResultSet rsToUse = rs;\n    if (nativeJdbcExtractor != null) {\n     rsToUse = nativeJdbcExtractor.getNativeResultSet(rs);\n    }\n    return rse.extractData(rsToUse);\n   }\n   finally {\n    JdbcUtils.closeResultSet(rs);\n   }\n  }\n  @Override\n  public String getSql() {\n   return sql;\n  }\n }\n\n return execute(new QueryStatementCallback());\n}\n\n@Override\npublic <T> T execute(StatementCallback<T> action) throws DataAccessException {\n Assert.notNull(action, \"Callback object must not be null\");\n\n Connection con = DataSourceUtils.getConnection(getDataSource());\n Statement stmt = null;\n try {\n  Connection conToUse = con;\n  if (this.nativeJdbcExtractor != null &&\n    this.nativeJdbcExtractor.isNativeConnectionNecessaryForNativeStatements()) {\n   conToUse = this.nativeJdbcExtractor.getNativeConnection(con);\n  }\n  stmt = conToUse.createStatement();\n  applyStatementSettings(stmt);\n  Statement stmtToUse = stmt;\n  if (this.nativeJdbcExtractor != null) {\n   stmtToUse = this.nativeJdbcExtractor.getNativeStatement(stmt);\n  }\n  T result = action.doInStatement(stmtToUse);\n  handleWarnings(stmt);\n  return result;\n }\n catch (SQLException ex) {\n  // Release Connection early, to avoid potential connection pool deadlock\n  // in the case when the exception translator hasn't been initialized yet.\n  JdbcUtils.closeStatement(stmt);\n  stmt = null;\n  DataSourceUtils.releaseConnection(con, getDataSource());\n  con = null;\n  throw getExceptionTranslator().translate(\"StatementCallback\", getSql(action), ex);\n }\n finally {\n  JdbcUtils.closeStatement(stmt);\n  DataSourceUtils.releaseConnection(con, getDataSource());\n }\n}\n```\n\n应用举例 addShutdownHook()\n\nHook可以翻译成“钩子”。有人说Hook就是Callback，是一回事。Callback更侧重语法机制的描述，Hook更加侧重应用场景的描述。Hook比较经典的场景就是Tomcat和JVM的shutdown hook。JVM提供了Runtime.addShutdownHook(Thread hook)方法，可以注册一个JVM关闭的Hook。当应用程序关闭的时候，JVM会自动调用Hook代码。代码示例如下：\n\n```java\npublic class ShutdownHookDemo {\n  private static class ShutdownHook extends Thread {\n    public void run() {\n      System.out.println(\"I an called during shutting down.\");\n    }\n  }\n  \n  public static void main(String[] args) {\n    Runtime.getRuntime().addShutdownHook(new ShutdownHook()));\n  }\n}\n```\n\naddShutdownHook()代码部分相关实现如下：\n\n```java\npublic class Runtime {\n  public void addShutdownHook(Thread hook) {\n    Securitymanager sm = System.getSecurityManager();\n    if(sm != null) {\n      sm.checkPermission(new RuntimePermission(\"shutdownHooks\"));\n    }\n    ApplicationShutdownHooks.add(hook);\n  }\n}\n\nclass ApplicationShutdownHooks {\n  /* The set of registered hooks */\n  private static IdentityHashMap<Thread,Thread> hooks;\n  static {\n    hooks = new IdentityHashMap<>();\n  } catch (IllegalStateException e) {\n    hooks = null;\n  }\n}\n\nstatic synchronized void add(Thread hook) {\n  if(hooks == null) {\n    throw new IllegalStateException(\"Shutdown in progress\");\n  }\n  if(hook.isAlive()) {\n    throw new IllegalArgumentException(\"Hook already running\");\n  }\n  if(hooks.containsKey(hook)) {\n    throw new IllegalArgumentException(\"Hook previously registered\");\n  }\n  hooks.put(hook,hook);\n}\n\nstatic void runHooks() {\n  Collection<Thread> threads;\n  synchronized(ApplicationShutdownHooks.class) {\n    threads = hooks.keySet();\n    hooks = null;\n  }\n  \n  for (Thread hook : threads) {\n    hook.start();\n  }\n  for (Thread hook : threads) {\n    while(true) {\n      try {\n        hook.join();\n        break;\n      } catch (InterruptedException ignored) {}\n    }\n  }\n}\n```\n\n有关Hook的逻辑都封装到ApplicationShutdownHooks类中，应用程序关闭的时候，JVM会调用这个类的runHooks()方法，创建多个线程，并发地执行多个Hook。我们注册完Hook之后，并不需要等待Hook执行完成，所以也是一种异步回调。\n\n模版模式VS回调\n\n从应用场景上来看，同步回调和模版模式几乎一致。它们都是在一个大的算法骨架中，自由替换其中的某个步骤，起到代码复用和扩展的目的。异步回调跟模版模式有较大区别，更像观察者模式。\n\n从代码实现来看，回调和模版模式完全不同。回调基于组合关系来实现，把一个对象传递给另一个对象，是一种对象之间的关系；模版模式基于继承关系来实现，子类重写父类的抽象方法，是一种类之间的关系。\n\n回调相对于模版模式会更加灵活，主要体现在以下几点：\n\n- Java只支持单继承的语言，基于模版模式编写的子类，已经继承了一个父类，不再具有继承的能力\n- 回调可以使用匿名类来创建回调对象，可以不用实现定义类；而模版模式针对不同的实现都要定义不同的子类。\n- 如果某个类中定义了多个模版方法，每个方法都有对应的抽象方法，那即便只用到其中的一个模版方法，子类也必须实现所有的抽象方法。而回调就更加灵活，只需要往用的模版方法中注入回调对象即可。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"设计模式之模版模式","published":1,"updated":"2021-06-03T05:26:10.000Z","comments":1,"photos":[],"link":"","_id":"cm1m304ya003w31b4ckhh1ndt","content":"<p>模版模式主要是用来解决复用和扩展两个问题。模版模式，全称模版方法设计模式，因为是Template Method Design Pattern。在GoF的《设计模式》中，定义如下:</p>\n<blockquote>\n<p>Define the skeleton of an algorithm in an operation,deferring some steps to subclasses.Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm’s structure.</p>\n</blockquote>\n<p>翻译成中文就是：模版方法模式在一个方法中定义一个算法骨架，并将某些步骤推迟到子类中实现。模版方法模式可以让子类在不改变算法整体结构的情况下，重新定义算法中的某些步骤。</p>\n<p>这里的“算法”可以理解为广义上的“业务逻辑”。先看一个示例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AbstractClass</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">templateMethod</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    method1();</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    method2();</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">method1</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">method2</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConcreteClass1</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractClass</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">method1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">method2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConcreteClass2</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractClass</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">method1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">method2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    AbstractClass demo = <span class=\"keyword\">new</span> ConcreteClass1();</span><br><span class=\"line\">    demo.templateMethod();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"模版模式的作用：\"><a href=\"#模版模式的作用：\" class=\"headerlink\" title=\"模版模式的作用：\"></a>模版模式的作用：</h5><h5 id=\"1-复用\"><a href=\"#1-复用\" class=\"headerlink\" title=\"1.复用\"></a>1.复用</h5><p>模版模式把一个算法中不变的流程抽象到父类的模版方法templateMethod()中，将可变的部分method1()、method2()留给子类来实现。所有的子类都可以复用父类中模版方法定义的流程代码。</p>\n<p>Java InputStream </p>\n<p>Java IO类库中，很多类的设计用到了模版模式，比如InputStream、OutputStream、Reader、Writer。</p>\n<p>看下InputStream代码，在代码中，read()函数是一个模版方法，定义了读取数据的整个流程，并且暴露了可以由子类来定制的抽象方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InputStream</span> <span class=\"keyword\">implements</span> <span class=\"title\">Closeable</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...省略其他代码...</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">read</span><span class=\"params\">(<span class=\"keyword\">byte</span>[] b,<span class=\"keyword\">int</span> off,<span class=\"keyword\">int</span> len)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(b == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointException();</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (off &lt; <span class=\"number\">0</span> || len &lt;<span class=\"number\">0</span> || len &gt; b.length - off) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IndexOutOfBoundsException();</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (len == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> c = read();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(c == -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    b[off] = (<span class=\"keyword\">byte</span>) c;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span>(; i &lt; len ; i++) &#123;</span><br><span class=\"line\">        c = read();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(c == -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        b[off + i] = (<span class=\"keyword\">byte</span>)c;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span>(IOException ee) &#123;</span><br><span class=\"line\">      </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">int</span> <span class=\"title\">read</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ByteArrayinputStream</span> <span class=\"keyword\">extends</span> <span class=\"title\">InputStream</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//... 省略其他代码</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">int</span> <span class=\"title\">read</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    retunr (pos &lt; count) ? (buf[pos++] &amp; <span class=\"number\">0xff</span>) : -<span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Java AbstractList</p>\n<p>在Java AbstractList类中，addAll()函数可以看作模版方法，add()是子类需要重写的方法，尽管没有声明为abstract的，但是函数直接抛出异常。前提是，如果子类不重写是不能使用的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">addAll</span><span class=\"params\">(<span class=\"keyword\">int</span> index,Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class=\"line\">  rangeCheckForAdd(index);</span><br><span class=\"line\">  <span class=\"keyword\">boolean</span> modified = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(E e : c) &#123;</span><br><span class=\"line\">    add(index++, e);</span><br><span class=\"line\">    modified = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> modified;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> index,E element)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//这里直接抛出异常，当子类不重写直接调用父类的add()函数直接抛出异常</span></span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> UnsupportedOperationException();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"2-扩展\"><a href=\"#2-扩展\" class=\"headerlink\" title=\"2.扩展\"></a>2.扩展</h5><p>这里说的扩展，并不是代码的扩展性，而是框架的扩展性，有点类似控制反转。通过Java Servlet、Junit TestCase来学习下。</p>\n<p>Java Servlet</p>\n<p>在没有SpringMVC的时候，使用比较底层的Servlet来开发Web项目，只需要定义一个继承HttpServlet的类，并且重写其中的doGet()或doPost()方法，分别来处理get和post请求。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloServlet</span> <span class=\"keyword\">extends</span> <span class=\"title\">HttpServlet</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">doGet</span><span class=\"params\">(HttpServletRequest req,HttpServletResponse resp)</span> <span class=\"keyword\">throws</span> ServletException, IOException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.doPost(req,resp);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">   <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">doPost</span><span class=\"params\">(HttpServletRequest req,HttpServletResponse resp)</span> <span class=\"keyword\">throws</span> ServletException, IOException </span>&#123;</span><br><span class=\"line\">    resp.getWriter().write(<span class=\"string\">&quot;Hello World.&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>除此之外，还需要在配置文件web.xml中配置下URL和Servlet的关系。Tomcat、Jetty等Servlet容器启动的时候，会自动加载这个配置文件中的对应关系。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>HelloServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span>com.xzg.cd.HelloServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-class</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>HelloServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/hello<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>在浏览器输入网址，Servlet容器会接收到相应的请求，并且根据URL和Servlet的对应关系，找对对应的Servlet执行它的service()方法。service()方法定义在父类HttpServlet中，它会调用doGet()或doPost()方法，然后输出数据到网页。</p>\n<p>看下HttpServlet的service()的函数</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">service</span><span class=\"params\">(ServletRequest req, ServletResponse res)</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"keyword\">throws</span> ServletException, IOException</span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    HttpServletRequest  request;</span><br><span class=\"line\">    HttpServletResponse response;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!(req <span class=\"keyword\">instanceof</span> HttpServletRequest &amp;&amp;</span><br><span class=\"line\">            res <span class=\"keyword\">instanceof</span> HttpServletResponse)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ServletException(<span class=\"string\">&quot;non-HTTP request or response&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    request = (HttpServletRequest) req;</span><br><span class=\"line\">    response = (HttpServletResponse) res;</span><br><span class=\"line\">    service(request, response);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">service</span><span class=\"params\">(HttpServletRequest req, HttpServletResponse resp)</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"keyword\">throws</span> ServletException, IOException</span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    String method = req.getMethod();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (method.equals(METHOD_GET)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> lastModified = getLastModified(req);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (lastModified == -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// servlet doesn&#x27;t support if-modified-since, no reason</span></span><br><span class=\"line\">            <span class=\"comment\">// to go through further expensive logic</span></span><br><span class=\"line\">            doGet(req, resp);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">long</span> ifModifiedSince = req.getDateHeader(HEADER_IFMODSINCE);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ifModifiedSince &lt; lastModified) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// If the servlet mod time is later, call doGet()</span></span><br><span class=\"line\">                <span class=\"comment\">// Round down to the nearest second for a proper compare</span></span><br><span class=\"line\">                <span class=\"comment\">// A ifModifiedSince of -1 will always be less</span></span><br><span class=\"line\">                maybeSetLastModified(resp, lastModified);</span><br><span class=\"line\">                doGet(req, resp);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (method.equals(METHOD_HEAD)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> lastModified = getLastModified(req);</span><br><span class=\"line\">        maybeSetLastModified(resp, lastModified);</span><br><span class=\"line\">        doHead(req, resp);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (method.equals(METHOD_POST)) &#123;</span><br><span class=\"line\">        doPost(req, resp);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (method.equals(METHOD_PUT)) &#123;</span><br><span class=\"line\">        doPut(req, resp);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (method.equals(METHOD_DELETE)) &#123;</span><br><span class=\"line\">        doDelete(req, resp);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (method.equals(METHOD_OPTIONS)) &#123;</span><br><span class=\"line\">        doOptions(req,resp);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (method.equals(METHOD_TRACE)) &#123;</span><br><span class=\"line\">        doTrace(req,resp);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        String errMsg = lStrings.getString(<span class=\"string\">&quot;http.method_not_implemented&quot;</span>);</span><br><span class=\"line\">        Object[] errArgs = <span class=\"keyword\">new</span> Object[<span class=\"number\">1</span>];</span><br><span class=\"line\">        errArgs[<span class=\"number\">0</span>] = method;</span><br><span class=\"line\">        errMsg = MessageFormat.format(errMsg, errArgs);</span><br><span class=\"line\">        resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>HttpServlet的service()方法就是一个模版方法，它实现了整个HTTP请求的执行流程，doGet()，doPost()是模版中可以由子类定制的部分。相当于Servlet框架提供了扩展点（doGet()，doPost()）,框架用户在不修改Servlet框架源码的情况下，将业务代码通过扩展点镶嵌到框架中执行。</p>\n<p>JUnit TestCase</p>\n<p>JUnit框架通过模版模式提供了一些功能扩展点（setUp()、teadDown()等），让框架用户可以在这些扩展点上扩展功能。在使用JUnit测试框架来编写单元测试的时候，编写的测试类都要继承框架提供的TestCase类。TestCase类中，runBare()函数是模版方法，它定义了执行测试用例的流程：先执行setUp()做准备工作，执行runTest()运行真正的测试代码，最后执行tearDown()做扫尾工作。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestCase</span> <span class=\"keyword\">extends</span> <span class=\"title\">Assert</span> <span class=\"keyword\">implements</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">runBare</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">    Throwable exception = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    setUp();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      runTest();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Throwable running) &#123;</span><br><span class=\"line\">      exception = running;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        tearDown();</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (Throwable tearingDown) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (exception == <span class=\"keyword\">null</span>) exception = tearingDown;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (exception != <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> exception;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * Sets up the fixture, for example, open a network connection.</span></span><br><span class=\"line\"><span class=\"comment\">  * This method is called before a test is executed.</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">setUp</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * Tears down the fixture, for example, close a network connection.</span></span><br><span class=\"line\"><span class=\"comment\">  * This method is called after a test is executed.</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">tearDown</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>回调也能起到跟模版模式相同的作用。</p>\n<h5 id=\"回调的原理解析\"><a href=\"#回调的原理解析\" class=\"headerlink\" title=\"回调的原理解析\"></a>回调的原理解析</h5><p>A调用B，B反过来又调用A，这种调用机制就叫“回调”。举个现实中的例子就是，张三去超市买牛奶，结果牛奶卖完了，张三给超市留了电话，让到货通知他，超市到货后通知张三，这就是回调。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ICallback</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">methodToCallback</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BClass</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">process</span><span class=\"params\">(ICallback callback)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    callback.methodToCallback();</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AClass</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    BClass b = <span class=\"keyword\">new</span> BClass();</span><br><span class=\"line\">    b.process(<span class=\"keyword\">new</span> ICallback() &#123; <span class=\"comment\">//回调对象</span></span><br><span class=\"line\">      <span class=\"meta\">@Override</span></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">methodToCallback</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Call back me.&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>回调不仅可以应用在代码设计上，在更高层次的架构设计上也比较常用。比如，通过三方支付系统来实现支付功能，用户在发起支付请求之后，一般不会一直阻塞到支付结果返回，而是注册回调接口（类似回调函数，一般是一个回调用的URL）给三方支付系统，等三方支付系统执行完成之后，将结果通过回调接口返回给用户。</p>\n<p>回调可以分为同步回调和异步回调（或延迟回调）。同步回调指在函数返回之前执行回调函数；异步回调指的是在函数返回之后执行回调函数。上面的代码是同步回调的实现方式，在process()函数返回之前，执行完回调函数methodToCallback()。支付回调的例子是异步回调的实现方式，发起支付之后不需要等待回调接口被调用就直接返回。从应用场景来看，同步回调看起来更像模版模式，异步回调更像观察者模式。</p>\n<p>应用举例：JdbcTemplate</p>\n<p>Spring提供了很多Template类，JdbcTemplate、RedisTemplate、RestTemplate。</p>\n<p>Java提供了JDBC类库来封装不同类型的数据库操作。不过，直接直接使用JDBC来编写操作数据库的代码，还是比较复杂的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JdbcDemo</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> User <span class=\"title\">queryUser</span><span class=\"params\">(<span class=\"keyword\">long</span> id)</span> </span>&#123;</span><br><span class=\"line\">    Connection conn = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    Statement stmt = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">//1.加载驱动</span></span><br><span class=\"line\">      Class.forName(<span class=\"string\">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class=\"line\">      conn = DriverManager.getConnectin(<span class=\"string\">&quot;jdbc:mysql://localhost:3306/demo&quot;</span>,<span class=\"string\">&quot;root&quot;</span>,<span class=\"string\">&quot;123456&quot;</span>);</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"comment\">//2.创建statement类对象，用来执行SQL语句</span></span><br><span class=\"line\">      stmt = conn.createStatement();</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"comment\">//3.ResultSet类，用来存放获取的结果集</span></span><br><span class=\"line\">      String sql = <span class=\"string\">&quot;select * from user where id = &quot;</span> + id;</span><br><span class=\"line\">      ResultSet result = stmt.executeQuery(sql);</span><br><span class=\"line\">      </span><br><span class=\"line\">      String eid = <span class=\"keyword\">null</span>,ename = <span class=\"keyword\">null</span>,price = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"keyword\">while</span>(resultSet.next()) &#123;</span><br><span class=\"line\">        User user = <span class=\"keyword\">new</span> User();</span><br><span class=\"line\">        user.setId(resultSet.getLong(<span class=\"string\">&quot;id&quot;</span>));</span><br><span class=\"line\">        user.setName(resultSet.getString(<span class=\"string\">&quot;name&quot;</span>));</span><br><span class=\"line\">        user.setTelephone(resultSet.getString(<span class=\"string\">&quot;telephone&quot;</span>));</span><br><span class=\"line\">        <span class=\"keyword\">return</span> user;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span>(ClassnotFountException e) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// log...</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span>(SQLException e) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// log...</span></span><br><span class=\"line\">    &#125;<span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(conn != <span class=\"keyword\">null</span>) </span><br><span class=\"line\">        <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">          conn.close();</span><br><span class=\"line\">        &#125;<span class=\"keyword\">catch</span>(SQLException e) &#123;</span><br><span class=\"line\">          <span class=\"comment\">//log...</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(stmt != <span class=\"keyword\">null</span>) </span><br><span class=\"line\">        <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">          stmt.close();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (SQLException e) &#123;</span><br><span class=\"line\">          <span class=\"comment\">//log...</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>queryUser()函数包含很多流程性质的代码，跟业务无关。比如，加载驱动、创建数据库连接、创建statement、关闭连接、关闭statement、处理异常。针对不同SQL执行请求，这些流程性质的代码是相同的、可以复用的。</p>\n<p>Spring提供了JdbcTemplate，对JDBC进一步封装，来简化数据库编程。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JdbcTemplateDemo</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> JdbcTemplate jdbcTemplate;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> User <span class=\"title\">queryUser</span><span class=\"params\">(<span class=\"keyword\">long</span> id)</span> </span>&#123;</span><br><span class=\"line\">    String sql = <span class=\"string\">&quot;select * from user where id =&quot;</span> + id;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> jdbcTemplate.query(sql,<span class=\"keyword\">new</span> UserRowWrapper()).get(<span class=\"number\">0</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserRowMapper</span> <span class=\"keyword\">implements</span> <span class=\"title\">RowMapper</span>&lt;<span class=\"title\">User</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> User <span class=\"title\">mapRow</span><span class=\"params\">(ResultSet rs,<span class=\"keyword\">int</span> rowNum)</span> <span class=\"keyword\">throws</span> SQLException </span>&#123;</span><br><span class=\"line\">      User user = <span class=\"keyword\">new</span> User();</span><br><span class=\"line\">      user.setId(rs.getLong(<span class=\"string\">&quot;id&quot;</span>));</span><br><span class=\"line\">      user.setName(rs.getString(<span class=\"string\">&quot;name&quot;</span>));</span><br><span class=\"line\">      user.setTelephone(rs.getString(<span class=\"string\">&quot;telephone&quot;</span>));</span><br><span class=\"line\">      <span class=\"keyword\">return</span> user;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>JdbcTemplate代码较多，只摘抄部分相关代码。JdbcTemplate通过回调机制，将不变的流程抽离出来，放到模版方法execute()中，将可变的部分设计成回调StatementCallback，由用户来定制。query()是对execute()函数的二次封装，让接口用起来更加方便。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">List&lt;T&gt; <span class=\"title\">query</span><span class=\"params\">(String sql, RowMapper&lt;T&gt; rowMapper)</span> <span class=\"keyword\">throws</span> DataAccessException </span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">return</span> query(sql, <span class=\"keyword\">new</span> RowMapperResultSetExtractor&lt;T&gt;(rowMapper));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">T <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">final</span> String sql, <span class=\"keyword\">final</span> ResultSetExtractor&lt;T&gt; rse)</span> <span class=\"keyword\">throws</span> DataAccessException </span>&#123;</span><br><span class=\"line\"> Assert.notNull(sql, <span class=\"string\">&quot;SQL must not be null&quot;</span>);</span><br><span class=\"line\"> Assert.notNull(rse, <span class=\"string\">&quot;ResultSetExtractor must not be null&quot;</span>);</span><br><span class=\"line\"> <span class=\"keyword\">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">  logger.debug(<span class=\"string\">&quot;Executing SQL query [&quot;</span> + sql + <span class=\"string\">&quot;]&quot;</span>);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">QueryStatementCallback</span> <span class=\"keyword\">implements</span> <span class=\"title\">StatementCallback</span>&lt;<span class=\"title\">T</span>&gt;, <span class=\"title\">SqlProvider</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">doInStatement</span><span class=\"params\">(Statement stmt)</span> <span class=\"keyword\">throws</span> SQLException </span>&#123;</span><br><span class=\"line\">   ResultSet rs = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">   <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    rs = stmt.executeQuery(sql);</span><br><span class=\"line\">    ResultSet rsToUse = rs;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nativeJdbcExtractor != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">     rsToUse = nativeJdbcExtractor.getNativeResultSet(rs);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> rse.extractData(rsToUse);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    JdbcUtils.closeResultSet(rs);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getSql</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> sql;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">return</span> execute(<span class=\"keyword\">new</span> QueryStatementCallback());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">T <span class=\"title\">execute</span><span class=\"params\">(StatementCallback&lt;T&gt; action)</span> <span class=\"keyword\">throws</span> DataAccessException </span>&#123;</span><br><span class=\"line\"> Assert.notNull(action, <span class=\"string\">&quot;Callback object must not be null&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"> Connection con = DataSourceUtils.getConnection(getDataSource());</span><br><span class=\"line\"> Statement stmt = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"> <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  Connection conToUse = con;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.nativeJdbcExtractor != <span class=\"keyword\">null</span> &amp;&amp;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.nativeJdbcExtractor.isNativeConnectionNecessaryForNativeStatements()) &#123;</span><br><span class=\"line\">   conToUse = <span class=\"keyword\">this</span>.nativeJdbcExtractor.getNativeConnection(con);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  stmt = conToUse.createStatement();</span><br><span class=\"line\">  applyStatementSettings(stmt);</span><br><span class=\"line\">  Statement stmtToUse = stmt;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.nativeJdbcExtractor != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">   stmtToUse = <span class=\"keyword\">this</span>.nativeJdbcExtractor.getNativeStatement(stmt);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  T result = action.doInStatement(stmtToUse);</span><br><span class=\"line\">  handleWarnings(stmt);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"keyword\">catch</span> (SQLException ex) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// Release Connection early, to avoid potential connection pool deadlock</span></span><br><span class=\"line\">  <span class=\"comment\">// in the case when the exception translator hasn&#x27;t been initialized yet.</span></span><br><span class=\"line\">  JdbcUtils.closeStatement(stmt);</span><br><span class=\"line\">  stmt = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">  DataSourceUtils.releaseConnection(con, getDataSource());</span><br><span class=\"line\">  con = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> getExceptionTranslator().translate(<span class=\"string\">&quot;StatementCallback&quot;</span>, getSql(action), ex);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">  JdbcUtils.closeStatement(stmt);</span><br><span class=\"line\">  DataSourceUtils.releaseConnection(con, getDataSource());</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>应用举例 addShutdownHook()</p>\n<p>Hook可以翻译成“钩子”。有人说Hook就是Callback，是一回事。Callback更侧重语法机制的描述，Hook更加侧重应用场景的描述。Hook比较经典的场景就是Tomcat和JVM的shutdown hook。JVM提供了Runtime.addShutdownHook(Thread hook)方法，可以注册一个JVM关闭的Hook。当应用程序关闭的时候，JVM会自动调用Hook代码。代码示例如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ShutdownHookDemo</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ShutdownHook</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;I an called during shutting down.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    Runtime.getRuntime().addShutdownHook(<span class=\"keyword\">new</span> ShutdownHook()));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>addShutdownHook()代码部分相关实现如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Runtime</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addShutdownHook</span><span class=\"params\">(Thread hook)</span> </span>&#123;</span><br><span class=\"line\">    Securitymanager sm = System.getSecurityManager();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(sm != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      sm.checkPermission(<span class=\"keyword\">new</span> RuntimePermission(<span class=\"string\">&quot;shutdownHooks&quot;</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ApplicationShutdownHooks.add(hook);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ApplicationShutdownHooks</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">/* The set of registered hooks */</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> IdentityHashMap&lt;Thread,Thread&gt; hooks;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">    hooks = <span class=\"keyword\">new</span> IdentityHashMap&lt;&gt;();</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (IllegalStateException e) &#123;</span><br><span class=\"line\">    hooks = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(Thread hook)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(hooks == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">&quot;Shutdown in progress&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(hook.isAlive()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">&quot;Hook already running&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(hooks.containsKey(hook)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">&quot;Hook previously registered&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  hooks.put(hook,hook);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">runHooks</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  Collection&lt;Thread&gt; threads;</span><br><span class=\"line\">  <span class=\"keyword\">synchronized</span>(ApplicationShutdownHooks.class) &#123;</span><br><span class=\"line\">    threads = hooks.keySet();</span><br><span class=\"line\">    hooks = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">for</span> (Thread hook : threads) &#123;</span><br><span class=\"line\">    hook.start();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (Thread hook : threads) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        hook.join();</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (InterruptedException ignored) &#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>有关Hook的逻辑都封装到ApplicationShutdownHooks类中，应用程序关闭的时候，JVM会调用这个类的runHooks()方法，创建多个线程，并发地执行多个Hook。我们注册完Hook之后，并不需要等待Hook执行完成，所以也是一种异步回调。</p>\n<p>模版模式VS回调</p>\n<p>从应用场景上来看，同步回调和模版模式几乎一致。它们都是在一个大的算法骨架中，自由替换其中的某个步骤，起到代码复用和扩展的目的。异步回调跟模版模式有较大区别，更像观察者模式。</p>\n<p>从代码实现来看，回调和模版模式完全不同。回调基于组合关系来实现，把一个对象传递给另一个对象，是一种对象之间的关系；模版模式基于继承关系来实现，子类重写父类的抽象方法，是一种类之间的关系。</p>\n<p>回调相对于模版模式会更加灵活，主要体现在以下几点：</p>\n<ul>\n<li>Java只支持单继承的语言，基于模版模式编写的子类，已经继承了一个父类，不再具有继承的能力</li>\n<li>回调可以使用匿名类来创建回调对象，可以不用实现定义类；而模版模式针对不同的实现都要定义不同的子类。</li>\n<li>如果某个类中定义了多个模版方法，每个方法都有对应的抽象方法，那即便只用到其中的一个模版方法，子类也必须实现所有的抽象方法。而回调就更加灵活，只需要往用的模版方法中注入回调对象即可。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>模版模式主要是用来解决复用和扩展两个问题。模版模式，全称模版方法设计模式，因为是Template Method Design Pattern。在GoF的《设计模式》中，定义如下:</p>\n<blockquote>\n<p>Define the skeleton of an algorithm in an operation,deferring some steps to subclasses.Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm’s structure.</p>\n</blockquote>\n<p>翻译成中文就是：模版方法模式在一个方法中定义一个算法骨架，并将某些步骤推迟到子类中实现。模版方法模式可以让子类在不改变算法整体结构的情况下，重新定义算法中的某些步骤。</p>\n<p>这里的“算法”可以理解为广义上的“业务逻辑”。先看一个示例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AbstractClass</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">templateMethod</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    method1();</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    method2();</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">method1</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">method2</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConcreteClass1</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractClass</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">method1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">method2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConcreteClass2</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractClass</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">method1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">method2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    AbstractClass demo = <span class=\"keyword\">new</span> ConcreteClass1();</span><br><span class=\"line\">    demo.templateMethod();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"模版模式的作用：\"><a href=\"#模版模式的作用：\" class=\"headerlink\" title=\"模版模式的作用：\"></a>模版模式的作用：</h5><h5 id=\"1-复用\"><a href=\"#1-复用\" class=\"headerlink\" title=\"1.复用\"></a>1.复用</h5><p>模版模式把一个算法中不变的流程抽象到父类的模版方法templateMethod()中，将可变的部分method1()、method2()留给子类来实现。所有的子类都可以复用父类中模版方法定义的流程代码。</p>\n<p>Java InputStream </p>\n<p>Java IO类库中，很多类的设计用到了模版模式，比如InputStream、OutputStream、Reader、Writer。</p>\n<p>看下InputStream代码，在代码中，read()函数是一个模版方法，定义了读取数据的整个流程，并且暴露了可以由子类来定制的抽象方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InputStream</span> <span class=\"keyword\">implements</span> <span class=\"title\">Closeable</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...省略其他代码...</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">read</span><span class=\"params\">(<span class=\"keyword\">byte</span>[] b,<span class=\"keyword\">int</span> off,<span class=\"keyword\">int</span> len)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(b == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointException();</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (off &lt; <span class=\"number\">0</span> || len &lt;<span class=\"number\">0</span> || len &gt; b.length - off) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IndexOutOfBoundsException();</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (len == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> c = read();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(c == -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    b[off] = (<span class=\"keyword\">byte</span>) c;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span>(; i &lt; len ; i++) &#123;</span><br><span class=\"line\">        c = read();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(c == -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        b[off + i] = (<span class=\"keyword\">byte</span>)c;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span>(IOException ee) &#123;</span><br><span class=\"line\">      </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">int</span> <span class=\"title\">read</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ByteArrayinputStream</span> <span class=\"keyword\">extends</span> <span class=\"title\">InputStream</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//... 省略其他代码</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">int</span> <span class=\"title\">read</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    retunr (pos &lt; count) ? (buf[pos++] &amp; <span class=\"number\">0xff</span>) : -<span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Java AbstractList</p>\n<p>在Java AbstractList类中，addAll()函数可以看作模版方法，add()是子类需要重写的方法，尽管没有声明为abstract的，但是函数直接抛出异常。前提是，如果子类不重写是不能使用的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">addAll</span><span class=\"params\">(<span class=\"keyword\">int</span> index,Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class=\"line\">  rangeCheckForAdd(index);</span><br><span class=\"line\">  <span class=\"keyword\">boolean</span> modified = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(E e : c) &#123;</span><br><span class=\"line\">    add(index++, e);</span><br><span class=\"line\">    modified = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> modified;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> index,E element)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//这里直接抛出异常，当子类不重写直接调用父类的add()函数直接抛出异常</span></span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> UnsupportedOperationException();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"2-扩展\"><a href=\"#2-扩展\" class=\"headerlink\" title=\"2.扩展\"></a>2.扩展</h5><p>这里说的扩展，并不是代码的扩展性，而是框架的扩展性，有点类似控制反转。通过Java Servlet、Junit TestCase来学习下。</p>\n<p>Java Servlet</p>\n<p>在没有SpringMVC的时候，使用比较底层的Servlet来开发Web项目，只需要定义一个继承HttpServlet的类，并且重写其中的doGet()或doPost()方法，分别来处理get和post请求。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloServlet</span> <span class=\"keyword\">extends</span> <span class=\"title\">HttpServlet</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">doGet</span><span class=\"params\">(HttpServletRequest req,HttpServletResponse resp)</span> <span class=\"keyword\">throws</span> ServletException, IOException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.doPost(req,resp);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">   <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">doPost</span><span class=\"params\">(HttpServletRequest req,HttpServletResponse resp)</span> <span class=\"keyword\">throws</span> ServletException, IOException </span>&#123;</span><br><span class=\"line\">    resp.getWriter().write(<span class=\"string\">&quot;Hello World.&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>除此之外，还需要在配置文件web.xml中配置下URL和Servlet的关系。Tomcat、Jetty等Servlet容器启动的时候，会自动加载这个配置文件中的对应关系。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>HelloServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span>com.xzg.cd.HelloServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-class</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>HelloServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/hello<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>在浏览器输入网址，Servlet容器会接收到相应的请求，并且根据URL和Servlet的对应关系，找对对应的Servlet执行它的service()方法。service()方法定义在父类HttpServlet中，它会调用doGet()或doPost()方法，然后输出数据到网页。</p>\n<p>看下HttpServlet的service()的函数</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">service</span><span class=\"params\">(ServletRequest req, ServletResponse res)</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"keyword\">throws</span> ServletException, IOException</span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    HttpServletRequest  request;</span><br><span class=\"line\">    HttpServletResponse response;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!(req <span class=\"keyword\">instanceof</span> HttpServletRequest &amp;&amp;</span><br><span class=\"line\">            res <span class=\"keyword\">instanceof</span> HttpServletResponse)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ServletException(<span class=\"string\">&quot;non-HTTP request or response&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    request = (HttpServletRequest) req;</span><br><span class=\"line\">    response = (HttpServletResponse) res;</span><br><span class=\"line\">    service(request, response);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">service</span><span class=\"params\">(HttpServletRequest req, HttpServletResponse resp)</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"keyword\">throws</span> ServletException, IOException</span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    String method = req.getMethod();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (method.equals(METHOD_GET)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> lastModified = getLastModified(req);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (lastModified == -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// servlet doesn&#x27;t support if-modified-since, no reason</span></span><br><span class=\"line\">            <span class=\"comment\">// to go through further expensive logic</span></span><br><span class=\"line\">            doGet(req, resp);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">long</span> ifModifiedSince = req.getDateHeader(HEADER_IFMODSINCE);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ifModifiedSince &lt; lastModified) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// If the servlet mod time is later, call doGet()</span></span><br><span class=\"line\">                <span class=\"comment\">// Round down to the nearest second for a proper compare</span></span><br><span class=\"line\">                <span class=\"comment\">// A ifModifiedSince of -1 will always be less</span></span><br><span class=\"line\">                maybeSetLastModified(resp, lastModified);</span><br><span class=\"line\">                doGet(req, resp);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (method.equals(METHOD_HEAD)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> lastModified = getLastModified(req);</span><br><span class=\"line\">        maybeSetLastModified(resp, lastModified);</span><br><span class=\"line\">        doHead(req, resp);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (method.equals(METHOD_POST)) &#123;</span><br><span class=\"line\">        doPost(req, resp);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (method.equals(METHOD_PUT)) &#123;</span><br><span class=\"line\">        doPut(req, resp);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (method.equals(METHOD_DELETE)) &#123;</span><br><span class=\"line\">        doDelete(req, resp);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (method.equals(METHOD_OPTIONS)) &#123;</span><br><span class=\"line\">        doOptions(req,resp);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (method.equals(METHOD_TRACE)) &#123;</span><br><span class=\"line\">        doTrace(req,resp);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        String errMsg = lStrings.getString(<span class=\"string\">&quot;http.method_not_implemented&quot;</span>);</span><br><span class=\"line\">        Object[] errArgs = <span class=\"keyword\">new</span> Object[<span class=\"number\">1</span>];</span><br><span class=\"line\">        errArgs[<span class=\"number\">0</span>] = method;</span><br><span class=\"line\">        errMsg = MessageFormat.format(errMsg, errArgs);</span><br><span class=\"line\">        resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>HttpServlet的service()方法就是一个模版方法，它实现了整个HTTP请求的执行流程，doGet()，doPost()是模版中可以由子类定制的部分。相当于Servlet框架提供了扩展点（doGet()，doPost()）,框架用户在不修改Servlet框架源码的情况下，将业务代码通过扩展点镶嵌到框架中执行。</p>\n<p>JUnit TestCase</p>\n<p>JUnit框架通过模版模式提供了一些功能扩展点（setUp()、teadDown()等），让框架用户可以在这些扩展点上扩展功能。在使用JUnit测试框架来编写单元测试的时候，编写的测试类都要继承框架提供的TestCase类。TestCase类中，runBare()函数是模版方法，它定义了执行测试用例的流程：先执行setUp()做准备工作，执行runTest()运行真正的测试代码，最后执行tearDown()做扫尾工作。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestCase</span> <span class=\"keyword\">extends</span> <span class=\"title\">Assert</span> <span class=\"keyword\">implements</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">runBare</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">    Throwable exception = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    setUp();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      runTest();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Throwable running) &#123;</span><br><span class=\"line\">      exception = running;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        tearDown();</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (Throwable tearingDown) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (exception == <span class=\"keyword\">null</span>) exception = tearingDown;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (exception != <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> exception;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * Sets up the fixture, for example, open a network connection.</span></span><br><span class=\"line\"><span class=\"comment\">  * This method is called before a test is executed.</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">setUp</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * Tears down the fixture, for example, close a network connection.</span></span><br><span class=\"line\"><span class=\"comment\">  * This method is called after a test is executed.</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">tearDown</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>回调也能起到跟模版模式相同的作用。</p>\n<h5 id=\"回调的原理解析\"><a href=\"#回调的原理解析\" class=\"headerlink\" title=\"回调的原理解析\"></a>回调的原理解析</h5><p>A调用B，B反过来又调用A，这种调用机制就叫“回调”。举个现实中的例子就是，张三去超市买牛奶，结果牛奶卖完了，张三给超市留了电话，让到货通知他，超市到货后通知张三，这就是回调。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ICallback</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">methodToCallback</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BClass</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">process</span><span class=\"params\">(ICallback callback)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    callback.methodToCallback();</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AClass</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    BClass b = <span class=\"keyword\">new</span> BClass();</span><br><span class=\"line\">    b.process(<span class=\"keyword\">new</span> ICallback() &#123; <span class=\"comment\">//回调对象</span></span><br><span class=\"line\">      <span class=\"meta\">@Override</span></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">methodToCallback</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Call back me.&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>回调不仅可以应用在代码设计上，在更高层次的架构设计上也比较常用。比如，通过三方支付系统来实现支付功能，用户在发起支付请求之后，一般不会一直阻塞到支付结果返回，而是注册回调接口（类似回调函数，一般是一个回调用的URL）给三方支付系统，等三方支付系统执行完成之后，将结果通过回调接口返回给用户。</p>\n<p>回调可以分为同步回调和异步回调（或延迟回调）。同步回调指在函数返回之前执行回调函数；异步回调指的是在函数返回之后执行回调函数。上面的代码是同步回调的实现方式，在process()函数返回之前，执行完回调函数methodToCallback()。支付回调的例子是异步回调的实现方式，发起支付之后不需要等待回调接口被调用就直接返回。从应用场景来看，同步回调看起来更像模版模式，异步回调更像观察者模式。</p>\n<p>应用举例：JdbcTemplate</p>\n<p>Spring提供了很多Template类，JdbcTemplate、RedisTemplate、RestTemplate。</p>\n<p>Java提供了JDBC类库来封装不同类型的数据库操作。不过，直接直接使用JDBC来编写操作数据库的代码，还是比较复杂的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JdbcDemo</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> User <span class=\"title\">queryUser</span><span class=\"params\">(<span class=\"keyword\">long</span> id)</span> </span>&#123;</span><br><span class=\"line\">    Connection conn = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    Statement stmt = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">//1.加载驱动</span></span><br><span class=\"line\">      Class.forName(<span class=\"string\">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class=\"line\">      conn = DriverManager.getConnectin(<span class=\"string\">&quot;jdbc:mysql://localhost:3306/demo&quot;</span>,<span class=\"string\">&quot;root&quot;</span>,<span class=\"string\">&quot;123456&quot;</span>);</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"comment\">//2.创建statement类对象，用来执行SQL语句</span></span><br><span class=\"line\">      stmt = conn.createStatement();</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"comment\">//3.ResultSet类，用来存放获取的结果集</span></span><br><span class=\"line\">      String sql = <span class=\"string\">&quot;select * from user where id = &quot;</span> + id;</span><br><span class=\"line\">      ResultSet result = stmt.executeQuery(sql);</span><br><span class=\"line\">      </span><br><span class=\"line\">      String eid = <span class=\"keyword\">null</span>,ename = <span class=\"keyword\">null</span>,price = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"keyword\">while</span>(resultSet.next()) &#123;</span><br><span class=\"line\">        User user = <span class=\"keyword\">new</span> User();</span><br><span class=\"line\">        user.setId(resultSet.getLong(<span class=\"string\">&quot;id&quot;</span>));</span><br><span class=\"line\">        user.setName(resultSet.getString(<span class=\"string\">&quot;name&quot;</span>));</span><br><span class=\"line\">        user.setTelephone(resultSet.getString(<span class=\"string\">&quot;telephone&quot;</span>));</span><br><span class=\"line\">        <span class=\"keyword\">return</span> user;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span>(ClassnotFountException e) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// log...</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span>(SQLException e) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// log...</span></span><br><span class=\"line\">    &#125;<span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(conn != <span class=\"keyword\">null</span>) </span><br><span class=\"line\">        <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">          conn.close();</span><br><span class=\"line\">        &#125;<span class=\"keyword\">catch</span>(SQLException e) &#123;</span><br><span class=\"line\">          <span class=\"comment\">//log...</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(stmt != <span class=\"keyword\">null</span>) </span><br><span class=\"line\">        <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">          stmt.close();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (SQLException e) &#123;</span><br><span class=\"line\">          <span class=\"comment\">//log...</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>queryUser()函数包含很多流程性质的代码，跟业务无关。比如，加载驱动、创建数据库连接、创建statement、关闭连接、关闭statement、处理异常。针对不同SQL执行请求，这些流程性质的代码是相同的、可以复用的。</p>\n<p>Spring提供了JdbcTemplate，对JDBC进一步封装，来简化数据库编程。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JdbcTemplateDemo</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> JdbcTemplate jdbcTemplate;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> User <span class=\"title\">queryUser</span><span class=\"params\">(<span class=\"keyword\">long</span> id)</span> </span>&#123;</span><br><span class=\"line\">    String sql = <span class=\"string\">&quot;select * from user where id =&quot;</span> + id;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> jdbcTemplate.query(sql,<span class=\"keyword\">new</span> UserRowWrapper()).get(<span class=\"number\">0</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserRowMapper</span> <span class=\"keyword\">implements</span> <span class=\"title\">RowMapper</span>&lt;<span class=\"title\">User</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> User <span class=\"title\">mapRow</span><span class=\"params\">(ResultSet rs,<span class=\"keyword\">int</span> rowNum)</span> <span class=\"keyword\">throws</span> SQLException </span>&#123;</span><br><span class=\"line\">      User user = <span class=\"keyword\">new</span> User();</span><br><span class=\"line\">      user.setId(rs.getLong(<span class=\"string\">&quot;id&quot;</span>));</span><br><span class=\"line\">      user.setName(rs.getString(<span class=\"string\">&quot;name&quot;</span>));</span><br><span class=\"line\">      user.setTelephone(rs.getString(<span class=\"string\">&quot;telephone&quot;</span>));</span><br><span class=\"line\">      <span class=\"keyword\">return</span> user;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>JdbcTemplate代码较多，只摘抄部分相关代码。JdbcTemplate通过回调机制，将不变的流程抽离出来，放到模版方法execute()中，将可变的部分设计成回调StatementCallback，由用户来定制。query()是对execute()函数的二次封装，让接口用起来更加方便。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">List&lt;T&gt; <span class=\"title\">query</span><span class=\"params\">(String sql, RowMapper&lt;T&gt; rowMapper)</span> <span class=\"keyword\">throws</span> DataAccessException </span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">return</span> query(sql, <span class=\"keyword\">new</span> RowMapperResultSetExtractor&lt;T&gt;(rowMapper));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">T <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">final</span> String sql, <span class=\"keyword\">final</span> ResultSetExtractor&lt;T&gt; rse)</span> <span class=\"keyword\">throws</span> DataAccessException </span>&#123;</span><br><span class=\"line\"> Assert.notNull(sql, <span class=\"string\">&quot;SQL must not be null&quot;</span>);</span><br><span class=\"line\"> Assert.notNull(rse, <span class=\"string\">&quot;ResultSetExtractor must not be null&quot;</span>);</span><br><span class=\"line\"> <span class=\"keyword\">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">  logger.debug(<span class=\"string\">&quot;Executing SQL query [&quot;</span> + sql + <span class=\"string\">&quot;]&quot;</span>);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">QueryStatementCallback</span> <span class=\"keyword\">implements</span> <span class=\"title\">StatementCallback</span>&lt;<span class=\"title\">T</span>&gt;, <span class=\"title\">SqlProvider</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">doInStatement</span><span class=\"params\">(Statement stmt)</span> <span class=\"keyword\">throws</span> SQLException </span>&#123;</span><br><span class=\"line\">   ResultSet rs = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">   <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    rs = stmt.executeQuery(sql);</span><br><span class=\"line\">    ResultSet rsToUse = rs;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nativeJdbcExtractor != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">     rsToUse = nativeJdbcExtractor.getNativeResultSet(rs);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> rse.extractData(rsToUse);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    JdbcUtils.closeResultSet(rs);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getSql</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> sql;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">return</span> execute(<span class=\"keyword\">new</span> QueryStatementCallback());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">T <span class=\"title\">execute</span><span class=\"params\">(StatementCallback&lt;T&gt; action)</span> <span class=\"keyword\">throws</span> DataAccessException </span>&#123;</span><br><span class=\"line\"> Assert.notNull(action, <span class=\"string\">&quot;Callback object must not be null&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"> Connection con = DataSourceUtils.getConnection(getDataSource());</span><br><span class=\"line\"> Statement stmt = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"> <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  Connection conToUse = con;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.nativeJdbcExtractor != <span class=\"keyword\">null</span> &amp;&amp;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.nativeJdbcExtractor.isNativeConnectionNecessaryForNativeStatements()) &#123;</span><br><span class=\"line\">   conToUse = <span class=\"keyword\">this</span>.nativeJdbcExtractor.getNativeConnection(con);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  stmt = conToUse.createStatement();</span><br><span class=\"line\">  applyStatementSettings(stmt);</span><br><span class=\"line\">  Statement stmtToUse = stmt;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.nativeJdbcExtractor != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">   stmtToUse = <span class=\"keyword\">this</span>.nativeJdbcExtractor.getNativeStatement(stmt);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  T result = action.doInStatement(stmtToUse);</span><br><span class=\"line\">  handleWarnings(stmt);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"keyword\">catch</span> (SQLException ex) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// Release Connection early, to avoid potential connection pool deadlock</span></span><br><span class=\"line\">  <span class=\"comment\">// in the case when the exception translator hasn&#x27;t been initialized yet.</span></span><br><span class=\"line\">  JdbcUtils.closeStatement(stmt);</span><br><span class=\"line\">  stmt = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">  DataSourceUtils.releaseConnection(con, getDataSource());</span><br><span class=\"line\">  con = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> getExceptionTranslator().translate(<span class=\"string\">&quot;StatementCallback&quot;</span>, getSql(action), ex);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">  JdbcUtils.closeStatement(stmt);</span><br><span class=\"line\">  DataSourceUtils.releaseConnection(con, getDataSource());</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>应用举例 addShutdownHook()</p>\n<p>Hook可以翻译成“钩子”。有人说Hook就是Callback，是一回事。Callback更侧重语法机制的描述，Hook更加侧重应用场景的描述。Hook比较经典的场景就是Tomcat和JVM的shutdown hook。JVM提供了Runtime.addShutdownHook(Thread hook)方法，可以注册一个JVM关闭的Hook。当应用程序关闭的时候，JVM会自动调用Hook代码。代码示例如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ShutdownHookDemo</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ShutdownHook</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      System.out.println(<span class=\"string\">&quot;I an called during shutting down.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    Runtime.getRuntime().addShutdownHook(<span class=\"keyword\">new</span> ShutdownHook()));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>addShutdownHook()代码部分相关实现如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Runtime</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addShutdownHook</span><span class=\"params\">(Thread hook)</span> </span>&#123;</span><br><span class=\"line\">    Securitymanager sm = System.getSecurityManager();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(sm != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      sm.checkPermission(<span class=\"keyword\">new</span> RuntimePermission(<span class=\"string\">&quot;shutdownHooks&quot;</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ApplicationShutdownHooks.add(hook);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ApplicationShutdownHooks</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">/* The set of registered hooks */</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> IdentityHashMap&lt;Thread,Thread&gt; hooks;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">    hooks = <span class=\"keyword\">new</span> IdentityHashMap&lt;&gt;();</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (IllegalStateException e) &#123;</span><br><span class=\"line\">    hooks = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(Thread hook)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(hooks == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">&quot;Shutdown in progress&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(hook.isAlive()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">&quot;Hook already running&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(hooks.containsKey(hook)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">&quot;Hook previously registered&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  hooks.put(hook,hook);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">runHooks</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  Collection&lt;Thread&gt; threads;</span><br><span class=\"line\">  <span class=\"keyword\">synchronized</span>(ApplicationShutdownHooks.class) &#123;</span><br><span class=\"line\">    threads = hooks.keySet();</span><br><span class=\"line\">    hooks = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">for</span> (Thread hook : threads) &#123;</span><br><span class=\"line\">    hook.start();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (Thread hook : threads) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        hook.join();</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (InterruptedException ignored) &#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>有关Hook的逻辑都封装到ApplicationShutdownHooks类中，应用程序关闭的时候，JVM会调用这个类的runHooks()方法，创建多个线程，并发地执行多个Hook。我们注册完Hook之后，并不需要等待Hook执行完成，所以也是一种异步回调。</p>\n<p>模版模式VS回调</p>\n<p>从应用场景上来看，同步回调和模版模式几乎一致。它们都是在一个大的算法骨架中，自由替换其中的某个步骤，起到代码复用和扩展的目的。异步回调跟模版模式有较大区别，更像观察者模式。</p>\n<p>从代码实现来看，回调和模版模式完全不同。回调基于组合关系来实现，把一个对象传递给另一个对象，是一种对象之间的关系；模版模式基于继承关系来实现，子类重写父类的抽象方法，是一种类之间的关系。</p>\n<p>回调相对于模版模式会更加灵活，主要体现在以下几点：</p>\n<ul>\n<li>Java只支持单继承的语言，基于模版模式编写的子类，已经继承了一个父类，不再具有继承的能力</li>\n<li>回调可以使用匿名类来创建回调对象，可以不用实现定义类；而模版模式针对不同的实现都要定义不同的子类。</li>\n<li>如果某个类中定义了多个模版方法，每个方法都有对应的抽象方法，那即便只用到其中的一个模版方法，子类也必须实现所有的抽象方法。而回调就更加灵活，只需要往用的模版方法中注入回调对象即可。</li>\n</ul>\n"},{"layout":"post","title":"设计模式之策略模式","description":"设计模式之策略模式","date":"2021-06-03T05:26:10.000Z","_content":"\n策略模式最常用的场景是避免冗长的if-else或switch分支判断。不过它还可以像模版模式那样，提供框架的扩展点等。\n\n策略模式，英文全称是Strategy Design Pattern。在GoF的《设计模式》一书中，是这样定义的：\n\n```java\nDefine a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from clients that use it.\n```\n\n翻译成中文是：定义一族算法类，将每个算法分别封装起来，让它们可以相互替换。策略模式可以使算法的变化独立于使用它们的客户端（这里的客户端代指使用算法的代码）。\n\n工厂模式是解耦对象的创建和使用，观察者模式是解耦观察者和被观察者。策略模式是解耦策略的定义、创建、使用这三部分。\n\n##### 1.策略的定义\n\n策略类的定义比较简单，包含一个策略接口和一组实现这个接口的策略类。因为所有的策略类都实现相同的接口，所以客户端代码基于接口编程而非实现编程，可以灵活地替换不同的策略。\n\n```java\npublic interface Strategy {\n  void algorithmInterface();\n}\n\npublic class ConcreteStrategyA implements Strategy {\n  @Override \n  public void algorithmInterface() {\n    //具体的实现...\n  }\n}\n\npublic class ConcreteStrategyB implements Strategy {\n\t  @Override \n  public void algorithmInterface() {\n    //具体的实现...\n  }\n}\n```\n\n##### 2.策略的创建\n\n因为策略模式会包含一组策略，在使用它们的时候，一般会通过类型（type）来判断创建哪个策略来使用。为了封装创建逻辑，我们需要对客户端代码屏蔽创建细节。我们可以把根据type创建策略的逻辑抽离出来，放到工厂类中。示例代码如下:\n\n```java\npublic class StrategyFactory {\n  private static final Map<String,Strategy> strategies = new HashMap<>();\n  \n  static {\n    strategies.put(\"A\",new ConcreteStrategyA());\n    strategies.put(\"B\",new ConcreteStrategyB());\n  }\n  \n  public static Strategy getStrategy(String type) {\n    if(type ==null || type.isEmpty()) {\n      throw new IllegalArgumentException(\"type should not be empty.\");\n    }\n    return strategies.get(type);\n  }\n}\n```\n\n一般来说，如果策略类是无状态的，不包含成员变量，只是纯粹的算法实现，这样的策略对象是可以被共享使用的，不需要在每次调用getStrategy()的时候，都创建一个新的策略对象。这种情况下，就可以用工厂类的实现方式，事先创建好每个策略对象，缓存到工厂类中，用的时候直接返回。\n\n如果策略类是有状态的，根据业务场景需要，我们希望每次获取的都是新创建的策略对象，而不是缓存好可共享的策略对象。那就需要使用下面的工厂。\n\n```java\npublic class StrategyFactory {\n  public static Strategy getStrategy(String type) {\n    if(type == null || type.isEmpty()) {\n      throw new IllegalArgumentException(\"type should not be empty.\");\n    }\n    \n    if(type.equals(\"A\")) {\n      return new ConcreteStrategyA();\n    }else if (type.equals(\"B\")) {\n      return new ConcreteStrategyB();\n    }\n    return null;\n  } \n}\n```\n\n##### 3.策略的使用\n\n策略模式包含一组可选策略，客户端代码如何确定使用哪个策略呢？常见的是运行时动态确定使用哪种策略，这也是策略模式最经典的应用场景。这里的动态，是事先并不知道会使用哪个策略，而是在程序运行期间，根据配置、用户输入、计算结果等这些不确定因素，动态决定使用哪种策略。\n\n```java\n//策略接口 EvictionStrategy\n//策略类：LruEvictionStrategy、FifoEvictionStrategy、LfuEvictionStrategy...\n//策略工厂：EvictionStrategyFactory\npublic class UserCache {\n  private Map<String,User> cacheData = new HashMap<>();\n  private EvictionStrategy eviction;\n  \n  public UserCache(EvictionStrategy eviction) {\n    this.eviction = eviction;\n  }\n  \n  //...\n}\n\n//运行时动态确定，根据配置文件的配置决定使用哪种策略\npublic class Application {\n  public static void main(String[] args) throws Exception{\n    EvictionStrategy evictionStrategy = null;\n    Properties props = new Properties(); \n    props.load(new FileInputStream(\"./config.properties\"));\n    String type = props.getProperty(\"eviction_type\");\n    evictionStrategy = EvictionStrategyFactory.getEvictionStrategy(type);\n    UserCache userCache = new UserCache(evictionStrategy); \n    //...\n  }\n}\n\n//非运行时动态确定，在代码中指定使用哪种策略\npublic class Application {\n  public static void main(String[] args) {\n    //... \n    EvictionStrategy evictionStrategy = new LruEvictionStrategy();\n    UserCache userCache = new UserCache(evictionStrategy); \n    //...\n  } \n}\n```\n\n非运行时动态确定，并不能发挥策略模式的优势。这种场景下，策略模式实际上退化成了“面向对象的多态特性”或“基于接口而非实现编程原则”。\n\n##### 如何利用策略模式避免分支判断\n\n能够移除分支判断逻辑的模式不仅仅有策略模式，状态模式也可以。对于使用哪种模式，具体还要看应用场景来定。策略模式适用于根据不同类型的动态，决定使用哪种策略这一种应用场景。\n\n先来看下if-else 或switch-case 分支判断逻辑是如何产生的。\n\n```java\n\npublic class OrderService {\n  public double discount(Order order) {\n    double discount = 0.0;\n    OrderType type = order.getType();\n    if (type.equals(OrderType.NORMAL)) { // 普通订单\n      //...省略折扣计算算法代码\n    } else if (type.equals(OrderType.GROUPON)) { // 团购订单\n      //...省略折扣计算算法代码\n    } else if (type.equals(OrderType.PROMOTION)) { // 促销订单\n      //...省略折扣计算算法代码\n    }\n    return discount;\n  }\n}\n```\n\n使用策略模式对上面的代码重构，将不同类型订单的打折策略设计成策略类，并由工厂类来负责创建策略对象。代码示例如下：\n\n```java\n\n// 策略的定义\npublic interface DiscountStrategy {\n  double calDiscount(Order order);\n}\n// 省略NormalDiscountStrategy、GrouponDiscountStrategy、PromotionDiscountStrategy类代码...\n\n// 策略的创建\npublic class DiscountStrategyFactory {\n  private static final Map<OrderType, DiscountStrategy> strategies = new HashMap<>();\n\n  static {\n    strategies.put(OrderType.NORMAL, new NormalDiscountStrategy());\n    strategies.put(OrderType.GROUPON, new GrouponDiscountStrategy());\n    strategies.put(OrderType.PROMOTION, new PromotionDiscountStrategy());\n  }\n\n  public static DiscountStrategy getDiscountStrategy(OrderType type) {\n    return strategies.get(type);\n  }\n}\n\n// 策略的使用\npublic class OrderService {\n  public double discount(Order order) {\n    OrderType type = order.getType();\n    DiscountStrategy discountStrategy = DiscountStrategyFactory.getDiscountStrategy(type);\n    return discountStrategy.calDiscount(order);\n  }\n}\n```\n\n重构之后的代码没有if-else 分支判断语句了。这得益于策略工厂类。在工厂类中，我们用Map来缓存策略，根据type直接从Map中获取对应的策略，从而避免if-else分支判断逻辑。其实就是借助“查表法”，根据type查表（代码中的strategies就是表）替代根据type分支判断。\n\n但是，如果业务场景需要每次创建不同的策略对象，我们就要用另一种工厂类的实现方式了。\n\n```java\n\npublic class DiscountStrategyFactory {\n  public static DiscountStrategy getDiscountStrategy(OrderType type) {\n    if (type == null) {\n      throw new IllegalArgumentException(\"Type should not be null.\");\n    }\n    if (type.equals(OrderType.NORMAL)) {\n      return new NormalDiscountStrategy();\n    } else if (type.equals(OrderType.GROUPON)) {\n      return new GrouponDiscountStrategy();\n    } else if (type.equals(OrderType.PROMOTION)) {\n      return new PromotionDiscountStrategy();\n    }\n    return null;\n  }\n}\n```\n\n单是这种方式相当于把原来的if-else分支逻辑，从OrderService类中已到了工厂类中，实际上并没有移除。\n\n可以像非动态的策略工厂一样，不过value放对应策略类的class，这样就可以通过反射去获取新的对象了。\n\n假设有这样一个需求，希望写一个小程序，实现一个对文件进行排序的功能。文件中只包含整型数，并且，相邻的数字通过逗号来分隔。\n\n最简单的思路，只需要将文件中的内容读取出来，并且通过逗号分隔成一个一个的数字放到内存数组中，然后编写某种排序算法，或者直接用编程语言提供的排序函数，对数组进行排序，最后再将数组中的数据写入文件就可以了。\n\n但是如果文件很大呢，如果文件10GB，内存只有8G，无法一次性加载文件中的所有数据到内存中，这个时候，就要利用外部排序算法了。\n\n如果文件更大，有100G大小，为了利用CPU多核的优势，可以在外部排序的基础上进行优化，加入多线程并发排序的功能，这就有点像“单机版”的MapReduce。\n\n如果文件非常大，有1TB，即便是单机多线程排序，也很慢，这个时候可以使用真正的MapReduce框架，利用多机的处理能力，提高排序的效率。\n\n```java\npublic class Sorter {\n  public static final long GB = 1000 * 1000 * 1000;\n  \n  public void sortFile(String filePath) {\n    //省略校验逻辑\n    File file = new File(filePath);\n    long fileSize = file.length();\n    if (fileSize < 6 * GB) { // [0, 6GB) \n      quickSort(filePath); \n    } else if (fileSize < 10 * GB) { // [6GB, 10GB) \n      externalSort(filePath); \n    } else if (fileSize < 100 * GB) { // [10GB, 100GB) \n      concurrentExternalSort(filePath); \n    } else { // [100GB, ~) \n      mapreduceSort(filePath); \n    }\n  }\n private void quickSort(String filePath) { \n   // 快速排序 \n } \n  \n  private void externalSort(String filePath) { \n   // 外部排序\n } \n  \n  private void concurrentExternalSort(String filePath) {\n   // 多线程外部排序 \n  } \n  \n  private void mapreduceSort(String filePath) { \n    // 利用MapReduce多机排序 \n  }\n}\npublic class SortingTool { \n  public static void main(String[] args) { \n    Sorter sorter = new Sorter();\n    sorter.sortFile(args[0]);\n  }\n}\n```\n\n如果只是开发一个简单的工具，那上面的代码实现就足够了。毕竟代码不多，后续修改、扩展的需求也不多，怎么写都不会导致代码不可维护。但是，如果我们是在开发一个大型项目，排序文件只是其中一个功能模块，那我们就要在代码设计、代码质量上下点儿功夫。只有每个小的功能模块都写好，整个项目的代码才能不差。\n\n刚刚的代码中，并没有给每种排序算法的代码实现，如果实现一下的话，每种排序算法的实现逻辑都比较复杂，代码行数都比较多。所有的排序算法都在Sorter类中，这就会导致这个类的代码很多，会影响到可读性、可维护性。除此之外，所有的排序算法都设计成Sorter的私有函数，也会影响代码的可复用性。\n\n针对上面的问题，即便想不到用什么设计模式来重构，但是也知道该把Sorter类中的某些代码拆分出来，独立成职责更加单一的小类。拆分是应对类或者函数代码过多、应对代码复杂性的一个常用手段。\n\n```java\npublic interface ISortAlg {\n  void sort(String filePath);\n}\n\npublic class QuickSort implements ISortAlg {\n  @Override\n  public void sort(String filePath) {\n    //...\n  }\n}\n\npublic class ExternalSort implements ISortAlg {\n  @Override\n  public void sort(String filePath) {\n    //...\n  }\n}\n\npublic class ConcurrentExternalSort implements ISortAlg {\n  @Override\n  public void sort(String filePath) {\n    //...\n  }\n}\n\npublic class MapReduceSort implements ISortAlg {\n  @Override\n  public void sort(String filePath) {\n    //...\n  }\n}\n\npublic class Sorter {\n  private static final long GB = 1000 * 1000 * 1000;\n\n  public void sortFile(String filePath) {\n    // 省略校验逻辑\n    File file = new File(filePath);\n    long fileSize = file.length();\n    ISortAlg sortAlg;\n    if (fileSize < 6 * GB) { // [0, 6GB)\n      sortAlg = new QuickSort();\n    } else if (fileSize < 10 * GB) { // [6GB, 10GB)\n      sortAlg = new ExternalSort();\n    } else if (fileSize < 100 * GB) { // [10GB, 100GB)\n      sortAlg = new ConcurrentExternalSort();\n    } else { // [100GB, ~)\n      sortAlg = new MapReduceSort();\n    }\n    sortAlg.sort(filePath);\n  }\n}\n```\n\n拆分过后，每个类的代码都不会太多，每个类的逻辑都不会太复杂，代码的可读性、可维护性提高了。将排序算法设计成独立的类，跟具体的业务逻辑（代码中的if-else那部分逻辑）解耦，也让排序算法能够复用。这一步就是策略模式的第一步，将策略的定义分离出来。\n\n上面的代码还可以继续优化。每种排序类都是无状态的，没必要每次使用的时候都重新创建一个新的对象。可以使用工厂模式对对象的创建进行封装。\n\n```java\npublic class SortAlgFactory {\n  private static final Map<String, ISortAlg> algs = new HashMap<>();\n\n  static {\n    algs.put(\"QuickSort\", new QuickSort());\n    algs.put(\"ExternalSort\", new ExternalSort());\n    algs.put(\"ConcurrentExternalSort\", new ConcurrentExternalSort());\n    algs.put(\"MapReduceSort\", new MapReduceSort());\n  }\n\n  public static ISortAlg getSortAlg(String type) {\n    if (type == null || type.isEmpty()) {\n      throw new IllegalArgumentException(\"type should not be empty.\");\n    }\n    return algs.get(type);\n  }\n}\n\npublic class Sorter {\n  private static final long GB = 1000 * 1000 * 1000;\n\n  public void sortFile(String filePath) {\n    // 省略校验逻辑\n    File file = new File(filePath);\n    long fileSize = file.length();\n    ISortAlg sortAlg;\n    if (fileSize < 6 * GB) { // [0, 6GB)\n      sortAlg = SortAlgFactory.getSortAlg(\"QuickSort\");\n    } else if (fileSize < 10 * GB) { // [6GB, 10GB)\n      sortAlg = SortAlgFactory.getSortAlg(\"ExternalSort\");\n    } else if (fileSize < 100 * GB) { // [10GB, 100GB)\n      sortAlg = SortAlgFactory.getSortAlg(\"ConcurrentExternalSort\");\n    } else { // [100GB, ~)\n      sortAlg = SortAlgFactory.getSortAlg(\"MapReduceSort\");\n    }\n    sortAlg.sort(filePath);\n  }\n}\n```\n\n经过两次重构后，现在的代码已经符合策略模式的代码结构了。通过策略模式将策略的定义、创建、使用解耦，让每一部分不至于太复杂。但是还是有一堆if-else逻辑，这里的if-else分支不多，也不复杂，这样写也没什么问题。可以基于查表法来解决，其中的\"algs\"就是“表”。\n\n```java\npublic class Sorter {\n  private static final long GB = 1000 * 1000 * 1000;\n  private static final List<AlgRange> algs = new ArrayList<>();\n  static {\n    algs.add(new AlgRange(0, 6*GB, SortAlgFactory.getSortAlg(\"QuickSort\")));\n    algs.add(new AlgRange(6*GB, 10*GB, SortAlgFactory.getSortAlg(\"ExternalSort\")));\n    algs.add(new AlgRange(10*GB, 100*GB, SortAlgFactory.getSortAlg(\"ConcurrentExternalSort\")));\n    algs.add(new AlgRange(100*GB, Long.MAX_VALUE, SortAlgFactory.getSortAlg(\"MapReduceSort\")));\n  }\n\n  public void sortFile(String filePath) {\n    // 省略校验逻辑\n    File file = new File(filePath);\n    long fileSize = file.length();\n    ISortAlg sortAlg = null;\n    for (AlgRange algRange : algs) {\n      if (algRange.inRange(fileSize)) {\n        sortAlg = algRange.getAlg();\n        break;\n      }\n    }\n    sortAlg.sort(filePath);\n  }\n\n  private static class AlgRange {\n    private long start;\n    private long end;\n    private ISortAlg alg;\n\n    public AlgRange(long start, long end, ISortAlg alg) {\n      this.start = start;\n      this.end = end;\n      this.alg = alg;\n    }\n\n    public ISortAlg getAlg() {\n      return alg;\n    }\n\n    public boolean inRange(long size) {\n      return size >= start && size < end;\n    }\n  }\n}\n```\n\n现在的代码就比较优美了。把可变的部分隔离到了策略工厂类和Sorter类中的静态代码段中。当要添加新的排序算法时，只需要修改策略工厂类和Sorter类中静态代码段，其他代码都不需要修改，这样就将代码改动最小化、集中化了。\n\n对于Java语言来说，我们可以通过反射来避免对策略工厂类的修改。可以通过一个配置文件或者自定义的annotation来标注有哪些策略类。策略工厂类读取配置文件或者搜索被annotation标注的策略类，然后通过反射动态地加载这些策略类、创建策略对象。当我们新添加一个策略的时候，只需要将这个新添加的策略类添加到配置文件或者用annotation标注即可。\n\n策略模式主要作用是解耦策略的定义、创建和使用，控制代码的复杂度，让每个部分都不至于过于复杂、代码量过多。除此之外，对于复杂代码来说，策略模式还能让其满足开闭原则，添加新策略的时候，最小化、集中化代码改动，减少引入bug的风险。\n\n设计原则和思想比设计模式更加普适和重要。掌握了代码的设计原则和思想，我们能更清楚的了解，为什么要用某种设计模式，就能更恰当地应用设计模式。\n\n\n\n\n\n","source":"_posts/设计模式之策略模式.md","raw":"---\nlayout:    post\ntitle:     设计模式之策略模式\ncategory:  设计模式之美\ndescription: 设计模式之策略模式\ntags: 设计模式之美\ndate: 2021/06/03 13:26:10\n---\n\n策略模式最常用的场景是避免冗长的if-else或switch分支判断。不过它还可以像模版模式那样，提供框架的扩展点等。\n\n策略模式，英文全称是Strategy Design Pattern。在GoF的《设计模式》一书中，是这样定义的：\n\n```java\nDefine a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from clients that use it.\n```\n\n翻译成中文是：定义一族算法类，将每个算法分别封装起来，让它们可以相互替换。策略模式可以使算法的变化独立于使用它们的客户端（这里的客户端代指使用算法的代码）。\n\n工厂模式是解耦对象的创建和使用，观察者模式是解耦观察者和被观察者。策略模式是解耦策略的定义、创建、使用这三部分。\n\n##### 1.策略的定义\n\n策略类的定义比较简单，包含一个策略接口和一组实现这个接口的策略类。因为所有的策略类都实现相同的接口，所以客户端代码基于接口编程而非实现编程，可以灵活地替换不同的策略。\n\n```java\npublic interface Strategy {\n  void algorithmInterface();\n}\n\npublic class ConcreteStrategyA implements Strategy {\n  @Override \n  public void algorithmInterface() {\n    //具体的实现...\n  }\n}\n\npublic class ConcreteStrategyB implements Strategy {\n\t  @Override \n  public void algorithmInterface() {\n    //具体的实现...\n  }\n}\n```\n\n##### 2.策略的创建\n\n因为策略模式会包含一组策略，在使用它们的时候，一般会通过类型（type）来判断创建哪个策略来使用。为了封装创建逻辑，我们需要对客户端代码屏蔽创建细节。我们可以把根据type创建策略的逻辑抽离出来，放到工厂类中。示例代码如下:\n\n```java\npublic class StrategyFactory {\n  private static final Map<String,Strategy> strategies = new HashMap<>();\n  \n  static {\n    strategies.put(\"A\",new ConcreteStrategyA());\n    strategies.put(\"B\",new ConcreteStrategyB());\n  }\n  \n  public static Strategy getStrategy(String type) {\n    if(type ==null || type.isEmpty()) {\n      throw new IllegalArgumentException(\"type should not be empty.\");\n    }\n    return strategies.get(type);\n  }\n}\n```\n\n一般来说，如果策略类是无状态的，不包含成员变量，只是纯粹的算法实现，这样的策略对象是可以被共享使用的，不需要在每次调用getStrategy()的时候，都创建一个新的策略对象。这种情况下，就可以用工厂类的实现方式，事先创建好每个策略对象，缓存到工厂类中，用的时候直接返回。\n\n如果策略类是有状态的，根据业务场景需要，我们希望每次获取的都是新创建的策略对象，而不是缓存好可共享的策略对象。那就需要使用下面的工厂。\n\n```java\npublic class StrategyFactory {\n  public static Strategy getStrategy(String type) {\n    if(type == null || type.isEmpty()) {\n      throw new IllegalArgumentException(\"type should not be empty.\");\n    }\n    \n    if(type.equals(\"A\")) {\n      return new ConcreteStrategyA();\n    }else if (type.equals(\"B\")) {\n      return new ConcreteStrategyB();\n    }\n    return null;\n  } \n}\n```\n\n##### 3.策略的使用\n\n策略模式包含一组可选策略，客户端代码如何确定使用哪个策略呢？常见的是运行时动态确定使用哪种策略，这也是策略模式最经典的应用场景。这里的动态，是事先并不知道会使用哪个策略，而是在程序运行期间，根据配置、用户输入、计算结果等这些不确定因素，动态决定使用哪种策略。\n\n```java\n//策略接口 EvictionStrategy\n//策略类：LruEvictionStrategy、FifoEvictionStrategy、LfuEvictionStrategy...\n//策略工厂：EvictionStrategyFactory\npublic class UserCache {\n  private Map<String,User> cacheData = new HashMap<>();\n  private EvictionStrategy eviction;\n  \n  public UserCache(EvictionStrategy eviction) {\n    this.eviction = eviction;\n  }\n  \n  //...\n}\n\n//运行时动态确定，根据配置文件的配置决定使用哪种策略\npublic class Application {\n  public static void main(String[] args) throws Exception{\n    EvictionStrategy evictionStrategy = null;\n    Properties props = new Properties(); \n    props.load(new FileInputStream(\"./config.properties\"));\n    String type = props.getProperty(\"eviction_type\");\n    evictionStrategy = EvictionStrategyFactory.getEvictionStrategy(type);\n    UserCache userCache = new UserCache(evictionStrategy); \n    //...\n  }\n}\n\n//非运行时动态确定，在代码中指定使用哪种策略\npublic class Application {\n  public static void main(String[] args) {\n    //... \n    EvictionStrategy evictionStrategy = new LruEvictionStrategy();\n    UserCache userCache = new UserCache(evictionStrategy); \n    //...\n  } \n}\n```\n\n非运行时动态确定，并不能发挥策略模式的优势。这种场景下，策略模式实际上退化成了“面向对象的多态特性”或“基于接口而非实现编程原则”。\n\n##### 如何利用策略模式避免分支判断\n\n能够移除分支判断逻辑的模式不仅仅有策略模式，状态模式也可以。对于使用哪种模式，具体还要看应用场景来定。策略模式适用于根据不同类型的动态，决定使用哪种策略这一种应用场景。\n\n先来看下if-else 或switch-case 分支判断逻辑是如何产生的。\n\n```java\n\npublic class OrderService {\n  public double discount(Order order) {\n    double discount = 0.0;\n    OrderType type = order.getType();\n    if (type.equals(OrderType.NORMAL)) { // 普通订单\n      //...省略折扣计算算法代码\n    } else if (type.equals(OrderType.GROUPON)) { // 团购订单\n      //...省略折扣计算算法代码\n    } else if (type.equals(OrderType.PROMOTION)) { // 促销订单\n      //...省略折扣计算算法代码\n    }\n    return discount;\n  }\n}\n```\n\n使用策略模式对上面的代码重构，将不同类型订单的打折策略设计成策略类，并由工厂类来负责创建策略对象。代码示例如下：\n\n```java\n\n// 策略的定义\npublic interface DiscountStrategy {\n  double calDiscount(Order order);\n}\n// 省略NormalDiscountStrategy、GrouponDiscountStrategy、PromotionDiscountStrategy类代码...\n\n// 策略的创建\npublic class DiscountStrategyFactory {\n  private static final Map<OrderType, DiscountStrategy> strategies = new HashMap<>();\n\n  static {\n    strategies.put(OrderType.NORMAL, new NormalDiscountStrategy());\n    strategies.put(OrderType.GROUPON, new GrouponDiscountStrategy());\n    strategies.put(OrderType.PROMOTION, new PromotionDiscountStrategy());\n  }\n\n  public static DiscountStrategy getDiscountStrategy(OrderType type) {\n    return strategies.get(type);\n  }\n}\n\n// 策略的使用\npublic class OrderService {\n  public double discount(Order order) {\n    OrderType type = order.getType();\n    DiscountStrategy discountStrategy = DiscountStrategyFactory.getDiscountStrategy(type);\n    return discountStrategy.calDiscount(order);\n  }\n}\n```\n\n重构之后的代码没有if-else 分支判断语句了。这得益于策略工厂类。在工厂类中，我们用Map来缓存策略，根据type直接从Map中获取对应的策略，从而避免if-else分支判断逻辑。其实就是借助“查表法”，根据type查表（代码中的strategies就是表）替代根据type分支判断。\n\n但是，如果业务场景需要每次创建不同的策略对象，我们就要用另一种工厂类的实现方式了。\n\n```java\n\npublic class DiscountStrategyFactory {\n  public static DiscountStrategy getDiscountStrategy(OrderType type) {\n    if (type == null) {\n      throw new IllegalArgumentException(\"Type should not be null.\");\n    }\n    if (type.equals(OrderType.NORMAL)) {\n      return new NormalDiscountStrategy();\n    } else if (type.equals(OrderType.GROUPON)) {\n      return new GrouponDiscountStrategy();\n    } else if (type.equals(OrderType.PROMOTION)) {\n      return new PromotionDiscountStrategy();\n    }\n    return null;\n  }\n}\n```\n\n单是这种方式相当于把原来的if-else分支逻辑，从OrderService类中已到了工厂类中，实际上并没有移除。\n\n可以像非动态的策略工厂一样，不过value放对应策略类的class，这样就可以通过反射去获取新的对象了。\n\n假设有这样一个需求，希望写一个小程序，实现一个对文件进行排序的功能。文件中只包含整型数，并且，相邻的数字通过逗号来分隔。\n\n最简单的思路，只需要将文件中的内容读取出来，并且通过逗号分隔成一个一个的数字放到内存数组中，然后编写某种排序算法，或者直接用编程语言提供的排序函数，对数组进行排序，最后再将数组中的数据写入文件就可以了。\n\n但是如果文件很大呢，如果文件10GB，内存只有8G，无法一次性加载文件中的所有数据到内存中，这个时候，就要利用外部排序算法了。\n\n如果文件更大，有100G大小，为了利用CPU多核的优势，可以在外部排序的基础上进行优化，加入多线程并发排序的功能，这就有点像“单机版”的MapReduce。\n\n如果文件非常大，有1TB，即便是单机多线程排序，也很慢，这个时候可以使用真正的MapReduce框架，利用多机的处理能力，提高排序的效率。\n\n```java\npublic class Sorter {\n  public static final long GB = 1000 * 1000 * 1000;\n  \n  public void sortFile(String filePath) {\n    //省略校验逻辑\n    File file = new File(filePath);\n    long fileSize = file.length();\n    if (fileSize < 6 * GB) { // [0, 6GB) \n      quickSort(filePath); \n    } else if (fileSize < 10 * GB) { // [6GB, 10GB) \n      externalSort(filePath); \n    } else if (fileSize < 100 * GB) { // [10GB, 100GB) \n      concurrentExternalSort(filePath); \n    } else { // [100GB, ~) \n      mapreduceSort(filePath); \n    }\n  }\n private void quickSort(String filePath) { \n   // 快速排序 \n } \n  \n  private void externalSort(String filePath) { \n   // 外部排序\n } \n  \n  private void concurrentExternalSort(String filePath) {\n   // 多线程外部排序 \n  } \n  \n  private void mapreduceSort(String filePath) { \n    // 利用MapReduce多机排序 \n  }\n}\npublic class SortingTool { \n  public static void main(String[] args) { \n    Sorter sorter = new Sorter();\n    sorter.sortFile(args[0]);\n  }\n}\n```\n\n如果只是开发一个简单的工具，那上面的代码实现就足够了。毕竟代码不多，后续修改、扩展的需求也不多，怎么写都不会导致代码不可维护。但是，如果我们是在开发一个大型项目，排序文件只是其中一个功能模块，那我们就要在代码设计、代码质量上下点儿功夫。只有每个小的功能模块都写好，整个项目的代码才能不差。\n\n刚刚的代码中，并没有给每种排序算法的代码实现，如果实现一下的话，每种排序算法的实现逻辑都比较复杂，代码行数都比较多。所有的排序算法都在Sorter类中，这就会导致这个类的代码很多，会影响到可读性、可维护性。除此之外，所有的排序算法都设计成Sorter的私有函数，也会影响代码的可复用性。\n\n针对上面的问题，即便想不到用什么设计模式来重构，但是也知道该把Sorter类中的某些代码拆分出来，独立成职责更加单一的小类。拆分是应对类或者函数代码过多、应对代码复杂性的一个常用手段。\n\n```java\npublic interface ISortAlg {\n  void sort(String filePath);\n}\n\npublic class QuickSort implements ISortAlg {\n  @Override\n  public void sort(String filePath) {\n    //...\n  }\n}\n\npublic class ExternalSort implements ISortAlg {\n  @Override\n  public void sort(String filePath) {\n    //...\n  }\n}\n\npublic class ConcurrentExternalSort implements ISortAlg {\n  @Override\n  public void sort(String filePath) {\n    //...\n  }\n}\n\npublic class MapReduceSort implements ISortAlg {\n  @Override\n  public void sort(String filePath) {\n    //...\n  }\n}\n\npublic class Sorter {\n  private static final long GB = 1000 * 1000 * 1000;\n\n  public void sortFile(String filePath) {\n    // 省略校验逻辑\n    File file = new File(filePath);\n    long fileSize = file.length();\n    ISortAlg sortAlg;\n    if (fileSize < 6 * GB) { // [0, 6GB)\n      sortAlg = new QuickSort();\n    } else if (fileSize < 10 * GB) { // [6GB, 10GB)\n      sortAlg = new ExternalSort();\n    } else if (fileSize < 100 * GB) { // [10GB, 100GB)\n      sortAlg = new ConcurrentExternalSort();\n    } else { // [100GB, ~)\n      sortAlg = new MapReduceSort();\n    }\n    sortAlg.sort(filePath);\n  }\n}\n```\n\n拆分过后，每个类的代码都不会太多，每个类的逻辑都不会太复杂，代码的可读性、可维护性提高了。将排序算法设计成独立的类，跟具体的业务逻辑（代码中的if-else那部分逻辑）解耦，也让排序算法能够复用。这一步就是策略模式的第一步，将策略的定义分离出来。\n\n上面的代码还可以继续优化。每种排序类都是无状态的，没必要每次使用的时候都重新创建一个新的对象。可以使用工厂模式对对象的创建进行封装。\n\n```java\npublic class SortAlgFactory {\n  private static final Map<String, ISortAlg> algs = new HashMap<>();\n\n  static {\n    algs.put(\"QuickSort\", new QuickSort());\n    algs.put(\"ExternalSort\", new ExternalSort());\n    algs.put(\"ConcurrentExternalSort\", new ConcurrentExternalSort());\n    algs.put(\"MapReduceSort\", new MapReduceSort());\n  }\n\n  public static ISortAlg getSortAlg(String type) {\n    if (type == null || type.isEmpty()) {\n      throw new IllegalArgumentException(\"type should not be empty.\");\n    }\n    return algs.get(type);\n  }\n}\n\npublic class Sorter {\n  private static final long GB = 1000 * 1000 * 1000;\n\n  public void sortFile(String filePath) {\n    // 省略校验逻辑\n    File file = new File(filePath);\n    long fileSize = file.length();\n    ISortAlg sortAlg;\n    if (fileSize < 6 * GB) { // [0, 6GB)\n      sortAlg = SortAlgFactory.getSortAlg(\"QuickSort\");\n    } else if (fileSize < 10 * GB) { // [6GB, 10GB)\n      sortAlg = SortAlgFactory.getSortAlg(\"ExternalSort\");\n    } else if (fileSize < 100 * GB) { // [10GB, 100GB)\n      sortAlg = SortAlgFactory.getSortAlg(\"ConcurrentExternalSort\");\n    } else { // [100GB, ~)\n      sortAlg = SortAlgFactory.getSortAlg(\"MapReduceSort\");\n    }\n    sortAlg.sort(filePath);\n  }\n}\n```\n\n经过两次重构后，现在的代码已经符合策略模式的代码结构了。通过策略模式将策略的定义、创建、使用解耦，让每一部分不至于太复杂。但是还是有一堆if-else逻辑，这里的if-else分支不多，也不复杂，这样写也没什么问题。可以基于查表法来解决，其中的\"algs\"就是“表”。\n\n```java\npublic class Sorter {\n  private static final long GB = 1000 * 1000 * 1000;\n  private static final List<AlgRange> algs = new ArrayList<>();\n  static {\n    algs.add(new AlgRange(0, 6*GB, SortAlgFactory.getSortAlg(\"QuickSort\")));\n    algs.add(new AlgRange(6*GB, 10*GB, SortAlgFactory.getSortAlg(\"ExternalSort\")));\n    algs.add(new AlgRange(10*GB, 100*GB, SortAlgFactory.getSortAlg(\"ConcurrentExternalSort\")));\n    algs.add(new AlgRange(100*GB, Long.MAX_VALUE, SortAlgFactory.getSortAlg(\"MapReduceSort\")));\n  }\n\n  public void sortFile(String filePath) {\n    // 省略校验逻辑\n    File file = new File(filePath);\n    long fileSize = file.length();\n    ISortAlg sortAlg = null;\n    for (AlgRange algRange : algs) {\n      if (algRange.inRange(fileSize)) {\n        sortAlg = algRange.getAlg();\n        break;\n      }\n    }\n    sortAlg.sort(filePath);\n  }\n\n  private static class AlgRange {\n    private long start;\n    private long end;\n    private ISortAlg alg;\n\n    public AlgRange(long start, long end, ISortAlg alg) {\n      this.start = start;\n      this.end = end;\n      this.alg = alg;\n    }\n\n    public ISortAlg getAlg() {\n      return alg;\n    }\n\n    public boolean inRange(long size) {\n      return size >= start && size < end;\n    }\n  }\n}\n```\n\n现在的代码就比较优美了。把可变的部分隔离到了策略工厂类和Sorter类中的静态代码段中。当要添加新的排序算法时，只需要修改策略工厂类和Sorter类中静态代码段，其他代码都不需要修改，这样就将代码改动最小化、集中化了。\n\n对于Java语言来说，我们可以通过反射来避免对策略工厂类的修改。可以通过一个配置文件或者自定义的annotation来标注有哪些策略类。策略工厂类读取配置文件或者搜索被annotation标注的策略类，然后通过反射动态地加载这些策略类、创建策略对象。当我们新添加一个策略的时候，只需要将这个新添加的策略类添加到配置文件或者用annotation标注即可。\n\n策略模式主要作用是解耦策略的定义、创建和使用，控制代码的复杂度，让每个部分都不至于过于复杂、代码量过多。除此之外，对于复杂代码来说，策略模式还能让其满足开闭原则，添加新策略的时候，最小化、集中化代码改动，减少引入bug的风险。\n\n设计原则和思想比设计模式更加普适和重要。掌握了代码的设计原则和思想，我们能更清楚的了解，为什么要用某种设计模式，就能更恰当地应用设计模式。\n\n\n\n\n\n","slug":"设计模式之策略模式","published":1,"updated":"2021-06-03T05:26:10.000Z","comments":1,"photos":[],"link":"","_id":"cm1m304ya003z31b42xb5azxi","content":"<p>策略模式最常用的场景是避免冗长的if-else或switch分支判断。不过它还可以像模版模式那样，提供框架的扩展点等。</p>\n<p>策略模式，英文全称是Strategy Design Pattern。在GoF的《设计模式》一书中，是这样定义的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Define a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from clients that use it.</span><br></pre></td></tr></table></figure>\n\n<p>翻译成中文是：定义一族算法类，将每个算法分别封装起来，让它们可以相互替换。策略模式可以使算法的变化独立于使用它们的客户端（这里的客户端代指使用算法的代码）。</p>\n<p>工厂模式是解耦对象的创建和使用，观察者模式是解耦观察者和被观察者。策略模式是解耦策略的定义、创建、使用这三部分。</p>\n<h5 id=\"1-策略的定义\"><a href=\"#1-策略的定义\" class=\"headerlink\" title=\"1.策略的定义\"></a>1.策略的定义</h5><p>策略类的定义比较简单，包含一个策略接口和一组实现这个接口的策略类。因为所有的策略类都实现相同的接口，所以客户端代码基于接口编程而非实现编程，可以灵活地替换不同的策略。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Strategy</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">algorithmInterface</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConcreteStrategyA</span> <span class=\"keyword\">implements</span> <span class=\"title\">Strategy</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span> </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">algorithmInterface</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//具体的实现...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConcreteStrategyB</span> <span class=\"keyword\">implements</span> <span class=\"title\">Strategy</span> </span>&#123;</span><br><span class=\"line\">\t  <span class=\"meta\">@Override</span> </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">algorithmInterface</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//具体的实现...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"2-策略的创建\"><a href=\"#2-策略的创建\" class=\"headerlink\" title=\"2.策略的创建\"></a>2.策略的创建</h5><p>因为策略模式会包含一组策略，在使用它们的时候，一般会通过类型（type）来判断创建哪个策略来使用。为了封装创建逻辑，我们需要对客户端代码屏蔽创建细节。我们可以把根据type创建策略的逻辑抽离出来，放到工厂类中。示例代码如下:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StrategyFactory</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Map&lt;String,Strategy&gt; strategies = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">    strategies.put(<span class=\"string\">&quot;A&quot;</span>,<span class=\"keyword\">new</span> ConcreteStrategyA());</span><br><span class=\"line\">    strategies.put(<span class=\"string\">&quot;B&quot;</span>,<span class=\"keyword\">new</span> ConcreteStrategyB());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Strategy <span class=\"title\">getStrategy</span><span class=\"params\">(String type)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(type ==<span class=\"keyword\">null</span> || type.isEmpty()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">&quot;type should not be empty.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> strategies.get(type);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>一般来说，如果策略类是无状态的，不包含成员变量，只是纯粹的算法实现，这样的策略对象是可以被共享使用的，不需要在每次调用getStrategy()的时候，都创建一个新的策略对象。这种情况下，就可以用工厂类的实现方式，事先创建好每个策略对象，缓存到工厂类中，用的时候直接返回。</p>\n<p>如果策略类是有状态的，根据业务场景需要，我们希望每次获取的都是新创建的策略对象，而不是缓存好可共享的策略对象。那就需要使用下面的工厂。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StrategyFactory</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Strategy <span class=\"title\">getStrategy</span><span class=\"params\">(String type)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(type == <span class=\"keyword\">null</span> || type.isEmpty()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">&quot;type should not be empty.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(type.equals(<span class=\"string\">&quot;A&quot;</span>)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ConcreteStrategyA();</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (type.equals(<span class=\"string\">&quot;B&quot;</span>)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ConcreteStrategyB();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"3-策略的使用\"><a href=\"#3-策略的使用\" class=\"headerlink\" title=\"3.策略的使用\"></a>3.策略的使用</h5><p>策略模式包含一组可选策略，客户端代码如何确定使用哪个策略呢？常见的是运行时动态确定使用哪种策略，这也是策略模式最经典的应用场景。这里的动态，是事先并不知道会使用哪个策略，而是在程序运行期间，根据配置、用户输入、计算结果等这些不确定因素，动态决定使用哪种策略。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//策略接口 EvictionStrategy</span></span><br><span class=\"line\"><span class=\"comment\">//策略类：LruEvictionStrategy、FifoEvictionStrategy、LfuEvictionStrategy...</span></span><br><span class=\"line\"><span class=\"comment\">//策略工厂：EvictionStrategyFactory</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserCache</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Map&lt;String,User&gt; cacheData = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">  <span class=\"keyword\">private</span> EvictionStrategy eviction;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">UserCache</span><span class=\"params\">(EvictionStrategy eviction)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.eviction = eviction;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//运行时动态确定，根据配置文件的配置决定使用哪种策略</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Application</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception</span>&#123;</span><br><span class=\"line\">    EvictionStrategy evictionStrategy = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    Properties props = <span class=\"keyword\">new</span> Properties(); </span><br><span class=\"line\">    props.load(<span class=\"keyword\">new</span> FileInputStream(<span class=\"string\">&quot;./config.properties&quot;</span>));</span><br><span class=\"line\">    String type = props.getProperty(<span class=\"string\">&quot;eviction_type&quot;</span>);</span><br><span class=\"line\">    evictionStrategy = EvictionStrategyFactory.getEvictionStrategy(type);</span><br><span class=\"line\">    UserCache userCache = <span class=\"keyword\">new</span> UserCache(evictionStrategy); </span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//非运行时动态确定，在代码中指定使用哪种策略</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Application</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//... </span></span><br><span class=\"line\">    EvictionStrategy evictionStrategy = <span class=\"keyword\">new</span> LruEvictionStrategy();</span><br><span class=\"line\">    UserCache userCache = <span class=\"keyword\">new</span> UserCache(evictionStrategy); </span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>非运行时动态确定，并不能发挥策略模式的优势。这种场景下，策略模式实际上退化成了“面向对象的多态特性”或“基于接口而非实现编程原则”。</p>\n<h5 id=\"如何利用策略模式避免分支判断\"><a href=\"#如何利用策略模式避免分支判断\" class=\"headerlink\" title=\"如何利用策略模式避免分支判断\"></a>如何利用策略模式避免分支判断</h5><p>能够移除分支判断逻辑的模式不仅仅有策略模式，状态模式也可以。对于使用哪种模式，具体还要看应用场景来定。策略模式适用于根据不同类型的动态，决定使用哪种策略这一种应用场景。</p>\n<p>先来看下if-else 或switch-case 分支判断逻辑是如何产生的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OrderService</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">double</span> <span class=\"title\">discount</span><span class=\"params\">(Order order)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> discount = <span class=\"number\">0.0</span>;</span><br><span class=\"line\">    OrderType type = order.getType();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (type.equals(OrderType.NORMAL)) &#123; <span class=\"comment\">// 普通订单</span></span><br><span class=\"line\">      <span class=\"comment\">//...省略折扣计算算法代码</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (type.equals(OrderType.GROUPON)) &#123; <span class=\"comment\">// 团购订单</span></span><br><span class=\"line\">      <span class=\"comment\">//...省略折扣计算算法代码</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (type.equals(OrderType.PROMOTION)) &#123; <span class=\"comment\">// 促销订单</span></span><br><span class=\"line\">      <span class=\"comment\">//...省略折扣计算算法代码</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> discount;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用策略模式对上面的代码重构，将不同类型订单的打折策略设计成策略类，并由工厂类来负责创建策略对象。代码示例如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 策略的定义</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">DiscountStrategy</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">calDiscount</span><span class=\"params\">(Order order)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 省略NormalDiscountStrategy、GrouponDiscountStrategy、PromotionDiscountStrategy类代码...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 策略的创建</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DiscountStrategyFactory</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Map&lt;OrderType, DiscountStrategy&gt; strategies = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">    strategies.put(OrderType.NORMAL, <span class=\"keyword\">new</span> NormalDiscountStrategy());</span><br><span class=\"line\">    strategies.put(OrderType.GROUPON, <span class=\"keyword\">new</span> GrouponDiscountStrategy());</span><br><span class=\"line\">    strategies.put(OrderType.PROMOTION, <span class=\"keyword\">new</span> PromotionDiscountStrategy());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> DiscountStrategy <span class=\"title\">getDiscountStrategy</span><span class=\"params\">(OrderType type)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> strategies.get(type);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 策略的使用</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OrderService</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">double</span> <span class=\"title\">discount</span><span class=\"params\">(Order order)</span> </span>&#123;</span><br><span class=\"line\">    OrderType type = order.getType();</span><br><span class=\"line\">    DiscountStrategy discountStrategy = DiscountStrategyFactory.getDiscountStrategy(type);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> discountStrategy.calDiscount(order);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>重构之后的代码没有if-else 分支判断语句了。这得益于策略工厂类。在工厂类中，我们用Map来缓存策略，根据type直接从Map中获取对应的策略，从而避免if-else分支判断逻辑。其实就是借助“查表法”，根据type查表（代码中的strategies就是表）替代根据type分支判断。</p>\n<p>但是，如果业务场景需要每次创建不同的策略对象，我们就要用另一种工厂类的实现方式了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DiscountStrategyFactory</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> DiscountStrategy <span class=\"title\">getDiscountStrategy</span><span class=\"params\">(OrderType type)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (type == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">&quot;Type should not be null.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (type.equals(OrderType.NORMAL)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> NormalDiscountStrategy();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (type.equals(OrderType.GROUPON)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> GrouponDiscountStrategy();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (type.equals(OrderType.PROMOTION)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> PromotionDiscountStrategy();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>单是这种方式相当于把原来的if-else分支逻辑，从OrderService类中已到了工厂类中，实际上并没有移除。</p>\n<p>可以像非动态的策略工厂一样，不过value放对应策略类的class，这样就可以通过反射去获取新的对象了。</p>\n<p>假设有这样一个需求，希望写一个小程序，实现一个对文件进行排序的功能。文件中只包含整型数，并且，相邻的数字通过逗号来分隔。</p>\n<p>最简单的思路，只需要将文件中的内容读取出来，并且通过逗号分隔成一个一个的数字放到内存数组中，然后编写某种排序算法，或者直接用编程语言提供的排序函数，对数组进行排序，最后再将数组中的数据写入文件就可以了。</p>\n<p>但是如果文件很大呢，如果文件10GB，内存只有8G，无法一次性加载文件中的所有数据到内存中，这个时候，就要利用外部排序算法了。</p>\n<p>如果文件更大，有100G大小，为了利用CPU多核的优势，可以在外部排序的基础上进行优化，加入多线程并发排序的功能，这就有点像“单机版”的MapReduce。</p>\n<p>如果文件非常大，有1TB，即便是单机多线程排序，也很慢，这个时候可以使用真正的MapReduce框架，利用多机的处理能力，提高排序的效率。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sorter</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> GB = <span class=\"number\">1000</span> * <span class=\"number\">1000</span> * <span class=\"number\">1000</span>;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sortFile</span><span class=\"params\">(String filePath)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//省略校验逻辑</span></span><br><span class=\"line\">    File file = <span class=\"keyword\">new</span> File(filePath);</span><br><span class=\"line\">    <span class=\"keyword\">long</span> fileSize = file.length();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fileSize &lt; <span class=\"number\">6</span> * GB) &#123; <span class=\"comment\">// [0, 6GB) </span></span><br><span class=\"line\">      quickSort(filePath); </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (fileSize &lt; <span class=\"number\">10</span> * GB) &#123; <span class=\"comment\">// [6GB, 10GB) </span></span><br><span class=\"line\">      externalSort(filePath); </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (fileSize &lt; <span class=\"number\">100</span> * GB) &#123; <span class=\"comment\">// [10GB, 100GB) </span></span><br><span class=\"line\">      concurrentExternalSort(filePath); </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// [100GB, ~) </span></span><br><span class=\"line\">      mapreduceSort(filePath); </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">quickSort</span><span class=\"params\">(String filePath)</span> </span>&#123; </span><br><span class=\"line\">   <span class=\"comment\">// 快速排序 </span></span><br><span class=\"line\"> &#125; </span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">externalSort</span><span class=\"params\">(String filePath)</span> </span>&#123; </span><br><span class=\"line\">   <span class=\"comment\">// 外部排序</span></span><br><span class=\"line\"> &#125; </span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">concurrentExternalSort</span><span class=\"params\">(String filePath)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// 多线程外部排序 </span></span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">mapreduceSort</span><span class=\"params\">(String filePath)</span> </span>&#123; </span><br><span class=\"line\">    <span class=\"comment\">// 利用MapReduce多机排序 </span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SortingTool</span> </span>&#123; </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123; </span><br><span class=\"line\">    Sorter sorter = <span class=\"keyword\">new</span> Sorter();</span><br><span class=\"line\">    sorter.sortFile(args[<span class=\"number\">0</span>]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果只是开发一个简单的工具，那上面的代码实现就足够了。毕竟代码不多，后续修改、扩展的需求也不多，怎么写都不会导致代码不可维护。但是，如果我们是在开发一个大型项目，排序文件只是其中一个功能模块，那我们就要在代码设计、代码质量上下点儿功夫。只有每个小的功能模块都写好，整个项目的代码才能不差。</p>\n<p>刚刚的代码中，并没有给每种排序算法的代码实现，如果实现一下的话，每种排序算法的实现逻辑都比较复杂，代码行数都比较多。所有的排序算法都在Sorter类中，这就会导致这个类的代码很多，会影响到可读性、可维护性。除此之外，所有的排序算法都设计成Sorter的私有函数，也会影响代码的可复用性。</p>\n<p>针对上面的问题，即便想不到用什么设计模式来重构，但是也知道该把Sorter类中的某些代码拆分出来，独立成职责更加单一的小类。拆分是应对类或者函数代码过多、应对代码复杂性的一个常用手段。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ISortAlg</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(String filePath)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">QuickSort</span> <span class=\"keyword\">implements</span> <span class=\"title\">ISortAlg</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(String filePath)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExternalSort</span> <span class=\"keyword\">implements</span> <span class=\"title\">ISortAlg</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(String filePath)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConcurrentExternalSort</span> <span class=\"keyword\">implements</span> <span class=\"title\">ISortAlg</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(String filePath)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MapReduceSort</span> <span class=\"keyword\">implements</span> <span class=\"title\">ISortAlg</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(String filePath)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sorter</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> GB = <span class=\"number\">1000</span> * <span class=\"number\">1000</span> * <span class=\"number\">1000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sortFile</span><span class=\"params\">(String filePath)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 省略校验逻辑</span></span><br><span class=\"line\">    File file = <span class=\"keyword\">new</span> File(filePath);</span><br><span class=\"line\">    <span class=\"keyword\">long</span> fileSize = file.length();</span><br><span class=\"line\">    ISortAlg sortAlg;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fileSize &lt; <span class=\"number\">6</span> * GB) &#123; <span class=\"comment\">// [0, 6GB)</span></span><br><span class=\"line\">      sortAlg = <span class=\"keyword\">new</span> QuickSort();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (fileSize &lt; <span class=\"number\">10</span> * GB) &#123; <span class=\"comment\">// [6GB, 10GB)</span></span><br><span class=\"line\">      sortAlg = <span class=\"keyword\">new</span> ExternalSort();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (fileSize &lt; <span class=\"number\">100</span> * GB) &#123; <span class=\"comment\">// [10GB, 100GB)</span></span><br><span class=\"line\">      sortAlg = <span class=\"keyword\">new</span> ConcurrentExternalSort();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// [100GB, ~)</span></span><br><span class=\"line\">      sortAlg = <span class=\"keyword\">new</span> MapReduceSort();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sortAlg.sort(filePath);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>拆分过后，每个类的代码都不会太多，每个类的逻辑都不会太复杂，代码的可读性、可维护性提高了。将排序算法设计成独立的类，跟具体的业务逻辑（代码中的if-else那部分逻辑）解耦，也让排序算法能够复用。这一步就是策略模式的第一步，将策略的定义分离出来。</p>\n<p>上面的代码还可以继续优化。每种排序类都是无状态的，没必要每次使用的时候都重新创建一个新的对象。可以使用工厂模式对对象的创建进行封装。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SortAlgFactory</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Map&lt;String, ISortAlg&gt; algs = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">    algs.put(<span class=\"string\">&quot;QuickSort&quot;</span>, <span class=\"keyword\">new</span> QuickSort());</span><br><span class=\"line\">    algs.put(<span class=\"string\">&quot;ExternalSort&quot;</span>, <span class=\"keyword\">new</span> ExternalSort());</span><br><span class=\"line\">    algs.put(<span class=\"string\">&quot;ConcurrentExternalSort&quot;</span>, <span class=\"keyword\">new</span> ConcurrentExternalSort());</span><br><span class=\"line\">    algs.put(<span class=\"string\">&quot;MapReduceSort&quot;</span>, <span class=\"keyword\">new</span> MapReduceSort());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ISortAlg <span class=\"title\">getSortAlg</span><span class=\"params\">(String type)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (type == <span class=\"keyword\">null</span> || type.isEmpty()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">&quot;type should not be empty.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> algs.get(type);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sorter</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> GB = <span class=\"number\">1000</span> * <span class=\"number\">1000</span> * <span class=\"number\">1000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sortFile</span><span class=\"params\">(String filePath)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 省略校验逻辑</span></span><br><span class=\"line\">    File file = <span class=\"keyword\">new</span> File(filePath);</span><br><span class=\"line\">    <span class=\"keyword\">long</span> fileSize = file.length();</span><br><span class=\"line\">    ISortAlg sortAlg;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fileSize &lt; <span class=\"number\">6</span> * GB) &#123; <span class=\"comment\">// [0, 6GB)</span></span><br><span class=\"line\">      sortAlg = SortAlgFactory.getSortAlg(<span class=\"string\">&quot;QuickSort&quot;</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (fileSize &lt; <span class=\"number\">10</span> * GB) &#123; <span class=\"comment\">// [6GB, 10GB)</span></span><br><span class=\"line\">      sortAlg = SortAlgFactory.getSortAlg(<span class=\"string\">&quot;ExternalSort&quot;</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (fileSize &lt; <span class=\"number\">100</span> * GB) &#123; <span class=\"comment\">// [10GB, 100GB)</span></span><br><span class=\"line\">      sortAlg = SortAlgFactory.getSortAlg(<span class=\"string\">&quot;ConcurrentExternalSort&quot;</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// [100GB, ~)</span></span><br><span class=\"line\">      sortAlg = SortAlgFactory.getSortAlg(<span class=\"string\">&quot;MapReduceSort&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sortAlg.sort(filePath);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>经过两次重构后，现在的代码已经符合策略模式的代码结构了。通过策略模式将策略的定义、创建、使用解耦，让每一部分不至于太复杂。但是还是有一堆if-else逻辑，这里的if-else分支不多，也不复杂，这样写也没什么问题。可以基于查表法来解决，其中的”algs”就是“表”。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sorter</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> GB = <span class=\"number\">1000</span> * <span class=\"number\">1000</span> * <span class=\"number\">1000</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> List&lt;AlgRange&gt; algs = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">  <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">    algs.add(<span class=\"keyword\">new</span> AlgRange(<span class=\"number\">0</span>, <span class=\"number\">6</span>*GB, SortAlgFactory.getSortAlg(<span class=\"string\">&quot;QuickSort&quot;</span>)));</span><br><span class=\"line\">    algs.add(<span class=\"keyword\">new</span> AlgRange(<span class=\"number\">6</span>*GB, <span class=\"number\">10</span>*GB, SortAlgFactory.getSortAlg(<span class=\"string\">&quot;ExternalSort&quot;</span>)));</span><br><span class=\"line\">    algs.add(<span class=\"keyword\">new</span> AlgRange(<span class=\"number\">10</span>*GB, <span class=\"number\">100</span>*GB, SortAlgFactory.getSortAlg(<span class=\"string\">&quot;ConcurrentExternalSort&quot;</span>)));</span><br><span class=\"line\">    algs.add(<span class=\"keyword\">new</span> AlgRange(<span class=\"number\">100</span>*GB, Long.MAX_VALUE, SortAlgFactory.getSortAlg(<span class=\"string\">&quot;MapReduceSort&quot;</span>)));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sortFile</span><span class=\"params\">(String filePath)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 省略校验逻辑</span></span><br><span class=\"line\">    File file = <span class=\"keyword\">new</span> File(filePath);</span><br><span class=\"line\">    <span class=\"keyword\">long</span> fileSize = file.length();</span><br><span class=\"line\">    ISortAlg sortAlg = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (AlgRange algRange : algs) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (algRange.inRange(fileSize)) &#123;</span><br><span class=\"line\">        sortAlg = algRange.getAlg();</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sortAlg.sort(filePath);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AlgRange</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> start;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> end;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> ISortAlg alg;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">AlgRange</span><span class=\"params\">(<span class=\"keyword\">long</span> start, <span class=\"keyword\">long</span> end, ISortAlg alg)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.start = start;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.end = end;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.alg = alg;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ISortAlg <span class=\"title\">getAlg</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> alg;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">inRange</span><span class=\"params\">(<span class=\"keyword\">long</span> size)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> size &gt;= start &amp;&amp; size &lt; end;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>现在的代码就比较优美了。把可变的部分隔离到了策略工厂类和Sorter类中的静态代码段中。当要添加新的排序算法时，只需要修改策略工厂类和Sorter类中静态代码段，其他代码都不需要修改，这样就将代码改动最小化、集中化了。</p>\n<p>对于Java语言来说，我们可以通过反射来避免对策略工厂类的修改。可以通过一个配置文件或者自定义的annotation来标注有哪些策略类。策略工厂类读取配置文件或者搜索被annotation标注的策略类，然后通过反射动态地加载这些策略类、创建策略对象。当我们新添加一个策略的时候，只需要将这个新添加的策略类添加到配置文件或者用annotation标注即可。</p>\n<p>策略模式主要作用是解耦策略的定义、创建和使用，控制代码的复杂度，让每个部分都不至于过于复杂、代码量过多。除此之外，对于复杂代码来说，策略模式还能让其满足开闭原则，添加新策略的时候，最小化、集中化代码改动，减少引入bug的风险。</p>\n<p>设计原则和思想比设计模式更加普适和重要。掌握了代码的设计原则和思想，我们能更清楚的了解，为什么要用某种设计模式，就能更恰当地应用设计模式。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>策略模式最常用的场景是避免冗长的if-else或switch分支判断。不过它还可以像模版模式那样，提供框架的扩展点等。</p>\n<p>策略模式，英文全称是Strategy Design Pattern。在GoF的《设计模式》一书中，是这样定义的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Define a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from clients that use it.</span><br></pre></td></tr></table></figure>\n\n<p>翻译成中文是：定义一族算法类，将每个算法分别封装起来，让它们可以相互替换。策略模式可以使算法的变化独立于使用它们的客户端（这里的客户端代指使用算法的代码）。</p>\n<p>工厂模式是解耦对象的创建和使用，观察者模式是解耦观察者和被观察者。策略模式是解耦策略的定义、创建、使用这三部分。</p>\n<h5 id=\"1-策略的定义\"><a href=\"#1-策略的定义\" class=\"headerlink\" title=\"1.策略的定义\"></a>1.策略的定义</h5><p>策略类的定义比较简单，包含一个策略接口和一组实现这个接口的策略类。因为所有的策略类都实现相同的接口，所以客户端代码基于接口编程而非实现编程，可以灵活地替换不同的策略。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Strategy</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">algorithmInterface</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConcreteStrategyA</span> <span class=\"keyword\">implements</span> <span class=\"title\">Strategy</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span> </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">algorithmInterface</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//具体的实现...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConcreteStrategyB</span> <span class=\"keyword\">implements</span> <span class=\"title\">Strategy</span> </span>&#123;</span><br><span class=\"line\">\t  <span class=\"meta\">@Override</span> </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">algorithmInterface</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//具体的实现...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"2-策略的创建\"><a href=\"#2-策略的创建\" class=\"headerlink\" title=\"2.策略的创建\"></a>2.策略的创建</h5><p>因为策略模式会包含一组策略，在使用它们的时候，一般会通过类型（type）来判断创建哪个策略来使用。为了封装创建逻辑，我们需要对客户端代码屏蔽创建细节。我们可以把根据type创建策略的逻辑抽离出来，放到工厂类中。示例代码如下:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StrategyFactory</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Map&lt;String,Strategy&gt; strategies = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">    strategies.put(<span class=\"string\">&quot;A&quot;</span>,<span class=\"keyword\">new</span> ConcreteStrategyA());</span><br><span class=\"line\">    strategies.put(<span class=\"string\">&quot;B&quot;</span>,<span class=\"keyword\">new</span> ConcreteStrategyB());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Strategy <span class=\"title\">getStrategy</span><span class=\"params\">(String type)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(type ==<span class=\"keyword\">null</span> || type.isEmpty()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">&quot;type should not be empty.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> strategies.get(type);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>一般来说，如果策略类是无状态的，不包含成员变量，只是纯粹的算法实现，这样的策略对象是可以被共享使用的，不需要在每次调用getStrategy()的时候，都创建一个新的策略对象。这种情况下，就可以用工厂类的实现方式，事先创建好每个策略对象，缓存到工厂类中，用的时候直接返回。</p>\n<p>如果策略类是有状态的，根据业务场景需要，我们希望每次获取的都是新创建的策略对象，而不是缓存好可共享的策略对象。那就需要使用下面的工厂。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StrategyFactory</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Strategy <span class=\"title\">getStrategy</span><span class=\"params\">(String type)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(type == <span class=\"keyword\">null</span> || type.isEmpty()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">&quot;type should not be empty.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(type.equals(<span class=\"string\">&quot;A&quot;</span>)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ConcreteStrategyA();</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (type.equals(<span class=\"string\">&quot;B&quot;</span>)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ConcreteStrategyB();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"3-策略的使用\"><a href=\"#3-策略的使用\" class=\"headerlink\" title=\"3.策略的使用\"></a>3.策略的使用</h5><p>策略模式包含一组可选策略，客户端代码如何确定使用哪个策略呢？常见的是运行时动态确定使用哪种策略，这也是策略模式最经典的应用场景。这里的动态，是事先并不知道会使用哪个策略，而是在程序运行期间，根据配置、用户输入、计算结果等这些不确定因素，动态决定使用哪种策略。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//策略接口 EvictionStrategy</span></span><br><span class=\"line\"><span class=\"comment\">//策略类：LruEvictionStrategy、FifoEvictionStrategy、LfuEvictionStrategy...</span></span><br><span class=\"line\"><span class=\"comment\">//策略工厂：EvictionStrategyFactory</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserCache</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Map&lt;String,User&gt; cacheData = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">  <span class=\"keyword\">private</span> EvictionStrategy eviction;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">UserCache</span><span class=\"params\">(EvictionStrategy eviction)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.eviction = eviction;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//运行时动态确定，根据配置文件的配置决定使用哪种策略</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Application</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception</span>&#123;</span><br><span class=\"line\">    EvictionStrategy evictionStrategy = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    Properties props = <span class=\"keyword\">new</span> Properties(); </span><br><span class=\"line\">    props.load(<span class=\"keyword\">new</span> FileInputStream(<span class=\"string\">&quot;./config.properties&quot;</span>));</span><br><span class=\"line\">    String type = props.getProperty(<span class=\"string\">&quot;eviction_type&quot;</span>);</span><br><span class=\"line\">    evictionStrategy = EvictionStrategyFactory.getEvictionStrategy(type);</span><br><span class=\"line\">    UserCache userCache = <span class=\"keyword\">new</span> UserCache(evictionStrategy); </span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//非运行时动态确定，在代码中指定使用哪种策略</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Application</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//... </span></span><br><span class=\"line\">    EvictionStrategy evictionStrategy = <span class=\"keyword\">new</span> LruEvictionStrategy();</span><br><span class=\"line\">    UserCache userCache = <span class=\"keyword\">new</span> UserCache(evictionStrategy); </span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>非运行时动态确定，并不能发挥策略模式的优势。这种场景下，策略模式实际上退化成了“面向对象的多态特性”或“基于接口而非实现编程原则”。</p>\n<h5 id=\"如何利用策略模式避免分支判断\"><a href=\"#如何利用策略模式避免分支判断\" class=\"headerlink\" title=\"如何利用策略模式避免分支判断\"></a>如何利用策略模式避免分支判断</h5><p>能够移除分支判断逻辑的模式不仅仅有策略模式，状态模式也可以。对于使用哪种模式，具体还要看应用场景来定。策略模式适用于根据不同类型的动态，决定使用哪种策略这一种应用场景。</p>\n<p>先来看下if-else 或switch-case 分支判断逻辑是如何产生的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OrderService</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">double</span> <span class=\"title\">discount</span><span class=\"params\">(Order order)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> discount = <span class=\"number\">0.0</span>;</span><br><span class=\"line\">    OrderType type = order.getType();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (type.equals(OrderType.NORMAL)) &#123; <span class=\"comment\">// 普通订单</span></span><br><span class=\"line\">      <span class=\"comment\">//...省略折扣计算算法代码</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (type.equals(OrderType.GROUPON)) &#123; <span class=\"comment\">// 团购订单</span></span><br><span class=\"line\">      <span class=\"comment\">//...省略折扣计算算法代码</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (type.equals(OrderType.PROMOTION)) &#123; <span class=\"comment\">// 促销订单</span></span><br><span class=\"line\">      <span class=\"comment\">//...省略折扣计算算法代码</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> discount;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用策略模式对上面的代码重构，将不同类型订单的打折策略设计成策略类，并由工厂类来负责创建策略对象。代码示例如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 策略的定义</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">DiscountStrategy</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">calDiscount</span><span class=\"params\">(Order order)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 省略NormalDiscountStrategy、GrouponDiscountStrategy、PromotionDiscountStrategy类代码...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 策略的创建</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DiscountStrategyFactory</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Map&lt;OrderType, DiscountStrategy&gt; strategies = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">    strategies.put(OrderType.NORMAL, <span class=\"keyword\">new</span> NormalDiscountStrategy());</span><br><span class=\"line\">    strategies.put(OrderType.GROUPON, <span class=\"keyword\">new</span> GrouponDiscountStrategy());</span><br><span class=\"line\">    strategies.put(OrderType.PROMOTION, <span class=\"keyword\">new</span> PromotionDiscountStrategy());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> DiscountStrategy <span class=\"title\">getDiscountStrategy</span><span class=\"params\">(OrderType type)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> strategies.get(type);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 策略的使用</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OrderService</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">double</span> <span class=\"title\">discount</span><span class=\"params\">(Order order)</span> </span>&#123;</span><br><span class=\"line\">    OrderType type = order.getType();</span><br><span class=\"line\">    DiscountStrategy discountStrategy = DiscountStrategyFactory.getDiscountStrategy(type);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> discountStrategy.calDiscount(order);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>重构之后的代码没有if-else 分支判断语句了。这得益于策略工厂类。在工厂类中，我们用Map来缓存策略，根据type直接从Map中获取对应的策略，从而避免if-else分支判断逻辑。其实就是借助“查表法”，根据type查表（代码中的strategies就是表）替代根据type分支判断。</p>\n<p>但是，如果业务场景需要每次创建不同的策略对象，我们就要用另一种工厂类的实现方式了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DiscountStrategyFactory</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> DiscountStrategy <span class=\"title\">getDiscountStrategy</span><span class=\"params\">(OrderType type)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (type == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">&quot;Type should not be null.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (type.equals(OrderType.NORMAL)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> NormalDiscountStrategy();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (type.equals(OrderType.GROUPON)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> GrouponDiscountStrategy();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (type.equals(OrderType.PROMOTION)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> PromotionDiscountStrategy();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>单是这种方式相当于把原来的if-else分支逻辑，从OrderService类中已到了工厂类中，实际上并没有移除。</p>\n<p>可以像非动态的策略工厂一样，不过value放对应策略类的class，这样就可以通过反射去获取新的对象了。</p>\n<p>假设有这样一个需求，希望写一个小程序，实现一个对文件进行排序的功能。文件中只包含整型数，并且，相邻的数字通过逗号来分隔。</p>\n<p>最简单的思路，只需要将文件中的内容读取出来，并且通过逗号分隔成一个一个的数字放到内存数组中，然后编写某种排序算法，或者直接用编程语言提供的排序函数，对数组进行排序，最后再将数组中的数据写入文件就可以了。</p>\n<p>但是如果文件很大呢，如果文件10GB，内存只有8G，无法一次性加载文件中的所有数据到内存中，这个时候，就要利用外部排序算法了。</p>\n<p>如果文件更大，有100G大小，为了利用CPU多核的优势，可以在外部排序的基础上进行优化，加入多线程并发排序的功能，这就有点像“单机版”的MapReduce。</p>\n<p>如果文件非常大，有1TB，即便是单机多线程排序，也很慢，这个时候可以使用真正的MapReduce框架，利用多机的处理能力，提高排序的效率。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sorter</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> GB = <span class=\"number\">1000</span> * <span class=\"number\">1000</span> * <span class=\"number\">1000</span>;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sortFile</span><span class=\"params\">(String filePath)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//省略校验逻辑</span></span><br><span class=\"line\">    File file = <span class=\"keyword\">new</span> File(filePath);</span><br><span class=\"line\">    <span class=\"keyword\">long</span> fileSize = file.length();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fileSize &lt; <span class=\"number\">6</span> * GB) &#123; <span class=\"comment\">// [0, 6GB) </span></span><br><span class=\"line\">      quickSort(filePath); </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (fileSize &lt; <span class=\"number\">10</span> * GB) &#123; <span class=\"comment\">// [6GB, 10GB) </span></span><br><span class=\"line\">      externalSort(filePath); </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (fileSize &lt; <span class=\"number\">100</span> * GB) &#123; <span class=\"comment\">// [10GB, 100GB) </span></span><br><span class=\"line\">      concurrentExternalSort(filePath); </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// [100GB, ~) </span></span><br><span class=\"line\">      mapreduceSort(filePath); </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">quickSort</span><span class=\"params\">(String filePath)</span> </span>&#123; </span><br><span class=\"line\">   <span class=\"comment\">// 快速排序 </span></span><br><span class=\"line\"> &#125; </span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">externalSort</span><span class=\"params\">(String filePath)</span> </span>&#123; </span><br><span class=\"line\">   <span class=\"comment\">// 外部排序</span></span><br><span class=\"line\"> &#125; </span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">concurrentExternalSort</span><span class=\"params\">(String filePath)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// 多线程外部排序 </span></span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">mapreduceSort</span><span class=\"params\">(String filePath)</span> </span>&#123; </span><br><span class=\"line\">    <span class=\"comment\">// 利用MapReduce多机排序 </span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SortingTool</span> </span>&#123; </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123; </span><br><span class=\"line\">    Sorter sorter = <span class=\"keyword\">new</span> Sorter();</span><br><span class=\"line\">    sorter.sortFile(args[<span class=\"number\">0</span>]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果只是开发一个简单的工具，那上面的代码实现就足够了。毕竟代码不多，后续修改、扩展的需求也不多，怎么写都不会导致代码不可维护。但是，如果我们是在开发一个大型项目，排序文件只是其中一个功能模块，那我们就要在代码设计、代码质量上下点儿功夫。只有每个小的功能模块都写好，整个项目的代码才能不差。</p>\n<p>刚刚的代码中，并没有给每种排序算法的代码实现，如果实现一下的话，每种排序算法的实现逻辑都比较复杂，代码行数都比较多。所有的排序算法都在Sorter类中，这就会导致这个类的代码很多，会影响到可读性、可维护性。除此之外，所有的排序算法都设计成Sorter的私有函数，也会影响代码的可复用性。</p>\n<p>针对上面的问题，即便想不到用什么设计模式来重构，但是也知道该把Sorter类中的某些代码拆分出来，独立成职责更加单一的小类。拆分是应对类或者函数代码过多、应对代码复杂性的一个常用手段。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ISortAlg</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(String filePath)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">QuickSort</span> <span class=\"keyword\">implements</span> <span class=\"title\">ISortAlg</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(String filePath)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExternalSort</span> <span class=\"keyword\">implements</span> <span class=\"title\">ISortAlg</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(String filePath)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConcurrentExternalSort</span> <span class=\"keyword\">implements</span> <span class=\"title\">ISortAlg</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(String filePath)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MapReduceSort</span> <span class=\"keyword\">implements</span> <span class=\"title\">ISortAlg</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(String filePath)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sorter</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> GB = <span class=\"number\">1000</span> * <span class=\"number\">1000</span> * <span class=\"number\">1000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sortFile</span><span class=\"params\">(String filePath)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 省略校验逻辑</span></span><br><span class=\"line\">    File file = <span class=\"keyword\">new</span> File(filePath);</span><br><span class=\"line\">    <span class=\"keyword\">long</span> fileSize = file.length();</span><br><span class=\"line\">    ISortAlg sortAlg;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fileSize &lt; <span class=\"number\">6</span> * GB) &#123; <span class=\"comment\">// [0, 6GB)</span></span><br><span class=\"line\">      sortAlg = <span class=\"keyword\">new</span> QuickSort();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (fileSize &lt; <span class=\"number\">10</span> * GB) &#123; <span class=\"comment\">// [6GB, 10GB)</span></span><br><span class=\"line\">      sortAlg = <span class=\"keyword\">new</span> ExternalSort();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (fileSize &lt; <span class=\"number\">100</span> * GB) &#123; <span class=\"comment\">// [10GB, 100GB)</span></span><br><span class=\"line\">      sortAlg = <span class=\"keyword\">new</span> ConcurrentExternalSort();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// [100GB, ~)</span></span><br><span class=\"line\">      sortAlg = <span class=\"keyword\">new</span> MapReduceSort();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sortAlg.sort(filePath);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>拆分过后，每个类的代码都不会太多，每个类的逻辑都不会太复杂，代码的可读性、可维护性提高了。将排序算法设计成独立的类，跟具体的业务逻辑（代码中的if-else那部分逻辑）解耦，也让排序算法能够复用。这一步就是策略模式的第一步，将策略的定义分离出来。</p>\n<p>上面的代码还可以继续优化。每种排序类都是无状态的，没必要每次使用的时候都重新创建一个新的对象。可以使用工厂模式对对象的创建进行封装。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SortAlgFactory</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Map&lt;String, ISortAlg&gt; algs = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">    algs.put(<span class=\"string\">&quot;QuickSort&quot;</span>, <span class=\"keyword\">new</span> QuickSort());</span><br><span class=\"line\">    algs.put(<span class=\"string\">&quot;ExternalSort&quot;</span>, <span class=\"keyword\">new</span> ExternalSort());</span><br><span class=\"line\">    algs.put(<span class=\"string\">&quot;ConcurrentExternalSort&quot;</span>, <span class=\"keyword\">new</span> ConcurrentExternalSort());</span><br><span class=\"line\">    algs.put(<span class=\"string\">&quot;MapReduceSort&quot;</span>, <span class=\"keyword\">new</span> MapReduceSort());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ISortAlg <span class=\"title\">getSortAlg</span><span class=\"params\">(String type)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (type == <span class=\"keyword\">null</span> || type.isEmpty()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">&quot;type should not be empty.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> algs.get(type);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sorter</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> GB = <span class=\"number\">1000</span> * <span class=\"number\">1000</span> * <span class=\"number\">1000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sortFile</span><span class=\"params\">(String filePath)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 省略校验逻辑</span></span><br><span class=\"line\">    File file = <span class=\"keyword\">new</span> File(filePath);</span><br><span class=\"line\">    <span class=\"keyword\">long</span> fileSize = file.length();</span><br><span class=\"line\">    ISortAlg sortAlg;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fileSize &lt; <span class=\"number\">6</span> * GB) &#123; <span class=\"comment\">// [0, 6GB)</span></span><br><span class=\"line\">      sortAlg = SortAlgFactory.getSortAlg(<span class=\"string\">&quot;QuickSort&quot;</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (fileSize &lt; <span class=\"number\">10</span> * GB) &#123; <span class=\"comment\">// [6GB, 10GB)</span></span><br><span class=\"line\">      sortAlg = SortAlgFactory.getSortAlg(<span class=\"string\">&quot;ExternalSort&quot;</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (fileSize &lt; <span class=\"number\">100</span> * GB) &#123; <span class=\"comment\">// [10GB, 100GB)</span></span><br><span class=\"line\">      sortAlg = SortAlgFactory.getSortAlg(<span class=\"string\">&quot;ConcurrentExternalSort&quot;</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// [100GB, ~)</span></span><br><span class=\"line\">      sortAlg = SortAlgFactory.getSortAlg(<span class=\"string\">&quot;MapReduceSort&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sortAlg.sort(filePath);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>经过两次重构后，现在的代码已经符合策略模式的代码结构了。通过策略模式将策略的定义、创建、使用解耦，让每一部分不至于太复杂。但是还是有一堆if-else逻辑，这里的if-else分支不多，也不复杂，这样写也没什么问题。可以基于查表法来解决，其中的”algs”就是“表”。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sorter</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> GB = <span class=\"number\">1000</span> * <span class=\"number\">1000</span> * <span class=\"number\">1000</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> List&lt;AlgRange&gt; algs = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">  <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">    algs.add(<span class=\"keyword\">new</span> AlgRange(<span class=\"number\">0</span>, <span class=\"number\">6</span>*GB, SortAlgFactory.getSortAlg(<span class=\"string\">&quot;QuickSort&quot;</span>)));</span><br><span class=\"line\">    algs.add(<span class=\"keyword\">new</span> AlgRange(<span class=\"number\">6</span>*GB, <span class=\"number\">10</span>*GB, SortAlgFactory.getSortAlg(<span class=\"string\">&quot;ExternalSort&quot;</span>)));</span><br><span class=\"line\">    algs.add(<span class=\"keyword\">new</span> AlgRange(<span class=\"number\">10</span>*GB, <span class=\"number\">100</span>*GB, SortAlgFactory.getSortAlg(<span class=\"string\">&quot;ConcurrentExternalSort&quot;</span>)));</span><br><span class=\"line\">    algs.add(<span class=\"keyword\">new</span> AlgRange(<span class=\"number\">100</span>*GB, Long.MAX_VALUE, SortAlgFactory.getSortAlg(<span class=\"string\">&quot;MapReduceSort&quot;</span>)));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sortFile</span><span class=\"params\">(String filePath)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 省略校验逻辑</span></span><br><span class=\"line\">    File file = <span class=\"keyword\">new</span> File(filePath);</span><br><span class=\"line\">    <span class=\"keyword\">long</span> fileSize = file.length();</span><br><span class=\"line\">    ISortAlg sortAlg = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (AlgRange algRange : algs) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (algRange.inRange(fileSize)) &#123;</span><br><span class=\"line\">        sortAlg = algRange.getAlg();</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sortAlg.sort(filePath);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AlgRange</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> start;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> end;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> ISortAlg alg;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">AlgRange</span><span class=\"params\">(<span class=\"keyword\">long</span> start, <span class=\"keyword\">long</span> end, ISortAlg alg)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.start = start;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.end = end;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.alg = alg;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ISortAlg <span class=\"title\">getAlg</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> alg;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">inRange</span><span class=\"params\">(<span class=\"keyword\">long</span> size)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> size &gt;= start &amp;&amp; size &lt; end;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>现在的代码就比较优美了。把可变的部分隔离到了策略工厂类和Sorter类中的静态代码段中。当要添加新的排序算法时，只需要修改策略工厂类和Sorter类中静态代码段，其他代码都不需要修改，这样就将代码改动最小化、集中化了。</p>\n<p>对于Java语言来说，我们可以通过反射来避免对策略工厂类的修改。可以通过一个配置文件或者自定义的annotation来标注有哪些策略类。策略工厂类读取配置文件或者搜索被annotation标注的策略类，然后通过反射动态地加载这些策略类、创建策略对象。当我们新添加一个策略的时候，只需要将这个新添加的策略类添加到配置文件或者用annotation标注即可。</p>\n<p>策略模式主要作用是解耦策略的定义、创建和使用，控制代码的复杂度，让每个部分都不至于过于复杂、代码量过多。除此之外，对于复杂代码来说，策略模式还能让其满足开闭原则，添加新策略的时候，最小化、集中化代码改动，减少引入bug的风险。</p>\n<p>设计原则和思想比设计模式更加普适和重要。掌握了代码的设计原则和思想，我们能更清楚的了解，为什么要用某种设计模式，就能更恰当地应用设计模式。</p>\n"},{"layout":"post","title":"设计模式之观察者模式","description":"设计模式之观察者模式","date":"2021-06-02T05:26:10.000Z","_content":"根据应用场景的不同，观察者模式会对应不同的代码实现方式：有同步阻塞的实现方式，也有异步非阻塞的实现方式；有进程内的实现方式，也有跨进程的实现方式。\n\n观察者模式（Observer Design Pattern）也被称为发布订阅模式（Publish-Subscribe Design Pattern）。Gof的《设计模式》中定义如下：\n\n> Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.\n\n翻译成中文就是：在对象之间定义一个一对多的依赖，当一个对象状态改变的时候，所有依赖的对象都会自动收到通知。\n\n一般情况下，被依赖的对象叫做被观察者（Observable），依赖的对象叫做观察者（Observer）。\n\n观察者模式是一个比较抽象的模式，根据不同的应用场景和需求，有完全不同的实现方式。下面是最常见的实现方式：\n\n```java\npublic interface Subject {\n  void registerObserver(Observer observer);\n  void removeObserver(Observer observer);\n  void notifyObserver(Observer observer);\n}\n\npublic interface Observer {\n  void update(Message message);\n}\n\npublic class ConcreteSubject implements Subject {\n  private List<Observer> observers = new ArrayList<Observer>();\n  \n  @Override\n  public void registerObserver(Observer observer) {\n    observers.add(observer);\n  }\n  \n  @Override\n  public void removeObserver(Observer observer) {\n    observers.remove(observer);\n  }\n  \n  @Override\n  public void notifyObservers(Message message) {\n    for(Observer observer : observers) {\n      observer.update(message);\n    }\n  }\n}\n\npublic class ConcreteObserverOne implements Observer {\n  @Override\n  public void update(Message message) {\n    //TODO 获取消息通知 执行自己的逻辑\n    System.out.println(\"ConcreteObserverTwo is notified\");\n  }\n}\n\npublic class ConcreteObserverTwo implements Observer {\n  @Override\n  public void update(Message message) {\n    //TODO 获取消息通知 执行自己的逻辑\n    System.out.println(\"ConcreteObserverTwo is notified\");\n  }\n}\n\npublic class Demo {\n  public static void main(String[] args) {\n    ConcreteSubject subject = new ConcreteSubject();\n    subject.registerObserver(new ConcreteObserverOne());\n    subject.registerObserver(new ConcreteObserverTwo());\n    subject.notifyObservers(new Message());\n  }\n}\n```\n\n上面的代码算是观察者模式的“模版代码”，只能反映大体的设计思路。在真实的软件开发中，并不需要照搬上面的模版代码，观察者模式的实现方法各式各样，函数、类的命名等会根据业务场景的不同有很大的差别，比如register函数还可以叫做attach,remove函数还可以叫做detach等。不过万变不离其宗，设计思路都是差不多的。\n\n那么什么情况下需要用到这种设计模式？假设我们在开发一个P2P投资理财系统，用户注册成功之后，我们会给用户发放投资体验金。代码实现大致是下面这个样子的：\n\n```java\npublic class UserController {\n  private UserService userService; //依赖注入\n  private PromotionService promotionService; //依赖注入\n  \n  public Long register (String telephone,String password) {\n    //省略输入参数的校验代码\n    //省略userService.register()异常的try-catch代码\n    long userId = userService.register(telephone,password);\n    promotionService.issueNewUserExperienceCash(userId);\n    return userId;\n  }\n}\n```\n\n虽然注册接口做了两件事情，注册和发放体验金，违反单一职责原则，但是如果没有扩展和修改的需求，现在的代码实现是可以接受的。如果非得用观察者模式，就需要引入更多的类和更加复杂的代码结构，反倒是一种过度设计。\n\n相反如果需求频繁变动，比如，用户注册成功之后，不再发放体验金，而是改为发放优惠券，并且还要给用户发送一封“欢迎注册成功”的站内信。这种情况下，我们就需要频繁地修改register()函数中的代码，违反开闭原则。而且，如果注册成功之后需要执行的后续操作越来越多，那register()函数的逻辑会变得越来越复杂，也就影响到代码的可读性和可维护性。\n\n这个时候，观察者模式就能派上用场了。利用观察者模式，我对上面的代码进行了重构。重构之后的代码如下所示：\n\n```java\npublic interface RegObserver {\n  void handleRegSuccess(long userId);\n}\n\npublic class RegPromotionObserver implements RegObserver {\n  private PromotionService promotionService; //依赖注入\n  \n  @Override\n  public void handleRegSuccess(long userId) {\n    promotionService.issueNewUserExperienceCash(userId);\n  }\n}\n\npublic class RegNotificationObserver implements RegObserver {\n  private NotificationService notificationService;\n  \n  @Override\n  public void handleRegSuccess(long userId) {\n    notificationService.sendInboxMessage(userId,\"Welcome...\");\n  }\n}\n\npublic class UserController {\n  private UserService userService; //依赖注入\n  private List<RegObserver> regObservers = new ArrayList<>();\n  \n  //一次性设置好，之后也不可能动态的修改\n  public void setRegObservers(List<RegObserver> observers) {\n    regObservers.addAll(observers);\n  }\n  \n  public Long register(String telephone,String password) {\n    //省略输入参数的校验代码\n    //省略userService.register()异常的try-catch代码\n    long userId = userService.register(telephone, password);\n    \n    for (RegObserver observer : regObservers) {\n      observer.handleRegSuccess(userId);\n    }\n    return userId;\n  }\n}\n```\n\n当需要添加新的观察者的时候，比如注册成功后，推送用户注册信息给大数据征信系统，基于观察者模式的代码实现，UserController类的register()函数完全不需要修改，只需要再添加一个实现了RegObserver接口的类，并且通过setRegObservers()函数将它注册到UserController类中即可。\n\n实际上，设计模式要干的事情就是解耦。创建型模式是将创建和使用代码解耦，结构型模式是将不同功能代码解耦，行为型模式是将不同的行为代码解耦，具体到观察者模式，它是将观察者和被观察者代码解耦。借助设计模式，我们利用更好的代码结构，将一大坨代码拆分成职责更单一的小类，让其满足开闭原则、高内聚送偶合等特性，以此来控制和应对代码的复杂性，提高代码的可扩展性。\n\n##### 基于不同应用场景的不同实现方式\n\n观察者模式的应用场景非常广泛，小到代码层面的解耦，大到架构层面的系统解耦，再或者一些产品的设计思路，都有这种模式的影子，比如邮件订阅、RSS Feeds，本质上都是观察者模式。\n\n之前的实现方式，从上面的分类方式上来看，它是一种同步阻塞的实现方式。观察者和被观察者代码在同一个线程内执行，被观察者一直阻塞，直到所有的观察者代码都执行完成之后，才执行后续的代码。对照上面讲到的用户注册的例子，register()函数依次调用执行每个观察者的handleRegSuccess()函数，等到都执行完成之后，才会返回结果给客户端。\n\n如果注册接口是一个调用比较频繁的接口，对性能非常敏感，希望接口的响应时间仅可能短，那我们可以将同步阻塞的实现方式改为异步非阻塞的实现方式，以此来减少响应时间。具体来说，当userService.register()函数执行完成之后，我们启动一个新的线程来执行观察者的handleRegSuccess()函数，这样userController.register()函数就不需要等到所有的handleRegSuccess()函数都执行完成之后才返回结果给客户端。\n\n如何实现一个异步非阻塞的观察者模式呢？最简单的做法是，在每个handleRegSuccess()函数中，创建一个新的线程执行代码。不过还有更优雅的实现方式，就是基于EventBus来实现。后面详细讲Google Guava EventBus框架的设计思想。\n\n刚刚的两个场景，不管是同步阻塞实现方式还是异步非阻塞实现方式，都是进程内的实现方式。如果用户注册成功之后，我们需要发送用户信息给大数据征信系统，而大数据征信系统是一个独立的系统，跟它之间的交互是跨不同进程的，那如何实现一个跨进程的观察者模式呢？\n\n如果大数据征信系统提供了发送用户注册信息的RPC接口，可以沿用之前的实现思路，在handleRegSuccess()函数中调用RPC接口来发送数据。还有更加优雅，更常用的实现方式，就是基于消息队列（Message Queue 比如ActiveMQ）来实现。\n\n这种实现方式也有弊端，就是需要引入一个新的系统（消息队列），增加了维护成本。不过好处也非常明显，在原来的实现中，观察者需要注册到被观察者中，被观察者需要依次遍历观察者来发送消息。而基于消息队列的方式，被观察者和观察者解耦更加彻底，两部分的耦合更小。被观察者完全不感知观察者，同理，观察者也完全不感知被观察者。被观察者直管发送消息到消息队列，观察者只管从消息队列中读取消息来执行相应的逻辑。\n\n##### 异步非阻塞观察者模式的简易实现\n\n实现异步非阻塞观察者模式，如果只是实现一个简易版本，不考虑任何通用型、复用性，实际上是非常容易的。\n\n有两种实现方式，第一种：在每个HandleRegSuccess()函数中创建一个新的线程执行代码逻辑；另一种：在UserController的register()函数中使用线程池来执行每个观察者的handleRegSuccess()函数。\n\n```java\n//第一种实现方式\npublic class RegPromotionObserver implements RegObserver {\n  private PromotionService promotionService; //依赖注入\n  \n  @Override\n  public void handleRegSuccess(Long userId) {\n    Thread thread = new Thread(new Runnable(){\n      @Override\n      public void run() {\n        promotionService.issueNewUserExperienceCash(userId);\n      }\n    });\n    thread.start();\n  }\n}\n\n//第二种实现方式\npublic class UserController {\n  private UserService userService; //依赖注入\n  private List<RegObserver> regObservers = new ArrayList();\n  private Executor executor;\n  \n  public UserController(Executor executor) {\n    this.executor = executor;\n  }\n  \n  public Long register(String telephone,String password) {\n    //省略输入参数的校验代码\n    //省略userService.register()异常的try-cache代码\n    long userId = userService.register(telephone,password);\n    \n    for(RegObserver observer : regObservers) {\n      executor.execute(new Runnable(){\n        @Override\n        public void run() {\n          observer.handleRegSuccess(userId);\n        }\n      });\n    }\n    return userId;\n  }\n}\n```\n\n第一种方式，频繁地藏剑和销毁线程比较耗时，并且并发线程数无法控制，创建过多线程会导致堆栈溢出。第二种实现方式，虽然利用了线程池解决了第一种方式的问题，但线程池、异步执行逻辑都耦合在了register()函数中，增加了这部分代码的维护成本。\n\n如果需求极端一点，要求在同步阻塞和异步非阻塞之间灵活切换，那就要不停地修改UserController的代码。除此之外，如果在项目中，不止一个业务模块需要用到异步非阻塞观察者模式，那这样的代码实现也无法做到复用。\n\n框架的作用有：隐藏实现细节，降低开发难度，做到代码复用，解耦业务与非业务代码，让程序员聚焦业务开发。\n\n##### EventBus框架功能需求介绍\n\nEventBus翻译为“事件总线”，它提供了实现观察者模式的骨架代码。Google Guava EventBus就是一个比较著名的EventBus框架，它不仅仅支持异步非阻塞模式，同时也支持同步阻塞模式。使用Guava EventBus重新实现上面的例子。\n\n```java\npublic class UserController {\n  private UserService userService; //依赖注入\n  \n  private EventBus eventBus;\n  private static final int DEFAULT_EVENTBUS_THREAD_POOL_SIZE = 20;\n  \n  public UserController() {\n    //eventBus = new EventBus(); //同步阻塞模式\n    eventBus = new AsyncEventBus(Executors.newFixedThreadpool(DEFAULT_EVENTBUS_THREAD_POOL_SIZE)); //异步非阻塞模式\n  }\n  \n  public void setRegObservers(List<Object> observers) {\n    for(Object observer : observers) {\n      eventBus.register(observer);\n    }\n  }\n  \n  public Long register(String telephone,String password) {\n    //省略输入参数的校验代码\n    //省略userService.register() 异常try-catch代码\n    long userId = userService.register(telephone,password);\n    \n    eventBus.post(userId);\n    \n    return userId;\n  }\n}\n  \n  public class RegPromotionObserver {\n    private PromotionService promotionService; //依赖注入\n    \n    @Subscribe\n    public void handleRegSuccess(Long userId) {\n      promotionService.issueNewUserExperienceCashh(userId);\n    }\n  }\n  \n  public class RegNotificationObserver {\n    private NotificationService notificationService; //依赖注入\n    \n    @Subscribe\n    public void handleRegSuccess(Long userId) {\n      notificationService.sendInboxMessage(userId, \"...\");\n    }\n  }\n```\n\n利用EventBus框架实现的观察者模式，从大的流程上来说，思路大致一样，都需要定义Observer，并且通过register()函数注册Observer，也都是通过调用某个函数(EventBus中的post()函数)来给Observer发送消息（在EventBus中消息被称作事件event）。\n\n但是细节上又有区别，基于EventBus，我们不需要定义Observer接口，任意类型的对象都可以注册到EventBus中，通过@Subscribe注解来标明类中哪个函数可以接受被观察者发送的消息。\n\n下面详细讲解下，Guava EventBus的几个主要的类和函数\n\n- EventBus、AsyncEventBus\n\nGuava EventBus对外暴露的所有可调用接口，都封装在EventBus类中。其中EventBus类中实现了同步阻塞的观察者模式，AsyncEventBus继承自EventBus，提供了异步非阻塞的观察者模式。使用方式如下：\n\n```java\nEventBus eventBus = new EventBus(); // 同步阻塞模式\nEventBus eventBus = new AsyncEventBus(Executors.newFixedThreadPool(8))；// 异步阻塞模式\n```\n\n- register()函数\n\nEventBus类提供了register()函数来注册观察者。具体函数定义如下。它可以接受任何类型（Object）的观察者，而在经典的观察者模式的实现中，register()函数必须接受同一Observer接口的类对象。\n\n```java\npublic void register(Object object);\n```\n\n- unregister()函数\n\n相对于register()函数，unregister()函数用来从EventBus中删除某个观察者。\n\n```java\npublic void unregister(Object object);\n```\n\n- post()函数\n\nEventBus类提供了post()函数，用来给观察者发送消息。\n\n```java\npublic void post(Object object);\n```\n\n跟观察者模式的不同之处在于，当调用post()函数发送消息的时候，并非把消息发送给所有的观察者，而是发送给可匹配的观察者。所谓的可匹配指的是，能接受的消息类型是发送消息（post函数定义中的event）类型的父类。\n\n比如，AObserver能接收的消息类型是XMsg，BObserver能接收的消息类型是YMsg，CObserver能接收的消息类型是ZMsg。其中，XMsg是YMsg的父类。当我们如下发送消息的时候，相应能接收到消息的可匹配观察者如下所示：\n\n```\nXMsg xMsg = new XMsg();\nYMsg yMsg = new YMsg();\nZMsg zMsg = new ZMsg();\npost(xMsg); => AObserver接收到消息\npost(yMsg); => AObserver、BObserver接收到消息\npost(zMsg); => CObserver接收到消息\n```\n\n可能会比较疑惑，每个Observer能接收的消息类型是在哪里定义的，来看下Guava EventBus最特别的一个地方，就是@Subscribe注解。\n\n- @Subscribe注解\n\nEventBus通过@Subscribe注解来标明，某个函数能接收哪种类型的消息。具体代码如下。子DObserver类中，我们通过@Subscribe注解了两个函数f1()、f2()。\n\n```java\npublic class DObserver {\n  //省略其他属性和方法\n  \n  @Subscribe\n  public void f1(PMsg event) {\n  }\n  \n   @Subscribe\n  public void f2(QMsg event) {\n  }\n}\n```\n\n当通过register()函数将DObserver类对象注册到EventBus的时候，EventBus会根据@Subscribe注解找到f1()和f2()，并且将两个函数能接收的消息类型纪录下来（PMsg->f1,QMsg->f2）。当我们通过post()函数发送消息（比如QMsg消息）的时候，EventBus会通过之前的纪录（QMsg->f2）,调用相应的函数（f2）。\n\n##### 手把手实现一个EventBus框架\n\nEventBus中两个核心函数register()和post()的实现原理。弄懂了它们，基本上就弄懂了整个EventBus框架。下面两张图是这两个函数的实现原理图。\n![img](https://static001.geekbang.org/resource/image/ce/c6/ce842666fa3dc92bb8f4f2d8e75d12c6.jpg)\n\n![img](https://static001.geekbang.org/resource/image/bf/45/bf7ef52a40b1e35b18f369265caca645.jpg)\n\n从图中看出，最关键的数据结构是Observer注册表，记录了消息类型和可接收消息函数的对应关系。当调用register()函数注册观察者的时候，Eventbus通过解析@Subscribe注解，生成Observer注册表。当调用post()函数发送消息的时候，EventBus通过这册表找到相应的可接受消息的函数，然后通过Java的反射语法来动态地创建对象、执行函数。对于同步阻塞模式，EventBus在一个线程内依次执行相应的函数。对于异步非阻塞模式，EventBus通过一个线程池来执行相应的函数。\n\n原理弄懂了，实现起来就简单多了。整个小框架代码实现包括5个类：EventBus、AsyncEventBus、Subscribe、ObserverAction、ObserverRegistry。\n\n##### 1.Subscribe\n\nSubscribe是一个注解，用于表明观察者中的哪个函数可以接收消息。\n\n```java\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.METHOD)\n@Beta\npublic @interface Subscribe {}\n```\n\n##### 2.ObserverAction\n\nObserverAction类用来表示@Subscribe注解的方法，其中，target表示观察者类，method表示方法。它主要用在ObserverRegistry观察者注册表中。\n\n```java\npublic class ObserverAction {\n  private Object target;\n  private Method method;\n  \n  public ObserverAction(Object target,Method method) {\n    this.target = Preconditions.checkNotNull(target);\n    this.method = method;\n    this.method.setAccessible(true);\n  }\n  \n  public void execute(Object event) {\n    try{\n      method.invoke(target,event);\n    } catch (InvocationTargetException | IllegalAccessException e) {\n      e.printStackTrace();\n    }\n  }\n}\n```\n\n##### 3.ObserverRegistry\n\nObserverRegistry类就是前面讲到的Observer注册表，是最复杂的一个类，框架中几乎所有的核心逻辑都在这个类中。这个类中大量使用了Java的反射语法，比较有技巧的是CopyOnWriteArraySet的使用。\n\nCopyOnWriteArraySet，顾名思义，在写入数据的时候，会创建一个新的set，并且将原始数据clone到新的set中，在新的set中写入数据完成之后，再用新的set替换老的set。这样就能保证写入数据的时候，不影响数据的读操作，以此来解决读写并发问题。除此之外，CopyOnWriteArraySet还通过加锁的方式，避免了并发写冲突。具体的作用可以看下CopyOnWriteArraySet类的源码。\n\n```java\npublic class ObserverRegistry {\n  private ConcurrentMap<Class<?>, CopyOnWriteArraySet<ObserverAction>> registry = new ConcurrentHashMap<>();\n\n  public void register(Object observer) {\n    Map<Class<?>, Collection<ObserverAction>> observerActions = findAllObserverActions(observer);\n    for (Map.Entry<Class<?>, Collection<ObserverAction>> entry : observerActions.entrySet()) {\n      Class<?> eventType = entry.getKey();\n      Collection<ObserverAction> eventActions = entry.getValue();\n      CopyOnWriteArraySet<ObserverAction> registeredEventActions = registry.get(eventType);\n      if (registeredEventActions == null) {\n        registry.putIfAbsent(eventType, new CopyOnWriteArraySet<>());\n        registeredEventActions = registry.get(eventType);\n      }\n      registeredEventActions.addAll(eventActions);\n    }\n  }\n\n  public List<ObserverAction> getMatchedObserverActions(Object event) {\n    List<ObserverAction> matchedObservers = new ArrayList<>();\n    Class<?> postedEventType = event.getClass();\n    for (Map.Entry<Class<?>, CopyOnWriteArraySet<ObserverAction>> entry : registry.entrySet()) {\n      Class<?> eventType = entry.getKey();\n      Collection<ObserverAction> eventActions = entry.getValue();\n      if (eventType.isAssignableFrom(postedEventType)) {\n        matchedObservers.addAll(eventActions);\n      }\n    }\n    return matchedObservers;\n  }\n\n  private Map<Class<?>, Collection<ObserverAction>> findAllObserverActions(Object observer) {\n    Map<Class<?>, Collection<ObserverAction>> observerActions = new HashMap<>();\n    Class<?> clazz = observer.getClass();\n    for (Method method : getAnnotatedMethods(clazz)) {\n      Class<?>[] parameterTypes = method.getParameterTypes();\n      Class<?> eventType = parameterTypes[0];\n      if (!observerActions.containsKey(eventType)) {\n        observerActions.put(eventType, new ArrayList<>());\n      }\n      observerActions.get(eventType).add(new ObserverAction(observer, method));\n    }\n    return observerActions;\n  }\n\n  private List<Method> getAnnotatedMethods(Class<?> clazz) {\n    List<Method> annotatedMethods = new ArrayList<>();\n    for (Method method : clazz.getDeclaredMethods()) {\n      if (method.isAnnotationPresent(Subscribe.class)) {\n        Class<?>[] parameterTypes = method.getParameterTypes();\n        Preconditions.checkArgument(parameterTypes.length == 1,\n                \"Method %s has @Subscribe annotation but has %s parameters.\"\n                        + \"Subscriber methods must have exactly 1 parameter.\",\n                method, parameterTypes.length);\n        annotatedMethods.add(method);\n      }\n    }\n    return annotatedMethods;\n  }\n}\n```\n\n##### 4.EventBus\n\nEventBus实现的是阻塞同步的观察者模式。看代码可能会疑惑，明明用到了线程池Executor。实际上，MoreExecutors.directExecutor()是Googld Guava提供的工具类，看似是多线程，实际上是单线程。之所以这么实现，是为了跟AsyncEventBus统一代码逻辑，做到代码复用。\n\n```java\npublic class EventBus {\n  private Executor executor;\n  private ObserverRegistry registry = new ObserverRegistry();\n  \n  public EventBus() {\n    this(MoreExecutors.directExecutor());\n  }\n  \n  protected EventBus(Executor executor) {\n    this.executor = executor;\n  }\n  \n  public void register(Object object) {\n    registry.register(object);\n  }\n  \n  public void post(Object event) {\n    List<ObserverAction> observerActions = registry.getMatchedObserverActions(event);\n    for(ObserverAction observerAction : observerActions) {\n      executor.execute(new Runnable() {\n        @Override\n        public void run() {\n          observerAction.execute(event);\n        }\n      });\n    }\n  }\n}\n```\n\n##### 5.AsyncEventBus\n\n有了EventBus，AsyncEventBus的实现就非常简单了。为了实现异步非阻塞的观察者模式，它就不能再继续使用MoreExecutors.directExecutor()了，而是需要在构造函数中，由调用者注入线程池。\n\n```java\npublic class AsyncEventBus extends EventBus {\n  public AsyncEventBus (Executor executor) {\n    super(executor);\n  }\n}\n```\n\n这样，用了不到200行代码。就实现了一个凑活能用的EventBus，功能上来说，和Google Guava EventBus几乎一样。如果查看 [Google Guava EventBus源码](https://github.com/google/guava) ，实现细节上，它做了很多优化，比如在注册表中查找消息可匹配函数的算法。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/设计模式之观察者模式.md","raw":"---\nlayout:    post\ntitle:     设计模式之观察者模式\ncategory:  设计模式之美\ndescription: 设计模式之观察者模式\ntags: 设计模式之美\ndate: 2021/06/02 13:26:10\n---\n根据应用场景的不同，观察者模式会对应不同的代码实现方式：有同步阻塞的实现方式，也有异步非阻塞的实现方式；有进程内的实现方式，也有跨进程的实现方式。\n\n观察者模式（Observer Design Pattern）也被称为发布订阅模式（Publish-Subscribe Design Pattern）。Gof的《设计模式》中定义如下：\n\n> Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.\n\n翻译成中文就是：在对象之间定义一个一对多的依赖，当一个对象状态改变的时候，所有依赖的对象都会自动收到通知。\n\n一般情况下，被依赖的对象叫做被观察者（Observable），依赖的对象叫做观察者（Observer）。\n\n观察者模式是一个比较抽象的模式，根据不同的应用场景和需求，有完全不同的实现方式。下面是最常见的实现方式：\n\n```java\npublic interface Subject {\n  void registerObserver(Observer observer);\n  void removeObserver(Observer observer);\n  void notifyObserver(Observer observer);\n}\n\npublic interface Observer {\n  void update(Message message);\n}\n\npublic class ConcreteSubject implements Subject {\n  private List<Observer> observers = new ArrayList<Observer>();\n  \n  @Override\n  public void registerObserver(Observer observer) {\n    observers.add(observer);\n  }\n  \n  @Override\n  public void removeObserver(Observer observer) {\n    observers.remove(observer);\n  }\n  \n  @Override\n  public void notifyObservers(Message message) {\n    for(Observer observer : observers) {\n      observer.update(message);\n    }\n  }\n}\n\npublic class ConcreteObserverOne implements Observer {\n  @Override\n  public void update(Message message) {\n    //TODO 获取消息通知 执行自己的逻辑\n    System.out.println(\"ConcreteObserverTwo is notified\");\n  }\n}\n\npublic class ConcreteObserverTwo implements Observer {\n  @Override\n  public void update(Message message) {\n    //TODO 获取消息通知 执行自己的逻辑\n    System.out.println(\"ConcreteObserverTwo is notified\");\n  }\n}\n\npublic class Demo {\n  public static void main(String[] args) {\n    ConcreteSubject subject = new ConcreteSubject();\n    subject.registerObserver(new ConcreteObserverOne());\n    subject.registerObserver(new ConcreteObserverTwo());\n    subject.notifyObservers(new Message());\n  }\n}\n```\n\n上面的代码算是观察者模式的“模版代码”，只能反映大体的设计思路。在真实的软件开发中，并不需要照搬上面的模版代码，观察者模式的实现方法各式各样，函数、类的命名等会根据业务场景的不同有很大的差别，比如register函数还可以叫做attach,remove函数还可以叫做detach等。不过万变不离其宗，设计思路都是差不多的。\n\n那么什么情况下需要用到这种设计模式？假设我们在开发一个P2P投资理财系统，用户注册成功之后，我们会给用户发放投资体验金。代码实现大致是下面这个样子的：\n\n```java\npublic class UserController {\n  private UserService userService; //依赖注入\n  private PromotionService promotionService; //依赖注入\n  \n  public Long register (String telephone,String password) {\n    //省略输入参数的校验代码\n    //省略userService.register()异常的try-catch代码\n    long userId = userService.register(telephone,password);\n    promotionService.issueNewUserExperienceCash(userId);\n    return userId;\n  }\n}\n```\n\n虽然注册接口做了两件事情，注册和发放体验金，违反单一职责原则，但是如果没有扩展和修改的需求，现在的代码实现是可以接受的。如果非得用观察者模式，就需要引入更多的类和更加复杂的代码结构，反倒是一种过度设计。\n\n相反如果需求频繁变动，比如，用户注册成功之后，不再发放体验金，而是改为发放优惠券，并且还要给用户发送一封“欢迎注册成功”的站内信。这种情况下，我们就需要频繁地修改register()函数中的代码，违反开闭原则。而且，如果注册成功之后需要执行的后续操作越来越多，那register()函数的逻辑会变得越来越复杂，也就影响到代码的可读性和可维护性。\n\n这个时候，观察者模式就能派上用场了。利用观察者模式，我对上面的代码进行了重构。重构之后的代码如下所示：\n\n```java\npublic interface RegObserver {\n  void handleRegSuccess(long userId);\n}\n\npublic class RegPromotionObserver implements RegObserver {\n  private PromotionService promotionService; //依赖注入\n  \n  @Override\n  public void handleRegSuccess(long userId) {\n    promotionService.issueNewUserExperienceCash(userId);\n  }\n}\n\npublic class RegNotificationObserver implements RegObserver {\n  private NotificationService notificationService;\n  \n  @Override\n  public void handleRegSuccess(long userId) {\n    notificationService.sendInboxMessage(userId,\"Welcome...\");\n  }\n}\n\npublic class UserController {\n  private UserService userService; //依赖注入\n  private List<RegObserver> regObservers = new ArrayList<>();\n  \n  //一次性设置好，之后也不可能动态的修改\n  public void setRegObservers(List<RegObserver> observers) {\n    regObservers.addAll(observers);\n  }\n  \n  public Long register(String telephone,String password) {\n    //省略输入参数的校验代码\n    //省略userService.register()异常的try-catch代码\n    long userId = userService.register(telephone, password);\n    \n    for (RegObserver observer : regObservers) {\n      observer.handleRegSuccess(userId);\n    }\n    return userId;\n  }\n}\n```\n\n当需要添加新的观察者的时候，比如注册成功后，推送用户注册信息给大数据征信系统，基于观察者模式的代码实现，UserController类的register()函数完全不需要修改，只需要再添加一个实现了RegObserver接口的类，并且通过setRegObservers()函数将它注册到UserController类中即可。\n\n实际上，设计模式要干的事情就是解耦。创建型模式是将创建和使用代码解耦，结构型模式是将不同功能代码解耦，行为型模式是将不同的行为代码解耦，具体到观察者模式，它是将观察者和被观察者代码解耦。借助设计模式，我们利用更好的代码结构，将一大坨代码拆分成职责更单一的小类，让其满足开闭原则、高内聚送偶合等特性，以此来控制和应对代码的复杂性，提高代码的可扩展性。\n\n##### 基于不同应用场景的不同实现方式\n\n观察者模式的应用场景非常广泛，小到代码层面的解耦，大到架构层面的系统解耦，再或者一些产品的设计思路，都有这种模式的影子，比如邮件订阅、RSS Feeds，本质上都是观察者模式。\n\n之前的实现方式，从上面的分类方式上来看，它是一种同步阻塞的实现方式。观察者和被观察者代码在同一个线程内执行，被观察者一直阻塞，直到所有的观察者代码都执行完成之后，才执行后续的代码。对照上面讲到的用户注册的例子，register()函数依次调用执行每个观察者的handleRegSuccess()函数，等到都执行完成之后，才会返回结果给客户端。\n\n如果注册接口是一个调用比较频繁的接口，对性能非常敏感，希望接口的响应时间仅可能短，那我们可以将同步阻塞的实现方式改为异步非阻塞的实现方式，以此来减少响应时间。具体来说，当userService.register()函数执行完成之后，我们启动一个新的线程来执行观察者的handleRegSuccess()函数，这样userController.register()函数就不需要等到所有的handleRegSuccess()函数都执行完成之后才返回结果给客户端。\n\n如何实现一个异步非阻塞的观察者模式呢？最简单的做法是，在每个handleRegSuccess()函数中，创建一个新的线程执行代码。不过还有更优雅的实现方式，就是基于EventBus来实现。后面详细讲Google Guava EventBus框架的设计思想。\n\n刚刚的两个场景，不管是同步阻塞实现方式还是异步非阻塞实现方式，都是进程内的实现方式。如果用户注册成功之后，我们需要发送用户信息给大数据征信系统，而大数据征信系统是一个独立的系统，跟它之间的交互是跨不同进程的，那如何实现一个跨进程的观察者模式呢？\n\n如果大数据征信系统提供了发送用户注册信息的RPC接口，可以沿用之前的实现思路，在handleRegSuccess()函数中调用RPC接口来发送数据。还有更加优雅，更常用的实现方式，就是基于消息队列（Message Queue 比如ActiveMQ）来实现。\n\n这种实现方式也有弊端，就是需要引入一个新的系统（消息队列），增加了维护成本。不过好处也非常明显，在原来的实现中，观察者需要注册到被观察者中，被观察者需要依次遍历观察者来发送消息。而基于消息队列的方式，被观察者和观察者解耦更加彻底，两部分的耦合更小。被观察者完全不感知观察者，同理，观察者也完全不感知被观察者。被观察者直管发送消息到消息队列，观察者只管从消息队列中读取消息来执行相应的逻辑。\n\n##### 异步非阻塞观察者模式的简易实现\n\n实现异步非阻塞观察者模式，如果只是实现一个简易版本，不考虑任何通用型、复用性，实际上是非常容易的。\n\n有两种实现方式，第一种：在每个HandleRegSuccess()函数中创建一个新的线程执行代码逻辑；另一种：在UserController的register()函数中使用线程池来执行每个观察者的handleRegSuccess()函数。\n\n```java\n//第一种实现方式\npublic class RegPromotionObserver implements RegObserver {\n  private PromotionService promotionService; //依赖注入\n  \n  @Override\n  public void handleRegSuccess(Long userId) {\n    Thread thread = new Thread(new Runnable(){\n      @Override\n      public void run() {\n        promotionService.issueNewUserExperienceCash(userId);\n      }\n    });\n    thread.start();\n  }\n}\n\n//第二种实现方式\npublic class UserController {\n  private UserService userService; //依赖注入\n  private List<RegObserver> regObservers = new ArrayList();\n  private Executor executor;\n  \n  public UserController(Executor executor) {\n    this.executor = executor;\n  }\n  \n  public Long register(String telephone,String password) {\n    //省略输入参数的校验代码\n    //省略userService.register()异常的try-cache代码\n    long userId = userService.register(telephone,password);\n    \n    for(RegObserver observer : regObservers) {\n      executor.execute(new Runnable(){\n        @Override\n        public void run() {\n          observer.handleRegSuccess(userId);\n        }\n      });\n    }\n    return userId;\n  }\n}\n```\n\n第一种方式，频繁地藏剑和销毁线程比较耗时，并且并发线程数无法控制，创建过多线程会导致堆栈溢出。第二种实现方式，虽然利用了线程池解决了第一种方式的问题，但线程池、异步执行逻辑都耦合在了register()函数中，增加了这部分代码的维护成本。\n\n如果需求极端一点，要求在同步阻塞和异步非阻塞之间灵活切换，那就要不停地修改UserController的代码。除此之外，如果在项目中，不止一个业务模块需要用到异步非阻塞观察者模式，那这样的代码实现也无法做到复用。\n\n框架的作用有：隐藏实现细节，降低开发难度，做到代码复用，解耦业务与非业务代码，让程序员聚焦业务开发。\n\n##### EventBus框架功能需求介绍\n\nEventBus翻译为“事件总线”，它提供了实现观察者模式的骨架代码。Google Guava EventBus就是一个比较著名的EventBus框架，它不仅仅支持异步非阻塞模式，同时也支持同步阻塞模式。使用Guava EventBus重新实现上面的例子。\n\n```java\npublic class UserController {\n  private UserService userService; //依赖注入\n  \n  private EventBus eventBus;\n  private static final int DEFAULT_EVENTBUS_THREAD_POOL_SIZE = 20;\n  \n  public UserController() {\n    //eventBus = new EventBus(); //同步阻塞模式\n    eventBus = new AsyncEventBus(Executors.newFixedThreadpool(DEFAULT_EVENTBUS_THREAD_POOL_SIZE)); //异步非阻塞模式\n  }\n  \n  public void setRegObservers(List<Object> observers) {\n    for(Object observer : observers) {\n      eventBus.register(observer);\n    }\n  }\n  \n  public Long register(String telephone,String password) {\n    //省略输入参数的校验代码\n    //省略userService.register() 异常try-catch代码\n    long userId = userService.register(telephone,password);\n    \n    eventBus.post(userId);\n    \n    return userId;\n  }\n}\n  \n  public class RegPromotionObserver {\n    private PromotionService promotionService; //依赖注入\n    \n    @Subscribe\n    public void handleRegSuccess(Long userId) {\n      promotionService.issueNewUserExperienceCashh(userId);\n    }\n  }\n  \n  public class RegNotificationObserver {\n    private NotificationService notificationService; //依赖注入\n    \n    @Subscribe\n    public void handleRegSuccess(Long userId) {\n      notificationService.sendInboxMessage(userId, \"...\");\n    }\n  }\n```\n\n利用EventBus框架实现的观察者模式，从大的流程上来说，思路大致一样，都需要定义Observer，并且通过register()函数注册Observer，也都是通过调用某个函数(EventBus中的post()函数)来给Observer发送消息（在EventBus中消息被称作事件event）。\n\n但是细节上又有区别，基于EventBus，我们不需要定义Observer接口，任意类型的对象都可以注册到EventBus中，通过@Subscribe注解来标明类中哪个函数可以接受被观察者发送的消息。\n\n下面详细讲解下，Guava EventBus的几个主要的类和函数\n\n- EventBus、AsyncEventBus\n\nGuava EventBus对外暴露的所有可调用接口，都封装在EventBus类中。其中EventBus类中实现了同步阻塞的观察者模式，AsyncEventBus继承自EventBus，提供了异步非阻塞的观察者模式。使用方式如下：\n\n```java\nEventBus eventBus = new EventBus(); // 同步阻塞模式\nEventBus eventBus = new AsyncEventBus(Executors.newFixedThreadPool(8))；// 异步阻塞模式\n```\n\n- register()函数\n\nEventBus类提供了register()函数来注册观察者。具体函数定义如下。它可以接受任何类型（Object）的观察者，而在经典的观察者模式的实现中，register()函数必须接受同一Observer接口的类对象。\n\n```java\npublic void register(Object object);\n```\n\n- unregister()函数\n\n相对于register()函数，unregister()函数用来从EventBus中删除某个观察者。\n\n```java\npublic void unregister(Object object);\n```\n\n- post()函数\n\nEventBus类提供了post()函数，用来给观察者发送消息。\n\n```java\npublic void post(Object object);\n```\n\n跟观察者模式的不同之处在于，当调用post()函数发送消息的时候，并非把消息发送给所有的观察者，而是发送给可匹配的观察者。所谓的可匹配指的是，能接受的消息类型是发送消息（post函数定义中的event）类型的父类。\n\n比如，AObserver能接收的消息类型是XMsg，BObserver能接收的消息类型是YMsg，CObserver能接收的消息类型是ZMsg。其中，XMsg是YMsg的父类。当我们如下发送消息的时候，相应能接收到消息的可匹配观察者如下所示：\n\n```\nXMsg xMsg = new XMsg();\nYMsg yMsg = new YMsg();\nZMsg zMsg = new ZMsg();\npost(xMsg); => AObserver接收到消息\npost(yMsg); => AObserver、BObserver接收到消息\npost(zMsg); => CObserver接收到消息\n```\n\n可能会比较疑惑，每个Observer能接收的消息类型是在哪里定义的，来看下Guava EventBus最特别的一个地方，就是@Subscribe注解。\n\n- @Subscribe注解\n\nEventBus通过@Subscribe注解来标明，某个函数能接收哪种类型的消息。具体代码如下。子DObserver类中，我们通过@Subscribe注解了两个函数f1()、f2()。\n\n```java\npublic class DObserver {\n  //省略其他属性和方法\n  \n  @Subscribe\n  public void f1(PMsg event) {\n  }\n  \n   @Subscribe\n  public void f2(QMsg event) {\n  }\n}\n```\n\n当通过register()函数将DObserver类对象注册到EventBus的时候，EventBus会根据@Subscribe注解找到f1()和f2()，并且将两个函数能接收的消息类型纪录下来（PMsg->f1,QMsg->f2）。当我们通过post()函数发送消息（比如QMsg消息）的时候，EventBus会通过之前的纪录（QMsg->f2）,调用相应的函数（f2）。\n\n##### 手把手实现一个EventBus框架\n\nEventBus中两个核心函数register()和post()的实现原理。弄懂了它们，基本上就弄懂了整个EventBus框架。下面两张图是这两个函数的实现原理图。\n![img](https://static001.geekbang.org/resource/image/ce/c6/ce842666fa3dc92bb8f4f2d8e75d12c6.jpg)\n\n![img](https://static001.geekbang.org/resource/image/bf/45/bf7ef52a40b1e35b18f369265caca645.jpg)\n\n从图中看出，最关键的数据结构是Observer注册表，记录了消息类型和可接收消息函数的对应关系。当调用register()函数注册观察者的时候，Eventbus通过解析@Subscribe注解，生成Observer注册表。当调用post()函数发送消息的时候，EventBus通过这册表找到相应的可接受消息的函数，然后通过Java的反射语法来动态地创建对象、执行函数。对于同步阻塞模式，EventBus在一个线程内依次执行相应的函数。对于异步非阻塞模式，EventBus通过一个线程池来执行相应的函数。\n\n原理弄懂了，实现起来就简单多了。整个小框架代码实现包括5个类：EventBus、AsyncEventBus、Subscribe、ObserverAction、ObserverRegistry。\n\n##### 1.Subscribe\n\nSubscribe是一个注解，用于表明观察者中的哪个函数可以接收消息。\n\n```java\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.METHOD)\n@Beta\npublic @interface Subscribe {}\n```\n\n##### 2.ObserverAction\n\nObserverAction类用来表示@Subscribe注解的方法，其中，target表示观察者类，method表示方法。它主要用在ObserverRegistry观察者注册表中。\n\n```java\npublic class ObserverAction {\n  private Object target;\n  private Method method;\n  \n  public ObserverAction(Object target,Method method) {\n    this.target = Preconditions.checkNotNull(target);\n    this.method = method;\n    this.method.setAccessible(true);\n  }\n  \n  public void execute(Object event) {\n    try{\n      method.invoke(target,event);\n    } catch (InvocationTargetException | IllegalAccessException e) {\n      e.printStackTrace();\n    }\n  }\n}\n```\n\n##### 3.ObserverRegistry\n\nObserverRegistry类就是前面讲到的Observer注册表，是最复杂的一个类，框架中几乎所有的核心逻辑都在这个类中。这个类中大量使用了Java的反射语法，比较有技巧的是CopyOnWriteArraySet的使用。\n\nCopyOnWriteArraySet，顾名思义，在写入数据的时候，会创建一个新的set，并且将原始数据clone到新的set中，在新的set中写入数据完成之后，再用新的set替换老的set。这样就能保证写入数据的时候，不影响数据的读操作，以此来解决读写并发问题。除此之外，CopyOnWriteArraySet还通过加锁的方式，避免了并发写冲突。具体的作用可以看下CopyOnWriteArraySet类的源码。\n\n```java\npublic class ObserverRegistry {\n  private ConcurrentMap<Class<?>, CopyOnWriteArraySet<ObserverAction>> registry = new ConcurrentHashMap<>();\n\n  public void register(Object observer) {\n    Map<Class<?>, Collection<ObserverAction>> observerActions = findAllObserverActions(observer);\n    for (Map.Entry<Class<?>, Collection<ObserverAction>> entry : observerActions.entrySet()) {\n      Class<?> eventType = entry.getKey();\n      Collection<ObserverAction> eventActions = entry.getValue();\n      CopyOnWriteArraySet<ObserverAction> registeredEventActions = registry.get(eventType);\n      if (registeredEventActions == null) {\n        registry.putIfAbsent(eventType, new CopyOnWriteArraySet<>());\n        registeredEventActions = registry.get(eventType);\n      }\n      registeredEventActions.addAll(eventActions);\n    }\n  }\n\n  public List<ObserverAction> getMatchedObserverActions(Object event) {\n    List<ObserverAction> matchedObservers = new ArrayList<>();\n    Class<?> postedEventType = event.getClass();\n    for (Map.Entry<Class<?>, CopyOnWriteArraySet<ObserverAction>> entry : registry.entrySet()) {\n      Class<?> eventType = entry.getKey();\n      Collection<ObserverAction> eventActions = entry.getValue();\n      if (eventType.isAssignableFrom(postedEventType)) {\n        matchedObservers.addAll(eventActions);\n      }\n    }\n    return matchedObservers;\n  }\n\n  private Map<Class<?>, Collection<ObserverAction>> findAllObserverActions(Object observer) {\n    Map<Class<?>, Collection<ObserverAction>> observerActions = new HashMap<>();\n    Class<?> clazz = observer.getClass();\n    for (Method method : getAnnotatedMethods(clazz)) {\n      Class<?>[] parameterTypes = method.getParameterTypes();\n      Class<?> eventType = parameterTypes[0];\n      if (!observerActions.containsKey(eventType)) {\n        observerActions.put(eventType, new ArrayList<>());\n      }\n      observerActions.get(eventType).add(new ObserverAction(observer, method));\n    }\n    return observerActions;\n  }\n\n  private List<Method> getAnnotatedMethods(Class<?> clazz) {\n    List<Method> annotatedMethods = new ArrayList<>();\n    for (Method method : clazz.getDeclaredMethods()) {\n      if (method.isAnnotationPresent(Subscribe.class)) {\n        Class<?>[] parameterTypes = method.getParameterTypes();\n        Preconditions.checkArgument(parameterTypes.length == 1,\n                \"Method %s has @Subscribe annotation but has %s parameters.\"\n                        + \"Subscriber methods must have exactly 1 parameter.\",\n                method, parameterTypes.length);\n        annotatedMethods.add(method);\n      }\n    }\n    return annotatedMethods;\n  }\n}\n```\n\n##### 4.EventBus\n\nEventBus实现的是阻塞同步的观察者模式。看代码可能会疑惑，明明用到了线程池Executor。实际上，MoreExecutors.directExecutor()是Googld Guava提供的工具类，看似是多线程，实际上是单线程。之所以这么实现，是为了跟AsyncEventBus统一代码逻辑，做到代码复用。\n\n```java\npublic class EventBus {\n  private Executor executor;\n  private ObserverRegistry registry = new ObserverRegistry();\n  \n  public EventBus() {\n    this(MoreExecutors.directExecutor());\n  }\n  \n  protected EventBus(Executor executor) {\n    this.executor = executor;\n  }\n  \n  public void register(Object object) {\n    registry.register(object);\n  }\n  \n  public void post(Object event) {\n    List<ObserverAction> observerActions = registry.getMatchedObserverActions(event);\n    for(ObserverAction observerAction : observerActions) {\n      executor.execute(new Runnable() {\n        @Override\n        public void run() {\n          observerAction.execute(event);\n        }\n      });\n    }\n  }\n}\n```\n\n##### 5.AsyncEventBus\n\n有了EventBus，AsyncEventBus的实现就非常简单了。为了实现异步非阻塞的观察者模式，它就不能再继续使用MoreExecutors.directExecutor()了，而是需要在构造函数中，由调用者注入线程池。\n\n```java\npublic class AsyncEventBus extends EventBus {\n  public AsyncEventBus (Executor executor) {\n    super(executor);\n  }\n}\n```\n\n这样，用了不到200行代码。就实现了一个凑活能用的EventBus，功能上来说，和Google Guava EventBus几乎一样。如果查看 [Google Guava EventBus源码](https://github.com/google/guava) ，实现细节上，它做了很多优化，比如在注册表中查找消息可匹配函数的算法。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"设计模式之观察者模式","published":1,"updated":"2021-06-02T05:26:10.000Z","comments":1,"photos":[],"link":"","_id":"cm1m304yb004231b47ghacufz","content":"<p>根据应用场景的不同，观察者模式会对应不同的代码实现方式：有同步阻塞的实现方式，也有异步非阻塞的实现方式；有进程内的实现方式，也有跨进程的实现方式。</p>\n<p>观察者模式（Observer Design Pattern）也被称为发布订阅模式（Publish-Subscribe Design Pattern）。Gof的《设计模式》中定义如下：</p>\n<blockquote>\n<p>Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.</p>\n</blockquote>\n<p>翻译成中文就是：在对象之间定义一个一对多的依赖，当一个对象状态改变的时候，所有依赖的对象都会自动收到通知。</p>\n<p>一般情况下，被依赖的对象叫做被观察者（Observable），依赖的对象叫做观察者（Observer）。</p>\n<p>观察者模式是一个比较抽象的模式，根据不同的应用场景和需求，有完全不同的实现方式。下面是最常见的实现方式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Subject</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">registerObserver</span><span class=\"params\">(Observer observer)</span></span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">removeObserver</span><span class=\"params\">(Observer observer)</span></span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">notifyObserver</span><span class=\"params\">(Observer observer)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Observer</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(Message message)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConcreteSubject</span> <span class=\"keyword\">implements</span> <span class=\"title\">Subject</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> List&lt;Observer&gt; observers = <span class=\"keyword\">new</span> ArrayList&lt;Observer&gt;();</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">registerObserver</span><span class=\"params\">(Observer observer)</span> </span>&#123;</span><br><span class=\"line\">    observers.add(observer);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">removeObserver</span><span class=\"params\">(Observer observer)</span> </span>&#123;</span><br><span class=\"line\">    observers.remove(observer);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">notifyObservers</span><span class=\"params\">(Message message)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(Observer observer : observers) &#123;</span><br><span class=\"line\">      observer.update(message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConcreteObserverOne</span> <span class=\"keyword\">implements</span> <span class=\"title\">Observer</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(Message message)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//TODO 获取消息通知 执行自己的逻辑</span></span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;ConcreteObserverTwo is notified&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConcreteObserverTwo</span> <span class=\"keyword\">implements</span> <span class=\"title\">Observer</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(Message message)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//TODO 获取消息通知 执行自己的逻辑</span></span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;ConcreteObserverTwo is notified&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    ConcreteSubject subject = <span class=\"keyword\">new</span> ConcreteSubject();</span><br><span class=\"line\">    subject.registerObserver(<span class=\"keyword\">new</span> ConcreteObserverOne());</span><br><span class=\"line\">    subject.registerObserver(<span class=\"keyword\">new</span> ConcreteObserverTwo());</span><br><span class=\"line\">    subject.notifyObservers(<span class=\"keyword\">new</span> Message());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的代码算是观察者模式的“模版代码”，只能反映大体的设计思路。在真实的软件开发中，并不需要照搬上面的模版代码，观察者模式的实现方法各式各样，函数、类的命名等会根据业务场景的不同有很大的差别，比如register函数还可以叫做attach,remove函数还可以叫做detach等。不过万变不离其宗，设计思路都是差不多的。</p>\n<p>那么什么情况下需要用到这种设计模式？假设我们在开发一个P2P投资理财系统，用户注册成功之后，我们会给用户发放投资体验金。代码实现大致是下面这个样子的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserController</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> UserService userService; <span class=\"comment\">//依赖注入</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> PromotionService promotionService; <span class=\"comment\">//依赖注入</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> Long <span class=\"title\">register</span> <span class=\"params\">(String telephone,String password)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//省略输入参数的校验代码</span></span><br><span class=\"line\">    <span class=\"comment\">//省略userService.register()异常的try-catch代码</span></span><br><span class=\"line\">    <span class=\"keyword\">long</span> userId = userService.register(telephone,password);</span><br><span class=\"line\">    promotionService.issueNewUserExperienceCash(userId);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> userId;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>虽然注册接口做了两件事情，注册和发放体验金，违反单一职责原则，但是如果没有扩展和修改的需求，现在的代码实现是可以接受的。如果非得用观察者模式，就需要引入更多的类和更加复杂的代码结构，反倒是一种过度设计。</p>\n<p>相反如果需求频繁变动，比如，用户注册成功之后，不再发放体验金，而是改为发放优惠券，并且还要给用户发送一封“欢迎注册成功”的站内信。这种情况下，我们就需要频繁地修改register()函数中的代码，违反开闭原则。而且，如果注册成功之后需要执行的后续操作越来越多，那register()函数的逻辑会变得越来越复杂，也就影响到代码的可读性和可维护性。</p>\n<p>这个时候，观察者模式就能派上用场了。利用观察者模式，我对上面的代码进行了重构。重构之后的代码如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">RegObserver</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">handleRegSuccess</span><span class=\"params\">(<span class=\"keyword\">long</span> userId)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RegPromotionObserver</span> <span class=\"keyword\">implements</span> <span class=\"title\">RegObserver</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> PromotionService promotionService; <span class=\"comment\">//依赖注入</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleRegSuccess</span><span class=\"params\">(<span class=\"keyword\">long</span> userId)</span> </span>&#123;</span><br><span class=\"line\">    promotionService.issueNewUserExperienceCash(userId);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RegNotificationObserver</span> <span class=\"keyword\">implements</span> <span class=\"title\">RegObserver</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> NotificationService notificationService;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleRegSuccess</span><span class=\"params\">(<span class=\"keyword\">long</span> userId)</span> </span>&#123;</span><br><span class=\"line\">    notificationService.sendInboxMessage(userId,<span class=\"string\">&quot;Welcome...&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserController</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> UserService userService; <span class=\"comment\">//依赖注入</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> List&lt;RegObserver&gt; regObservers = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">//一次性设置好，之后也不可能动态的修改</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setRegObservers</span><span class=\"params\">(List&lt;RegObserver&gt; observers)</span> </span>&#123;</span><br><span class=\"line\">    regObservers.addAll(observers);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> Long <span class=\"title\">register</span><span class=\"params\">(String telephone,String password)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//省略输入参数的校验代码</span></span><br><span class=\"line\">    <span class=\"comment\">//省略userService.register()异常的try-catch代码</span></span><br><span class=\"line\">    <span class=\"keyword\">long</span> userId = userService.register(telephone, password);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (RegObserver observer : regObservers) &#123;</span><br><span class=\"line\">      observer.handleRegSuccess(userId);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> userId;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当需要添加新的观察者的时候，比如注册成功后，推送用户注册信息给大数据征信系统，基于观察者模式的代码实现，UserController类的register()函数完全不需要修改，只需要再添加一个实现了RegObserver接口的类，并且通过setRegObservers()函数将它注册到UserController类中即可。</p>\n<p>实际上，设计模式要干的事情就是解耦。创建型模式是将创建和使用代码解耦，结构型模式是将不同功能代码解耦，行为型模式是将不同的行为代码解耦，具体到观察者模式，它是将观察者和被观察者代码解耦。借助设计模式，我们利用更好的代码结构，将一大坨代码拆分成职责更单一的小类，让其满足开闭原则、高内聚送偶合等特性，以此来控制和应对代码的复杂性，提高代码的可扩展性。</p>\n<h5 id=\"基于不同应用场景的不同实现方式\"><a href=\"#基于不同应用场景的不同实现方式\" class=\"headerlink\" title=\"基于不同应用场景的不同实现方式\"></a>基于不同应用场景的不同实现方式</h5><p>观察者模式的应用场景非常广泛，小到代码层面的解耦，大到架构层面的系统解耦，再或者一些产品的设计思路，都有这种模式的影子，比如邮件订阅、RSS Feeds，本质上都是观察者模式。</p>\n<p>之前的实现方式，从上面的分类方式上来看，它是一种同步阻塞的实现方式。观察者和被观察者代码在同一个线程内执行，被观察者一直阻塞，直到所有的观察者代码都执行完成之后，才执行后续的代码。对照上面讲到的用户注册的例子，register()函数依次调用执行每个观察者的handleRegSuccess()函数，等到都执行完成之后，才会返回结果给客户端。</p>\n<p>如果注册接口是一个调用比较频繁的接口，对性能非常敏感，希望接口的响应时间仅可能短，那我们可以将同步阻塞的实现方式改为异步非阻塞的实现方式，以此来减少响应时间。具体来说，当userService.register()函数执行完成之后，我们启动一个新的线程来执行观察者的handleRegSuccess()函数，这样userController.register()函数就不需要等到所有的handleRegSuccess()函数都执行完成之后才返回结果给客户端。</p>\n<p>如何实现一个异步非阻塞的观察者模式呢？最简单的做法是，在每个handleRegSuccess()函数中，创建一个新的线程执行代码。不过还有更优雅的实现方式，就是基于EventBus来实现。后面详细讲Google Guava EventBus框架的设计思想。</p>\n<p>刚刚的两个场景，不管是同步阻塞实现方式还是异步非阻塞实现方式，都是进程内的实现方式。如果用户注册成功之后，我们需要发送用户信息给大数据征信系统，而大数据征信系统是一个独立的系统，跟它之间的交互是跨不同进程的，那如何实现一个跨进程的观察者模式呢？</p>\n<p>如果大数据征信系统提供了发送用户注册信息的RPC接口，可以沿用之前的实现思路，在handleRegSuccess()函数中调用RPC接口来发送数据。还有更加优雅，更常用的实现方式，就是基于消息队列（Message Queue 比如ActiveMQ）来实现。</p>\n<p>这种实现方式也有弊端，就是需要引入一个新的系统（消息队列），增加了维护成本。不过好处也非常明显，在原来的实现中，观察者需要注册到被观察者中，被观察者需要依次遍历观察者来发送消息。而基于消息队列的方式，被观察者和观察者解耦更加彻底，两部分的耦合更小。被观察者完全不感知观察者，同理，观察者也完全不感知被观察者。被观察者直管发送消息到消息队列，观察者只管从消息队列中读取消息来执行相应的逻辑。</p>\n<h5 id=\"异步非阻塞观察者模式的简易实现\"><a href=\"#异步非阻塞观察者模式的简易实现\" class=\"headerlink\" title=\"异步非阻塞观察者模式的简易实现\"></a>异步非阻塞观察者模式的简易实现</h5><p>实现异步非阻塞观察者模式，如果只是实现一个简易版本，不考虑任何通用型、复用性，实际上是非常容易的。</p>\n<p>有两种实现方式，第一种：在每个HandleRegSuccess()函数中创建一个新的线程执行代码逻辑；另一种：在UserController的register()函数中使用线程池来执行每个观察者的handleRegSuccess()函数。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//第一种实现方式</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RegPromotionObserver</span> <span class=\"keyword\">implements</span> <span class=\"title\">RegObserver</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> PromotionService promotionService; <span class=\"comment\">//依赖注入</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleRegSuccess</span><span class=\"params\">(Long userId)</span> </span>&#123;</span><br><span class=\"line\">    Thread thread = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable()&#123;</span><br><span class=\"line\">      <span class=\"meta\">@Override</span></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        promotionService.issueNewUserExperienceCash(userId);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    thread.start();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//第二种实现方式</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserController</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> UserService userService; <span class=\"comment\">//依赖注入</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> List&lt;RegObserver&gt; regObservers = <span class=\"keyword\">new</span> ArrayList();</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Executor executor;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">UserController</span><span class=\"params\">(Executor executor)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.executor = executor;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> Long <span class=\"title\">register</span><span class=\"params\">(String telephone,String password)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//省略输入参数的校验代码</span></span><br><span class=\"line\">    <span class=\"comment\">//省略userService.register()异常的try-cache代码</span></span><br><span class=\"line\">    <span class=\"keyword\">long</span> userId = userService.register(telephone,password);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(RegObserver observer : regObservers) &#123;</span><br><span class=\"line\">      executor.execute(<span class=\"keyword\">new</span> Runnable()&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">          observer.handleRegSuccess(userId);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> userId;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>第一种方式，频繁地藏剑和销毁线程比较耗时，并且并发线程数无法控制，创建过多线程会导致堆栈溢出。第二种实现方式，虽然利用了线程池解决了第一种方式的问题，但线程池、异步执行逻辑都耦合在了register()函数中，增加了这部分代码的维护成本。</p>\n<p>如果需求极端一点，要求在同步阻塞和异步非阻塞之间灵活切换，那就要不停地修改UserController的代码。除此之外，如果在项目中，不止一个业务模块需要用到异步非阻塞观察者模式，那这样的代码实现也无法做到复用。</p>\n<p>框架的作用有：隐藏实现细节，降低开发难度，做到代码复用，解耦业务与非业务代码，让程序员聚焦业务开发。</p>\n<h5 id=\"EventBus框架功能需求介绍\"><a href=\"#EventBus框架功能需求介绍\" class=\"headerlink\" title=\"EventBus框架功能需求介绍\"></a>EventBus框架功能需求介绍</h5><p>EventBus翻译为“事件总线”，它提供了实现观察者模式的骨架代码。Google Guava EventBus就是一个比较著名的EventBus框架，它不仅仅支持异步非阻塞模式，同时也支持同步阻塞模式。使用Guava EventBus重新实现上面的例子。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserController</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> UserService userService; <span class=\"comment\">//依赖注入</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">private</span> EventBus eventBus;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_EVENTBUS_THREAD_POOL_SIZE = <span class=\"number\">20</span>;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">UserController</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//eventBus = new EventBus(); //同步阻塞模式</span></span><br><span class=\"line\">    eventBus = <span class=\"keyword\">new</span> AsyncEventBus(Executors.newFixedThreadpool(DEFAULT_EVENTBUS_THREAD_POOL_SIZE)); <span class=\"comment\">//异步非阻塞模式</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setRegObservers</span><span class=\"params\">(List&lt;Object&gt; observers)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(Object observer : observers) &#123;</span><br><span class=\"line\">      eventBus.register(observer);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> Long <span class=\"title\">register</span><span class=\"params\">(String telephone,String password)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//省略输入参数的校验代码</span></span><br><span class=\"line\">    <span class=\"comment\">//省略userService.register() 异常try-catch代码</span></span><br><span class=\"line\">    <span class=\"keyword\">long</span> userId = userService.register(telephone,password);</span><br><span class=\"line\">    </span><br><span class=\"line\">    eventBus.post(userId);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> userId;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RegPromotionObserver</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> PromotionService promotionService; <span class=\"comment\">//依赖注入</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Subscribe</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleRegSuccess</span><span class=\"params\">(Long userId)</span> </span>&#123;</span><br><span class=\"line\">      promotionService.issueNewUserExperienceCashh(userId);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RegNotificationObserver</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> NotificationService notificationService; <span class=\"comment\">//依赖注入</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Subscribe</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleRegSuccess</span><span class=\"params\">(Long userId)</span> </span>&#123;</span><br><span class=\"line\">      notificationService.sendInboxMessage(userId, <span class=\"string\">&quot;...&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>利用EventBus框架实现的观察者模式，从大的流程上来说，思路大致一样，都需要定义Observer，并且通过register()函数注册Observer，也都是通过调用某个函数(EventBus中的post()函数)来给Observer发送消息（在EventBus中消息被称作事件event）。</p>\n<p>但是细节上又有区别，基于EventBus，我们不需要定义Observer接口，任意类型的对象都可以注册到EventBus中，通过@Subscribe注解来标明类中哪个函数可以接受被观察者发送的消息。</p>\n<p>下面详细讲解下，Guava EventBus的几个主要的类和函数</p>\n<ul>\n<li>EventBus、AsyncEventBus</li>\n</ul>\n<p>Guava EventBus对外暴露的所有可调用接口，都封装在EventBus类中。其中EventBus类中实现了同步阻塞的观察者模式，AsyncEventBus继承自EventBus，提供了异步非阻塞的观察者模式。使用方式如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EventBus eventBus = <span class=\"keyword\">new</span> EventBus(); <span class=\"comment\">// 同步阻塞模式</span></span><br><span class=\"line\">EventBus eventBus = <span class=\"keyword\">new</span> AsyncEventBus(Executors.newFixedThreadPool(<span class=\"number\">8</span>))；<span class=\"comment\">// 异步阻塞模式</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>register()函数</li>\n</ul>\n<p>EventBus类提供了register()函数来注册观察者。具体函数定义如下。它可以接受任何类型（Object）的观察者，而在经典的观察者模式的实现中，register()函数必须接受同一Observer接口的类对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">register</span><span class=\"params\">(Object object)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>unregister()函数</li>\n</ul>\n<p>相对于register()函数，unregister()函数用来从EventBus中删除某个观察者。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">unregister</span><span class=\"params\">(Object object)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>post()函数</li>\n</ul>\n<p>EventBus类提供了post()函数，用来给观察者发送消息。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">post</span><span class=\"params\">(Object object)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>跟观察者模式的不同之处在于，当调用post()函数发送消息的时候，并非把消息发送给所有的观察者，而是发送给可匹配的观察者。所谓的可匹配指的是，能接受的消息类型是发送消息（post函数定义中的event）类型的父类。</p>\n<p>比如，AObserver能接收的消息类型是XMsg，BObserver能接收的消息类型是YMsg，CObserver能接收的消息类型是ZMsg。其中，XMsg是YMsg的父类。当我们如下发送消息的时候，相应能接收到消息的可匹配观察者如下所示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">XMsg xMsg = new XMsg();</span><br><span class=\"line\">YMsg yMsg = new YMsg();</span><br><span class=\"line\">ZMsg zMsg = new ZMsg();</span><br><span class=\"line\">post(xMsg); =&gt; AObserver接收到消息</span><br><span class=\"line\">post(yMsg); =&gt; AObserver、BObserver接收到消息</span><br><span class=\"line\">post(zMsg); =&gt; CObserver接收到消息</span><br></pre></td></tr></table></figure>\n\n<p>可能会比较疑惑，每个Observer能接收的消息类型是在哪里定义的，来看下Guava EventBus最特别的一个地方，就是@Subscribe注解。</p>\n<ul>\n<li>@Subscribe注解</li>\n</ul>\n<p>EventBus通过@Subscribe注解来标明，某个函数能接收哪种类型的消息。具体代码如下。子DObserver类中，我们通过@Subscribe注解了两个函数f1()、f2()。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DObserver</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//省略其他属性和方法</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"meta\">@Subscribe</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">f1</span><span class=\"params\">(PMsg event)</span> </span>&#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">   <span class=\"meta\">@Subscribe</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">f2</span><span class=\"params\">(QMsg event)</span> </span>&#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当通过register()函数将DObserver类对象注册到EventBus的时候，EventBus会根据@Subscribe注解找到f1()和f2()，并且将两个函数能接收的消息类型纪录下来（PMsg-&gt;f1,QMsg-&gt;f2）。当我们通过post()函数发送消息（比如QMsg消息）的时候，EventBus会通过之前的纪录（QMsg-&gt;f2）,调用相应的函数（f2）。</p>\n<h5 id=\"手把手实现一个EventBus框架\"><a href=\"#手把手实现一个EventBus框架\" class=\"headerlink\" title=\"手把手实现一个EventBus框架\"></a>手把手实现一个EventBus框架</h5><p>EventBus中两个核心函数register()和post()的实现原理。弄懂了它们，基本上就弄懂了整个EventBus框架。下面两张图是这两个函数的实现原理图。<br><img src=\"https://static001.geekbang.org/resource/image/ce/c6/ce842666fa3dc92bb8f4f2d8e75d12c6.jpg\" alt=\"img\"></p>\n<p><img src=\"https://static001.geekbang.org/resource/image/bf/45/bf7ef52a40b1e35b18f369265caca645.jpg\" alt=\"img\"></p>\n<p>从图中看出，最关键的数据结构是Observer注册表，记录了消息类型和可接收消息函数的对应关系。当调用register()函数注册观察者的时候，Eventbus通过解析@Subscribe注解，生成Observer注册表。当调用post()函数发送消息的时候，EventBus通过这册表找到相应的可接受消息的函数，然后通过Java的反射语法来动态地创建对象、执行函数。对于同步阻塞模式，EventBus在一个线程内依次执行相应的函数。对于异步非阻塞模式，EventBus通过一个线程池来执行相应的函数。</p>\n<p>原理弄懂了，实现起来就简单多了。整个小框架代码实现包括5个类：EventBus、AsyncEventBus、Subscribe、ObserverAction、ObserverRegistry。</p>\n<h5 id=\"1-Subscribe\"><a href=\"#1-Subscribe\" class=\"headerlink\" title=\"1.Subscribe\"></a>1.Subscribe</h5><p>Subscribe是一个注解，用于表明观察者中的哪个函数可以接收消息。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"meta\">@Target(ElementType.METHOD)</span></span><br><span class=\"line\"><span class=\"meta\">@Beta</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> Subscribe &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"2-ObserverAction\"><a href=\"#2-ObserverAction\" class=\"headerlink\" title=\"2.ObserverAction\"></a>2.ObserverAction</h5><p>ObserverAction类用来表示@Subscribe注解的方法，其中，target表示观察者类，method表示方法。它主要用在ObserverRegistry观察者注册表中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ObserverAction</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Object target;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Method method;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ObserverAction</span><span class=\"params\">(Object target,Method method)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.target = Preconditions.checkNotNull(target);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.method = method;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.method.setAccessible(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(Object event)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">      method.invoke(target,event);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (InvocationTargetException | IllegalAccessException e) &#123;</span><br><span class=\"line\">      e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"3-ObserverRegistry\"><a href=\"#3-ObserverRegistry\" class=\"headerlink\" title=\"3.ObserverRegistry\"></a>3.ObserverRegistry</h5><p>ObserverRegistry类就是前面讲到的Observer注册表，是最复杂的一个类，框架中几乎所有的核心逻辑都在这个类中。这个类中大量使用了Java的反射语法，比较有技巧的是CopyOnWriteArraySet的使用。</p>\n<p>CopyOnWriteArraySet，顾名思义，在写入数据的时候，会创建一个新的set，并且将原始数据clone到新的set中，在新的set中写入数据完成之后，再用新的set替换老的set。这样就能保证写入数据的时候，不影响数据的读操作，以此来解决读写并发问题。除此之外，CopyOnWriteArraySet还通过加锁的方式，避免了并发写冲突。具体的作用可以看下CopyOnWriteArraySet类的源码。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ObserverRegistry</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> ConcurrentMap&lt;Class&lt;?&gt;, CopyOnWriteArraySet&lt;ObserverAction&gt;&gt; registry = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">register</span><span class=\"params\">(Object observer)</span> </span>&#123;</span><br><span class=\"line\">    Map&lt;Class&lt;?&gt;, Collection&lt;ObserverAction&gt;&gt; observerActions = findAllObserverActions(observer);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Map.Entry&lt;Class&lt;?&gt;, Collection&lt;ObserverAction&gt;&gt; entry : observerActions.entrySet()) &#123;</span><br><span class=\"line\">      Class&lt;?&gt; eventType = entry.getKey();</span><br><span class=\"line\">      Collection&lt;ObserverAction&gt; eventActions = entry.getValue();</span><br><span class=\"line\">      CopyOnWriteArraySet&lt;ObserverAction&gt; registeredEventActions = registry.get(eventType);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (registeredEventActions == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        registry.putIfAbsent(eventType, <span class=\"keyword\">new</span> CopyOnWriteArraySet&lt;&gt;());</span><br><span class=\"line\">        registeredEventActions = registry.get(eventType);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      registeredEventActions.addAll(eventActions);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> List&lt;ObserverAction&gt; <span class=\"title\">getMatchedObserverActions</span><span class=\"params\">(Object event)</span> </span>&#123;</span><br><span class=\"line\">    List&lt;ObserverAction&gt; matchedObservers = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    Class&lt;?&gt; postedEventType = event.getClass();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Map.Entry&lt;Class&lt;?&gt;, CopyOnWriteArraySet&lt;ObserverAction&gt;&gt; entry : registry.entrySet()) &#123;</span><br><span class=\"line\">      Class&lt;?&gt; eventType = entry.getKey();</span><br><span class=\"line\">      Collection&lt;ObserverAction&gt; eventActions = entry.getValue();</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (eventType.isAssignableFrom(postedEventType)) &#123;</span><br><span class=\"line\">        matchedObservers.addAll(eventActions);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> matchedObservers;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> Map&lt;Class&lt;?&gt;, Collection&lt;ObserverAction&gt;&gt; findAllObserverActions(Object observer) &#123;</span><br><span class=\"line\">    Map&lt;Class&lt;?&gt;, Collection&lt;ObserverAction&gt;&gt; observerActions = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">    Class&lt;?&gt; clazz = observer.getClass();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Method method : getAnnotatedMethods(clazz)) &#123;</span><br><span class=\"line\">      Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class=\"line\">      Class&lt;?&gt; eventType = parameterTypes[<span class=\"number\">0</span>];</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!observerActions.containsKey(eventType)) &#123;</span><br><span class=\"line\">        observerActions.put(eventType, <span class=\"keyword\">new</span> ArrayList&lt;&gt;());</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      observerActions.get(eventType).add(<span class=\"keyword\">new</span> ObserverAction(observer, method));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> observerActions;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> List&lt;Method&gt; <span class=\"title\">getAnnotatedMethods</span><span class=\"params\">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class=\"line\">    List&lt;Method&gt; annotatedMethods = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Method method : clazz.getDeclaredMethods()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (method.isAnnotationPresent(Subscribe.class)) &#123;</span><br><span class=\"line\">        Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class=\"line\">        Preconditions.checkArgument(parameterTypes.length == <span class=\"number\">1</span>,</span><br><span class=\"line\">                <span class=\"string\">&quot;Method %s has @Subscribe annotation but has %s parameters.&quot;</span></span><br><span class=\"line\">                        + <span class=\"string\">&quot;Subscriber methods must have exactly 1 parameter.&quot;</span>,</span><br><span class=\"line\">                method, parameterTypes.length);</span><br><span class=\"line\">        annotatedMethods.add(method);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> annotatedMethods;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"4-EventBus\"><a href=\"#4-EventBus\" class=\"headerlink\" title=\"4.EventBus\"></a>4.EventBus</h5><p>EventBus实现的是阻塞同步的观察者模式。看代码可能会疑惑，明明用到了线程池Executor。实际上，MoreExecutors.directExecutor()是Googld Guava提供的工具类，看似是多线程，实际上是单线程。之所以这么实现，是为了跟AsyncEventBus统一代码逻辑，做到代码复用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EventBus</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Executor executor;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> ObserverRegistry registry = <span class=\"keyword\">new</span> ObserverRegistry();</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">EventBus</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>(MoreExecutors.directExecutor());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"title\">EventBus</span><span class=\"params\">(Executor executor)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.executor = executor;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">register</span><span class=\"params\">(Object object)</span> </span>&#123;</span><br><span class=\"line\">    registry.register(object);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">post</span><span class=\"params\">(Object event)</span> </span>&#123;</span><br><span class=\"line\">    List&lt;ObserverAction&gt; observerActions = registry.getMatchedObserverActions(event);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(ObserverAction observerAction : observerActions) &#123;</span><br><span class=\"line\">      executor.execute(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">          observerAction.execute(event);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"5-AsyncEventBus\"><a href=\"#5-AsyncEventBus\" class=\"headerlink\" title=\"5.AsyncEventBus\"></a>5.AsyncEventBus</h5><p>有了EventBus，AsyncEventBus的实现就非常简单了。为了实现异步非阻塞的观察者模式，它就不能再继续使用MoreExecutors.directExecutor()了，而是需要在构造函数中，由调用者注入线程池。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AsyncEventBus</span> <span class=\"keyword\">extends</span> <span class=\"title\">EventBus</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">AsyncEventBus</span> <span class=\"params\">(Executor executor)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(executor);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样，用了不到200行代码。就实现了一个凑活能用的EventBus，功能上来说，和Google Guava EventBus几乎一样。如果查看 <a href=\"https://github.com/google/guava\">Google Guava EventBus源码</a> ，实现细节上，它做了很多优化，比如在注册表中查找消息可匹配函数的算法。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>根据应用场景的不同，观察者模式会对应不同的代码实现方式：有同步阻塞的实现方式，也有异步非阻塞的实现方式；有进程内的实现方式，也有跨进程的实现方式。</p>\n<p>观察者模式（Observer Design Pattern）也被称为发布订阅模式（Publish-Subscribe Design Pattern）。Gof的《设计模式》中定义如下：</p>\n<blockquote>\n<p>Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.</p>\n</blockquote>\n<p>翻译成中文就是：在对象之间定义一个一对多的依赖，当一个对象状态改变的时候，所有依赖的对象都会自动收到通知。</p>\n<p>一般情况下，被依赖的对象叫做被观察者（Observable），依赖的对象叫做观察者（Observer）。</p>\n<p>观察者模式是一个比较抽象的模式，根据不同的应用场景和需求，有完全不同的实现方式。下面是最常见的实现方式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Subject</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">registerObserver</span><span class=\"params\">(Observer observer)</span></span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">removeObserver</span><span class=\"params\">(Observer observer)</span></span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">notifyObserver</span><span class=\"params\">(Observer observer)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Observer</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(Message message)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConcreteSubject</span> <span class=\"keyword\">implements</span> <span class=\"title\">Subject</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> List&lt;Observer&gt; observers = <span class=\"keyword\">new</span> ArrayList&lt;Observer&gt;();</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">registerObserver</span><span class=\"params\">(Observer observer)</span> </span>&#123;</span><br><span class=\"line\">    observers.add(observer);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">removeObserver</span><span class=\"params\">(Observer observer)</span> </span>&#123;</span><br><span class=\"line\">    observers.remove(observer);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">notifyObservers</span><span class=\"params\">(Message message)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(Observer observer : observers) &#123;</span><br><span class=\"line\">      observer.update(message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConcreteObserverOne</span> <span class=\"keyword\">implements</span> <span class=\"title\">Observer</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(Message message)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//TODO 获取消息通知 执行自己的逻辑</span></span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;ConcreteObserverTwo is notified&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConcreteObserverTwo</span> <span class=\"keyword\">implements</span> <span class=\"title\">Observer</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(Message message)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//TODO 获取消息通知 执行自己的逻辑</span></span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;ConcreteObserverTwo is notified&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    ConcreteSubject subject = <span class=\"keyword\">new</span> ConcreteSubject();</span><br><span class=\"line\">    subject.registerObserver(<span class=\"keyword\">new</span> ConcreteObserverOne());</span><br><span class=\"line\">    subject.registerObserver(<span class=\"keyword\">new</span> ConcreteObserverTwo());</span><br><span class=\"line\">    subject.notifyObservers(<span class=\"keyword\">new</span> Message());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的代码算是观察者模式的“模版代码”，只能反映大体的设计思路。在真实的软件开发中，并不需要照搬上面的模版代码，观察者模式的实现方法各式各样，函数、类的命名等会根据业务场景的不同有很大的差别，比如register函数还可以叫做attach,remove函数还可以叫做detach等。不过万变不离其宗，设计思路都是差不多的。</p>\n<p>那么什么情况下需要用到这种设计模式？假设我们在开发一个P2P投资理财系统，用户注册成功之后，我们会给用户发放投资体验金。代码实现大致是下面这个样子的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserController</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> UserService userService; <span class=\"comment\">//依赖注入</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> PromotionService promotionService; <span class=\"comment\">//依赖注入</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> Long <span class=\"title\">register</span> <span class=\"params\">(String telephone,String password)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//省略输入参数的校验代码</span></span><br><span class=\"line\">    <span class=\"comment\">//省略userService.register()异常的try-catch代码</span></span><br><span class=\"line\">    <span class=\"keyword\">long</span> userId = userService.register(telephone,password);</span><br><span class=\"line\">    promotionService.issueNewUserExperienceCash(userId);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> userId;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>虽然注册接口做了两件事情，注册和发放体验金，违反单一职责原则，但是如果没有扩展和修改的需求，现在的代码实现是可以接受的。如果非得用观察者模式，就需要引入更多的类和更加复杂的代码结构，反倒是一种过度设计。</p>\n<p>相反如果需求频繁变动，比如，用户注册成功之后，不再发放体验金，而是改为发放优惠券，并且还要给用户发送一封“欢迎注册成功”的站内信。这种情况下，我们就需要频繁地修改register()函数中的代码，违反开闭原则。而且，如果注册成功之后需要执行的后续操作越来越多，那register()函数的逻辑会变得越来越复杂，也就影响到代码的可读性和可维护性。</p>\n<p>这个时候，观察者模式就能派上用场了。利用观察者模式，我对上面的代码进行了重构。重构之后的代码如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">RegObserver</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">handleRegSuccess</span><span class=\"params\">(<span class=\"keyword\">long</span> userId)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RegPromotionObserver</span> <span class=\"keyword\">implements</span> <span class=\"title\">RegObserver</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> PromotionService promotionService; <span class=\"comment\">//依赖注入</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleRegSuccess</span><span class=\"params\">(<span class=\"keyword\">long</span> userId)</span> </span>&#123;</span><br><span class=\"line\">    promotionService.issueNewUserExperienceCash(userId);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RegNotificationObserver</span> <span class=\"keyword\">implements</span> <span class=\"title\">RegObserver</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> NotificationService notificationService;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleRegSuccess</span><span class=\"params\">(<span class=\"keyword\">long</span> userId)</span> </span>&#123;</span><br><span class=\"line\">    notificationService.sendInboxMessage(userId,<span class=\"string\">&quot;Welcome...&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserController</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> UserService userService; <span class=\"comment\">//依赖注入</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> List&lt;RegObserver&gt; regObservers = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">//一次性设置好，之后也不可能动态的修改</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setRegObservers</span><span class=\"params\">(List&lt;RegObserver&gt; observers)</span> </span>&#123;</span><br><span class=\"line\">    regObservers.addAll(observers);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> Long <span class=\"title\">register</span><span class=\"params\">(String telephone,String password)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//省略输入参数的校验代码</span></span><br><span class=\"line\">    <span class=\"comment\">//省略userService.register()异常的try-catch代码</span></span><br><span class=\"line\">    <span class=\"keyword\">long</span> userId = userService.register(telephone, password);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (RegObserver observer : regObservers) &#123;</span><br><span class=\"line\">      observer.handleRegSuccess(userId);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> userId;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当需要添加新的观察者的时候，比如注册成功后，推送用户注册信息给大数据征信系统，基于观察者模式的代码实现，UserController类的register()函数完全不需要修改，只需要再添加一个实现了RegObserver接口的类，并且通过setRegObservers()函数将它注册到UserController类中即可。</p>\n<p>实际上，设计模式要干的事情就是解耦。创建型模式是将创建和使用代码解耦，结构型模式是将不同功能代码解耦，行为型模式是将不同的行为代码解耦，具体到观察者模式，它是将观察者和被观察者代码解耦。借助设计模式，我们利用更好的代码结构，将一大坨代码拆分成职责更单一的小类，让其满足开闭原则、高内聚送偶合等特性，以此来控制和应对代码的复杂性，提高代码的可扩展性。</p>\n<h5 id=\"基于不同应用场景的不同实现方式\"><a href=\"#基于不同应用场景的不同实现方式\" class=\"headerlink\" title=\"基于不同应用场景的不同实现方式\"></a>基于不同应用场景的不同实现方式</h5><p>观察者模式的应用场景非常广泛，小到代码层面的解耦，大到架构层面的系统解耦，再或者一些产品的设计思路，都有这种模式的影子，比如邮件订阅、RSS Feeds，本质上都是观察者模式。</p>\n<p>之前的实现方式，从上面的分类方式上来看，它是一种同步阻塞的实现方式。观察者和被观察者代码在同一个线程内执行，被观察者一直阻塞，直到所有的观察者代码都执行完成之后，才执行后续的代码。对照上面讲到的用户注册的例子，register()函数依次调用执行每个观察者的handleRegSuccess()函数，等到都执行完成之后，才会返回结果给客户端。</p>\n<p>如果注册接口是一个调用比较频繁的接口，对性能非常敏感，希望接口的响应时间仅可能短，那我们可以将同步阻塞的实现方式改为异步非阻塞的实现方式，以此来减少响应时间。具体来说，当userService.register()函数执行完成之后，我们启动一个新的线程来执行观察者的handleRegSuccess()函数，这样userController.register()函数就不需要等到所有的handleRegSuccess()函数都执行完成之后才返回结果给客户端。</p>\n<p>如何实现一个异步非阻塞的观察者模式呢？最简单的做法是，在每个handleRegSuccess()函数中，创建一个新的线程执行代码。不过还有更优雅的实现方式，就是基于EventBus来实现。后面详细讲Google Guava EventBus框架的设计思想。</p>\n<p>刚刚的两个场景，不管是同步阻塞实现方式还是异步非阻塞实现方式，都是进程内的实现方式。如果用户注册成功之后，我们需要发送用户信息给大数据征信系统，而大数据征信系统是一个独立的系统，跟它之间的交互是跨不同进程的，那如何实现一个跨进程的观察者模式呢？</p>\n<p>如果大数据征信系统提供了发送用户注册信息的RPC接口，可以沿用之前的实现思路，在handleRegSuccess()函数中调用RPC接口来发送数据。还有更加优雅，更常用的实现方式，就是基于消息队列（Message Queue 比如ActiveMQ）来实现。</p>\n<p>这种实现方式也有弊端，就是需要引入一个新的系统（消息队列），增加了维护成本。不过好处也非常明显，在原来的实现中，观察者需要注册到被观察者中，被观察者需要依次遍历观察者来发送消息。而基于消息队列的方式，被观察者和观察者解耦更加彻底，两部分的耦合更小。被观察者完全不感知观察者，同理，观察者也完全不感知被观察者。被观察者直管发送消息到消息队列，观察者只管从消息队列中读取消息来执行相应的逻辑。</p>\n<h5 id=\"异步非阻塞观察者模式的简易实现\"><a href=\"#异步非阻塞观察者模式的简易实现\" class=\"headerlink\" title=\"异步非阻塞观察者模式的简易实现\"></a>异步非阻塞观察者模式的简易实现</h5><p>实现异步非阻塞观察者模式，如果只是实现一个简易版本，不考虑任何通用型、复用性，实际上是非常容易的。</p>\n<p>有两种实现方式，第一种：在每个HandleRegSuccess()函数中创建一个新的线程执行代码逻辑；另一种：在UserController的register()函数中使用线程池来执行每个观察者的handleRegSuccess()函数。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//第一种实现方式</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RegPromotionObserver</span> <span class=\"keyword\">implements</span> <span class=\"title\">RegObserver</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> PromotionService promotionService; <span class=\"comment\">//依赖注入</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleRegSuccess</span><span class=\"params\">(Long userId)</span> </span>&#123;</span><br><span class=\"line\">    Thread thread = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable()&#123;</span><br><span class=\"line\">      <span class=\"meta\">@Override</span></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        promotionService.issueNewUserExperienceCash(userId);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    thread.start();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//第二种实现方式</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserController</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> UserService userService; <span class=\"comment\">//依赖注入</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> List&lt;RegObserver&gt; regObservers = <span class=\"keyword\">new</span> ArrayList();</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Executor executor;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">UserController</span><span class=\"params\">(Executor executor)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.executor = executor;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> Long <span class=\"title\">register</span><span class=\"params\">(String telephone,String password)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//省略输入参数的校验代码</span></span><br><span class=\"line\">    <span class=\"comment\">//省略userService.register()异常的try-cache代码</span></span><br><span class=\"line\">    <span class=\"keyword\">long</span> userId = userService.register(telephone,password);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(RegObserver observer : regObservers) &#123;</span><br><span class=\"line\">      executor.execute(<span class=\"keyword\">new</span> Runnable()&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">          observer.handleRegSuccess(userId);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> userId;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>第一种方式，频繁地藏剑和销毁线程比较耗时，并且并发线程数无法控制，创建过多线程会导致堆栈溢出。第二种实现方式，虽然利用了线程池解决了第一种方式的问题，但线程池、异步执行逻辑都耦合在了register()函数中，增加了这部分代码的维护成本。</p>\n<p>如果需求极端一点，要求在同步阻塞和异步非阻塞之间灵活切换，那就要不停地修改UserController的代码。除此之外，如果在项目中，不止一个业务模块需要用到异步非阻塞观察者模式，那这样的代码实现也无法做到复用。</p>\n<p>框架的作用有：隐藏实现细节，降低开发难度，做到代码复用，解耦业务与非业务代码，让程序员聚焦业务开发。</p>\n<h5 id=\"EventBus框架功能需求介绍\"><a href=\"#EventBus框架功能需求介绍\" class=\"headerlink\" title=\"EventBus框架功能需求介绍\"></a>EventBus框架功能需求介绍</h5><p>EventBus翻译为“事件总线”，它提供了实现观察者模式的骨架代码。Google Guava EventBus就是一个比较著名的EventBus框架，它不仅仅支持异步非阻塞模式，同时也支持同步阻塞模式。使用Guava EventBus重新实现上面的例子。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserController</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> UserService userService; <span class=\"comment\">//依赖注入</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">private</span> EventBus eventBus;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_EVENTBUS_THREAD_POOL_SIZE = <span class=\"number\">20</span>;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">UserController</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//eventBus = new EventBus(); //同步阻塞模式</span></span><br><span class=\"line\">    eventBus = <span class=\"keyword\">new</span> AsyncEventBus(Executors.newFixedThreadpool(DEFAULT_EVENTBUS_THREAD_POOL_SIZE)); <span class=\"comment\">//异步非阻塞模式</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setRegObservers</span><span class=\"params\">(List&lt;Object&gt; observers)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(Object observer : observers) &#123;</span><br><span class=\"line\">      eventBus.register(observer);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> Long <span class=\"title\">register</span><span class=\"params\">(String telephone,String password)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//省略输入参数的校验代码</span></span><br><span class=\"line\">    <span class=\"comment\">//省略userService.register() 异常try-catch代码</span></span><br><span class=\"line\">    <span class=\"keyword\">long</span> userId = userService.register(telephone,password);</span><br><span class=\"line\">    </span><br><span class=\"line\">    eventBus.post(userId);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> userId;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RegPromotionObserver</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> PromotionService promotionService; <span class=\"comment\">//依赖注入</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Subscribe</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleRegSuccess</span><span class=\"params\">(Long userId)</span> </span>&#123;</span><br><span class=\"line\">      promotionService.issueNewUserExperienceCashh(userId);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RegNotificationObserver</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> NotificationService notificationService; <span class=\"comment\">//依赖注入</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Subscribe</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleRegSuccess</span><span class=\"params\">(Long userId)</span> </span>&#123;</span><br><span class=\"line\">      notificationService.sendInboxMessage(userId, <span class=\"string\">&quot;...&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>利用EventBus框架实现的观察者模式，从大的流程上来说，思路大致一样，都需要定义Observer，并且通过register()函数注册Observer，也都是通过调用某个函数(EventBus中的post()函数)来给Observer发送消息（在EventBus中消息被称作事件event）。</p>\n<p>但是细节上又有区别，基于EventBus，我们不需要定义Observer接口，任意类型的对象都可以注册到EventBus中，通过@Subscribe注解来标明类中哪个函数可以接受被观察者发送的消息。</p>\n<p>下面详细讲解下，Guava EventBus的几个主要的类和函数</p>\n<ul>\n<li>EventBus、AsyncEventBus</li>\n</ul>\n<p>Guava EventBus对外暴露的所有可调用接口，都封装在EventBus类中。其中EventBus类中实现了同步阻塞的观察者模式，AsyncEventBus继承自EventBus，提供了异步非阻塞的观察者模式。使用方式如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EventBus eventBus = <span class=\"keyword\">new</span> EventBus(); <span class=\"comment\">// 同步阻塞模式</span></span><br><span class=\"line\">EventBus eventBus = <span class=\"keyword\">new</span> AsyncEventBus(Executors.newFixedThreadPool(<span class=\"number\">8</span>))；<span class=\"comment\">// 异步阻塞模式</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>register()函数</li>\n</ul>\n<p>EventBus类提供了register()函数来注册观察者。具体函数定义如下。它可以接受任何类型（Object）的观察者，而在经典的观察者模式的实现中，register()函数必须接受同一Observer接口的类对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">register</span><span class=\"params\">(Object object)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>unregister()函数</li>\n</ul>\n<p>相对于register()函数，unregister()函数用来从EventBus中删除某个观察者。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">unregister</span><span class=\"params\">(Object object)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>post()函数</li>\n</ul>\n<p>EventBus类提供了post()函数，用来给观察者发送消息。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">post</span><span class=\"params\">(Object object)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>跟观察者模式的不同之处在于，当调用post()函数发送消息的时候，并非把消息发送给所有的观察者，而是发送给可匹配的观察者。所谓的可匹配指的是，能接受的消息类型是发送消息（post函数定义中的event）类型的父类。</p>\n<p>比如，AObserver能接收的消息类型是XMsg，BObserver能接收的消息类型是YMsg，CObserver能接收的消息类型是ZMsg。其中，XMsg是YMsg的父类。当我们如下发送消息的时候，相应能接收到消息的可匹配观察者如下所示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">XMsg xMsg = new XMsg();</span><br><span class=\"line\">YMsg yMsg = new YMsg();</span><br><span class=\"line\">ZMsg zMsg = new ZMsg();</span><br><span class=\"line\">post(xMsg); =&gt; AObserver接收到消息</span><br><span class=\"line\">post(yMsg); =&gt; AObserver、BObserver接收到消息</span><br><span class=\"line\">post(zMsg); =&gt; CObserver接收到消息</span><br></pre></td></tr></table></figure>\n\n<p>可能会比较疑惑，每个Observer能接收的消息类型是在哪里定义的，来看下Guava EventBus最特别的一个地方，就是@Subscribe注解。</p>\n<ul>\n<li>@Subscribe注解</li>\n</ul>\n<p>EventBus通过@Subscribe注解来标明，某个函数能接收哪种类型的消息。具体代码如下。子DObserver类中，我们通过@Subscribe注解了两个函数f1()、f2()。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DObserver</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//省略其他属性和方法</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"meta\">@Subscribe</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">f1</span><span class=\"params\">(PMsg event)</span> </span>&#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">   <span class=\"meta\">@Subscribe</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">f2</span><span class=\"params\">(QMsg event)</span> </span>&#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当通过register()函数将DObserver类对象注册到EventBus的时候，EventBus会根据@Subscribe注解找到f1()和f2()，并且将两个函数能接收的消息类型纪录下来（PMsg-&gt;f1,QMsg-&gt;f2）。当我们通过post()函数发送消息（比如QMsg消息）的时候，EventBus会通过之前的纪录（QMsg-&gt;f2）,调用相应的函数（f2）。</p>\n<h5 id=\"手把手实现一个EventBus框架\"><a href=\"#手把手实现一个EventBus框架\" class=\"headerlink\" title=\"手把手实现一个EventBus框架\"></a>手把手实现一个EventBus框架</h5><p>EventBus中两个核心函数register()和post()的实现原理。弄懂了它们，基本上就弄懂了整个EventBus框架。下面两张图是这两个函数的实现原理图。<br><img src=\"https://static001.geekbang.org/resource/image/ce/c6/ce842666fa3dc92bb8f4f2d8e75d12c6.jpg\" alt=\"img\"></p>\n<p><img src=\"https://static001.geekbang.org/resource/image/bf/45/bf7ef52a40b1e35b18f369265caca645.jpg\" alt=\"img\"></p>\n<p>从图中看出，最关键的数据结构是Observer注册表，记录了消息类型和可接收消息函数的对应关系。当调用register()函数注册观察者的时候，Eventbus通过解析@Subscribe注解，生成Observer注册表。当调用post()函数发送消息的时候，EventBus通过这册表找到相应的可接受消息的函数，然后通过Java的反射语法来动态地创建对象、执行函数。对于同步阻塞模式，EventBus在一个线程内依次执行相应的函数。对于异步非阻塞模式，EventBus通过一个线程池来执行相应的函数。</p>\n<p>原理弄懂了，实现起来就简单多了。整个小框架代码实现包括5个类：EventBus、AsyncEventBus、Subscribe、ObserverAction、ObserverRegistry。</p>\n<h5 id=\"1-Subscribe\"><a href=\"#1-Subscribe\" class=\"headerlink\" title=\"1.Subscribe\"></a>1.Subscribe</h5><p>Subscribe是一个注解，用于表明观察者中的哪个函数可以接收消息。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"meta\">@Target(ElementType.METHOD)</span></span><br><span class=\"line\"><span class=\"meta\">@Beta</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> Subscribe &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"2-ObserverAction\"><a href=\"#2-ObserverAction\" class=\"headerlink\" title=\"2.ObserverAction\"></a>2.ObserverAction</h5><p>ObserverAction类用来表示@Subscribe注解的方法，其中，target表示观察者类，method表示方法。它主要用在ObserverRegistry观察者注册表中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ObserverAction</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Object target;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Method method;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ObserverAction</span><span class=\"params\">(Object target,Method method)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.target = Preconditions.checkNotNull(target);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.method = method;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.method.setAccessible(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(Object event)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">      method.invoke(target,event);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (InvocationTargetException | IllegalAccessException e) &#123;</span><br><span class=\"line\">      e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"3-ObserverRegistry\"><a href=\"#3-ObserverRegistry\" class=\"headerlink\" title=\"3.ObserverRegistry\"></a>3.ObserverRegistry</h5><p>ObserverRegistry类就是前面讲到的Observer注册表，是最复杂的一个类，框架中几乎所有的核心逻辑都在这个类中。这个类中大量使用了Java的反射语法，比较有技巧的是CopyOnWriteArraySet的使用。</p>\n<p>CopyOnWriteArraySet，顾名思义，在写入数据的时候，会创建一个新的set，并且将原始数据clone到新的set中，在新的set中写入数据完成之后，再用新的set替换老的set。这样就能保证写入数据的时候，不影响数据的读操作，以此来解决读写并发问题。除此之外，CopyOnWriteArraySet还通过加锁的方式，避免了并发写冲突。具体的作用可以看下CopyOnWriteArraySet类的源码。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ObserverRegistry</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> ConcurrentMap&lt;Class&lt;?&gt;, CopyOnWriteArraySet&lt;ObserverAction&gt;&gt; registry = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">register</span><span class=\"params\">(Object observer)</span> </span>&#123;</span><br><span class=\"line\">    Map&lt;Class&lt;?&gt;, Collection&lt;ObserverAction&gt;&gt; observerActions = findAllObserverActions(observer);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Map.Entry&lt;Class&lt;?&gt;, Collection&lt;ObserverAction&gt;&gt; entry : observerActions.entrySet()) &#123;</span><br><span class=\"line\">      Class&lt;?&gt; eventType = entry.getKey();</span><br><span class=\"line\">      Collection&lt;ObserverAction&gt; eventActions = entry.getValue();</span><br><span class=\"line\">      CopyOnWriteArraySet&lt;ObserverAction&gt; registeredEventActions = registry.get(eventType);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (registeredEventActions == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        registry.putIfAbsent(eventType, <span class=\"keyword\">new</span> CopyOnWriteArraySet&lt;&gt;());</span><br><span class=\"line\">        registeredEventActions = registry.get(eventType);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      registeredEventActions.addAll(eventActions);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> List&lt;ObserverAction&gt; <span class=\"title\">getMatchedObserverActions</span><span class=\"params\">(Object event)</span> </span>&#123;</span><br><span class=\"line\">    List&lt;ObserverAction&gt; matchedObservers = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    Class&lt;?&gt; postedEventType = event.getClass();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Map.Entry&lt;Class&lt;?&gt;, CopyOnWriteArraySet&lt;ObserverAction&gt;&gt; entry : registry.entrySet()) &#123;</span><br><span class=\"line\">      Class&lt;?&gt; eventType = entry.getKey();</span><br><span class=\"line\">      Collection&lt;ObserverAction&gt; eventActions = entry.getValue();</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (eventType.isAssignableFrom(postedEventType)) &#123;</span><br><span class=\"line\">        matchedObservers.addAll(eventActions);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> matchedObservers;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> Map&lt;Class&lt;?&gt;, Collection&lt;ObserverAction&gt;&gt; findAllObserverActions(Object observer) &#123;</span><br><span class=\"line\">    Map&lt;Class&lt;?&gt;, Collection&lt;ObserverAction&gt;&gt; observerActions = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">    Class&lt;?&gt; clazz = observer.getClass();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Method method : getAnnotatedMethods(clazz)) &#123;</span><br><span class=\"line\">      Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class=\"line\">      Class&lt;?&gt; eventType = parameterTypes[<span class=\"number\">0</span>];</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!observerActions.containsKey(eventType)) &#123;</span><br><span class=\"line\">        observerActions.put(eventType, <span class=\"keyword\">new</span> ArrayList&lt;&gt;());</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      observerActions.get(eventType).add(<span class=\"keyword\">new</span> ObserverAction(observer, method));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> observerActions;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> List&lt;Method&gt; <span class=\"title\">getAnnotatedMethods</span><span class=\"params\">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class=\"line\">    List&lt;Method&gt; annotatedMethods = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Method method : clazz.getDeclaredMethods()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (method.isAnnotationPresent(Subscribe.class)) &#123;</span><br><span class=\"line\">        Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class=\"line\">        Preconditions.checkArgument(parameterTypes.length == <span class=\"number\">1</span>,</span><br><span class=\"line\">                <span class=\"string\">&quot;Method %s has @Subscribe annotation but has %s parameters.&quot;</span></span><br><span class=\"line\">                        + <span class=\"string\">&quot;Subscriber methods must have exactly 1 parameter.&quot;</span>,</span><br><span class=\"line\">                method, parameterTypes.length);</span><br><span class=\"line\">        annotatedMethods.add(method);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> annotatedMethods;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"4-EventBus\"><a href=\"#4-EventBus\" class=\"headerlink\" title=\"4.EventBus\"></a>4.EventBus</h5><p>EventBus实现的是阻塞同步的观察者模式。看代码可能会疑惑，明明用到了线程池Executor。实际上，MoreExecutors.directExecutor()是Googld Guava提供的工具类，看似是多线程，实际上是单线程。之所以这么实现，是为了跟AsyncEventBus统一代码逻辑，做到代码复用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EventBus</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Executor executor;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> ObserverRegistry registry = <span class=\"keyword\">new</span> ObserverRegistry();</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">EventBus</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>(MoreExecutors.directExecutor());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"title\">EventBus</span><span class=\"params\">(Executor executor)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.executor = executor;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">register</span><span class=\"params\">(Object object)</span> </span>&#123;</span><br><span class=\"line\">    registry.register(object);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">post</span><span class=\"params\">(Object event)</span> </span>&#123;</span><br><span class=\"line\">    List&lt;ObserverAction&gt; observerActions = registry.getMatchedObserverActions(event);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(ObserverAction observerAction : observerActions) &#123;</span><br><span class=\"line\">      executor.execute(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">          observerAction.execute(event);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"5-AsyncEventBus\"><a href=\"#5-AsyncEventBus\" class=\"headerlink\" title=\"5.AsyncEventBus\"></a>5.AsyncEventBus</h5><p>有了EventBus，AsyncEventBus的实现就非常简单了。为了实现异步非阻塞的观察者模式，它就不能再继续使用MoreExecutors.directExecutor()了，而是需要在构造函数中，由调用者注入线程池。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AsyncEventBus</span> <span class=\"keyword\">extends</span> <span class=\"title\">EventBus</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">AsyncEventBus</span> <span class=\"params\">(Executor executor)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(executor);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样，用了不到200行代码。就实现了一个凑活能用的EventBus，功能上来说，和Google Guava EventBus几乎一样。如果查看 <a href=\"https://github.com/google/guava\">Google Guava EventBus源码</a> ，实现细节上，它做了很多优化，比如在注册表中查找消息可匹配函数的算法。</p>\n"},{"layout":"post","title":"设计模式之访问者模式","description":"设计模式之访问者模式","date":"2021-06-09T05:26:10.000Z","_content":"访问者模式，难理解、难实现，应用它会导致代码的可读性、可维护性变差，开发中很少用到。但是为了读到应用了访问者模式的代码的时候，能一眼看出代码的设计意图，还是有必要学一学的。\n\n假设从网站上爬取了很多资源文件，他们的格式有三种：PDF、PPT、Word。我们现在要开发一个工具来处理这批资源文件。这个工具的其中一个功能是，把这些资源文件中的文本内容抽取出来放到txt文件中。\n\nResourceFile是一个抽象类，包含一个抽象函数extract2txt()。PdfFile、PPTFile、WordFile 都继承 ResourceFile 类，并且重写了 extract2txt() 函数。在ToolApplication中，可以利用多态特性，根据对象的实际类型，来决定执行哪个方法。\n\n```java\npublic abstract class ResourceFile {\n  protected String filePath;\n\n  public ResourceFile(String filePath) {\n    this.filePath = filePath;\n  }\n\n  public abstract void extract2txt();\n}\n\npublic class PPTFile extends ResourceFile {\n  public PPTFile(String filePath) {\n    super(filePath);\n  }\n\n  @Override\n  public void extract2txt() {\n    //...省略一大坨从PPT中抽取文本的代码...\n    //...将抽取出来的文本保存在跟filePath同名的.txt文件中...\n    System.out.println(\"Extract PPT.\");\n  }\n}\n\npublic class PdfFile extends ResourceFile {\n  public PdfFile(String filePath) {\n    super(filePath);\n  }\n\n  @Override\n  public void extract2txt() {\n    //...\n    System.out.println(\"Extract PDF.\");\n  }\n}\n\npublic class WordFile extends ResourceFile {\n  public WordFile(String filePath) {\n    super(filePath);\n  }\n\n  @Override\n  public void extract2txt() {\n    //...\n    System.out.println(\"Extract WORD.\");\n  }\n}\n\n// 运行结果是：\n// Extract PDF.\n// Extract WORD.\n// Extract PPT.\npublic class ToolApplication {\n  public static void main(String[] args) {\n    List<ResourceFile> resourceFiles = listAllResourceFiles(args[0]);\n    for (ResourceFile resourceFile : resourceFiles) {\n      resourceFile.extract2txt();\n    }\n  }\n\n  private static List<ResourceFile> listAllResourceFiles(String resourceDirectory) {\n    List<ResourceFile> resourceFiles = new ArrayList<>();\n    //...根据后缀(pdf/ppt/word)由工厂方法创建不同的类对象(PdfFile/PPTFile/WordFile)\n    resourceFiles.add(new PdfFile(\"a.pdf\"));\n    resourceFiles.add(new WordFile(\"b.word\"));\n    resourceFiles.add(new PPTFile(\"c.ppt\"));\n    return resourceFiles;\n  }\n}\n```\n\n如果工具的功能不停扩展，不仅要抽取文本内容，还要支持压缩、提取文件元信息（文件名、大小、更新时间等等）构建索引等一系列功能，如果按照上面的实现思路，就会存在这样几个问题：\n\n- 违背开闭原则，添加一个新的功能，所有类的代码都要修改；\n- 虽然功能增多，每个类的代码都不断膨胀，可读性和可维护性都变差了；\n- 把所有比较上层逻辑都耦合到PdfFile、PPTFile、WordFile类中，导致这些类的职责不够单一，变成了大杂烩。\n\n针对上面的问题，常用的解决方法就是拆分解耦，把业务操作和具体的数据结构解耦，设计成独立的类。这里按访问者模式的严谨思路来对上面的代码进行重构。\n\n```java\npublic abstract class ResourceFile {\n  protected String filePath;\n  public ResourceFile(String filePath) {\n    this.filePath = filePath;\n  }\n}\n\npublic class PdfFile extends ResourceFile {\n  public PdfFile(String filePath) {\n    super(filePath);\n  }\n  //...\n}\n//...PPTFile、WordFile代码省略...\npublic class Extractor {\n  public void extract2txt(PPTFile pptFile) {\n    //...\n    System.out.println(\"Extract PPT.\");\n  }\n\n  public void extract2txt(PdfFile pdfFile) {\n    //...\n    System.out.println(\"Extract PDF.\");\n  }\n\n  public void extract2txt(WordFile wordFile) {\n    //...\n    System.out.println(\"Extract WORD.\");\n  }\n}\n\npublic class ToolApplication {\n  public static void main(String[] args) {\n    Extractor extractor = new Extractor();\n    List<ResourceFile> resourceFiles = listAllResourceFiles(args[0]);\n    for (ResourceFile resourceFile : resourceFiles) {\n      extractor.extract2txt(resourceFile);\n    }\n  }\n\n  private static List<ResourceFile> listAllResourceFiles(String resourceDirectory) {\n    List<ResourceFile> resourceFiles = new ArrayList<>();\n    //...根据后缀(pdf/ppt/word)由工厂方法创建不同的类对象(PdfFile/PPTFile/WordFile)\n    resourceFiles.add(new PdfFile(\"a.pdf\"));\n    resourceFiles.add(new WordFile(\"b.word\"));\n    resourceFiles.add(new PPTFile(\"c.ppt\"));\n    return resourceFiles;\n  }\n}\n```\n\n这里最关键的一点设计是，把抽取不同类型文本的操作，设计成了三个重载函数。不过，其实上面的代码编译是不通过的，第37行会报错。这是为什么呢？\n\n多态是一种动态绑定，可以在运行时获取对象的实际类型，来运行实际类型对应的方法。而函数重载是一种静态绑定，在编译时并不能获取对象的实际类型，而是根据声明类型执行声明类型对应的方法。\n\n在上面的35-38行中，resourceFiles包含的对象的声明类型都是ResourceFile，而我们并没有在Extractor类中定义参数类型是ResourceFile的extract2txt()重载函数，所以在编译阶段就通过不了，更别说在运行时根据对象的实际类型执行不同的重载函数了。那如何解决呢？\n\n```java\npublic abstract class ResourceFile {\n  protected String filePath;\n  public ResourceFile(String filePath) {\n    this.filePath = filePath;\n  }\n  abstract public void accept(Extractor extractor);\n}\n\npublic class PdfFile extends ResourceFile {\n  public PdfFile(String filePath) {\n    super(filePath);\n  }\n\n  @Override\n  public void accept(Extractor extractor) {\n    extractor.extract2txt(this);\n  }\n\n  //...\n}\n\n//...PPTFile、WordFile跟PdfFile类似，这里就省略了...\n//...Extractor代码不变...\n\npublic class ToolApplication {\n  public static void main(String[] args) {\n    Extractor extractor = new Extractor();\n    List<ResourceFile> resourceFiles = listAllResourceFiles(args[0]);\n    for (ResourceFile resourceFile : resourceFiles) {\n      resourceFile.accept(extractor);\n    }\n  }\n\n  private static List<ResourceFile> listAllResourceFiles(String resourceDirectory) {\n    List<ResourceFile> resourceFiles = new ArrayList<>();\n    //...根据后缀(pdf/ppt/word)由工厂方法创建不同的类对象(PdfFile/PPTFile/WordFile)\n    resourceFiles.add(new PdfFile(\"a.pdf\"));\n    resourceFiles.add(new WordFile(\"b.word\"));\n    resourceFiles.add(new PPTFile(\"c.ppt\"));\n    return resourceFiles;\n  }\n}\n```\n\n在执行第30行的时候，根据多态特性，程序会调用实际类型的accept函数，也就是第16行代码。而16行代码中的this类型是PdfFile的，在编译的时候就确定了，所以会调用extractor的extract2txt(PdfFile pdfFile)这个重载函数。这是理解访问者模式的关键所在。\n\n现在，如果要继续添加新的功能，比如前面说的压缩功能，根据不同的文件类型，使用不同的压缩算法来压缩资源文件，那么该如何实现呢？需要实现一个类似Extractor类的新类Compressor类，在其中定义三个重载函数，实现对不同类型资源文件的压缩。除此之外，还要在每个资源文件类中定义新的accept重载函数。\n\n```java\npublic abstract class ResourceFile {\n  protected String filePath;\n  public ResourceFile(String filePath) {\n    this.filePath = filePath;\n  }\n  abstract public void accept(Extractor extractor);\n  abstract public void accept(Compressor compressor);\n}\n\npublic class PdfFile extends ResourceFile {\n  public PdfFile(String filePath) {\n    super(filePath);\n  }\n\n  @Override\n  public void accept(Extractor extractor) {\n    extractor.extract2txt(this);\n  }\n\n  @Override\n  public void accept(Compressor compressor) {\n    compressor.compress(this);\n  }\n\n  //...\n}\n}\n//...PPTFile、WordFile跟PdfFile类似，这里就省略了...\n//...Extractor代码不变\n\npublic class ToolApplication {\n  public static void main(String[] args) {\n    Extractor extractor = new Extractor();\n    List<ResourceFile> resourceFiles = listAllResourceFiles(args[0]);\n    for (ResourceFile resourceFile : resourceFiles) {\n      resourceFile.accept(extractor);\n    }\n\n    Compressor compressor = new Compressor();\n    for(ResourceFile resourceFile : resourceFiles) {\n      resourceFile.accept(compressor);\n    }\n  }\n\n  private static List<ResourceFile> listAllResourceFiles(String resourceDirectory) {\n    List<ResourceFile> resourceFiles = new ArrayList<>();\n    //...根据后缀(pdf/ppt/word)由工厂方法创建不同的类对象(PdfFile/PPTFile/WordFile)\n    resourceFiles.add(new PdfFile(\"a.pdf\"));\n    resourceFiles.add(new WordFile(\"b.word\"));\n    resourceFiles.add(new PPTFile(\"c.ppt\"));\n    return resourceFiles;\n  }\n}\n```\n\n上面的代码还存在一些问题，添加一个新的业务，还是需要修改每个资源文件类，违反了开闭原则。针对这个问题，抽象出来一个Visitor接口，包含是三个命名非常通用的visit()重载函数，分别处理不同类型的资源文件。具体做什么业务处理，由实现这个Visitor接口的具体的类来决定，比如Extractor负责抽取文本内容，Compressor负责压缩。当我们新添加一个业务功能的时候，资源文件类不需要做任何修改，只需要修改ToolApplication的代码就可以了。\n\n按照这个思路对代码进行重构\n\n```java\npublic abstract class ResourceFile {\n  protected String filePath;\n  public ResourceFile(String filePath) {\n    this.filePath = filePath;\n  }\n  abstract public void accept(Visitor vistor);\n}\n\npublic class PdfFile extends ResourceFile {\n  public PdfFile(String filePath) {\n    super(filePath);\n  }\n\n  @Override\n  public void accept(Visitor visitor) {\n    visitor.visit(this);\n  }\n\n  //...\n}\n//...PPTFile、WordFile跟PdfFile类似，这里就省略了...\n\npublic interface Visitor {\n  void visit(PdfFile pdfFile);\n  void visit(PPTFile pdfFile);\n  void visit(WordFile pdfFile);\n}\n\npublic class Extractor implements Visitor {\n  @Override\n  public void visit(PPTFile pptFile) {\n    //...\n    System.out.println(\"Extract PPT.\");\n  }\n\n  @Override\n  public void visit(PdfFile pdfFile) {\n    //...\n    System.out.println(\"Extract PDF.\");\n  }\n\n  @Override\n  public void visit(WordFile wordFile) {\n    //...\n    System.out.println(\"Extract WORD.\");\n  }\n}\n\npublic class Compressor implements Visitor {\n  @Override\n  public void visit(PPTFile pptFile) {\n    //...\n    System.out.println(\"Compress PPT.\");\n  }\n\n  @Override\n  public void visit(PdfFile pdfFile) {\n    //...\n    System.out.println(\"Compress PDF.\");\n  }\n\n  @Override\n  public void visit(WordFile wordFile) {\n    //...\n    System.out.println(\"Compress WORD.\");\n  }\n\n}\n\npublic class ToolApplication {\n  public static void main(String[] args) {\n    Extractor extractor = new Extractor();\n    List<ResourceFile> resourceFiles = listAllResourceFiles(args[0]);\n    for (ResourceFile resourceFile : resourceFiles) {\n      resourceFile.accept(extractor);\n    }\n\n    Compressor compressor = new Compressor();\n    for(ResourceFile resourceFile : resourceFiles) {\n      resourceFile.accept(compressor);\n    }\n  }\n\n  private static List<ResourceFile> listAllResourceFiles(String resourceDirectory) {\n    List<ResourceFile> resourceFiles = new ArrayList<>();\n    //...根据后缀(pdf/ppt/word)由工厂方法创建不同的类对象(PdfFile/PPTFile/WordFile)\n    resourceFiles.add(new PdfFile(\"a.pdf\"));\n    resourceFiles.add(new WordFile(\"b.word\"));\n    resourceFiles.add(new PPTFile(\"c.ppt\"));\n    return resourceFiles;\n  }\n}\n```\n\n设计模式英文翻译是Visitor Design Pattern。在GoF的《设计模式》中是这么定义的：\n\n> Allows for one or more operation to be applied to a set of objects at runtime, decoupling the operations from the object structure.\n\n翻译成中文就是：允许一个或者多个操作应用到一组对象上，解耦操作和对象本身。\n\n经过重重重构之后的最终代码，就是标准的访问者模式的实现代码。类图如下：\n\n![img](https://static001.geekbang.org/resource/image/c4/65/c42c636c5384da5bd5343618305db865.jpg)\n\n访问者模式应用场景。\n\n访问者模式针对的是一组类型不同的对象。不过，尽管这组对象的类型是不同的，但是，它们继承相同的父类或者实现相同的接口，在不同的应用场景下，我们需要对这组对象进行一系列不想管的业务操作（抽取文本、压缩等），但为了避免不断添加功能导致类（PdfFile、PPTFile、WordFile）不断膨胀，职责越来越不单一，以及避免频繁地添加功能导致的频繁代码修改，我们使用访问者模式，将对象与操作解耦，将这些业务操作抽离出来，定义在独立细分的访问者类（Extractor、Compressor）中。\n\n##### 为什么支持双分派的语言不需要访问者模式？\n\nSingle Dispatch 指的是执行哪个对象的方法，根据对象的运行时类型来决定；执行对象的哪个方法，根据方法参数的编译时类型来决定。\n\nDouble Dispatch 指的是执行哪个对象的方法，根据对象的运行时类型来决定；执行对象的哪个方法，根据方法参数的运行时类型来决定。 \n\n**如何理解“Dispatch”呢?** 在面向对象编程语言中，可以把方法调用理解为一种消息传递，也就是“Dispatch”。一个对象调用另一个对象的方法，就相当于给它发送一条消息，这条消息起码要包含对象名、方法名、方法参数。\n\n**如何理解“Single”“Double”这两个单词呢？** 这两个单词指的是执行哪个对象的哪个方法，跟几个因素的运行时类型有关。Single Dispatch之所以称为“Single”是因为执行哪个对象的哪个方法，只跟“对象”的运行时类型有关。Double Dispatch是因为跟执行哪个对象的哪个方法，跟“对象”和“方法参数”两者的运行时类型有关。\n\n具体到编程语言的语法机制，Single Dispatch 和 Double Dispatch 跟多态和函数重载直接相关。当前主流的面向对象编程语言（比如，Java、C++、C#）都只支持 Single Dispatch，不支持 Double Dispatch。\n\n拿Java语言举例说明下。\n\nJava 支持多态特性，代码可以在运行时获得对象的实际类型（也就是前面提到的运行时类型），然后根据实际类型决定调用哪个方法。尽管 Java 支持函数重载，但 Java 设计的函数重载的语法规则是，并不是在运行时，根据传递进函数的参数的实际类型，来决定调用哪个重载函数，而是在编译时，根据传递进函数的参数的声明类型（也就是前面提到的编译时类型），来决定调用哪个重载函数。也就是说，具体执行哪个对象的哪个方法，只跟对象的运行时类型有关，跟参数的运行时类型无关。所以，Java 语言只支持 Single Dispatch。\n\n假设Java语言支持Double Dispatch，那么前面说的37行报错就不会报错了。代码会在运行时，根据参数（resourceFile）的实际类型（PdfFile、PPTFile、WordFile），来决定使用extract2txt的三个重载函数中的哪一个。所以也就不需要访问者模式了。\n\n##### 除了访问者模式，刚才的例子还有其他实现方案么？\n\n还可以利用工厂模式来实现，定义一个包含extract2txt()接口函数的Extractor接口。PdfExtractor、PPTExtractor、WordExtractor 类实现 Extractor 接口，并且在各自的 extract2txt() 函数中，分别实现 Pdf、PPT、Word 格式文件的文本内容抽取。ExtractorFactory 工厂类根据不同的文件类型，返回不同的 Extractor。\n\n```java\npublic abstract class ResourceFile {\n  protected String filePath;\n  public ResourceFile(String filePath) {\n    this.filePath = filePath;\n  }\n  public abstract ResourceFileType getType();\n}\n\npublic class PdfFile extends ResourceFile {\n  public PdfFile(String filePath) {\n    super(filePath);\n  }\n\n  @Override\n  public ResourceFileType getType() {\n    return ResourceFileType.PDF;\n  }\n\n  //...\n}\n\n//...PPTFile/WordFile跟PdfFile代码结构类似，此处省略...\n\npublic interface Extractor {\n  void extract2txt(ResourceFile resourceFile);\n}\n\npublic class PdfExtractor implements Extractor {\n  @Override\n  public void extract2txt(ResourceFile resourceFile) {\n    //...\n  }\n}\n\n//...PPTExtractor/WordExtractor跟PdfExtractor代码结构类似，此处省略...\n\npublic class ExtractorFactory {\n  private static final Map<ResourceFileType, Extractor> extractors = new HashMap<>();\n  static {\n    extractors.put(ResourceFileType.PDF, new PdfExtractor());\n    extractors.put(ResourceFileType.PPT, new PPTExtractor());\n    extractors.put(ResourceFileType.WORD, new WordExtractor());\n  }\n\n  public static Extractor getExtractor(ResourceFileType type) {\n    return extractors.get(type);\n  }\n}\n\npublic class ToolApplication {\n  public static void main(String[] args) {\n    List<ResourceFile> resourceFiles = listAllResourceFiles(args[0]);\n    for (ResourceFile resourceFile : resourceFiles) {\n      Extractor extractor = ExtractorFactory.getExtractor(resourceFile.getType());\n      extractor.extract2txt(resourceFile);\n    }\n  }\n\n  private static List<ResourceFile> listAllResourceFiles(String resourceDirectory) {\n    List<ResourceFile> resourceFiles = new ArrayList<>();\n    //...根据后缀(pdf/ppt/word)由工厂方法创建不同的类对象(PdfFile/PPTFile/WordFile)\n    resourceFiles.add(new PdfFile(\"a.pdf\"));\n    resourceFiles.add(new WordFile(\"b.word\"));\n    resourceFiles.add(new PPTFile(\"c.ppt\"));\n    return resourceFiles;\n  }\n}\n```\n\n当添加新的功能的时候，比如压缩文件，类似抽取文本内容功能的代码实现，只需要添加一个Compressor接口，PdfCompressor、PPTCompressor、WordCompressor 三个实现类，以及创建它们的 CompressorFactory 工厂类即可。唯一修改的就是最上层的ToolApplication类。基本符合“对扩展开放、对修改关闭”的设计原则。\n\n对于资源文件处理工具的例子，如果工具提供的功能并不多，是有几个而已，那更推荐工厂模式的实现方式，毕竟代码清晰、易懂。相反，如果工具提供非常多的功能，十几个，那更推荐访问者模式，因为访问者模式需要定义的类比工厂模式的实现方式少很多，类太多也会影响到代码的可维护性。\n\n","source":"_posts/设计模式之访问者模式.md","raw":"---\nlayout:    post\ntitle:     设计模式之访问者模式\ncategory:  设计模式之美\ndescription: 设计模式之访问者模式\ntags: 设计模式之美\ndate: 2021/06/09 13:26:10\n---\n访问者模式，难理解、难实现，应用它会导致代码的可读性、可维护性变差，开发中很少用到。但是为了读到应用了访问者模式的代码的时候，能一眼看出代码的设计意图，还是有必要学一学的。\n\n假设从网站上爬取了很多资源文件，他们的格式有三种：PDF、PPT、Word。我们现在要开发一个工具来处理这批资源文件。这个工具的其中一个功能是，把这些资源文件中的文本内容抽取出来放到txt文件中。\n\nResourceFile是一个抽象类，包含一个抽象函数extract2txt()。PdfFile、PPTFile、WordFile 都继承 ResourceFile 类，并且重写了 extract2txt() 函数。在ToolApplication中，可以利用多态特性，根据对象的实际类型，来决定执行哪个方法。\n\n```java\npublic abstract class ResourceFile {\n  protected String filePath;\n\n  public ResourceFile(String filePath) {\n    this.filePath = filePath;\n  }\n\n  public abstract void extract2txt();\n}\n\npublic class PPTFile extends ResourceFile {\n  public PPTFile(String filePath) {\n    super(filePath);\n  }\n\n  @Override\n  public void extract2txt() {\n    //...省略一大坨从PPT中抽取文本的代码...\n    //...将抽取出来的文本保存在跟filePath同名的.txt文件中...\n    System.out.println(\"Extract PPT.\");\n  }\n}\n\npublic class PdfFile extends ResourceFile {\n  public PdfFile(String filePath) {\n    super(filePath);\n  }\n\n  @Override\n  public void extract2txt() {\n    //...\n    System.out.println(\"Extract PDF.\");\n  }\n}\n\npublic class WordFile extends ResourceFile {\n  public WordFile(String filePath) {\n    super(filePath);\n  }\n\n  @Override\n  public void extract2txt() {\n    //...\n    System.out.println(\"Extract WORD.\");\n  }\n}\n\n// 运行结果是：\n// Extract PDF.\n// Extract WORD.\n// Extract PPT.\npublic class ToolApplication {\n  public static void main(String[] args) {\n    List<ResourceFile> resourceFiles = listAllResourceFiles(args[0]);\n    for (ResourceFile resourceFile : resourceFiles) {\n      resourceFile.extract2txt();\n    }\n  }\n\n  private static List<ResourceFile> listAllResourceFiles(String resourceDirectory) {\n    List<ResourceFile> resourceFiles = new ArrayList<>();\n    //...根据后缀(pdf/ppt/word)由工厂方法创建不同的类对象(PdfFile/PPTFile/WordFile)\n    resourceFiles.add(new PdfFile(\"a.pdf\"));\n    resourceFiles.add(new WordFile(\"b.word\"));\n    resourceFiles.add(new PPTFile(\"c.ppt\"));\n    return resourceFiles;\n  }\n}\n```\n\n如果工具的功能不停扩展，不仅要抽取文本内容，还要支持压缩、提取文件元信息（文件名、大小、更新时间等等）构建索引等一系列功能，如果按照上面的实现思路，就会存在这样几个问题：\n\n- 违背开闭原则，添加一个新的功能，所有类的代码都要修改；\n- 虽然功能增多，每个类的代码都不断膨胀，可读性和可维护性都变差了；\n- 把所有比较上层逻辑都耦合到PdfFile、PPTFile、WordFile类中，导致这些类的职责不够单一，变成了大杂烩。\n\n针对上面的问题，常用的解决方法就是拆分解耦，把业务操作和具体的数据结构解耦，设计成独立的类。这里按访问者模式的严谨思路来对上面的代码进行重构。\n\n```java\npublic abstract class ResourceFile {\n  protected String filePath;\n  public ResourceFile(String filePath) {\n    this.filePath = filePath;\n  }\n}\n\npublic class PdfFile extends ResourceFile {\n  public PdfFile(String filePath) {\n    super(filePath);\n  }\n  //...\n}\n//...PPTFile、WordFile代码省略...\npublic class Extractor {\n  public void extract2txt(PPTFile pptFile) {\n    //...\n    System.out.println(\"Extract PPT.\");\n  }\n\n  public void extract2txt(PdfFile pdfFile) {\n    //...\n    System.out.println(\"Extract PDF.\");\n  }\n\n  public void extract2txt(WordFile wordFile) {\n    //...\n    System.out.println(\"Extract WORD.\");\n  }\n}\n\npublic class ToolApplication {\n  public static void main(String[] args) {\n    Extractor extractor = new Extractor();\n    List<ResourceFile> resourceFiles = listAllResourceFiles(args[0]);\n    for (ResourceFile resourceFile : resourceFiles) {\n      extractor.extract2txt(resourceFile);\n    }\n  }\n\n  private static List<ResourceFile> listAllResourceFiles(String resourceDirectory) {\n    List<ResourceFile> resourceFiles = new ArrayList<>();\n    //...根据后缀(pdf/ppt/word)由工厂方法创建不同的类对象(PdfFile/PPTFile/WordFile)\n    resourceFiles.add(new PdfFile(\"a.pdf\"));\n    resourceFiles.add(new WordFile(\"b.word\"));\n    resourceFiles.add(new PPTFile(\"c.ppt\"));\n    return resourceFiles;\n  }\n}\n```\n\n这里最关键的一点设计是，把抽取不同类型文本的操作，设计成了三个重载函数。不过，其实上面的代码编译是不通过的，第37行会报错。这是为什么呢？\n\n多态是一种动态绑定，可以在运行时获取对象的实际类型，来运行实际类型对应的方法。而函数重载是一种静态绑定，在编译时并不能获取对象的实际类型，而是根据声明类型执行声明类型对应的方法。\n\n在上面的35-38行中，resourceFiles包含的对象的声明类型都是ResourceFile，而我们并没有在Extractor类中定义参数类型是ResourceFile的extract2txt()重载函数，所以在编译阶段就通过不了，更别说在运行时根据对象的实际类型执行不同的重载函数了。那如何解决呢？\n\n```java\npublic abstract class ResourceFile {\n  protected String filePath;\n  public ResourceFile(String filePath) {\n    this.filePath = filePath;\n  }\n  abstract public void accept(Extractor extractor);\n}\n\npublic class PdfFile extends ResourceFile {\n  public PdfFile(String filePath) {\n    super(filePath);\n  }\n\n  @Override\n  public void accept(Extractor extractor) {\n    extractor.extract2txt(this);\n  }\n\n  //...\n}\n\n//...PPTFile、WordFile跟PdfFile类似，这里就省略了...\n//...Extractor代码不变...\n\npublic class ToolApplication {\n  public static void main(String[] args) {\n    Extractor extractor = new Extractor();\n    List<ResourceFile> resourceFiles = listAllResourceFiles(args[0]);\n    for (ResourceFile resourceFile : resourceFiles) {\n      resourceFile.accept(extractor);\n    }\n  }\n\n  private static List<ResourceFile> listAllResourceFiles(String resourceDirectory) {\n    List<ResourceFile> resourceFiles = new ArrayList<>();\n    //...根据后缀(pdf/ppt/word)由工厂方法创建不同的类对象(PdfFile/PPTFile/WordFile)\n    resourceFiles.add(new PdfFile(\"a.pdf\"));\n    resourceFiles.add(new WordFile(\"b.word\"));\n    resourceFiles.add(new PPTFile(\"c.ppt\"));\n    return resourceFiles;\n  }\n}\n```\n\n在执行第30行的时候，根据多态特性，程序会调用实际类型的accept函数，也就是第16行代码。而16行代码中的this类型是PdfFile的，在编译的时候就确定了，所以会调用extractor的extract2txt(PdfFile pdfFile)这个重载函数。这是理解访问者模式的关键所在。\n\n现在，如果要继续添加新的功能，比如前面说的压缩功能，根据不同的文件类型，使用不同的压缩算法来压缩资源文件，那么该如何实现呢？需要实现一个类似Extractor类的新类Compressor类，在其中定义三个重载函数，实现对不同类型资源文件的压缩。除此之外，还要在每个资源文件类中定义新的accept重载函数。\n\n```java\npublic abstract class ResourceFile {\n  protected String filePath;\n  public ResourceFile(String filePath) {\n    this.filePath = filePath;\n  }\n  abstract public void accept(Extractor extractor);\n  abstract public void accept(Compressor compressor);\n}\n\npublic class PdfFile extends ResourceFile {\n  public PdfFile(String filePath) {\n    super(filePath);\n  }\n\n  @Override\n  public void accept(Extractor extractor) {\n    extractor.extract2txt(this);\n  }\n\n  @Override\n  public void accept(Compressor compressor) {\n    compressor.compress(this);\n  }\n\n  //...\n}\n}\n//...PPTFile、WordFile跟PdfFile类似，这里就省略了...\n//...Extractor代码不变\n\npublic class ToolApplication {\n  public static void main(String[] args) {\n    Extractor extractor = new Extractor();\n    List<ResourceFile> resourceFiles = listAllResourceFiles(args[0]);\n    for (ResourceFile resourceFile : resourceFiles) {\n      resourceFile.accept(extractor);\n    }\n\n    Compressor compressor = new Compressor();\n    for(ResourceFile resourceFile : resourceFiles) {\n      resourceFile.accept(compressor);\n    }\n  }\n\n  private static List<ResourceFile> listAllResourceFiles(String resourceDirectory) {\n    List<ResourceFile> resourceFiles = new ArrayList<>();\n    //...根据后缀(pdf/ppt/word)由工厂方法创建不同的类对象(PdfFile/PPTFile/WordFile)\n    resourceFiles.add(new PdfFile(\"a.pdf\"));\n    resourceFiles.add(new WordFile(\"b.word\"));\n    resourceFiles.add(new PPTFile(\"c.ppt\"));\n    return resourceFiles;\n  }\n}\n```\n\n上面的代码还存在一些问题，添加一个新的业务，还是需要修改每个资源文件类，违反了开闭原则。针对这个问题，抽象出来一个Visitor接口，包含是三个命名非常通用的visit()重载函数，分别处理不同类型的资源文件。具体做什么业务处理，由实现这个Visitor接口的具体的类来决定，比如Extractor负责抽取文本内容，Compressor负责压缩。当我们新添加一个业务功能的时候，资源文件类不需要做任何修改，只需要修改ToolApplication的代码就可以了。\n\n按照这个思路对代码进行重构\n\n```java\npublic abstract class ResourceFile {\n  protected String filePath;\n  public ResourceFile(String filePath) {\n    this.filePath = filePath;\n  }\n  abstract public void accept(Visitor vistor);\n}\n\npublic class PdfFile extends ResourceFile {\n  public PdfFile(String filePath) {\n    super(filePath);\n  }\n\n  @Override\n  public void accept(Visitor visitor) {\n    visitor.visit(this);\n  }\n\n  //...\n}\n//...PPTFile、WordFile跟PdfFile类似，这里就省略了...\n\npublic interface Visitor {\n  void visit(PdfFile pdfFile);\n  void visit(PPTFile pdfFile);\n  void visit(WordFile pdfFile);\n}\n\npublic class Extractor implements Visitor {\n  @Override\n  public void visit(PPTFile pptFile) {\n    //...\n    System.out.println(\"Extract PPT.\");\n  }\n\n  @Override\n  public void visit(PdfFile pdfFile) {\n    //...\n    System.out.println(\"Extract PDF.\");\n  }\n\n  @Override\n  public void visit(WordFile wordFile) {\n    //...\n    System.out.println(\"Extract WORD.\");\n  }\n}\n\npublic class Compressor implements Visitor {\n  @Override\n  public void visit(PPTFile pptFile) {\n    //...\n    System.out.println(\"Compress PPT.\");\n  }\n\n  @Override\n  public void visit(PdfFile pdfFile) {\n    //...\n    System.out.println(\"Compress PDF.\");\n  }\n\n  @Override\n  public void visit(WordFile wordFile) {\n    //...\n    System.out.println(\"Compress WORD.\");\n  }\n\n}\n\npublic class ToolApplication {\n  public static void main(String[] args) {\n    Extractor extractor = new Extractor();\n    List<ResourceFile> resourceFiles = listAllResourceFiles(args[0]);\n    for (ResourceFile resourceFile : resourceFiles) {\n      resourceFile.accept(extractor);\n    }\n\n    Compressor compressor = new Compressor();\n    for(ResourceFile resourceFile : resourceFiles) {\n      resourceFile.accept(compressor);\n    }\n  }\n\n  private static List<ResourceFile> listAllResourceFiles(String resourceDirectory) {\n    List<ResourceFile> resourceFiles = new ArrayList<>();\n    //...根据后缀(pdf/ppt/word)由工厂方法创建不同的类对象(PdfFile/PPTFile/WordFile)\n    resourceFiles.add(new PdfFile(\"a.pdf\"));\n    resourceFiles.add(new WordFile(\"b.word\"));\n    resourceFiles.add(new PPTFile(\"c.ppt\"));\n    return resourceFiles;\n  }\n}\n```\n\n设计模式英文翻译是Visitor Design Pattern。在GoF的《设计模式》中是这么定义的：\n\n> Allows for one or more operation to be applied to a set of objects at runtime, decoupling the operations from the object structure.\n\n翻译成中文就是：允许一个或者多个操作应用到一组对象上，解耦操作和对象本身。\n\n经过重重重构之后的最终代码，就是标准的访问者模式的实现代码。类图如下：\n\n![img](https://static001.geekbang.org/resource/image/c4/65/c42c636c5384da5bd5343618305db865.jpg)\n\n访问者模式应用场景。\n\n访问者模式针对的是一组类型不同的对象。不过，尽管这组对象的类型是不同的，但是，它们继承相同的父类或者实现相同的接口，在不同的应用场景下，我们需要对这组对象进行一系列不想管的业务操作（抽取文本、压缩等），但为了避免不断添加功能导致类（PdfFile、PPTFile、WordFile）不断膨胀，职责越来越不单一，以及避免频繁地添加功能导致的频繁代码修改，我们使用访问者模式，将对象与操作解耦，将这些业务操作抽离出来，定义在独立细分的访问者类（Extractor、Compressor）中。\n\n##### 为什么支持双分派的语言不需要访问者模式？\n\nSingle Dispatch 指的是执行哪个对象的方法，根据对象的运行时类型来决定；执行对象的哪个方法，根据方法参数的编译时类型来决定。\n\nDouble Dispatch 指的是执行哪个对象的方法，根据对象的运行时类型来决定；执行对象的哪个方法，根据方法参数的运行时类型来决定。 \n\n**如何理解“Dispatch”呢?** 在面向对象编程语言中，可以把方法调用理解为一种消息传递，也就是“Dispatch”。一个对象调用另一个对象的方法，就相当于给它发送一条消息，这条消息起码要包含对象名、方法名、方法参数。\n\n**如何理解“Single”“Double”这两个单词呢？** 这两个单词指的是执行哪个对象的哪个方法，跟几个因素的运行时类型有关。Single Dispatch之所以称为“Single”是因为执行哪个对象的哪个方法，只跟“对象”的运行时类型有关。Double Dispatch是因为跟执行哪个对象的哪个方法，跟“对象”和“方法参数”两者的运行时类型有关。\n\n具体到编程语言的语法机制，Single Dispatch 和 Double Dispatch 跟多态和函数重载直接相关。当前主流的面向对象编程语言（比如，Java、C++、C#）都只支持 Single Dispatch，不支持 Double Dispatch。\n\n拿Java语言举例说明下。\n\nJava 支持多态特性，代码可以在运行时获得对象的实际类型（也就是前面提到的运行时类型），然后根据实际类型决定调用哪个方法。尽管 Java 支持函数重载，但 Java 设计的函数重载的语法规则是，并不是在运行时，根据传递进函数的参数的实际类型，来决定调用哪个重载函数，而是在编译时，根据传递进函数的参数的声明类型（也就是前面提到的编译时类型），来决定调用哪个重载函数。也就是说，具体执行哪个对象的哪个方法，只跟对象的运行时类型有关，跟参数的运行时类型无关。所以，Java 语言只支持 Single Dispatch。\n\n假设Java语言支持Double Dispatch，那么前面说的37行报错就不会报错了。代码会在运行时，根据参数（resourceFile）的实际类型（PdfFile、PPTFile、WordFile），来决定使用extract2txt的三个重载函数中的哪一个。所以也就不需要访问者模式了。\n\n##### 除了访问者模式，刚才的例子还有其他实现方案么？\n\n还可以利用工厂模式来实现，定义一个包含extract2txt()接口函数的Extractor接口。PdfExtractor、PPTExtractor、WordExtractor 类实现 Extractor 接口，并且在各自的 extract2txt() 函数中，分别实现 Pdf、PPT、Word 格式文件的文本内容抽取。ExtractorFactory 工厂类根据不同的文件类型，返回不同的 Extractor。\n\n```java\npublic abstract class ResourceFile {\n  protected String filePath;\n  public ResourceFile(String filePath) {\n    this.filePath = filePath;\n  }\n  public abstract ResourceFileType getType();\n}\n\npublic class PdfFile extends ResourceFile {\n  public PdfFile(String filePath) {\n    super(filePath);\n  }\n\n  @Override\n  public ResourceFileType getType() {\n    return ResourceFileType.PDF;\n  }\n\n  //...\n}\n\n//...PPTFile/WordFile跟PdfFile代码结构类似，此处省略...\n\npublic interface Extractor {\n  void extract2txt(ResourceFile resourceFile);\n}\n\npublic class PdfExtractor implements Extractor {\n  @Override\n  public void extract2txt(ResourceFile resourceFile) {\n    //...\n  }\n}\n\n//...PPTExtractor/WordExtractor跟PdfExtractor代码结构类似，此处省略...\n\npublic class ExtractorFactory {\n  private static final Map<ResourceFileType, Extractor> extractors = new HashMap<>();\n  static {\n    extractors.put(ResourceFileType.PDF, new PdfExtractor());\n    extractors.put(ResourceFileType.PPT, new PPTExtractor());\n    extractors.put(ResourceFileType.WORD, new WordExtractor());\n  }\n\n  public static Extractor getExtractor(ResourceFileType type) {\n    return extractors.get(type);\n  }\n}\n\npublic class ToolApplication {\n  public static void main(String[] args) {\n    List<ResourceFile> resourceFiles = listAllResourceFiles(args[0]);\n    for (ResourceFile resourceFile : resourceFiles) {\n      Extractor extractor = ExtractorFactory.getExtractor(resourceFile.getType());\n      extractor.extract2txt(resourceFile);\n    }\n  }\n\n  private static List<ResourceFile> listAllResourceFiles(String resourceDirectory) {\n    List<ResourceFile> resourceFiles = new ArrayList<>();\n    //...根据后缀(pdf/ppt/word)由工厂方法创建不同的类对象(PdfFile/PPTFile/WordFile)\n    resourceFiles.add(new PdfFile(\"a.pdf\"));\n    resourceFiles.add(new WordFile(\"b.word\"));\n    resourceFiles.add(new PPTFile(\"c.ppt\"));\n    return resourceFiles;\n  }\n}\n```\n\n当添加新的功能的时候，比如压缩文件，类似抽取文本内容功能的代码实现，只需要添加一个Compressor接口，PdfCompressor、PPTCompressor、WordCompressor 三个实现类，以及创建它们的 CompressorFactory 工厂类即可。唯一修改的就是最上层的ToolApplication类。基本符合“对扩展开放、对修改关闭”的设计原则。\n\n对于资源文件处理工具的例子，如果工具提供的功能并不多，是有几个而已，那更推荐工厂模式的实现方式，毕竟代码清晰、易懂。相反，如果工具提供非常多的功能，十几个，那更推荐访问者模式，因为访问者模式需要定义的类比工厂模式的实现方式少很多，类太多也会影响到代码的可维护性。\n\n","slug":"设计模式之访问者模式","published":1,"updated":"2021-06-09T05:26:10.000Z","comments":1,"photos":[],"link":"","_id":"cm1m304yd004d31b42qxg8i7d","content":"<p>访问者模式，难理解、难实现，应用它会导致代码的可读性、可维护性变差，开发中很少用到。但是为了读到应用了访问者模式的代码的时候，能一眼看出代码的设计意图，还是有必要学一学的。</p>\n<p>假设从网站上爬取了很多资源文件，他们的格式有三种：PDF、PPT、Word。我们现在要开发一个工具来处理这批资源文件。这个工具的其中一个功能是，把这些资源文件中的文本内容抽取出来放到txt文件中。</p>\n<p>ResourceFile是一个抽象类，包含一个抽象函数extract2txt()。PdfFile、PPTFile、WordFile 都继承 ResourceFile 类，并且重写了 extract2txt() 函数。在ToolApplication中，可以利用多态特性，根据对象的实际类型，来决定执行哪个方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ResourceFile</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">protected</span> String filePath;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ResourceFile</span><span class=\"params\">(String filePath)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.filePath = filePath;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">extract2txt</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PPTFile</span> <span class=\"keyword\">extends</span> <span class=\"title\">ResourceFile</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">PPTFile</span><span class=\"params\">(String filePath)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(filePath);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">extract2txt</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...省略一大坨从PPT中抽取文本的代码...</span></span><br><span class=\"line\">    <span class=\"comment\">//...将抽取出来的文本保存在跟filePath同名的.txt文件中...</span></span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;Extract PPT.&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PdfFile</span> <span class=\"keyword\">extends</span> <span class=\"title\">ResourceFile</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">PdfFile</span><span class=\"params\">(String filePath)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(filePath);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">extract2txt</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;Extract PDF.&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WordFile</span> <span class=\"keyword\">extends</span> <span class=\"title\">ResourceFile</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">WordFile</span><span class=\"params\">(String filePath)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(filePath);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">extract2txt</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;Extract WORD.&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 运行结果是：</span></span><br><span class=\"line\"><span class=\"comment\">// Extract PDF.</span></span><br><span class=\"line\"><span class=\"comment\">// Extract WORD.</span></span><br><span class=\"line\"><span class=\"comment\">// Extract PPT.</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ToolApplication</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    List&lt;ResourceFile&gt; resourceFiles = listAllResourceFiles(args[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (ResourceFile resourceFile : resourceFiles) &#123;</span><br><span class=\"line\">      resourceFile.extract2txt();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> List&lt;ResourceFile&gt; <span class=\"title\">listAllResourceFiles</span><span class=\"params\">(String resourceDirectory)</span> </span>&#123;</span><br><span class=\"line\">    List&lt;ResourceFile&gt; resourceFiles = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    <span class=\"comment\">//...根据后缀(pdf/ppt/word)由工厂方法创建不同的类对象(PdfFile/PPTFile/WordFile)</span></span><br><span class=\"line\">    resourceFiles.add(<span class=\"keyword\">new</span> PdfFile(<span class=\"string\">&quot;a.pdf&quot;</span>));</span><br><span class=\"line\">    resourceFiles.add(<span class=\"keyword\">new</span> WordFile(<span class=\"string\">&quot;b.word&quot;</span>));</span><br><span class=\"line\">    resourceFiles.add(<span class=\"keyword\">new</span> PPTFile(<span class=\"string\">&quot;c.ppt&quot;</span>));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> resourceFiles;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果工具的功能不停扩展，不仅要抽取文本内容，还要支持压缩、提取文件元信息（文件名、大小、更新时间等等）构建索引等一系列功能，如果按照上面的实现思路，就会存在这样几个问题：</p>\n<ul>\n<li>违背开闭原则，添加一个新的功能，所有类的代码都要修改；</li>\n<li>虽然功能增多，每个类的代码都不断膨胀，可读性和可维护性都变差了；</li>\n<li>把所有比较上层逻辑都耦合到PdfFile、PPTFile、WordFile类中，导致这些类的职责不够单一，变成了大杂烩。</li>\n</ul>\n<p>针对上面的问题，常用的解决方法就是拆分解耦，把业务操作和具体的数据结构解耦，设计成独立的类。这里按访问者模式的严谨思路来对上面的代码进行重构。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ResourceFile</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">protected</span> String filePath;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ResourceFile</span><span class=\"params\">(String filePath)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.filePath = filePath;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PdfFile</span> <span class=\"keyword\">extends</span> <span class=\"title\">ResourceFile</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">PdfFile</span><span class=\"params\">(String filePath)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(filePath);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//...PPTFile、WordFile代码省略...</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Extractor</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">extract2txt</span><span class=\"params\">(PPTFile pptFile)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;Extract PPT.&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">extract2txt</span><span class=\"params\">(PdfFile pdfFile)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;Extract PDF.&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">extract2txt</span><span class=\"params\">(WordFile wordFile)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;Extract WORD.&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ToolApplication</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    Extractor extractor = <span class=\"keyword\">new</span> Extractor();</span><br><span class=\"line\">    List&lt;ResourceFile&gt; resourceFiles = listAllResourceFiles(args[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (ResourceFile resourceFile : resourceFiles) &#123;</span><br><span class=\"line\">      extractor.extract2txt(resourceFile);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> List&lt;ResourceFile&gt; <span class=\"title\">listAllResourceFiles</span><span class=\"params\">(String resourceDirectory)</span> </span>&#123;</span><br><span class=\"line\">    List&lt;ResourceFile&gt; resourceFiles = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    <span class=\"comment\">//...根据后缀(pdf/ppt/word)由工厂方法创建不同的类对象(PdfFile/PPTFile/WordFile)</span></span><br><span class=\"line\">    resourceFiles.add(<span class=\"keyword\">new</span> PdfFile(<span class=\"string\">&quot;a.pdf&quot;</span>));</span><br><span class=\"line\">    resourceFiles.add(<span class=\"keyword\">new</span> WordFile(<span class=\"string\">&quot;b.word&quot;</span>));</span><br><span class=\"line\">    resourceFiles.add(<span class=\"keyword\">new</span> PPTFile(<span class=\"string\">&quot;c.ppt&quot;</span>));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> resourceFiles;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里最关键的一点设计是，把抽取不同类型文本的操作，设计成了三个重载函数。不过，其实上面的代码编译是不通过的，第37行会报错。这是为什么呢？</p>\n<p>多态是一种动态绑定，可以在运行时获取对象的实际类型，来运行实际类型对应的方法。而函数重载是一种静态绑定，在编译时并不能获取对象的实际类型，而是根据声明类型执行声明类型对应的方法。</p>\n<p>在上面的35-38行中，resourceFiles包含的对象的声明类型都是ResourceFile，而我们并没有在Extractor类中定义参数类型是ResourceFile的extract2txt()重载函数，所以在编译阶段就通过不了，更别说在运行时根据对象的实际类型执行不同的重载函数了。那如何解决呢？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ResourceFile</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">protected</span> String filePath;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ResourceFile</span><span class=\"params\">(String filePath)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.filePath = filePath;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">accept</span><span class=\"params\">(Extractor extractor)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PdfFile</span> <span class=\"keyword\">extends</span> <span class=\"title\">ResourceFile</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">PdfFile</span><span class=\"params\">(String filePath)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(filePath);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">accept</span><span class=\"params\">(Extractor extractor)</span> </span>&#123;</span><br><span class=\"line\">    extractor.extract2txt(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//...PPTFile、WordFile跟PdfFile类似，这里就省略了...</span></span><br><span class=\"line\"><span class=\"comment\">//...Extractor代码不变...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ToolApplication</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    Extractor extractor = <span class=\"keyword\">new</span> Extractor();</span><br><span class=\"line\">    List&lt;ResourceFile&gt; resourceFiles = listAllResourceFiles(args[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (ResourceFile resourceFile : resourceFiles) &#123;</span><br><span class=\"line\">      resourceFile.accept(extractor);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> List&lt;ResourceFile&gt; <span class=\"title\">listAllResourceFiles</span><span class=\"params\">(String resourceDirectory)</span> </span>&#123;</span><br><span class=\"line\">    List&lt;ResourceFile&gt; resourceFiles = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    <span class=\"comment\">//...根据后缀(pdf/ppt/word)由工厂方法创建不同的类对象(PdfFile/PPTFile/WordFile)</span></span><br><span class=\"line\">    resourceFiles.add(<span class=\"keyword\">new</span> PdfFile(<span class=\"string\">&quot;a.pdf&quot;</span>));</span><br><span class=\"line\">    resourceFiles.add(<span class=\"keyword\">new</span> WordFile(<span class=\"string\">&quot;b.word&quot;</span>));</span><br><span class=\"line\">    resourceFiles.add(<span class=\"keyword\">new</span> PPTFile(<span class=\"string\">&quot;c.ppt&quot;</span>));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> resourceFiles;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在执行第30行的时候，根据多态特性，程序会调用实际类型的accept函数，也就是第16行代码。而16行代码中的this类型是PdfFile的，在编译的时候就确定了，所以会调用extractor的extract2txt(PdfFile pdfFile)这个重载函数。这是理解访问者模式的关键所在。</p>\n<p>现在，如果要继续添加新的功能，比如前面说的压缩功能，根据不同的文件类型，使用不同的压缩算法来压缩资源文件，那么该如何实现呢？需要实现一个类似Extractor类的新类Compressor类，在其中定义三个重载函数，实现对不同类型资源文件的压缩。除此之外，还要在每个资源文件类中定义新的accept重载函数。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ResourceFile</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">protected</span> String filePath;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ResourceFile</span><span class=\"params\">(String filePath)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.filePath = filePath;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">accept</span><span class=\"params\">(Extractor extractor)</span></span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">accept</span><span class=\"params\">(Compressor compressor)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PdfFile</span> <span class=\"keyword\">extends</span> <span class=\"title\">ResourceFile</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">PdfFile</span><span class=\"params\">(String filePath)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(filePath);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">accept</span><span class=\"params\">(Extractor extractor)</span> </span>&#123;</span><br><span class=\"line\">    extractor.extract2txt(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">accept</span><span class=\"params\">(Compressor compressor)</span> </span>&#123;</span><br><span class=\"line\">    compressor.compress(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//...PPTFile、WordFile跟PdfFile类似，这里就省略了...</span></span><br><span class=\"line\"><span class=\"comment\">//...Extractor代码不变</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ToolApplication</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    Extractor extractor = <span class=\"keyword\">new</span> Extractor();</span><br><span class=\"line\">    List&lt;ResourceFile&gt; resourceFiles = listAllResourceFiles(args[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (ResourceFile resourceFile : resourceFiles) &#123;</span><br><span class=\"line\">      resourceFile.accept(extractor);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Compressor compressor = <span class=\"keyword\">new</span> Compressor();</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(ResourceFile resourceFile : resourceFiles) &#123;</span><br><span class=\"line\">      resourceFile.accept(compressor);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> List&lt;ResourceFile&gt; <span class=\"title\">listAllResourceFiles</span><span class=\"params\">(String resourceDirectory)</span> </span>&#123;</span><br><span class=\"line\">    List&lt;ResourceFile&gt; resourceFiles = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    <span class=\"comment\">//...根据后缀(pdf/ppt/word)由工厂方法创建不同的类对象(PdfFile/PPTFile/WordFile)</span></span><br><span class=\"line\">    resourceFiles.add(<span class=\"keyword\">new</span> PdfFile(<span class=\"string\">&quot;a.pdf&quot;</span>));</span><br><span class=\"line\">    resourceFiles.add(<span class=\"keyword\">new</span> WordFile(<span class=\"string\">&quot;b.word&quot;</span>));</span><br><span class=\"line\">    resourceFiles.add(<span class=\"keyword\">new</span> PPTFile(<span class=\"string\">&quot;c.ppt&quot;</span>));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> resourceFiles;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的代码还存在一些问题，添加一个新的业务，还是需要修改每个资源文件类，违反了开闭原则。针对这个问题，抽象出来一个Visitor接口，包含是三个命名非常通用的visit()重载函数，分别处理不同类型的资源文件。具体做什么业务处理，由实现这个Visitor接口的具体的类来决定，比如Extractor负责抽取文本内容，Compressor负责压缩。当我们新添加一个业务功能的时候，资源文件类不需要做任何修改，只需要修改ToolApplication的代码就可以了。</p>\n<p>按照这个思路对代码进行重构</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ResourceFile</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">protected</span> String filePath;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ResourceFile</span><span class=\"params\">(String filePath)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.filePath = filePath;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">accept</span><span class=\"params\">(Visitor vistor)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PdfFile</span> <span class=\"keyword\">extends</span> <span class=\"title\">ResourceFile</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">PdfFile</span><span class=\"params\">(String filePath)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(filePath);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">accept</span><span class=\"params\">(Visitor visitor)</span> </span>&#123;</span><br><span class=\"line\">    visitor.visit(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//...PPTFile、WordFile跟PdfFile类似，这里就省略了...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Visitor</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">visit</span><span class=\"params\">(PdfFile pdfFile)</span></span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">visit</span><span class=\"params\">(PPTFile pdfFile)</span></span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">visit</span><span class=\"params\">(WordFile pdfFile)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Extractor</span> <span class=\"keyword\">implements</span> <span class=\"title\">Visitor</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">visit</span><span class=\"params\">(PPTFile pptFile)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;Extract PPT.&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">visit</span><span class=\"params\">(PdfFile pdfFile)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;Extract PDF.&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">visit</span><span class=\"params\">(WordFile wordFile)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;Extract WORD.&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Compressor</span> <span class=\"keyword\">implements</span> <span class=\"title\">Visitor</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">visit</span><span class=\"params\">(PPTFile pptFile)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;Compress PPT.&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">visit</span><span class=\"params\">(PdfFile pdfFile)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;Compress PDF.&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">visit</span><span class=\"params\">(WordFile wordFile)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;Compress WORD.&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ToolApplication</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    Extractor extractor = <span class=\"keyword\">new</span> Extractor();</span><br><span class=\"line\">    List&lt;ResourceFile&gt; resourceFiles = listAllResourceFiles(args[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (ResourceFile resourceFile : resourceFiles) &#123;</span><br><span class=\"line\">      resourceFile.accept(extractor);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Compressor compressor = <span class=\"keyword\">new</span> Compressor();</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(ResourceFile resourceFile : resourceFiles) &#123;</span><br><span class=\"line\">      resourceFile.accept(compressor);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> List&lt;ResourceFile&gt; <span class=\"title\">listAllResourceFiles</span><span class=\"params\">(String resourceDirectory)</span> </span>&#123;</span><br><span class=\"line\">    List&lt;ResourceFile&gt; resourceFiles = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    <span class=\"comment\">//...根据后缀(pdf/ppt/word)由工厂方法创建不同的类对象(PdfFile/PPTFile/WordFile)</span></span><br><span class=\"line\">    resourceFiles.add(<span class=\"keyword\">new</span> PdfFile(<span class=\"string\">&quot;a.pdf&quot;</span>));</span><br><span class=\"line\">    resourceFiles.add(<span class=\"keyword\">new</span> WordFile(<span class=\"string\">&quot;b.word&quot;</span>));</span><br><span class=\"line\">    resourceFiles.add(<span class=\"keyword\">new</span> PPTFile(<span class=\"string\">&quot;c.ppt&quot;</span>));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> resourceFiles;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>设计模式英文翻译是Visitor Design Pattern。在GoF的《设计模式》中是这么定义的：</p>\n<blockquote>\n<p>Allows for one or more operation to be applied to a set of objects at runtime, decoupling the operations from the object structure.</p>\n</blockquote>\n<p>翻译成中文就是：允许一个或者多个操作应用到一组对象上，解耦操作和对象本身。</p>\n<p>经过重重重构之后的最终代码，就是标准的访问者模式的实现代码。类图如下：</p>\n<p><img src=\"https://static001.geekbang.org/resource/image/c4/65/c42c636c5384da5bd5343618305db865.jpg\" alt=\"img\"></p>\n<p>访问者模式应用场景。</p>\n<p>访问者模式针对的是一组类型不同的对象。不过，尽管这组对象的类型是不同的，但是，它们继承相同的父类或者实现相同的接口，在不同的应用场景下，我们需要对这组对象进行一系列不想管的业务操作（抽取文本、压缩等），但为了避免不断添加功能导致类（PdfFile、PPTFile、WordFile）不断膨胀，职责越来越不单一，以及避免频繁地添加功能导致的频繁代码修改，我们使用访问者模式，将对象与操作解耦，将这些业务操作抽离出来，定义在独立细分的访问者类（Extractor、Compressor）中。</p>\n<h5 id=\"为什么支持双分派的语言不需要访问者模式？\"><a href=\"#为什么支持双分派的语言不需要访问者模式？\" class=\"headerlink\" title=\"为什么支持双分派的语言不需要访问者模式？\"></a>为什么支持双分派的语言不需要访问者模式？</h5><p>Single Dispatch 指的是执行哪个对象的方法，根据对象的运行时类型来决定；执行对象的哪个方法，根据方法参数的编译时类型来决定。</p>\n<p>Double Dispatch 指的是执行哪个对象的方法，根据对象的运行时类型来决定；执行对象的哪个方法，根据方法参数的运行时类型来决定。 </p>\n<p><strong>如何理解“Dispatch”呢?</strong> 在面向对象编程语言中，可以把方法调用理解为一种消息传递，也就是“Dispatch”。一个对象调用另一个对象的方法，就相当于给它发送一条消息，这条消息起码要包含对象名、方法名、方法参数。</p>\n<p><strong>如何理解“Single”“Double”这两个单词呢？</strong> 这两个单词指的是执行哪个对象的哪个方法，跟几个因素的运行时类型有关。Single Dispatch之所以称为“Single”是因为执行哪个对象的哪个方法，只跟“对象”的运行时类型有关。Double Dispatch是因为跟执行哪个对象的哪个方法，跟“对象”和“方法参数”两者的运行时类型有关。</p>\n<p>具体到编程语言的语法机制，Single Dispatch 和 Double Dispatch 跟多态和函数重载直接相关。当前主流的面向对象编程语言（比如，Java、C++、C#）都只支持 Single Dispatch，不支持 Double Dispatch。</p>\n<p>拿Java语言举例说明下。</p>\n<p>Java 支持多态特性，代码可以在运行时获得对象的实际类型（也就是前面提到的运行时类型），然后根据实际类型决定调用哪个方法。尽管 Java 支持函数重载，但 Java 设计的函数重载的语法规则是，并不是在运行时，根据传递进函数的参数的实际类型，来决定调用哪个重载函数，而是在编译时，根据传递进函数的参数的声明类型（也就是前面提到的编译时类型），来决定调用哪个重载函数。也就是说，具体执行哪个对象的哪个方法，只跟对象的运行时类型有关，跟参数的运行时类型无关。所以，Java 语言只支持 Single Dispatch。</p>\n<p>假设Java语言支持Double Dispatch，那么前面说的37行报错就不会报错了。代码会在运行时，根据参数（resourceFile）的实际类型（PdfFile、PPTFile、WordFile），来决定使用extract2txt的三个重载函数中的哪一个。所以也就不需要访问者模式了。</p>\n<h5 id=\"除了访问者模式，刚才的例子还有其他实现方案么？\"><a href=\"#除了访问者模式，刚才的例子还有其他实现方案么？\" class=\"headerlink\" title=\"除了访问者模式，刚才的例子还有其他实现方案么？\"></a>除了访问者模式，刚才的例子还有其他实现方案么？</h5><p>还可以利用工厂模式来实现，定义一个包含extract2txt()接口函数的Extractor接口。PdfExtractor、PPTExtractor、WordExtractor 类实现 Extractor 接口，并且在各自的 extract2txt() 函数中，分别实现 Pdf、PPT、Word 格式文件的文本内容抽取。ExtractorFactory 工厂类根据不同的文件类型，返回不同的 Extractor。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ResourceFile</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">protected</span> String filePath;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ResourceFile</span><span class=\"params\">(String filePath)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.filePath = filePath;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> ResourceFileType <span class=\"title\">getType</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PdfFile</span> <span class=\"keyword\">extends</span> <span class=\"title\">ResourceFile</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">PdfFile</span><span class=\"params\">(String filePath)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(filePath);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> ResourceFileType <span class=\"title\">getType</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ResourceFileType.PDF;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//...PPTFile/WordFile跟PdfFile代码结构类似，此处省略...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Extractor</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">extract2txt</span><span class=\"params\">(ResourceFile resourceFile)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PdfExtractor</span> <span class=\"keyword\">implements</span> <span class=\"title\">Extractor</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">extract2txt</span><span class=\"params\">(ResourceFile resourceFile)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//...PPTExtractor/WordExtractor跟PdfExtractor代码结构类似，此处省略...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExtractorFactory</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Map&lt;ResourceFileType, Extractor&gt; extractors = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">  <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">    extractors.put(ResourceFileType.PDF, <span class=\"keyword\">new</span> PdfExtractor());</span><br><span class=\"line\">    extractors.put(ResourceFileType.PPT, <span class=\"keyword\">new</span> PPTExtractor());</span><br><span class=\"line\">    extractors.put(ResourceFileType.WORD, <span class=\"keyword\">new</span> WordExtractor());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Extractor <span class=\"title\">getExtractor</span><span class=\"params\">(ResourceFileType type)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> extractors.get(type);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ToolApplication</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    List&lt;ResourceFile&gt; resourceFiles = listAllResourceFiles(args[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (ResourceFile resourceFile : resourceFiles) &#123;</span><br><span class=\"line\">      Extractor extractor = ExtractorFactory.getExtractor(resourceFile.getType());</span><br><span class=\"line\">      extractor.extract2txt(resourceFile);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> List&lt;ResourceFile&gt; <span class=\"title\">listAllResourceFiles</span><span class=\"params\">(String resourceDirectory)</span> </span>&#123;</span><br><span class=\"line\">    List&lt;ResourceFile&gt; resourceFiles = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    <span class=\"comment\">//...根据后缀(pdf/ppt/word)由工厂方法创建不同的类对象(PdfFile/PPTFile/WordFile)</span></span><br><span class=\"line\">    resourceFiles.add(<span class=\"keyword\">new</span> PdfFile(<span class=\"string\">&quot;a.pdf&quot;</span>));</span><br><span class=\"line\">    resourceFiles.add(<span class=\"keyword\">new</span> WordFile(<span class=\"string\">&quot;b.word&quot;</span>));</span><br><span class=\"line\">    resourceFiles.add(<span class=\"keyword\">new</span> PPTFile(<span class=\"string\">&quot;c.ppt&quot;</span>));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> resourceFiles;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当添加新的功能的时候，比如压缩文件，类似抽取文本内容功能的代码实现，只需要添加一个Compressor接口，PdfCompressor、PPTCompressor、WordCompressor 三个实现类，以及创建它们的 CompressorFactory 工厂类即可。唯一修改的就是最上层的ToolApplication类。基本符合“对扩展开放、对修改关闭”的设计原则。</p>\n<p>对于资源文件处理工具的例子，如果工具提供的功能并不多，是有几个而已，那更推荐工厂模式的实现方式，毕竟代码清晰、易懂。相反，如果工具提供非常多的功能，十几个，那更推荐访问者模式，因为访问者模式需要定义的类比工厂模式的实现方式少很多，类太多也会影响到代码的可维护性。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>访问者模式，难理解、难实现，应用它会导致代码的可读性、可维护性变差，开发中很少用到。但是为了读到应用了访问者模式的代码的时候，能一眼看出代码的设计意图，还是有必要学一学的。</p>\n<p>假设从网站上爬取了很多资源文件，他们的格式有三种：PDF、PPT、Word。我们现在要开发一个工具来处理这批资源文件。这个工具的其中一个功能是，把这些资源文件中的文本内容抽取出来放到txt文件中。</p>\n<p>ResourceFile是一个抽象类，包含一个抽象函数extract2txt()。PdfFile、PPTFile、WordFile 都继承 ResourceFile 类，并且重写了 extract2txt() 函数。在ToolApplication中，可以利用多态特性，根据对象的实际类型，来决定执行哪个方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ResourceFile</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">protected</span> String filePath;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ResourceFile</span><span class=\"params\">(String filePath)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.filePath = filePath;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">extract2txt</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PPTFile</span> <span class=\"keyword\">extends</span> <span class=\"title\">ResourceFile</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">PPTFile</span><span class=\"params\">(String filePath)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(filePath);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">extract2txt</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...省略一大坨从PPT中抽取文本的代码...</span></span><br><span class=\"line\">    <span class=\"comment\">//...将抽取出来的文本保存在跟filePath同名的.txt文件中...</span></span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;Extract PPT.&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PdfFile</span> <span class=\"keyword\">extends</span> <span class=\"title\">ResourceFile</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">PdfFile</span><span class=\"params\">(String filePath)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(filePath);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">extract2txt</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;Extract PDF.&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WordFile</span> <span class=\"keyword\">extends</span> <span class=\"title\">ResourceFile</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">WordFile</span><span class=\"params\">(String filePath)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(filePath);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">extract2txt</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;Extract WORD.&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 运行结果是：</span></span><br><span class=\"line\"><span class=\"comment\">// Extract PDF.</span></span><br><span class=\"line\"><span class=\"comment\">// Extract WORD.</span></span><br><span class=\"line\"><span class=\"comment\">// Extract PPT.</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ToolApplication</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    List&lt;ResourceFile&gt; resourceFiles = listAllResourceFiles(args[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (ResourceFile resourceFile : resourceFiles) &#123;</span><br><span class=\"line\">      resourceFile.extract2txt();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> List&lt;ResourceFile&gt; <span class=\"title\">listAllResourceFiles</span><span class=\"params\">(String resourceDirectory)</span> </span>&#123;</span><br><span class=\"line\">    List&lt;ResourceFile&gt; resourceFiles = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    <span class=\"comment\">//...根据后缀(pdf/ppt/word)由工厂方法创建不同的类对象(PdfFile/PPTFile/WordFile)</span></span><br><span class=\"line\">    resourceFiles.add(<span class=\"keyword\">new</span> PdfFile(<span class=\"string\">&quot;a.pdf&quot;</span>));</span><br><span class=\"line\">    resourceFiles.add(<span class=\"keyword\">new</span> WordFile(<span class=\"string\">&quot;b.word&quot;</span>));</span><br><span class=\"line\">    resourceFiles.add(<span class=\"keyword\">new</span> PPTFile(<span class=\"string\">&quot;c.ppt&quot;</span>));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> resourceFiles;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果工具的功能不停扩展，不仅要抽取文本内容，还要支持压缩、提取文件元信息（文件名、大小、更新时间等等）构建索引等一系列功能，如果按照上面的实现思路，就会存在这样几个问题：</p>\n<ul>\n<li>违背开闭原则，添加一个新的功能，所有类的代码都要修改；</li>\n<li>虽然功能增多，每个类的代码都不断膨胀，可读性和可维护性都变差了；</li>\n<li>把所有比较上层逻辑都耦合到PdfFile、PPTFile、WordFile类中，导致这些类的职责不够单一，变成了大杂烩。</li>\n</ul>\n<p>针对上面的问题，常用的解决方法就是拆分解耦，把业务操作和具体的数据结构解耦，设计成独立的类。这里按访问者模式的严谨思路来对上面的代码进行重构。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ResourceFile</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">protected</span> String filePath;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ResourceFile</span><span class=\"params\">(String filePath)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.filePath = filePath;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PdfFile</span> <span class=\"keyword\">extends</span> <span class=\"title\">ResourceFile</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">PdfFile</span><span class=\"params\">(String filePath)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(filePath);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//...PPTFile、WordFile代码省略...</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Extractor</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">extract2txt</span><span class=\"params\">(PPTFile pptFile)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;Extract PPT.&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">extract2txt</span><span class=\"params\">(PdfFile pdfFile)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;Extract PDF.&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">extract2txt</span><span class=\"params\">(WordFile wordFile)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;Extract WORD.&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ToolApplication</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    Extractor extractor = <span class=\"keyword\">new</span> Extractor();</span><br><span class=\"line\">    List&lt;ResourceFile&gt; resourceFiles = listAllResourceFiles(args[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (ResourceFile resourceFile : resourceFiles) &#123;</span><br><span class=\"line\">      extractor.extract2txt(resourceFile);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> List&lt;ResourceFile&gt; <span class=\"title\">listAllResourceFiles</span><span class=\"params\">(String resourceDirectory)</span> </span>&#123;</span><br><span class=\"line\">    List&lt;ResourceFile&gt; resourceFiles = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    <span class=\"comment\">//...根据后缀(pdf/ppt/word)由工厂方法创建不同的类对象(PdfFile/PPTFile/WordFile)</span></span><br><span class=\"line\">    resourceFiles.add(<span class=\"keyword\">new</span> PdfFile(<span class=\"string\">&quot;a.pdf&quot;</span>));</span><br><span class=\"line\">    resourceFiles.add(<span class=\"keyword\">new</span> WordFile(<span class=\"string\">&quot;b.word&quot;</span>));</span><br><span class=\"line\">    resourceFiles.add(<span class=\"keyword\">new</span> PPTFile(<span class=\"string\">&quot;c.ppt&quot;</span>));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> resourceFiles;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里最关键的一点设计是，把抽取不同类型文本的操作，设计成了三个重载函数。不过，其实上面的代码编译是不通过的，第37行会报错。这是为什么呢？</p>\n<p>多态是一种动态绑定，可以在运行时获取对象的实际类型，来运行实际类型对应的方法。而函数重载是一种静态绑定，在编译时并不能获取对象的实际类型，而是根据声明类型执行声明类型对应的方法。</p>\n<p>在上面的35-38行中，resourceFiles包含的对象的声明类型都是ResourceFile，而我们并没有在Extractor类中定义参数类型是ResourceFile的extract2txt()重载函数，所以在编译阶段就通过不了，更别说在运行时根据对象的实际类型执行不同的重载函数了。那如何解决呢？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ResourceFile</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">protected</span> String filePath;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ResourceFile</span><span class=\"params\">(String filePath)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.filePath = filePath;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">accept</span><span class=\"params\">(Extractor extractor)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PdfFile</span> <span class=\"keyword\">extends</span> <span class=\"title\">ResourceFile</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">PdfFile</span><span class=\"params\">(String filePath)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(filePath);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">accept</span><span class=\"params\">(Extractor extractor)</span> </span>&#123;</span><br><span class=\"line\">    extractor.extract2txt(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//...PPTFile、WordFile跟PdfFile类似，这里就省略了...</span></span><br><span class=\"line\"><span class=\"comment\">//...Extractor代码不变...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ToolApplication</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    Extractor extractor = <span class=\"keyword\">new</span> Extractor();</span><br><span class=\"line\">    List&lt;ResourceFile&gt; resourceFiles = listAllResourceFiles(args[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (ResourceFile resourceFile : resourceFiles) &#123;</span><br><span class=\"line\">      resourceFile.accept(extractor);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> List&lt;ResourceFile&gt; <span class=\"title\">listAllResourceFiles</span><span class=\"params\">(String resourceDirectory)</span> </span>&#123;</span><br><span class=\"line\">    List&lt;ResourceFile&gt; resourceFiles = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    <span class=\"comment\">//...根据后缀(pdf/ppt/word)由工厂方法创建不同的类对象(PdfFile/PPTFile/WordFile)</span></span><br><span class=\"line\">    resourceFiles.add(<span class=\"keyword\">new</span> PdfFile(<span class=\"string\">&quot;a.pdf&quot;</span>));</span><br><span class=\"line\">    resourceFiles.add(<span class=\"keyword\">new</span> WordFile(<span class=\"string\">&quot;b.word&quot;</span>));</span><br><span class=\"line\">    resourceFiles.add(<span class=\"keyword\">new</span> PPTFile(<span class=\"string\">&quot;c.ppt&quot;</span>));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> resourceFiles;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在执行第30行的时候，根据多态特性，程序会调用实际类型的accept函数，也就是第16行代码。而16行代码中的this类型是PdfFile的，在编译的时候就确定了，所以会调用extractor的extract2txt(PdfFile pdfFile)这个重载函数。这是理解访问者模式的关键所在。</p>\n<p>现在，如果要继续添加新的功能，比如前面说的压缩功能，根据不同的文件类型，使用不同的压缩算法来压缩资源文件，那么该如何实现呢？需要实现一个类似Extractor类的新类Compressor类，在其中定义三个重载函数，实现对不同类型资源文件的压缩。除此之外，还要在每个资源文件类中定义新的accept重载函数。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ResourceFile</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">protected</span> String filePath;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ResourceFile</span><span class=\"params\">(String filePath)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.filePath = filePath;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">accept</span><span class=\"params\">(Extractor extractor)</span></span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">accept</span><span class=\"params\">(Compressor compressor)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PdfFile</span> <span class=\"keyword\">extends</span> <span class=\"title\">ResourceFile</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">PdfFile</span><span class=\"params\">(String filePath)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(filePath);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">accept</span><span class=\"params\">(Extractor extractor)</span> </span>&#123;</span><br><span class=\"line\">    extractor.extract2txt(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">accept</span><span class=\"params\">(Compressor compressor)</span> </span>&#123;</span><br><span class=\"line\">    compressor.compress(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//...PPTFile、WordFile跟PdfFile类似，这里就省略了...</span></span><br><span class=\"line\"><span class=\"comment\">//...Extractor代码不变</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ToolApplication</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    Extractor extractor = <span class=\"keyword\">new</span> Extractor();</span><br><span class=\"line\">    List&lt;ResourceFile&gt; resourceFiles = listAllResourceFiles(args[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (ResourceFile resourceFile : resourceFiles) &#123;</span><br><span class=\"line\">      resourceFile.accept(extractor);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Compressor compressor = <span class=\"keyword\">new</span> Compressor();</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(ResourceFile resourceFile : resourceFiles) &#123;</span><br><span class=\"line\">      resourceFile.accept(compressor);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> List&lt;ResourceFile&gt; <span class=\"title\">listAllResourceFiles</span><span class=\"params\">(String resourceDirectory)</span> </span>&#123;</span><br><span class=\"line\">    List&lt;ResourceFile&gt; resourceFiles = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    <span class=\"comment\">//...根据后缀(pdf/ppt/word)由工厂方法创建不同的类对象(PdfFile/PPTFile/WordFile)</span></span><br><span class=\"line\">    resourceFiles.add(<span class=\"keyword\">new</span> PdfFile(<span class=\"string\">&quot;a.pdf&quot;</span>));</span><br><span class=\"line\">    resourceFiles.add(<span class=\"keyword\">new</span> WordFile(<span class=\"string\">&quot;b.word&quot;</span>));</span><br><span class=\"line\">    resourceFiles.add(<span class=\"keyword\">new</span> PPTFile(<span class=\"string\">&quot;c.ppt&quot;</span>));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> resourceFiles;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的代码还存在一些问题，添加一个新的业务，还是需要修改每个资源文件类，违反了开闭原则。针对这个问题，抽象出来一个Visitor接口，包含是三个命名非常通用的visit()重载函数，分别处理不同类型的资源文件。具体做什么业务处理，由实现这个Visitor接口的具体的类来决定，比如Extractor负责抽取文本内容，Compressor负责压缩。当我们新添加一个业务功能的时候，资源文件类不需要做任何修改，只需要修改ToolApplication的代码就可以了。</p>\n<p>按照这个思路对代码进行重构</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ResourceFile</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">protected</span> String filePath;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ResourceFile</span><span class=\"params\">(String filePath)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.filePath = filePath;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">accept</span><span class=\"params\">(Visitor vistor)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PdfFile</span> <span class=\"keyword\">extends</span> <span class=\"title\">ResourceFile</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">PdfFile</span><span class=\"params\">(String filePath)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(filePath);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">accept</span><span class=\"params\">(Visitor visitor)</span> </span>&#123;</span><br><span class=\"line\">    visitor.visit(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//...PPTFile、WordFile跟PdfFile类似，这里就省略了...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Visitor</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">visit</span><span class=\"params\">(PdfFile pdfFile)</span></span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">visit</span><span class=\"params\">(PPTFile pdfFile)</span></span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">visit</span><span class=\"params\">(WordFile pdfFile)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Extractor</span> <span class=\"keyword\">implements</span> <span class=\"title\">Visitor</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">visit</span><span class=\"params\">(PPTFile pptFile)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;Extract PPT.&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">visit</span><span class=\"params\">(PdfFile pdfFile)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;Extract PDF.&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">visit</span><span class=\"params\">(WordFile wordFile)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;Extract WORD.&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Compressor</span> <span class=\"keyword\">implements</span> <span class=\"title\">Visitor</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">visit</span><span class=\"params\">(PPTFile pptFile)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;Compress PPT.&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">visit</span><span class=\"params\">(PdfFile pdfFile)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;Compress PDF.&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">visit</span><span class=\"params\">(WordFile wordFile)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;Compress WORD.&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ToolApplication</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    Extractor extractor = <span class=\"keyword\">new</span> Extractor();</span><br><span class=\"line\">    List&lt;ResourceFile&gt; resourceFiles = listAllResourceFiles(args[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (ResourceFile resourceFile : resourceFiles) &#123;</span><br><span class=\"line\">      resourceFile.accept(extractor);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Compressor compressor = <span class=\"keyword\">new</span> Compressor();</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(ResourceFile resourceFile : resourceFiles) &#123;</span><br><span class=\"line\">      resourceFile.accept(compressor);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> List&lt;ResourceFile&gt; <span class=\"title\">listAllResourceFiles</span><span class=\"params\">(String resourceDirectory)</span> </span>&#123;</span><br><span class=\"line\">    List&lt;ResourceFile&gt; resourceFiles = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    <span class=\"comment\">//...根据后缀(pdf/ppt/word)由工厂方法创建不同的类对象(PdfFile/PPTFile/WordFile)</span></span><br><span class=\"line\">    resourceFiles.add(<span class=\"keyword\">new</span> PdfFile(<span class=\"string\">&quot;a.pdf&quot;</span>));</span><br><span class=\"line\">    resourceFiles.add(<span class=\"keyword\">new</span> WordFile(<span class=\"string\">&quot;b.word&quot;</span>));</span><br><span class=\"line\">    resourceFiles.add(<span class=\"keyword\">new</span> PPTFile(<span class=\"string\">&quot;c.ppt&quot;</span>));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> resourceFiles;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>设计模式英文翻译是Visitor Design Pattern。在GoF的《设计模式》中是这么定义的：</p>\n<blockquote>\n<p>Allows for one or more operation to be applied to a set of objects at runtime, decoupling the operations from the object structure.</p>\n</blockquote>\n<p>翻译成中文就是：允许一个或者多个操作应用到一组对象上，解耦操作和对象本身。</p>\n<p>经过重重重构之后的最终代码，就是标准的访问者模式的实现代码。类图如下：</p>\n<p><img src=\"https://static001.geekbang.org/resource/image/c4/65/c42c636c5384da5bd5343618305db865.jpg\" alt=\"img\"></p>\n<p>访问者模式应用场景。</p>\n<p>访问者模式针对的是一组类型不同的对象。不过，尽管这组对象的类型是不同的，但是，它们继承相同的父类或者实现相同的接口，在不同的应用场景下，我们需要对这组对象进行一系列不想管的业务操作（抽取文本、压缩等），但为了避免不断添加功能导致类（PdfFile、PPTFile、WordFile）不断膨胀，职责越来越不单一，以及避免频繁地添加功能导致的频繁代码修改，我们使用访问者模式，将对象与操作解耦，将这些业务操作抽离出来，定义在独立细分的访问者类（Extractor、Compressor）中。</p>\n<h5 id=\"为什么支持双分派的语言不需要访问者模式？\"><a href=\"#为什么支持双分派的语言不需要访问者模式？\" class=\"headerlink\" title=\"为什么支持双分派的语言不需要访问者模式？\"></a>为什么支持双分派的语言不需要访问者模式？</h5><p>Single Dispatch 指的是执行哪个对象的方法，根据对象的运行时类型来决定；执行对象的哪个方法，根据方法参数的编译时类型来决定。</p>\n<p>Double Dispatch 指的是执行哪个对象的方法，根据对象的运行时类型来决定；执行对象的哪个方法，根据方法参数的运行时类型来决定。 </p>\n<p><strong>如何理解“Dispatch”呢?</strong> 在面向对象编程语言中，可以把方法调用理解为一种消息传递，也就是“Dispatch”。一个对象调用另一个对象的方法，就相当于给它发送一条消息，这条消息起码要包含对象名、方法名、方法参数。</p>\n<p><strong>如何理解“Single”“Double”这两个单词呢？</strong> 这两个单词指的是执行哪个对象的哪个方法，跟几个因素的运行时类型有关。Single Dispatch之所以称为“Single”是因为执行哪个对象的哪个方法，只跟“对象”的运行时类型有关。Double Dispatch是因为跟执行哪个对象的哪个方法，跟“对象”和“方法参数”两者的运行时类型有关。</p>\n<p>具体到编程语言的语法机制，Single Dispatch 和 Double Dispatch 跟多态和函数重载直接相关。当前主流的面向对象编程语言（比如，Java、C++、C#）都只支持 Single Dispatch，不支持 Double Dispatch。</p>\n<p>拿Java语言举例说明下。</p>\n<p>Java 支持多态特性，代码可以在运行时获得对象的实际类型（也就是前面提到的运行时类型），然后根据实际类型决定调用哪个方法。尽管 Java 支持函数重载，但 Java 设计的函数重载的语法规则是，并不是在运行时，根据传递进函数的参数的实际类型，来决定调用哪个重载函数，而是在编译时，根据传递进函数的参数的声明类型（也就是前面提到的编译时类型），来决定调用哪个重载函数。也就是说，具体执行哪个对象的哪个方法，只跟对象的运行时类型有关，跟参数的运行时类型无关。所以，Java 语言只支持 Single Dispatch。</p>\n<p>假设Java语言支持Double Dispatch，那么前面说的37行报错就不会报错了。代码会在运行时，根据参数（resourceFile）的实际类型（PdfFile、PPTFile、WordFile），来决定使用extract2txt的三个重载函数中的哪一个。所以也就不需要访问者模式了。</p>\n<h5 id=\"除了访问者模式，刚才的例子还有其他实现方案么？\"><a href=\"#除了访问者模式，刚才的例子还有其他实现方案么？\" class=\"headerlink\" title=\"除了访问者模式，刚才的例子还有其他实现方案么？\"></a>除了访问者模式，刚才的例子还有其他实现方案么？</h5><p>还可以利用工厂模式来实现，定义一个包含extract2txt()接口函数的Extractor接口。PdfExtractor、PPTExtractor、WordExtractor 类实现 Extractor 接口，并且在各自的 extract2txt() 函数中，分别实现 Pdf、PPT、Word 格式文件的文本内容抽取。ExtractorFactory 工厂类根据不同的文件类型，返回不同的 Extractor。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ResourceFile</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">protected</span> String filePath;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ResourceFile</span><span class=\"params\">(String filePath)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.filePath = filePath;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> ResourceFileType <span class=\"title\">getType</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PdfFile</span> <span class=\"keyword\">extends</span> <span class=\"title\">ResourceFile</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">PdfFile</span><span class=\"params\">(String filePath)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(filePath);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> ResourceFileType <span class=\"title\">getType</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ResourceFileType.PDF;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//...PPTFile/WordFile跟PdfFile代码结构类似，此处省略...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Extractor</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">extract2txt</span><span class=\"params\">(ResourceFile resourceFile)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PdfExtractor</span> <span class=\"keyword\">implements</span> <span class=\"title\">Extractor</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">extract2txt</span><span class=\"params\">(ResourceFile resourceFile)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//...PPTExtractor/WordExtractor跟PdfExtractor代码结构类似，此处省略...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExtractorFactory</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Map&lt;ResourceFileType, Extractor&gt; extractors = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">  <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">    extractors.put(ResourceFileType.PDF, <span class=\"keyword\">new</span> PdfExtractor());</span><br><span class=\"line\">    extractors.put(ResourceFileType.PPT, <span class=\"keyword\">new</span> PPTExtractor());</span><br><span class=\"line\">    extractors.put(ResourceFileType.WORD, <span class=\"keyword\">new</span> WordExtractor());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Extractor <span class=\"title\">getExtractor</span><span class=\"params\">(ResourceFileType type)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> extractors.get(type);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ToolApplication</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    List&lt;ResourceFile&gt; resourceFiles = listAllResourceFiles(args[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (ResourceFile resourceFile : resourceFiles) &#123;</span><br><span class=\"line\">      Extractor extractor = ExtractorFactory.getExtractor(resourceFile.getType());</span><br><span class=\"line\">      extractor.extract2txt(resourceFile);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> List&lt;ResourceFile&gt; <span class=\"title\">listAllResourceFiles</span><span class=\"params\">(String resourceDirectory)</span> </span>&#123;</span><br><span class=\"line\">    List&lt;ResourceFile&gt; resourceFiles = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    <span class=\"comment\">//...根据后缀(pdf/ppt/word)由工厂方法创建不同的类对象(PdfFile/PPTFile/WordFile)</span></span><br><span class=\"line\">    resourceFiles.add(<span class=\"keyword\">new</span> PdfFile(<span class=\"string\">&quot;a.pdf&quot;</span>));</span><br><span class=\"line\">    resourceFiles.add(<span class=\"keyword\">new</span> WordFile(<span class=\"string\">&quot;b.word&quot;</span>));</span><br><span class=\"line\">    resourceFiles.add(<span class=\"keyword\">new</span> PPTFile(<span class=\"string\">&quot;c.ppt&quot;</span>));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> resourceFiles;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当添加新的功能的时候，比如压缩文件，类似抽取文本内容功能的代码实现，只需要添加一个Compressor接口，PdfCompressor、PPTCompressor、WordCompressor 三个实现类，以及创建它们的 CompressorFactory 工厂类即可。唯一修改的就是最上层的ToolApplication类。基本符合“对扩展开放、对修改关闭”的设计原则。</p>\n<p>对于资源文件处理工具的例子，如果工具提供的功能并不多，是有几个而已，那更推荐工厂模式的实现方式，毕竟代码清晰、易懂。相反，如果工具提供非常多的功能，十几个，那更推荐访问者模式，因为访问者模式需要定义的类比工厂模式的实现方式少很多，类太多也会影响到代码的可维护性。</p>\n"},{"layout":"post","title":"设计模式之迭代器模式","description":"设计模式之迭代器模式","date":"2021-06-09T05:26:10.000Z","_content":"迭代器模式，用来遍历集合对象。很多编程语言都将迭代器作为一个基础的类库，直接提供出来了。在平时的开发中，我们直接使用即可， 很少去实现一个迭代器。不过知其然知其所以然，弄懂原理能帮助我们更好的使用这些工具类。\n\n迭代器模式（Iterator Design Pattern），也叫作游标模式。\n\n一开始说说到，它用来遍历集合对象。这里的“集合对象”也可以叫“容器”“聚合对象”，实际上就是包含一组对象的对象，比如数组、链表、树、图、跳表。迭代器模式将集合对象的遍历操作从集合类中拆分出来，放到迭代器类中，让两者的职责更加单一。\n\n迭代器是用来遍历容器的，所以，一个完整的迭代器模式一般会涉及容器和容器迭代器两部分。为了达到基于接口而非实现编程的目的，容器又包含容器接口、容器实现类，迭代器又包含迭代器接口、迭代器实现类。\n\n线性数据结构包括数组和链表，在大部分编程语言中都有对应的类来封装这两种数据结构，在开发中直接拿来用就可以了。假设在这种新的编程语言中，这两个数据结构分别对应ArrayList和LinkedList两个类。除此之外，我们从两个类中抽象出公共的接口，定义为List接口，以方便开发者基于接口而非实现编程，编写的代码能在两种数据存储结构之间灵活切换。\n\n现在，针对ArrayList和LinkedList两个线性容器，设计实现对应的迭代器。定义一个迭代器接口Iterator，以及针对两种容器的具体的迭代器实现类ArrayIterator和ListIterator。\n\nIterator接口的定义代码如下：\n\n```java\n//接口定义方式一\npublic interface Iterator<E> {\n  boolean hasNext();\n  void next();\n  E currentItem();\n}\n\n//接口定义方式二\npublic interface Iterator<E> {\n  boolean hasNext();\n  E next();\n}\n```\n\nIterator接口有两种定义方式。\n\n第一种定义中，next()函数用来将游标后移一位元素，currentItem()函数用来返回当前游标指向的元素。在第二种定义中，返回当前元素于后移一位这两个操作，要放到同一个函数next()中完成。\n\n第一种定义方式更加灵活，可以多次调用currentItem()查询当前元素，而不移动游标。\n\n再来看下ArrayIterator的代码实现。\n\n```java\npublic class ArrayIterator<E> implements Iterator<E> {\n  private int cursor;\n  private ArrayList<E> arrayList;\n  \n  public ArrayIterator(ArrayList<E> arrayList) {\n    this.cursor = 0;\n    this.arrayList = arrayList;\n  }\n  \n  @Override\n  public boolean hasNext() {\n    return cursor != arrayList.size(); //注意这里，cursor在指向最后一个元素的时候，hasNext()仍返回true\n  }\n  \n  @Override\n  public void next() {\n    cursor++;\n  }\n  \n  @Override\n  public E currentItem() {\n    if(cursor >= arrayList.size()) {\n      throw new NoSuchElementException();\n    }\n    return arrayList.get(cursor);\n  }\n}\n\npublic class Demo {\n  public static void main(String[] args) {\n    ArrayList<String> names = new ArrayList<>();\n    names.add(\"xzg\"); \n    names.add(\"wang\"); \n    names.add(\"zheng\");\n    \n    Iterator<String> iterator = new ArrayIterator(names);\n    while(iterator.hasNext()) {\n      System.out.println(iterator.currentItem());\n      iterator.next();\n    }\n  }\n}\n```\n\n上面的实现中，需要将待遍历的容器对象，通过构造函数传递给迭代器类。实际上，为了封装迭代器的创建细节，可以在容器中定义一个iterator()方法，来创建对应的迭代器。为了能实现基于接口而非实现编程，我们还需要将这个方法定义在List接口中。具体的代码实现和使用示例如下：\n\n```java\npublic interface List<E> {\n  Iterator iterator();\n  //...省略其他接口函数...\n}\n\npublic class ArrayList<E> implements List<E> {\n  //...\n  public Iterator iterator() {\n    return new ArrayIterator(this);\n  }\n  //..省略其他代码\n}\n\npublic class Demo {\n  public static void main(String[] args) {\n    ArrayList<String> names = new ArrayList<>();\n    names.add(\"xzg\"); \n    names.add(\"wang\"); \n    names.add(\"zheng\");\n    \n    Iterator<String> iterator = names.iterator();\n    while(iterator.hasNext()) {\n      System.out.println(iterator.currentItem());\n      iterator.next();\n    }\n  }\n}\n```\n\n迭代器中需要定义hasNext()、currentItem()、next()三个最基本的方法。待遍历的容器对象通过依赖注入传递到迭代器类中。容器通过iterator()方法来创建迭代器。\n\n类图如下：\n\n![img](https://static001.geekbang.org/resource/image/b6/30/b685b61448aaa638b03b5bf3d9d93330.jpg)\n\n迭代器模式的优势\n\n一般来讲，遍历集合数据有三种方法：for循环、foreach循环、iterator迭代器。\n\n```java\n\nList<String> names = new ArrayList<>();\nnames.add(\"xzg\");\nnames.add(\"wang\");\nnames.add(\"zheng\");\n\n// 第一种遍历方式：for循环\nfor (int i = 0; i < names.size(); i++) {\n  System.out.print(names.get(i) + \",\");\n}\n\n// 第二种遍历方式：foreach循环\nfor (String name : names) {\n  System.out.print(name + \",\")\n}\n\n// 第三种遍历方式：迭代器遍历\nIterator<String> iterator = names.iterator();\nwhile (iterator.hasNext()) {\n  System.out.print(iterator.next() + \",\");//Java中的迭代器接口是第二种定义方式，next()既移动游标又返回数据\n}\n```\n\n实际上，foreach循环只是一个语法糖而已，底层是基于迭代器来实现的。第二种和第三种遍历方式可以看作同一种遍历方式，也就是迭代器遍历方式。\n\n从上面的代码看，for循环遍历方式比起迭代器遍历方式，代码看起来更简洁。那为什么还要用迭代器来遍历容器呢？为什么还要给容器设计对应的迭代器呢？原因有以下三个。\n\n首先，对于类似数组和链表这样的数据结构，遍历方式比较简单，直接使用for循环来遍历就足够了。但是对于复杂的数据结构（比如树、图）来说，有各种复杂的遍历方式。比如，树有前中后序、按层遍历，图有深度优先、广度优先遍历等等。如果由客户端代码来实现这些遍历算法，势必增加开发成本，并且容易写错。如果将这部分遍历的逻辑写到容器类中，也会增加容器类代码的复杂性。\n\n应对复杂性的方法就是拆分。可以将遍历操作拆分到迭代器类中。比如，针对图的遍历，就可以定义DFSIterator、BFSIt erator两个迭代器类，让它们分别来实现深度优先和广度优先遍历。\n\n其次，将游标指向的当前位置等信息，存储在迭代器类中，每个迭代器独享游标信息。这样，就可以创建多个不同的迭代器，同时对同一个容器进行遍历而互不影响。\n\n最后，容器和迭代器都提供了抽象的接口，方便我们在开发的时候，基于接口而非具体的实现编程。当需要切换新的遍历算法的时候，比如，从前往后遍历链表切换成丛后往前遍历链表，客户端代码只需要将迭代器类从LinkedIterator切换为ReversedLinkedIterator即可，其他代码都不需要修改。除此之外，添加新的遍历算法，只需要扩展新的迭代器类，也更符合开闭原则。\n\n总结下，相对于for循环遍历，迭代器遍历由三个优势：\n\n- 迭代器模式封装集合内部的复杂数据结构，开发者不需要了解如何遍历，直接使用容器提供的迭代器即可。\n- 迭代器模式将集合对象的遍历操作从集合类中拆分出来，放到迭代器类中，让两者的职责更加单一。\n- 迭代器模式让添加新的遍历算法更加容易，更符合开闭原则。除此之外，因为迭代器都实现自相同的接口，在开发中，基于接口而非实现编程，替换迭代器也变得更加容易。\n\n##### 在遍历的同时删除集合元素会发生什么\n\n在通过迭代器来遍历集合元素的同时，增加或者删除集合中的元素，有可能会导致某个元素被重复遍历或遍历不到。不过，并不是所有情况下都会遍历出错，有的时候也可以正常遍历，所以，这种行为称为结果不可预期行为或者未决行为，也就是说，运行结果到底是对还是错，要视情况而定。\n\n还是ArrayList迭代器的例子。\n\n```java\npublic interface Iterator<E> {\n  boolean hasNext();\n  void next();\n  E currentItem();\n}\n\npublic class ArrayIterator<E> implements Iterator<E> {\n  private int cursor;\n  private ArrayList<E> arrayList;\n\n  public ArrayIterator(ArrayList<E> arrayList) {\n    this.cursor = 0;\n    this.arrayList = arrayList;\n  }\n\n  @Override\n  public boolean hasNext() {\n    return cursor < arrayList.size();\n  }\n\n  @Override\n  public void next() {\n    cursor++;\n  }\n\n  @Override\n  public E currentItem() {\n    if (cursor >= arrayList.size()) {\n      throw new NoSuchElementException();\n    }\n    return arrayList.get(cursor);\n  }\n}\n\npublic interface List<E> {\n  Iterator iterator();\n}\n\npublic class ArrayList<E> implements List<E> {\n  //...\n  public Iterator iterator() {\n    return new ArrayIterator(this);\n  }\n  //...\n}\n\npublic class Demo {\n  public static void main(String[] args) {\n    List<String> names = new ArrayList<>();\n    names.add(\"a\");\n    names.add(\"b\");\n    names.add(\"c\");\n    names.add(\"d\");\n\n    Iterator<String> iterator = names.iterator();\n    iterator.next();\n    names.remove(\"a\");\n  }\n}\n```\n\nArrayList底层对应的是数组这种数据结构，在执行完第55行代码的时候，数组中存储的是abcd四个元素，迭代器的游标cursor指向元素a。当执行完第56行代码的时候，游标指向元素b，到这里都没有问题。\n\n为了保持数组存储数据的连续性，数组的删除操作会涉及元素的搬移。当执行到57行的时候，从数组中将元素a删除，bcd三个元素会依次往前搬移一位，这就导致游标本来指向元素b，现在变成了元素c。原本在执行完第56行代码之后，我们还可以遍历到bcd三个元素，但在执行完第57行代码之后，我们只能遍历到cd两个元素，b遍历不到了。\n\n不过，如果第57行删除的不是游标前面的元素以及游标所在位置的元素，而是游标后面的元素，就不会存在这样的问题了，不会存在某个元素遍历不到的情况了。\n\n所以，在遍历的过程中删除集合元素，结果是不可预期的，有时候没问题，有时候就有问题，要视情况而定。\n\n在遍历的过程中删除集合元素，可能会导致某个元素遍历不到，在遍历的过程中添加集合元素，会发生什么呢？还是刚才的例子，稍微改下代码。\n\n```java\npublic class Demo {\n  public static void main(String[] args) {\n    List<String> names = new ArrayList<>();\n    names.add(\"a\");\n    names.add(\"b\");\n    names.add(\"c\");\n    names.add(\"d\");\n\n    Iterator<String> iterator = names.iterator();\n    iterator.next();\n    names.add(0, \"x\");\n  }\n}\n```\n\n在执行完第10行代码之后，数组中包含abcd四个元素，游标指向b元素，已经跳过了元素a。在执行完第11行代码后，将x插入到下标为0的位置，abcd依次后移一位。这个时候，游标又重新指向了元素a。元素a被游标重复指向两次，也就是说，元素a存在被重复遍历的情况。\n\n和删除情况类似，如果在游标后面添加元素，就不会存在问题。所以，遍历的时候添加元素也是一种不可预期的行为。\n\n如何应对遍历时改变集合导致的未决行为\n\n有两种方式：一种是遍历的时候不允许增删元素，另一种是增删元素之后让遍历报错。\n\n实际上，第一种实现方式比较难实现，需要确定遍历开始和结束的时间点。遍历开始的时间点比较好获得，可以把创建迭代器的时间点作为遍历开始的时间点。但是，遍历结束的时间点如何来确定呢？\n\n是遍历到最后一个元素的时候算结束么\u0010？那么如果只要找到一个值为b的元素就结束遍历，又没办法确定结束的时间点了。如果在迭代器中定义一个新的接口，通过那个接口主动告知容器迭代器用完了，可以删除元素了。但是这样的话，就需要程序员在使用完迭代器之后要主动调用这个函数，增加了开发成本，而且还很容易漏掉。\n\n实际上，第二种解决方法更加合理。Java就采用这种方案，增删元素之后，让遍历报错。\n\n怎么确定在遍历的时候，集合有没有增删元素呢？在ArrayList中定义一个成员变量modCount，记录集合被修改的次数，集合每调用一次增加或者删除元素的函数，就会给modCount加1。当调用集合上的iterator()函数来创建迭代器的时候，我们把modCount值传递给迭代器的exceptedModCount成员变量，之后每次调用迭代器上的hasNext()、next()、currentItem()函数，都会检查集合上的modCount是否等于expectedModCount，也就是看，在创建完迭代器之后，modCount是否改变过。\n\n如果两个值不同，那就说明集合存储的元素已经改变了，之前创建的迭代器已经不能正确运行了，再继续使用就会产生不可预期的结果，所以选择fail-fast解决方式，抛出运行时异常，结束掉程序，让程序员修复这个因为不正确使用迭代器而产生的bug。\n\n上面的描述翻译成代码就是下面的样子。\n\n```java\npublic class ArrayIterator implements Iterator {\n  private int cursor;\n  private ArrayList arrayList;\n  private int expectedModCount;\n  \n  public ArrayIterator(ArrayList arrayList) {\n    this.cursor = 0;\n    this.arrayList = arrayList;\n    this.expectedModCount = arrayList.modCount;\n  }\n  \n  @Override\n  public boolean hasNext() {\n    checkForComodification();\n    return cursor < arrayList.size();\n  }\n  \n  @Override\n  public void next() {\n    checkForComodification();\n    cursor++;\n  }\n  \n  @Override\n  public Object currentItem() {\n    checkForComodification();\n    return arrayList.get(cursor);\n  }\n  \n  private void checkForComodification() {\n    if(arrayList.modCount != expectedModCount)\n      throw new ConcurrentModificationException();\n  }\n}\n```\n\n##### 如何在遍历的同时安全地删除集合元素？\n\n像Java语言，迭代器类中除了前面提到的几个最基本的方法之外，还定义了一个remove()方法，能够在遍历集合的同时，安全地删除集合中的元素。不过，它并没有提供添加元素的方法。毕竟迭代器的主要作用是遍历，添加元素放到迭代器里本身就不合适。\n\nJava迭代器提供的remove()方法还是有局限的。它只能删除游标指向的前一个元素，而且一个next()函数之后，只能跟着最多一个remove()操作，多次调用remove()操作回报错。\n\n```java\n\npublic class Demo {\n  public static void main(String[] args) {\n    List<String> names = new ArrayList<>();\n    names.add(\"a\");\n    names.add(\"b\");\n    names.add(\"c\");\n    names.add(\"d\");\n\n    Iterator<String> iterator = names.iterator();\n    iterator.next();\n    iterator.remove();\n    iterator.remove(); //报错，抛出IllegalStateException异常\n  }\n}\n```\n\n迭代器为什么可以安全的删除集合中的元素呢？源码之下无秘密。看下remove()函数如何实现的。在Java实现中，迭代器类是容器类的内部类，并且next()函数不仅将游标后移一位，还会返回当前的元素。\n\n```java\npublic class ArrayList<E> {\n  transient Object[] elementData;\n  private int size;\n  \n  public Iterator<E> iterator() {\n    return new Itr();\n  }\n  \n  private class Itr implements Iterator<E> {\n    int cursor; //index of next element to return \n    int lastRet = -1; //index of last element returned; -1 if no such\n    int expectedModCount = modCount;\n    \n    Itr() {}\n    \n    public boolean hasNext() {\n      return cursor != size;\n    }\n    \n    @SupperessWarnings(\"unchecked\")\n    public E next() {\n      checkForComodification();\n      int i = cursor;\n      if (i >= size) \n        throw new NoSuchElementException();\n      Object[] elementData = ArrayList.this.elementData;\n      if(i >= elementData.length)\n        throw new ConcurrentModificationException();\n      cursor = i + 1;\n      return (E) elementData[lastRet = i];\n    }\n    \n    public void remove() {\n      if (lastRet < 0) \n        throw new IllegalStateException();\n      checkForComodification();\n      \n      try {\n        ArrayList.this.remove(lastRet);\n        cursor = lastRet;\n        lastRet = -1;\n        expectedModCount = modCount;\n      } catch (IndexOutOfBoundsException ex) {\n        throw new ConcurrentModificationException();\n      }\n    }\n  }\n}\n```\n\n上面的代码实现中，迭代器类新增了一个lastRet成员变量，用来记录游标指向的前一个元素。通过迭代器去删除这个元素的时候，我们可以更新迭代器中的游标和lastRet值，来保证不会因为删除元素而导致某个元素遍历不到。如果通过容器来删除元素，并且希望更新迭代器中的游标值来保证遍历不出错，我们就要维护这个容器都创建了哪些迭代器，没个迭代器是否还在使用等信息，代码实现就变得比较复杂了。\n\n“不可预期”比直接出错更可怕，有的时候运行正确，有的时候运行错误，一些隐藏很深、很难debug的bug就是这么产生的。\n\n如何实现一个支持“快照”功能的迭代器？这个问题是为了加深对迭代器模式的理解，也是对分析、解决问题的一种锻炼。\n\n所谓“快照”，指我们为容器创建迭代器的时候，相当于给容器拍了一张快照（Snapshot）。之后即便增加容器中的元素，快照中的元素并不会做相应的改动。而迭代器遍历的对象是快照而非容器，这样就避免了在使用迭代器遍历的过程中，增删容器中的元素，导致的不可预期的结果或者报错。\n\n```java\nList<Integer> list = new ArrayList<>();\nlist.add(3);\nlist.add(8);\nlist.add(2);\n\nIterator<Integer> iter1 = list.iterator();//snapshot: 3, 8, 2\nlist.remove(new Integer(2));//list：3, 8\nIterator<Integer> iter2 = list.iterator();//snapshot: 3, 8\nlist.remove(new Integer(3));//list：8\nIterator<Integer> iter3 = list.iterator();//snapshot: 3\n\n// 输出结果：3 8 2\nwhile (iter1.hasNext()) {\n  System.out.print(iter1.next() + \" \");\n}\nSystem.out.println();\n\n// 输出结果：3 8\nwhile (iter2.hasNext()) {\n  System.out.print(iter1.next() + \" \");\n}\nSystem.out.println();\n\n// 输出结果：8\nwhile (iter3.hasNext()) {\n  System.out.print(iter1.next() + \" \");\n}\nSystem.out.println();\n```\n\n如果要你来实现上面的功能，你会如何做呢？下面是一份骨架代码。\n\n```java\npublic ArrayList<E> implements List<E> {\n  // TODO: 成员变量、私有函数等随便你定义\n  \n  @Override\n  public void add(E obj) {\n    //TODO: 由你来完善\n  }\n  \n  @Override\n  public void remove(E obj) {\n    // TODO: 由你来完善\n  }\n  \n  @Override\n  public Iterator<E> iterator() {\n    return new SnapshotArrayIterator(this);\n  }\n}\n\npublic class SnapshotArrayIterator<E> implements Iterator<E> {\n  // TODO: 成员变量、私有函数等随便你定义\n  \n  @Override\n  public boolean hasNext() {\n    // TODO: 由你来完善\n  }\n  \n  @Override\n  public E next() {//返回当前元素，并且游标后移一位\n    // TODO: 由你来完善\n  }\n}\n```\n\n解决方案一\n\n在迭代器类中定义一个成员变量snapshot来存储快照，每当创建迭代器的时候，都拷贝一份容器中的元素到快照中，后续的遍历操作都基于这个迭代器自己持有的快照来进行。\n\n这个解决方案虽然简单，但是每次创建迭代器的时候，都要拷贝一份数据到快照中，会增加内存的消耗。不过，Java中的拷贝属于浅拷贝，容器中的对象并非真的拷贝了多份，而只是拷贝了对象的引用而已。\n\n解决方案二\n\n可以在容器中，为每个元素保存两个时间戳，一个是添加时间，一个是删除时间，当元素被添加到集合中时，将当前时间赋值给添加时间，将删除时间设置成最大长整型。当元素被删除时，将删除时间更新为当前时间，表示已经删除。这是一种标记删除，并不是真正的从容器中删除。\n\n同时，每个迭代器也保存一个迭代器创建时间戳，也就是迭代器对应的快照的创建时间戳。当使用迭代器遍历的时候，只有满足添加时间 < 快照时间 < 删除时间的元素，才是属于这个迭代器的快照。\n\n如果元素的添加时间大于快照时间，说明元素在创建了迭代器之后才加入的，不属于这个迭代器的快照；如果元素的删除时间小于快照时间，说明元素在创建迭代器之前就被删除了，也不属于这个迭代器的快照。\n\n但是这种方案又引入了另外一个问题，ArrayList底层依赖数组这种数据结构，原本可以支持快速的随机访问，在O(1)时间复杂度内获取下标为i的元素，但现在删除并非真正的删除，只是通过时间戳来标记删除，这就导致无法支持按照下标快速随机访问了。\n\n如何解决让容器既支持快照遍历，又支持随机访问？\n\n在ArrayList中存储两个数组，一个支持标记删除，用来实现快照遍历功能。一个不支持标记删除，用来支持随机访问。\n\n只掌握了知识，没锻炼能力，遇到实际的问题还是没法自己去分析、思考、解决。\n","source":"_posts/设计模式之迭代器模式.md","raw":"---\nlayout:    post\ntitle:     设计模式之迭代器模式\ncategory:  设计模式之美\ndescription: 设计模式之迭代器模式\ntags: 设计模式之美\ndate: 2021/06/09 13:26:10\n---\n迭代器模式，用来遍历集合对象。很多编程语言都将迭代器作为一个基础的类库，直接提供出来了。在平时的开发中，我们直接使用即可， 很少去实现一个迭代器。不过知其然知其所以然，弄懂原理能帮助我们更好的使用这些工具类。\n\n迭代器模式（Iterator Design Pattern），也叫作游标模式。\n\n一开始说说到，它用来遍历集合对象。这里的“集合对象”也可以叫“容器”“聚合对象”，实际上就是包含一组对象的对象，比如数组、链表、树、图、跳表。迭代器模式将集合对象的遍历操作从集合类中拆分出来，放到迭代器类中，让两者的职责更加单一。\n\n迭代器是用来遍历容器的，所以，一个完整的迭代器模式一般会涉及容器和容器迭代器两部分。为了达到基于接口而非实现编程的目的，容器又包含容器接口、容器实现类，迭代器又包含迭代器接口、迭代器实现类。\n\n线性数据结构包括数组和链表，在大部分编程语言中都有对应的类来封装这两种数据结构，在开发中直接拿来用就可以了。假设在这种新的编程语言中，这两个数据结构分别对应ArrayList和LinkedList两个类。除此之外，我们从两个类中抽象出公共的接口，定义为List接口，以方便开发者基于接口而非实现编程，编写的代码能在两种数据存储结构之间灵活切换。\n\n现在，针对ArrayList和LinkedList两个线性容器，设计实现对应的迭代器。定义一个迭代器接口Iterator，以及针对两种容器的具体的迭代器实现类ArrayIterator和ListIterator。\n\nIterator接口的定义代码如下：\n\n```java\n//接口定义方式一\npublic interface Iterator<E> {\n  boolean hasNext();\n  void next();\n  E currentItem();\n}\n\n//接口定义方式二\npublic interface Iterator<E> {\n  boolean hasNext();\n  E next();\n}\n```\n\nIterator接口有两种定义方式。\n\n第一种定义中，next()函数用来将游标后移一位元素，currentItem()函数用来返回当前游标指向的元素。在第二种定义中，返回当前元素于后移一位这两个操作，要放到同一个函数next()中完成。\n\n第一种定义方式更加灵活，可以多次调用currentItem()查询当前元素，而不移动游标。\n\n再来看下ArrayIterator的代码实现。\n\n```java\npublic class ArrayIterator<E> implements Iterator<E> {\n  private int cursor;\n  private ArrayList<E> arrayList;\n  \n  public ArrayIterator(ArrayList<E> arrayList) {\n    this.cursor = 0;\n    this.arrayList = arrayList;\n  }\n  \n  @Override\n  public boolean hasNext() {\n    return cursor != arrayList.size(); //注意这里，cursor在指向最后一个元素的时候，hasNext()仍返回true\n  }\n  \n  @Override\n  public void next() {\n    cursor++;\n  }\n  \n  @Override\n  public E currentItem() {\n    if(cursor >= arrayList.size()) {\n      throw new NoSuchElementException();\n    }\n    return arrayList.get(cursor);\n  }\n}\n\npublic class Demo {\n  public static void main(String[] args) {\n    ArrayList<String> names = new ArrayList<>();\n    names.add(\"xzg\"); \n    names.add(\"wang\"); \n    names.add(\"zheng\");\n    \n    Iterator<String> iterator = new ArrayIterator(names);\n    while(iterator.hasNext()) {\n      System.out.println(iterator.currentItem());\n      iterator.next();\n    }\n  }\n}\n```\n\n上面的实现中，需要将待遍历的容器对象，通过构造函数传递给迭代器类。实际上，为了封装迭代器的创建细节，可以在容器中定义一个iterator()方法，来创建对应的迭代器。为了能实现基于接口而非实现编程，我们还需要将这个方法定义在List接口中。具体的代码实现和使用示例如下：\n\n```java\npublic interface List<E> {\n  Iterator iterator();\n  //...省略其他接口函数...\n}\n\npublic class ArrayList<E> implements List<E> {\n  //...\n  public Iterator iterator() {\n    return new ArrayIterator(this);\n  }\n  //..省略其他代码\n}\n\npublic class Demo {\n  public static void main(String[] args) {\n    ArrayList<String> names = new ArrayList<>();\n    names.add(\"xzg\"); \n    names.add(\"wang\"); \n    names.add(\"zheng\");\n    \n    Iterator<String> iterator = names.iterator();\n    while(iterator.hasNext()) {\n      System.out.println(iterator.currentItem());\n      iterator.next();\n    }\n  }\n}\n```\n\n迭代器中需要定义hasNext()、currentItem()、next()三个最基本的方法。待遍历的容器对象通过依赖注入传递到迭代器类中。容器通过iterator()方法来创建迭代器。\n\n类图如下：\n\n![img](https://static001.geekbang.org/resource/image/b6/30/b685b61448aaa638b03b5bf3d9d93330.jpg)\n\n迭代器模式的优势\n\n一般来讲，遍历集合数据有三种方法：for循环、foreach循环、iterator迭代器。\n\n```java\n\nList<String> names = new ArrayList<>();\nnames.add(\"xzg\");\nnames.add(\"wang\");\nnames.add(\"zheng\");\n\n// 第一种遍历方式：for循环\nfor (int i = 0; i < names.size(); i++) {\n  System.out.print(names.get(i) + \",\");\n}\n\n// 第二种遍历方式：foreach循环\nfor (String name : names) {\n  System.out.print(name + \",\")\n}\n\n// 第三种遍历方式：迭代器遍历\nIterator<String> iterator = names.iterator();\nwhile (iterator.hasNext()) {\n  System.out.print(iterator.next() + \",\");//Java中的迭代器接口是第二种定义方式，next()既移动游标又返回数据\n}\n```\n\n实际上，foreach循环只是一个语法糖而已，底层是基于迭代器来实现的。第二种和第三种遍历方式可以看作同一种遍历方式，也就是迭代器遍历方式。\n\n从上面的代码看，for循环遍历方式比起迭代器遍历方式，代码看起来更简洁。那为什么还要用迭代器来遍历容器呢？为什么还要给容器设计对应的迭代器呢？原因有以下三个。\n\n首先，对于类似数组和链表这样的数据结构，遍历方式比较简单，直接使用for循环来遍历就足够了。但是对于复杂的数据结构（比如树、图）来说，有各种复杂的遍历方式。比如，树有前中后序、按层遍历，图有深度优先、广度优先遍历等等。如果由客户端代码来实现这些遍历算法，势必增加开发成本，并且容易写错。如果将这部分遍历的逻辑写到容器类中，也会增加容器类代码的复杂性。\n\n应对复杂性的方法就是拆分。可以将遍历操作拆分到迭代器类中。比如，针对图的遍历，就可以定义DFSIterator、BFSIt erator两个迭代器类，让它们分别来实现深度优先和广度优先遍历。\n\n其次，将游标指向的当前位置等信息，存储在迭代器类中，每个迭代器独享游标信息。这样，就可以创建多个不同的迭代器，同时对同一个容器进行遍历而互不影响。\n\n最后，容器和迭代器都提供了抽象的接口，方便我们在开发的时候，基于接口而非具体的实现编程。当需要切换新的遍历算法的时候，比如，从前往后遍历链表切换成丛后往前遍历链表，客户端代码只需要将迭代器类从LinkedIterator切换为ReversedLinkedIterator即可，其他代码都不需要修改。除此之外，添加新的遍历算法，只需要扩展新的迭代器类，也更符合开闭原则。\n\n总结下，相对于for循环遍历，迭代器遍历由三个优势：\n\n- 迭代器模式封装集合内部的复杂数据结构，开发者不需要了解如何遍历，直接使用容器提供的迭代器即可。\n- 迭代器模式将集合对象的遍历操作从集合类中拆分出来，放到迭代器类中，让两者的职责更加单一。\n- 迭代器模式让添加新的遍历算法更加容易，更符合开闭原则。除此之外，因为迭代器都实现自相同的接口，在开发中，基于接口而非实现编程，替换迭代器也变得更加容易。\n\n##### 在遍历的同时删除集合元素会发生什么\n\n在通过迭代器来遍历集合元素的同时，增加或者删除集合中的元素，有可能会导致某个元素被重复遍历或遍历不到。不过，并不是所有情况下都会遍历出错，有的时候也可以正常遍历，所以，这种行为称为结果不可预期行为或者未决行为，也就是说，运行结果到底是对还是错，要视情况而定。\n\n还是ArrayList迭代器的例子。\n\n```java\npublic interface Iterator<E> {\n  boolean hasNext();\n  void next();\n  E currentItem();\n}\n\npublic class ArrayIterator<E> implements Iterator<E> {\n  private int cursor;\n  private ArrayList<E> arrayList;\n\n  public ArrayIterator(ArrayList<E> arrayList) {\n    this.cursor = 0;\n    this.arrayList = arrayList;\n  }\n\n  @Override\n  public boolean hasNext() {\n    return cursor < arrayList.size();\n  }\n\n  @Override\n  public void next() {\n    cursor++;\n  }\n\n  @Override\n  public E currentItem() {\n    if (cursor >= arrayList.size()) {\n      throw new NoSuchElementException();\n    }\n    return arrayList.get(cursor);\n  }\n}\n\npublic interface List<E> {\n  Iterator iterator();\n}\n\npublic class ArrayList<E> implements List<E> {\n  //...\n  public Iterator iterator() {\n    return new ArrayIterator(this);\n  }\n  //...\n}\n\npublic class Demo {\n  public static void main(String[] args) {\n    List<String> names = new ArrayList<>();\n    names.add(\"a\");\n    names.add(\"b\");\n    names.add(\"c\");\n    names.add(\"d\");\n\n    Iterator<String> iterator = names.iterator();\n    iterator.next();\n    names.remove(\"a\");\n  }\n}\n```\n\nArrayList底层对应的是数组这种数据结构，在执行完第55行代码的时候，数组中存储的是abcd四个元素，迭代器的游标cursor指向元素a。当执行完第56行代码的时候，游标指向元素b，到这里都没有问题。\n\n为了保持数组存储数据的连续性，数组的删除操作会涉及元素的搬移。当执行到57行的时候，从数组中将元素a删除，bcd三个元素会依次往前搬移一位，这就导致游标本来指向元素b，现在变成了元素c。原本在执行完第56行代码之后，我们还可以遍历到bcd三个元素，但在执行完第57行代码之后，我们只能遍历到cd两个元素，b遍历不到了。\n\n不过，如果第57行删除的不是游标前面的元素以及游标所在位置的元素，而是游标后面的元素，就不会存在这样的问题了，不会存在某个元素遍历不到的情况了。\n\n所以，在遍历的过程中删除集合元素，结果是不可预期的，有时候没问题，有时候就有问题，要视情况而定。\n\n在遍历的过程中删除集合元素，可能会导致某个元素遍历不到，在遍历的过程中添加集合元素，会发生什么呢？还是刚才的例子，稍微改下代码。\n\n```java\npublic class Demo {\n  public static void main(String[] args) {\n    List<String> names = new ArrayList<>();\n    names.add(\"a\");\n    names.add(\"b\");\n    names.add(\"c\");\n    names.add(\"d\");\n\n    Iterator<String> iterator = names.iterator();\n    iterator.next();\n    names.add(0, \"x\");\n  }\n}\n```\n\n在执行完第10行代码之后，数组中包含abcd四个元素，游标指向b元素，已经跳过了元素a。在执行完第11行代码后，将x插入到下标为0的位置，abcd依次后移一位。这个时候，游标又重新指向了元素a。元素a被游标重复指向两次，也就是说，元素a存在被重复遍历的情况。\n\n和删除情况类似，如果在游标后面添加元素，就不会存在问题。所以，遍历的时候添加元素也是一种不可预期的行为。\n\n如何应对遍历时改变集合导致的未决行为\n\n有两种方式：一种是遍历的时候不允许增删元素，另一种是增删元素之后让遍历报错。\n\n实际上，第一种实现方式比较难实现，需要确定遍历开始和结束的时间点。遍历开始的时间点比较好获得，可以把创建迭代器的时间点作为遍历开始的时间点。但是，遍历结束的时间点如何来确定呢？\n\n是遍历到最后一个元素的时候算结束么\u0010？那么如果只要找到一个值为b的元素就结束遍历，又没办法确定结束的时间点了。如果在迭代器中定义一个新的接口，通过那个接口主动告知容器迭代器用完了，可以删除元素了。但是这样的话，就需要程序员在使用完迭代器之后要主动调用这个函数，增加了开发成本，而且还很容易漏掉。\n\n实际上，第二种解决方法更加合理。Java就采用这种方案，增删元素之后，让遍历报错。\n\n怎么确定在遍历的时候，集合有没有增删元素呢？在ArrayList中定义一个成员变量modCount，记录集合被修改的次数，集合每调用一次增加或者删除元素的函数，就会给modCount加1。当调用集合上的iterator()函数来创建迭代器的时候，我们把modCount值传递给迭代器的exceptedModCount成员变量，之后每次调用迭代器上的hasNext()、next()、currentItem()函数，都会检查集合上的modCount是否等于expectedModCount，也就是看，在创建完迭代器之后，modCount是否改变过。\n\n如果两个值不同，那就说明集合存储的元素已经改变了，之前创建的迭代器已经不能正确运行了，再继续使用就会产生不可预期的结果，所以选择fail-fast解决方式，抛出运行时异常，结束掉程序，让程序员修复这个因为不正确使用迭代器而产生的bug。\n\n上面的描述翻译成代码就是下面的样子。\n\n```java\npublic class ArrayIterator implements Iterator {\n  private int cursor;\n  private ArrayList arrayList;\n  private int expectedModCount;\n  \n  public ArrayIterator(ArrayList arrayList) {\n    this.cursor = 0;\n    this.arrayList = arrayList;\n    this.expectedModCount = arrayList.modCount;\n  }\n  \n  @Override\n  public boolean hasNext() {\n    checkForComodification();\n    return cursor < arrayList.size();\n  }\n  \n  @Override\n  public void next() {\n    checkForComodification();\n    cursor++;\n  }\n  \n  @Override\n  public Object currentItem() {\n    checkForComodification();\n    return arrayList.get(cursor);\n  }\n  \n  private void checkForComodification() {\n    if(arrayList.modCount != expectedModCount)\n      throw new ConcurrentModificationException();\n  }\n}\n```\n\n##### 如何在遍历的同时安全地删除集合元素？\n\n像Java语言，迭代器类中除了前面提到的几个最基本的方法之外，还定义了一个remove()方法，能够在遍历集合的同时，安全地删除集合中的元素。不过，它并没有提供添加元素的方法。毕竟迭代器的主要作用是遍历，添加元素放到迭代器里本身就不合适。\n\nJava迭代器提供的remove()方法还是有局限的。它只能删除游标指向的前一个元素，而且一个next()函数之后，只能跟着最多一个remove()操作，多次调用remove()操作回报错。\n\n```java\n\npublic class Demo {\n  public static void main(String[] args) {\n    List<String> names = new ArrayList<>();\n    names.add(\"a\");\n    names.add(\"b\");\n    names.add(\"c\");\n    names.add(\"d\");\n\n    Iterator<String> iterator = names.iterator();\n    iterator.next();\n    iterator.remove();\n    iterator.remove(); //报错，抛出IllegalStateException异常\n  }\n}\n```\n\n迭代器为什么可以安全的删除集合中的元素呢？源码之下无秘密。看下remove()函数如何实现的。在Java实现中，迭代器类是容器类的内部类，并且next()函数不仅将游标后移一位，还会返回当前的元素。\n\n```java\npublic class ArrayList<E> {\n  transient Object[] elementData;\n  private int size;\n  \n  public Iterator<E> iterator() {\n    return new Itr();\n  }\n  \n  private class Itr implements Iterator<E> {\n    int cursor; //index of next element to return \n    int lastRet = -1; //index of last element returned; -1 if no such\n    int expectedModCount = modCount;\n    \n    Itr() {}\n    \n    public boolean hasNext() {\n      return cursor != size;\n    }\n    \n    @SupperessWarnings(\"unchecked\")\n    public E next() {\n      checkForComodification();\n      int i = cursor;\n      if (i >= size) \n        throw new NoSuchElementException();\n      Object[] elementData = ArrayList.this.elementData;\n      if(i >= elementData.length)\n        throw new ConcurrentModificationException();\n      cursor = i + 1;\n      return (E) elementData[lastRet = i];\n    }\n    \n    public void remove() {\n      if (lastRet < 0) \n        throw new IllegalStateException();\n      checkForComodification();\n      \n      try {\n        ArrayList.this.remove(lastRet);\n        cursor = lastRet;\n        lastRet = -1;\n        expectedModCount = modCount;\n      } catch (IndexOutOfBoundsException ex) {\n        throw new ConcurrentModificationException();\n      }\n    }\n  }\n}\n```\n\n上面的代码实现中，迭代器类新增了一个lastRet成员变量，用来记录游标指向的前一个元素。通过迭代器去删除这个元素的时候，我们可以更新迭代器中的游标和lastRet值，来保证不会因为删除元素而导致某个元素遍历不到。如果通过容器来删除元素，并且希望更新迭代器中的游标值来保证遍历不出错，我们就要维护这个容器都创建了哪些迭代器，没个迭代器是否还在使用等信息，代码实现就变得比较复杂了。\n\n“不可预期”比直接出错更可怕，有的时候运行正确，有的时候运行错误，一些隐藏很深、很难debug的bug就是这么产生的。\n\n如何实现一个支持“快照”功能的迭代器？这个问题是为了加深对迭代器模式的理解，也是对分析、解决问题的一种锻炼。\n\n所谓“快照”，指我们为容器创建迭代器的时候，相当于给容器拍了一张快照（Snapshot）。之后即便增加容器中的元素，快照中的元素并不会做相应的改动。而迭代器遍历的对象是快照而非容器，这样就避免了在使用迭代器遍历的过程中，增删容器中的元素，导致的不可预期的结果或者报错。\n\n```java\nList<Integer> list = new ArrayList<>();\nlist.add(3);\nlist.add(8);\nlist.add(2);\n\nIterator<Integer> iter1 = list.iterator();//snapshot: 3, 8, 2\nlist.remove(new Integer(2));//list：3, 8\nIterator<Integer> iter2 = list.iterator();//snapshot: 3, 8\nlist.remove(new Integer(3));//list：8\nIterator<Integer> iter3 = list.iterator();//snapshot: 3\n\n// 输出结果：3 8 2\nwhile (iter1.hasNext()) {\n  System.out.print(iter1.next() + \" \");\n}\nSystem.out.println();\n\n// 输出结果：3 8\nwhile (iter2.hasNext()) {\n  System.out.print(iter1.next() + \" \");\n}\nSystem.out.println();\n\n// 输出结果：8\nwhile (iter3.hasNext()) {\n  System.out.print(iter1.next() + \" \");\n}\nSystem.out.println();\n```\n\n如果要你来实现上面的功能，你会如何做呢？下面是一份骨架代码。\n\n```java\npublic ArrayList<E> implements List<E> {\n  // TODO: 成员变量、私有函数等随便你定义\n  \n  @Override\n  public void add(E obj) {\n    //TODO: 由你来完善\n  }\n  \n  @Override\n  public void remove(E obj) {\n    // TODO: 由你来完善\n  }\n  \n  @Override\n  public Iterator<E> iterator() {\n    return new SnapshotArrayIterator(this);\n  }\n}\n\npublic class SnapshotArrayIterator<E> implements Iterator<E> {\n  // TODO: 成员变量、私有函数等随便你定义\n  \n  @Override\n  public boolean hasNext() {\n    // TODO: 由你来完善\n  }\n  \n  @Override\n  public E next() {//返回当前元素，并且游标后移一位\n    // TODO: 由你来完善\n  }\n}\n```\n\n解决方案一\n\n在迭代器类中定义一个成员变量snapshot来存储快照，每当创建迭代器的时候，都拷贝一份容器中的元素到快照中，后续的遍历操作都基于这个迭代器自己持有的快照来进行。\n\n这个解决方案虽然简单，但是每次创建迭代器的时候，都要拷贝一份数据到快照中，会增加内存的消耗。不过，Java中的拷贝属于浅拷贝，容器中的对象并非真的拷贝了多份，而只是拷贝了对象的引用而已。\n\n解决方案二\n\n可以在容器中，为每个元素保存两个时间戳，一个是添加时间，一个是删除时间，当元素被添加到集合中时，将当前时间赋值给添加时间，将删除时间设置成最大长整型。当元素被删除时，将删除时间更新为当前时间，表示已经删除。这是一种标记删除，并不是真正的从容器中删除。\n\n同时，每个迭代器也保存一个迭代器创建时间戳，也就是迭代器对应的快照的创建时间戳。当使用迭代器遍历的时候，只有满足添加时间 < 快照时间 < 删除时间的元素，才是属于这个迭代器的快照。\n\n如果元素的添加时间大于快照时间，说明元素在创建了迭代器之后才加入的，不属于这个迭代器的快照；如果元素的删除时间小于快照时间，说明元素在创建迭代器之前就被删除了，也不属于这个迭代器的快照。\n\n但是这种方案又引入了另外一个问题，ArrayList底层依赖数组这种数据结构，原本可以支持快速的随机访问，在O(1)时间复杂度内获取下标为i的元素，但现在删除并非真正的删除，只是通过时间戳来标记删除，这就导致无法支持按照下标快速随机访问了。\n\n如何解决让容器既支持快照遍历，又支持随机访问？\n\n在ArrayList中存储两个数组，一个支持标记删除，用来实现快照遍历功能。一个不支持标记删除，用来支持随机访问。\n\n只掌握了知识，没锻炼能力，遇到实际的问题还是没法自己去分析、思考、解决。\n","slug":"设计模式之迭代器模式","published":1,"updated":"2021-06-09T05:26:10.000Z","comments":1,"photos":[],"link":"","_id":"cm1m304yd004e31b4h5rmhcbb","content":"<p>迭代器模式，用来遍历集合对象。很多编程语言都将迭代器作为一个基础的类库，直接提供出来了。在平时的开发中，我们直接使用即可， 很少去实现一个迭代器。不过知其然知其所以然，弄懂原理能帮助我们更好的使用这些工具类。</p>\n<p>迭代器模式（Iterator Design Pattern），也叫作游标模式。</p>\n<p>一开始说说到，它用来遍历集合对象。这里的“集合对象”也可以叫“容器”“聚合对象”，实际上就是包含一组对象的对象，比如数组、链表、树、图、跳表。迭代器模式将集合对象的遍历操作从集合类中拆分出来，放到迭代器类中，让两者的职责更加单一。</p>\n<p>迭代器是用来遍历容器的，所以，一个完整的迭代器模式一般会涉及容器和容器迭代器两部分。为了达到基于接口而非实现编程的目的，容器又包含容器接口、容器实现类，迭代器又包含迭代器接口、迭代器实现类。</p>\n<p>线性数据结构包括数组和链表，在大部分编程语言中都有对应的类来封装这两种数据结构，在开发中直接拿来用就可以了。假设在这种新的编程语言中，这两个数据结构分别对应ArrayList和LinkedList两个类。除此之外，我们从两个类中抽象出公共的接口，定义为List接口，以方便开发者基于接口而非实现编程，编写的代码能在两种数据存储结构之间灵活切换。</p>\n<p>现在，针对ArrayList和LinkedList两个线性容器，设计实现对应的迭代器。定义一个迭代器接口Iterator，以及针对两种容器的具体的迭代器实现类ArrayIterator和ListIterator。</p>\n<p>Iterator接口的定义代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//接口定义方式一</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Iterator</span>&lt;<span class=\"title\">E</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">hasNext</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">next</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">  <span class=\"function\">E <span class=\"title\">currentItem</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//接口定义方式二</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Iterator</span>&lt;<span class=\"title\">E</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">hasNext</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">  <span class=\"function\">E <span class=\"title\">next</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Iterator接口有两种定义方式。</p>\n<p>第一种定义中，next()函数用来将游标后移一位元素，currentItem()函数用来返回当前游标指向的元素。在第二种定义中，返回当前元素于后移一位这两个操作，要放到同一个函数next()中完成。</p>\n<p>第一种定义方式更加灵活，可以多次调用currentItem()查询当前元素，而不移动游标。</p>\n<p>再来看下ArrayIterator的代码实现。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ArrayIterator</span>&lt;<span class=\"title\">E</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Iterator</span>&lt;<span class=\"title\">E</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> cursor;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> ArrayList&lt;E&gt; arrayList;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ArrayIterator</span><span class=\"params\">(ArrayList&lt;E&gt; arrayList)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.cursor = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.arrayList = arrayList;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasNext</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cursor != arrayList.size(); <span class=\"comment\">//注意这里，cursor在指向最后一个元素的时候，hasNext()仍返回true</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    cursor++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">currentItem</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(cursor &gt;= arrayList.size()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NoSuchElementException();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arrayList.get(cursor);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    ArrayList&lt;String&gt; names = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    names.add(<span class=\"string\">&quot;xzg&quot;</span>); </span><br><span class=\"line\">    names.add(<span class=\"string\">&quot;wang&quot;</span>); </span><br><span class=\"line\">    names.add(<span class=\"string\">&quot;zheng&quot;</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    Iterator&lt;String&gt; iterator = <span class=\"keyword\">new</span> ArrayIterator(names);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(iterator.hasNext()) &#123;</span><br><span class=\"line\">      System.out.println(iterator.currentItem());</span><br><span class=\"line\">      iterator.next();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的实现中，需要将待遍历的容器对象，通过构造函数传递给迭代器类。实际上，为了封装迭代器的创建细节，可以在容器中定义一个iterator()方法，来创建对应的迭代器。为了能实现基于接口而非实现编程，我们还需要将这个方法定义在List接口中。具体的代码实现和使用示例如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">List</span>&lt;<span class=\"title\">E</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"function\">Iterator <span class=\"title\">iterator</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">  <span class=\"comment\">//...省略其他接口函数...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ArrayList</span>&lt;<span class=\"title\">E</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">List</span>&lt;<span class=\"title\">E</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> Iterator <span class=\"title\">iterator</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ArrayIterator(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//..省略其他代码</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    ArrayList&lt;String&gt; names = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    names.add(<span class=\"string\">&quot;xzg&quot;</span>); </span><br><span class=\"line\">    names.add(<span class=\"string\">&quot;wang&quot;</span>); </span><br><span class=\"line\">    names.add(<span class=\"string\">&quot;zheng&quot;</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    Iterator&lt;String&gt; iterator = names.iterator();</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(iterator.hasNext()) &#123;</span><br><span class=\"line\">      System.out.println(iterator.currentItem());</span><br><span class=\"line\">      iterator.next();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>迭代器中需要定义hasNext()、currentItem()、next()三个最基本的方法。待遍历的容器对象通过依赖注入传递到迭代器类中。容器通过iterator()方法来创建迭代器。</p>\n<p>类图如下：</p>\n<p><img src=\"https://static001.geekbang.org/resource/image/b6/30/b685b61448aaa638b03b5bf3d9d93330.jpg\" alt=\"img\"></p>\n<p>迭代器模式的优势</p>\n<p>一般来讲，遍历集合数据有三种方法：for循环、foreach循环、iterator迭代器。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">List&lt;String&gt; names = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">names.add(<span class=\"string\">&quot;xzg&quot;</span>);</span><br><span class=\"line\">names.add(<span class=\"string\">&quot;wang&quot;</span>);</span><br><span class=\"line\">names.add(<span class=\"string\">&quot;zheng&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 第一种遍历方式：for循环</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; names.size(); i++) &#123;</span><br><span class=\"line\">  System.out.print(names.get(i) + <span class=\"string\">&quot;,&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 第二种遍历方式：foreach循环</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (String name : names) &#123;</span><br><span class=\"line\">  System.out.print(name + <span class=\"string\">&quot;,&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 第三种遍历方式：迭代器遍历</span></span><br><span class=\"line\">Iterator&lt;String&gt; iterator = names.iterator();</span><br><span class=\"line\"><span class=\"keyword\">while</span> (iterator.hasNext()) &#123;</span><br><span class=\"line\">  System.out.print(iterator.next() + <span class=\"string\">&quot;,&quot;</span>);<span class=\"comment\">//Java中的迭代器接口是第二种定义方式，next()既移动游标又返回数据</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实际上，foreach循环只是一个语法糖而已，底层是基于迭代器来实现的。第二种和第三种遍历方式可以看作同一种遍历方式，也就是迭代器遍历方式。</p>\n<p>从上面的代码看，for循环遍历方式比起迭代器遍历方式，代码看起来更简洁。那为什么还要用迭代器来遍历容器呢？为什么还要给容器设计对应的迭代器呢？原因有以下三个。</p>\n<p>首先，对于类似数组和链表这样的数据结构，遍历方式比较简单，直接使用for循环来遍历就足够了。但是对于复杂的数据结构（比如树、图）来说，有各种复杂的遍历方式。比如，树有前中后序、按层遍历，图有深度优先、广度优先遍历等等。如果由客户端代码来实现这些遍历算法，势必增加开发成本，并且容易写错。如果将这部分遍历的逻辑写到容器类中，也会增加容器类代码的复杂性。</p>\n<p>应对复杂性的方法就是拆分。可以将遍历操作拆分到迭代器类中。比如，针对图的遍历，就可以定义DFSIterator、BFSIt erator两个迭代器类，让它们分别来实现深度优先和广度优先遍历。</p>\n<p>其次，将游标指向的当前位置等信息，存储在迭代器类中，每个迭代器独享游标信息。这样，就可以创建多个不同的迭代器，同时对同一个容器进行遍历而互不影响。</p>\n<p>最后，容器和迭代器都提供了抽象的接口，方便我们在开发的时候，基于接口而非具体的实现编程。当需要切换新的遍历算法的时候，比如，从前往后遍历链表切换成丛后往前遍历链表，客户端代码只需要将迭代器类从LinkedIterator切换为ReversedLinkedIterator即可，其他代码都不需要修改。除此之外，添加新的遍历算法，只需要扩展新的迭代器类，也更符合开闭原则。</p>\n<p>总结下，相对于for循环遍历，迭代器遍历由三个优势：</p>\n<ul>\n<li>迭代器模式封装集合内部的复杂数据结构，开发者不需要了解如何遍历，直接使用容器提供的迭代器即可。</li>\n<li>迭代器模式将集合对象的遍历操作从集合类中拆分出来，放到迭代器类中，让两者的职责更加单一。</li>\n<li>迭代器模式让添加新的遍历算法更加容易，更符合开闭原则。除此之外，因为迭代器都实现自相同的接口，在开发中，基于接口而非实现编程，替换迭代器也变得更加容易。</li>\n</ul>\n<h5 id=\"在遍历的同时删除集合元素会发生什么\"><a href=\"#在遍历的同时删除集合元素会发生什么\" class=\"headerlink\" title=\"在遍历的同时删除集合元素会发生什么\"></a>在遍历的同时删除集合元素会发生什么</h5><p>在通过迭代器来遍历集合元素的同时，增加或者删除集合中的元素，有可能会导致某个元素被重复遍历或遍历不到。不过，并不是所有情况下都会遍历出错，有的时候也可以正常遍历，所以，这种行为称为结果不可预期行为或者未决行为，也就是说，运行结果到底是对还是错，要视情况而定。</p>\n<p>还是ArrayList迭代器的例子。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Iterator</span>&lt;<span class=\"title\">E</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">hasNext</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">next</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">  <span class=\"function\">E <span class=\"title\">currentItem</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ArrayIterator</span>&lt;<span class=\"title\">E</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Iterator</span>&lt;<span class=\"title\">E</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> cursor;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> ArrayList&lt;E&gt; arrayList;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ArrayIterator</span><span class=\"params\">(ArrayList&lt;E&gt; arrayList)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.cursor = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.arrayList = arrayList;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasNext</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cursor &lt; arrayList.size();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    cursor++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">currentItem</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cursor &gt;= arrayList.size()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NoSuchElementException();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arrayList.get(cursor);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">List</span>&lt;<span class=\"title\">E</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"function\">Iterator <span class=\"title\">iterator</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ArrayList</span>&lt;<span class=\"title\">E</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">List</span>&lt;<span class=\"title\">E</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> Iterator <span class=\"title\">iterator</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ArrayIterator(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    List&lt;String&gt; names = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    names.add(<span class=\"string\">&quot;a&quot;</span>);</span><br><span class=\"line\">    names.add(<span class=\"string\">&quot;b&quot;</span>);</span><br><span class=\"line\">    names.add(<span class=\"string\">&quot;c&quot;</span>);</span><br><span class=\"line\">    names.add(<span class=\"string\">&quot;d&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    Iterator&lt;String&gt; iterator = names.iterator();</span><br><span class=\"line\">    iterator.next();</span><br><span class=\"line\">    names.remove(<span class=\"string\">&quot;a&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>ArrayList底层对应的是数组这种数据结构，在执行完第55行代码的时候，数组中存储的是abcd四个元素，迭代器的游标cursor指向元素a。当执行完第56行代码的时候，游标指向元素b，到这里都没有问题。</p>\n<p>为了保持数组存储数据的连续性，数组的删除操作会涉及元素的搬移。当执行到57行的时候，从数组中将元素a删除，bcd三个元素会依次往前搬移一位，这就导致游标本来指向元素b，现在变成了元素c。原本在执行完第56行代码之后，我们还可以遍历到bcd三个元素，但在执行完第57行代码之后，我们只能遍历到cd两个元素，b遍历不到了。</p>\n<p>不过，如果第57行删除的不是游标前面的元素以及游标所在位置的元素，而是游标后面的元素，就不会存在这样的问题了，不会存在某个元素遍历不到的情况了。</p>\n<p>所以，在遍历的过程中删除集合元素，结果是不可预期的，有时候没问题，有时候就有问题，要视情况而定。</p>\n<p>在遍历的过程中删除集合元素，可能会导致某个元素遍历不到，在遍历的过程中添加集合元素，会发生什么呢？还是刚才的例子，稍微改下代码。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    List&lt;String&gt; names = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    names.add(<span class=\"string\">&quot;a&quot;</span>);</span><br><span class=\"line\">    names.add(<span class=\"string\">&quot;b&quot;</span>);</span><br><span class=\"line\">    names.add(<span class=\"string\">&quot;c&quot;</span>);</span><br><span class=\"line\">    names.add(<span class=\"string\">&quot;d&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    Iterator&lt;String&gt; iterator = names.iterator();</span><br><span class=\"line\">    iterator.next();</span><br><span class=\"line\">    names.add(<span class=\"number\">0</span>, <span class=\"string\">&quot;x&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在执行完第10行代码之后，数组中包含abcd四个元素，游标指向b元素，已经跳过了元素a。在执行完第11行代码后，将x插入到下标为0的位置，abcd依次后移一位。这个时候，游标又重新指向了元素a。元素a被游标重复指向两次，也就是说，元素a存在被重复遍历的情况。</p>\n<p>和删除情况类似，如果在游标后面添加元素，就不会存在问题。所以，遍历的时候添加元素也是一种不可预期的行为。</p>\n<p>如何应对遍历时改变集合导致的未决行为</p>\n<p>有两种方式：一种是遍历的时候不允许增删元素，另一种是增删元素之后让遍历报错。</p>\n<p>实际上，第一种实现方式比较难实现，需要确定遍历开始和结束的时间点。遍历开始的时间点比较好获得，可以把创建迭代器的时间点作为遍历开始的时间点。但是，遍历结束的时间点如何来确定呢？</p>\n<p>是遍历到最后一个元素的时候算结束么\u0010？那么如果只要找到一个值为b的元素就结束遍历，又没办法确定结束的时间点了。如果在迭代器中定义一个新的接口，通过那个接口主动告知容器迭代器用完了，可以删除元素了。但是这样的话，就需要程序员在使用完迭代器之后要主动调用这个函数，增加了开发成本，而且还很容易漏掉。</p>\n<p>实际上，第二种解决方法更加合理。Java就采用这种方案，增删元素之后，让遍历报错。</p>\n<p>怎么确定在遍历的时候，集合有没有增删元素呢？在ArrayList中定义一个成员变量modCount，记录集合被修改的次数，集合每调用一次增加或者删除元素的函数，就会给modCount加1。当调用集合上的iterator()函数来创建迭代器的时候，我们把modCount值传递给迭代器的exceptedModCount成员变量，之后每次调用迭代器上的hasNext()、next()、currentItem()函数，都会检查集合上的modCount是否等于expectedModCount，也就是看，在创建完迭代器之后，modCount是否改变过。</p>\n<p>如果两个值不同，那就说明集合存储的元素已经改变了，之前创建的迭代器已经不能正确运行了，再继续使用就会产生不可预期的结果，所以选择fail-fast解决方式，抛出运行时异常，结束掉程序，让程序员修复这个因为不正确使用迭代器而产生的bug。</p>\n<p>上面的描述翻译成代码就是下面的样子。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ArrayIterator</span> <span class=\"keyword\">implements</span> <span class=\"title\">Iterator</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> cursor;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> ArrayList arrayList;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> expectedModCount;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ArrayIterator</span><span class=\"params\">(ArrayList arrayList)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.cursor = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.arrayList = arrayList;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.expectedModCount = arrayList.modCount;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasNext</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    checkForComodification();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cursor &lt; arrayList.size();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    checkForComodification();</span><br><span class=\"line\">    cursor++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">currentItem</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    checkForComodification();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arrayList.get(cursor);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">checkForComodification</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(arrayList.modCount != expectedModCount)</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ConcurrentModificationException();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"如何在遍历的同时安全地删除集合元素？\"><a href=\"#如何在遍历的同时安全地删除集合元素？\" class=\"headerlink\" title=\"如何在遍历的同时安全地删除集合元素？\"></a>如何在遍历的同时安全地删除集合元素？</h5><p>像Java语言，迭代器类中除了前面提到的几个最基本的方法之外，还定义了一个remove()方法，能够在遍历集合的同时，安全地删除集合中的元素。不过，它并没有提供添加元素的方法。毕竟迭代器的主要作用是遍历，添加元素放到迭代器里本身就不合适。</p>\n<p>Java迭代器提供的remove()方法还是有局限的。它只能删除游标指向的前一个元素，而且一个next()函数之后，只能跟着最多一个remove()操作，多次调用remove()操作回报错。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    List&lt;String&gt; names = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    names.add(<span class=\"string\">&quot;a&quot;</span>);</span><br><span class=\"line\">    names.add(<span class=\"string\">&quot;b&quot;</span>);</span><br><span class=\"line\">    names.add(<span class=\"string\">&quot;c&quot;</span>);</span><br><span class=\"line\">    names.add(<span class=\"string\">&quot;d&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    Iterator&lt;String&gt; iterator = names.iterator();</span><br><span class=\"line\">    iterator.next();</span><br><span class=\"line\">    iterator.remove();</span><br><span class=\"line\">    iterator.remove(); <span class=\"comment\">//报错，抛出IllegalStateException异常</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>迭代器为什么可以安全的删除集合中的元素呢？源码之下无秘密。看下remove()函数如何实现的。在Java实现中，迭代器类是容器类的内部类，并且next()函数不仅将游标后移一位，还会返回当前的元素。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ArrayList</span>&lt;<span class=\"title\">E</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">transient</span> Object[] elementData;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> size;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> Iterator&lt;E&gt; <span class=\"title\">iterator</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Itr();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Itr</span> <span class=\"keyword\">implements</span> <span class=\"title\">Iterator</span>&lt;<span class=\"title\">E</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> cursor; <span class=\"comment\">//index of next element to return </span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> lastRet = -<span class=\"number\">1</span>; <span class=\"comment\">//index of last element returned; -1 if no such</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> expectedModCount = modCount;</span><br><span class=\"line\">    </span><br><span class=\"line\">    Itr() &#123;&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasNext</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> cursor != size;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@SupperessWarnings(&quot;unchecked&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      checkForComodification();</span><br><span class=\"line\">      <span class=\"keyword\">int</span> i = cursor;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (i &gt;= size) </span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NoSuchElementException();</span><br><span class=\"line\">      Object[] elementData = ArrayList.<span class=\"keyword\">this</span>.elementData;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(i &gt;= elementData.length)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ConcurrentModificationException();</span><br><span class=\"line\">      cursor = i + <span class=\"number\">1</span>;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> (E) elementData[lastRet = i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (lastRet &lt; <span class=\"number\">0</span>) </span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException();</span><br><span class=\"line\">      checkForComodification();</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        ArrayList.<span class=\"keyword\">this</span>.remove(lastRet);</span><br><span class=\"line\">        cursor = lastRet;</span><br><span class=\"line\">        lastRet = -<span class=\"number\">1</span>;</span><br><span class=\"line\">        expectedModCount = modCount;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ConcurrentModificationException();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的代码实现中，迭代器类新增了一个lastRet成员变量，用来记录游标指向的前一个元素。通过迭代器去删除这个元素的时候，我们可以更新迭代器中的游标和lastRet值，来保证不会因为删除元素而导致某个元素遍历不到。如果通过容器来删除元素，并且希望更新迭代器中的游标值来保证遍历不出错，我们就要维护这个容器都创建了哪些迭代器，没个迭代器是否还在使用等信息，代码实现就变得比较复杂了。</p>\n<p>“不可预期”比直接出错更可怕，有的时候运行正确，有的时候运行错误，一些隐藏很深、很难debug的bug就是这么产生的。</p>\n<p>如何实现一个支持“快照”功能的迭代器？这个问题是为了加深对迭代器模式的理解，也是对分析、解决问题的一种锻炼。</p>\n<p>所谓“快照”，指我们为容器创建迭代器的时候，相当于给容器拍了一张快照（Snapshot）。之后即便增加容器中的元素，快照中的元素并不会做相应的改动。而迭代器遍历的对象是快照而非容器，这样就避免了在使用迭代器遍历的过程中，增删容器中的元素，导致的不可预期的结果或者报错。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Integer&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">list.add(<span class=\"number\">3</span>);</span><br><span class=\"line\">list.add(<span class=\"number\">8</span>);</span><br><span class=\"line\">list.add(<span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">Iterator&lt;Integer&gt; iter1 = list.iterator();<span class=\"comment\">//snapshot: 3, 8, 2</span></span><br><span class=\"line\">list.remove(<span class=\"keyword\">new</span> Integer(<span class=\"number\">2</span>));<span class=\"comment\">//list：3, 8</span></span><br><span class=\"line\">Iterator&lt;Integer&gt; iter2 = list.iterator();<span class=\"comment\">//snapshot: 3, 8</span></span><br><span class=\"line\">list.remove(<span class=\"keyword\">new</span> Integer(<span class=\"number\">3</span>));<span class=\"comment\">//list：8</span></span><br><span class=\"line\">Iterator&lt;Integer&gt; iter3 = list.iterator();<span class=\"comment\">//snapshot: 3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 输出结果：3 8 2</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> (iter1.hasNext()) &#123;</span><br><span class=\"line\">  System.out.print(iter1.next() + <span class=\"string\">&quot; &quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">System.out.println();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 输出结果：3 8</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> (iter2.hasNext()) &#123;</span><br><span class=\"line\">  System.out.print(iter1.next() + <span class=\"string\">&quot; &quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">System.out.println();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 输出结果：8</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> (iter3.hasNext()) &#123;</span><br><span class=\"line\">  System.out.print(iter1.next() + <span class=\"string\">&quot; &quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">System.out.println();</span><br></pre></td></tr></table></figure>\n\n<p>如果要你来实现上面的功能，你会如何做呢？下面是一份骨架代码。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> ArrayList&lt;E&gt; implements List&lt;E&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">// <span class=\"doctag\">TODO:</span> 成员变量、私有函数等随便你定义</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(E obj)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//<span class=\"doctag\">TODO:</span> 由你来完善</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">(E obj)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span> 由你来完善</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> Iterator&lt;E&gt; <span class=\"title\">iterator</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> SnapshotArrayIterator(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SnapshotArrayIterator</span>&lt;<span class=\"title\">E</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Iterator</span>&lt;<span class=\"title\">E</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// <span class=\"doctag\">TODO:</span> 成员变量、私有函数等随便你定义</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasNext</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span> 由你来完善</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123;<span class=\"comment\">//返回当前元素，并且游标后移一位</span></span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span> 由你来完善</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>解决方案一</p>\n<p>在迭代器类中定义一个成员变量snapshot来存储快照，每当创建迭代器的时候，都拷贝一份容器中的元素到快照中，后续的遍历操作都基于这个迭代器自己持有的快照来进行。</p>\n<p>这个解决方案虽然简单，但是每次创建迭代器的时候，都要拷贝一份数据到快照中，会增加内存的消耗。不过，Java中的拷贝属于浅拷贝，容器中的对象并非真的拷贝了多份，而只是拷贝了对象的引用而已。</p>\n<p>解决方案二</p>\n<p>可以在容器中，为每个元素保存两个时间戳，一个是添加时间，一个是删除时间，当元素被添加到集合中时，将当前时间赋值给添加时间，将删除时间设置成最大长整型。当元素被删除时，将删除时间更新为当前时间，表示已经删除。这是一种标记删除，并不是真正的从容器中删除。</p>\n<p>同时，每个迭代器也保存一个迭代器创建时间戳，也就是迭代器对应的快照的创建时间戳。当使用迭代器遍历的时候，只有满足添加时间 &lt; 快照时间 &lt; 删除时间的元素，才是属于这个迭代器的快照。</p>\n<p>如果元素的添加时间大于快照时间，说明元素在创建了迭代器之后才加入的，不属于这个迭代器的快照；如果元素的删除时间小于快照时间，说明元素在创建迭代器之前就被删除了，也不属于这个迭代器的快照。</p>\n<p>但是这种方案又引入了另外一个问题，ArrayList底层依赖数组这种数据结构，原本可以支持快速的随机访问，在O(1)时间复杂度内获取下标为i的元素，但现在删除并非真正的删除，只是通过时间戳来标记删除，这就导致无法支持按照下标快速随机访问了。</p>\n<p>如何解决让容器既支持快照遍历，又支持随机访问？</p>\n<p>在ArrayList中存储两个数组，一个支持标记删除，用来实现快照遍历功能。一个不支持标记删除，用来支持随机访问。</p>\n<p>只掌握了知识，没锻炼能力，遇到实际的问题还是没法自己去分析、思考、解决。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>迭代器模式，用来遍历集合对象。很多编程语言都将迭代器作为一个基础的类库，直接提供出来了。在平时的开发中，我们直接使用即可， 很少去实现一个迭代器。不过知其然知其所以然，弄懂原理能帮助我们更好的使用这些工具类。</p>\n<p>迭代器模式（Iterator Design Pattern），也叫作游标模式。</p>\n<p>一开始说说到，它用来遍历集合对象。这里的“集合对象”也可以叫“容器”“聚合对象”，实际上就是包含一组对象的对象，比如数组、链表、树、图、跳表。迭代器模式将集合对象的遍历操作从集合类中拆分出来，放到迭代器类中，让两者的职责更加单一。</p>\n<p>迭代器是用来遍历容器的，所以，一个完整的迭代器模式一般会涉及容器和容器迭代器两部分。为了达到基于接口而非实现编程的目的，容器又包含容器接口、容器实现类，迭代器又包含迭代器接口、迭代器实现类。</p>\n<p>线性数据结构包括数组和链表，在大部分编程语言中都有对应的类来封装这两种数据结构，在开发中直接拿来用就可以了。假设在这种新的编程语言中，这两个数据结构分别对应ArrayList和LinkedList两个类。除此之外，我们从两个类中抽象出公共的接口，定义为List接口，以方便开发者基于接口而非实现编程，编写的代码能在两种数据存储结构之间灵活切换。</p>\n<p>现在，针对ArrayList和LinkedList两个线性容器，设计实现对应的迭代器。定义一个迭代器接口Iterator，以及针对两种容器的具体的迭代器实现类ArrayIterator和ListIterator。</p>\n<p>Iterator接口的定义代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//接口定义方式一</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Iterator</span>&lt;<span class=\"title\">E</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">hasNext</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">next</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">  <span class=\"function\">E <span class=\"title\">currentItem</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//接口定义方式二</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Iterator</span>&lt;<span class=\"title\">E</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">hasNext</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">  <span class=\"function\">E <span class=\"title\">next</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Iterator接口有两种定义方式。</p>\n<p>第一种定义中，next()函数用来将游标后移一位元素，currentItem()函数用来返回当前游标指向的元素。在第二种定义中，返回当前元素于后移一位这两个操作，要放到同一个函数next()中完成。</p>\n<p>第一种定义方式更加灵活，可以多次调用currentItem()查询当前元素，而不移动游标。</p>\n<p>再来看下ArrayIterator的代码实现。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ArrayIterator</span>&lt;<span class=\"title\">E</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Iterator</span>&lt;<span class=\"title\">E</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> cursor;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> ArrayList&lt;E&gt; arrayList;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ArrayIterator</span><span class=\"params\">(ArrayList&lt;E&gt; arrayList)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.cursor = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.arrayList = arrayList;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasNext</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cursor != arrayList.size(); <span class=\"comment\">//注意这里，cursor在指向最后一个元素的时候，hasNext()仍返回true</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    cursor++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">currentItem</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(cursor &gt;= arrayList.size()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NoSuchElementException();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arrayList.get(cursor);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    ArrayList&lt;String&gt; names = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    names.add(<span class=\"string\">&quot;xzg&quot;</span>); </span><br><span class=\"line\">    names.add(<span class=\"string\">&quot;wang&quot;</span>); </span><br><span class=\"line\">    names.add(<span class=\"string\">&quot;zheng&quot;</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    Iterator&lt;String&gt; iterator = <span class=\"keyword\">new</span> ArrayIterator(names);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(iterator.hasNext()) &#123;</span><br><span class=\"line\">      System.out.println(iterator.currentItem());</span><br><span class=\"line\">      iterator.next();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的实现中，需要将待遍历的容器对象，通过构造函数传递给迭代器类。实际上，为了封装迭代器的创建细节，可以在容器中定义一个iterator()方法，来创建对应的迭代器。为了能实现基于接口而非实现编程，我们还需要将这个方法定义在List接口中。具体的代码实现和使用示例如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">List</span>&lt;<span class=\"title\">E</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"function\">Iterator <span class=\"title\">iterator</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">  <span class=\"comment\">//...省略其他接口函数...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ArrayList</span>&lt;<span class=\"title\">E</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">List</span>&lt;<span class=\"title\">E</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> Iterator <span class=\"title\">iterator</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ArrayIterator(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//..省略其他代码</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    ArrayList&lt;String&gt; names = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    names.add(<span class=\"string\">&quot;xzg&quot;</span>); </span><br><span class=\"line\">    names.add(<span class=\"string\">&quot;wang&quot;</span>); </span><br><span class=\"line\">    names.add(<span class=\"string\">&quot;zheng&quot;</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    Iterator&lt;String&gt; iterator = names.iterator();</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(iterator.hasNext()) &#123;</span><br><span class=\"line\">      System.out.println(iterator.currentItem());</span><br><span class=\"line\">      iterator.next();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>迭代器中需要定义hasNext()、currentItem()、next()三个最基本的方法。待遍历的容器对象通过依赖注入传递到迭代器类中。容器通过iterator()方法来创建迭代器。</p>\n<p>类图如下：</p>\n<p><img src=\"https://static001.geekbang.org/resource/image/b6/30/b685b61448aaa638b03b5bf3d9d93330.jpg\" alt=\"img\"></p>\n<p>迭代器模式的优势</p>\n<p>一般来讲，遍历集合数据有三种方法：for循环、foreach循环、iterator迭代器。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">List&lt;String&gt; names = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">names.add(<span class=\"string\">&quot;xzg&quot;</span>);</span><br><span class=\"line\">names.add(<span class=\"string\">&quot;wang&quot;</span>);</span><br><span class=\"line\">names.add(<span class=\"string\">&quot;zheng&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 第一种遍历方式：for循环</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; names.size(); i++) &#123;</span><br><span class=\"line\">  System.out.print(names.get(i) + <span class=\"string\">&quot;,&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 第二种遍历方式：foreach循环</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (String name : names) &#123;</span><br><span class=\"line\">  System.out.print(name + <span class=\"string\">&quot;,&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 第三种遍历方式：迭代器遍历</span></span><br><span class=\"line\">Iterator&lt;String&gt; iterator = names.iterator();</span><br><span class=\"line\"><span class=\"keyword\">while</span> (iterator.hasNext()) &#123;</span><br><span class=\"line\">  System.out.print(iterator.next() + <span class=\"string\">&quot;,&quot;</span>);<span class=\"comment\">//Java中的迭代器接口是第二种定义方式，next()既移动游标又返回数据</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实际上，foreach循环只是一个语法糖而已，底层是基于迭代器来实现的。第二种和第三种遍历方式可以看作同一种遍历方式，也就是迭代器遍历方式。</p>\n<p>从上面的代码看，for循环遍历方式比起迭代器遍历方式，代码看起来更简洁。那为什么还要用迭代器来遍历容器呢？为什么还要给容器设计对应的迭代器呢？原因有以下三个。</p>\n<p>首先，对于类似数组和链表这样的数据结构，遍历方式比较简单，直接使用for循环来遍历就足够了。但是对于复杂的数据结构（比如树、图）来说，有各种复杂的遍历方式。比如，树有前中后序、按层遍历，图有深度优先、广度优先遍历等等。如果由客户端代码来实现这些遍历算法，势必增加开发成本，并且容易写错。如果将这部分遍历的逻辑写到容器类中，也会增加容器类代码的复杂性。</p>\n<p>应对复杂性的方法就是拆分。可以将遍历操作拆分到迭代器类中。比如，针对图的遍历，就可以定义DFSIterator、BFSIt erator两个迭代器类，让它们分别来实现深度优先和广度优先遍历。</p>\n<p>其次，将游标指向的当前位置等信息，存储在迭代器类中，每个迭代器独享游标信息。这样，就可以创建多个不同的迭代器，同时对同一个容器进行遍历而互不影响。</p>\n<p>最后，容器和迭代器都提供了抽象的接口，方便我们在开发的时候，基于接口而非具体的实现编程。当需要切换新的遍历算法的时候，比如，从前往后遍历链表切换成丛后往前遍历链表，客户端代码只需要将迭代器类从LinkedIterator切换为ReversedLinkedIterator即可，其他代码都不需要修改。除此之外，添加新的遍历算法，只需要扩展新的迭代器类，也更符合开闭原则。</p>\n<p>总结下，相对于for循环遍历，迭代器遍历由三个优势：</p>\n<ul>\n<li>迭代器模式封装集合内部的复杂数据结构，开发者不需要了解如何遍历，直接使用容器提供的迭代器即可。</li>\n<li>迭代器模式将集合对象的遍历操作从集合类中拆分出来，放到迭代器类中，让两者的职责更加单一。</li>\n<li>迭代器模式让添加新的遍历算法更加容易，更符合开闭原则。除此之外，因为迭代器都实现自相同的接口，在开发中，基于接口而非实现编程，替换迭代器也变得更加容易。</li>\n</ul>\n<h5 id=\"在遍历的同时删除集合元素会发生什么\"><a href=\"#在遍历的同时删除集合元素会发生什么\" class=\"headerlink\" title=\"在遍历的同时删除集合元素会发生什么\"></a>在遍历的同时删除集合元素会发生什么</h5><p>在通过迭代器来遍历集合元素的同时，增加或者删除集合中的元素，有可能会导致某个元素被重复遍历或遍历不到。不过，并不是所有情况下都会遍历出错，有的时候也可以正常遍历，所以，这种行为称为结果不可预期行为或者未决行为，也就是说，运行结果到底是对还是错，要视情况而定。</p>\n<p>还是ArrayList迭代器的例子。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Iterator</span>&lt;<span class=\"title\">E</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">hasNext</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">next</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">  <span class=\"function\">E <span class=\"title\">currentItem</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ArrayIterator</span>&lt;<span class=\"title\">E</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Iterator</span>&lt;<span class=\"title\">E</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> cursor;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> ArrayList&lt;E&gt; arrayList;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ArrayIterator</span><span class=\"params\">(ArrayList&lt;E&gt; arrayList)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.cursor = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.arrayList = arrayList;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasNext</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cursor &lt; arrayList.size();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    cursor++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">currentItem</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cursor &gt;= arrayList.size()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NoSuchElementException();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arrayList.get(cursor);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">List</span>&lt;<span class=\"title\">E</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"function\">Iterator <span class=\"title\">iterator</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ArrayList</span>&lt;<span class=\"title\">E</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">List</span>&lt;<span class=\"title\">E</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> Iterator <span class=\"title\">iterator</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ArrayIterator(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    List&lt;String&gt; names = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    names.add(<span class=\"string\">&quot;a&quot;</span>);</span><br><span class=\"line\">    names.add(<span class=\"string\">&quot;b&quot;</span>);</span><br><span class=\"line\">    names.add(<span class=\"string\">&quot;c&quot;</span>);</span><br><span class=\"line\">    names.add(<span class=\"string\">&quot;d&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    Iterator&lt;String&gt; iterator = names.iterator();</span><br><span class=\"line\">    iterator.next();</span><br><span class=\"line\">    names.remove(<span class=\"string\">&quot;a&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>ArrayList底层对应的是数组这种数据结构，在执行完第55行代码的时候，数组中存储的是abcd四个元素，迭代器的游标cursor指向元素a。当执行完第56行代码的时候，游标指向元素b，到这里都没有问题。</p>\n<p>为了保持数组存储数据的连续性，数组的删除操作会涉及元素的搬移。当执行到57行的时候，从数组中将元素a删除，bcd三个元素会依次往前搬移一位，这就导致游标本来指向元素b，现在变成了元素c。原本在执行完第56行代码之后，我们还可以遍历到bcd三个元素，但在执行完第57行代码之后，我们只能遍历到cd两个元素，b遍历不到了。</p>\n<p>不过，如果第57行删除的不是游标前面的元素以及游标所在位置的元素，而是游标后面的元素，就不会存在这样的问题了，不会存在某个元素遍历不到的情况了。</p>\n<p>所以，在遍历的过程中删除集合元素，结果是不可预期的，有时候没问题，有时候就有问题，要视情况而定。</p>\n<p>在遍历的过程中删除集合元素，可能会导致某个元素遍历不到，在遍历的过程中添加集合元素，会发生什么呢？还是刚才的例子，稍微改下代码。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    List&lt;String&gt; names = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    names.add(<span class=\"string\">&quot;a&quot;</span>);</span><br><span class=\"line\">    names.add(<span class=\"string\">&quot;b&quot;</span>);</span><br><span class=\"line\">    names.add(<span class=\"string\">&quot;c&quot;</span>);</span><br><span class=\"line\">    names.add(<span class=\"string\">&quot;d&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    Iterator&lt;String&gt; iterator = names.iterator();</span><br><span class=\"line\">    iterator.next();</span><br><span class=\"line\">    names.add(<span class=\"number\">0</span>, <span class=\"string\">&quot;x&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在执行完第10行代码之后，数组中包含abcd四个元素，游标指向b元素，已经跳过了元素a。在执行完第11行代码后，将x插入到下标为0的位置，abcd依次后移一位。这个时候，游标又重新指向了元素a。元素a被游标重复指向两次，也就是说，元素a存在被重复遍历的情况。</p>\n<p>和删除情况类似，如果在游标后面添加元素，就不会存在问题。所以，遍历的时候添加元素也是一种不可预期的行为。</p>\n<p>如何应对遍历时改变集合导致的未决行为</p>\n<p>有两种方式：一种是遍历的时候不允许增删元素，另一种是增删元素之后让遍历报错。</p>\n<p>实际上，第一种实现方式比较难实现，需要确定遍历开始和结束的时间点。遍历开始的时间点比较好获得，可以把创建迭代器的时间点作为遍历开始的时间点。但是，遍历结束的时间点如何来确定呢？</p>\n<p>是遍历到最后一个元素的时候算结束么\u0010？那么如果只要找到一个值为b的元素就结束遍历，又没办法确定结束的时间点了。如果在迭代器中定义一个新的接口，通过那个接口主动告知容器迭代器用完了，可以删除元素了。但是这样的话，就需要程序员在使用完迭代器之后要主动调用这个函数，增加了开发成本，而且还很容易漏掉。</p>\n<p>实际上，第二种解决方法更加合理。Java就采用这种方案，增删元素之后，让遍历报错。</p>\n<p>怎么确定在遍历的时候，集合有没有增删元素呢？在ArrayList中定义一个成员变量modCount，记录集合被修改的次数，集合每调用一次增加或者删除元素的函数，就会给modCount加1。当调用集合上的iterator()函数来创建迭代器的时候，我们把modCount值传递给迭代器的exceptedModCount成员变量，之后每次调用迭代器上的hasNext()、next()、currentItem()函数，都会检查集合上的modCount是否等于expectedModCount，也就是看，在创建完迭代器之后，modCount是否改变过。</p>\n<p>如果两个值不同，那就说明集合存储的元素已经改变了，之前创建的迭代器已经不能正确运行了，再继续使用就会产生不可预期的结果，所以选择fail-fast解决方式，抛出运行时异常，结束掉程序，让程序员修复这个因为不正确使用迭代器而产生的bug。</p>\n<p>上面的描述翻译成代码就是下面的样子。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ArrayIterator</span> <span class=\"keyword\">implements</span> <span class=\"title\">Iterator</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> cursor;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> ArrayList arrayList;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> expectedModCount;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ArrayIterator</span><span class=\"params\">(ArrayList arrayList)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.cursor = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.arrayList = arrayList;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.expectedModCount = arrayList.modCount;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasNext</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    checkForComodification();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cursor &lt; arrayList.size();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    checkForComodification();</span><br><span class=\"line\">    cursor++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">currentItem</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    checkForComodification();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arrayList.get(cursor);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">checkForComodification</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(arrayList.modCount != expectedModCount)</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ConcurrentModificationException();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"如何在遍历的同时安全地删除集合元素？\"><a href=\"#如何在遍历的同时安全地删除集合元素？\" class=\"headerlink\" title=\"如何在遍历的同时安全地删除集合元素？\"></a>如何在遍历的同时安全地删除集合元素？</h5><p>像Java语言，迭代器类中除了前面提到的几个最基本的方法之外，还定义了一个remove()方法，能够在遍历集合的同时，安全地删除集合中的元素。不过，它并没有提供添加元素的方法。毕竟迭代器的主要作用是遍历，添加元素放到迭代器里本身就不合适。</p>\n<p>Java迭代器提供的remove()方法还是有局限的。它只能删除游标指向的前一个元素，而且一个next()函数之后，只能跟着最多一个remove()操作，多次调用remove()操作回报错。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    List&lt;String&gt; names = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    names.add(<span class=\"string\">&quot;a&quot;</span>);</span><br><span class=\"line\">    names.add(<span class=\"string\">&quot;b&quot;</span>);</span><br><span class=\"line\">    names.add(<span class=\"string\">&quot;c&quot;</span>);</span><br><span class=\"line\">    names.add(<span class=\"string\">&quot;d&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    Iterator&lt;String&gt; iterator = names.iterator();</span><br><span class=\"line\">    iterator.next();</span><br><span class=\"line\">    iterator.remove();</span><br><span class=\"line\">    iterator.remove(); <span class=\"comment\">//报错，抛出IllegalStateException异常</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>迭代器为什么可以安全的删除集合中的元素呢？源码之下无秘密。看下remove()函数如何实现的。在Java实现中，迭代器类是容器类的内部类，并且next()函数不仅将游标后移一位，还会返回当前的元素。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ArrayList</span>&lt;<span class=\"title\">E</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">transient</span> Object[] elementData;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> size;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> Iterator&lt;E&gt; <span class=\"title\">iterator</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Itr();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Itr</span> <span class=\"keyword\">implements</span> <span class=\"title\">Iterator</span>&lt;<span class=\"title\">E</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> cursor; <span class=\"comment\">//index of next element to return </span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> lastRet = -<span class=\"number\">1</span>; <span class=\"comment\">//index of last element returned; -1 if no such</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> expectedModCount = modCount;</span><br><span class=\"line\">    </span><br><span class=\"line\">    Itr() &#123;&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasNext</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> cursor != size;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@SupperessWarnings(&quot;unchecked&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      checkForComodification();</span><br><span class=\"line\">      <span class=\"keyword\">int</span> i = cursor;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (i &gt;= size) </span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NoSuchElementException();</span><br><span class=\"line\">      Object[] elementData = ArrayList.<span class=\"keyword\">this</span>.elementData;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(i &gt;= elementData.length)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ConcurrentModificationException();</span><br><span class=\"line\">      cursor = i + <span class=\"number\">1</span>;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> (E) elementData[lastRet = i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (lastRet &lt; <span class=\"number\">0</span>) </span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException();</span><br><span class=\"line\">      checkForComodification();</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        ArrayList.<span class=\"keyword\">this</span>.remove(lastRet);</span><br><span class=\"line\">        cursor = lastRet;</span><br><span class=\"line\">        lastRet = -<span class=\"number\">1</span>;</span><br><span class=\"line\">        expectedModCount = modCount;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ConcurrentModificationException();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的代码实现中，迭代器类新增了一个lastRet成员变量，用来记录游标指向的前一个元素。通过迭代器去删除这个元素的时候，我们可以更新迭代器中的游标和lastRet值，来保证不会因为删除元素而导致某个元素遍历不到。如果通过容器来删除元素，并且希望更新迭代器中的游标值来保证遍历不出错，我们就要维护这个容器都创建了哪些迭代器，没个迭代器是否还在使用等信息，代码实现就变得比较复杂了。</p>\n<p>“不可预期”比直接出错更可怕，有的时候运行正确，有的时候运行错误，一些隐藏很深、很难debug的bug就是这么产生的。</p>\n<p>如何实现一个支持“快照”功能的迭代器？这个问题是为了加深对迭代器模式的理解，也是对分析、解决问题的一种锻炼。</p>\n<p>所谓“快照”，指我们为容器创建迭代器的时候，相当于给容器拍了一张快照（Snapshot）。之后即便增加容器中的元素，快照中的元素并不会做相应的改动。而迭代器遍历的对象是快照而非容器，这样就避免了在使用迭代器遍历的过程中，增删容器中的元素，导致的不可预期的结果或者报错。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Integer&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">list.add(<span class=\"number\">3</span>);</span><br><span class=\"line\">list.add(<span class=\"number\">8</span>);</span><br><span class=\"line\">list.add(<span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">Iterator&lt;Integer&gt; iter1 = list.iterator();<span class=\"comment\">//snapshot: 3, 8, 2</span></span><br><span class=\"line\">list.remove(<span class=\"keyword\">new</span> Integer(<span class=\"number\">2</span>));<span class=\"comment\">//list：3, 8</span></span><br><span class=\"line\">Iterator&lt;Integer&gt; iter2 = list.iterator();<span class=\"comment\">//snapshot: 3, 8</span></span><br><span class=\"line\">list.remove(<span class=\"keyword\">new</span> Integer(<span class=\"number\">3</span>));<span class=\"comment\">//list：8</span></span><br><span class=\"line\">Iterator&lt;Integer&gt; iter3 = list.iterator();<span class=\"comment\">//snapshot: 3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 输出结果：3 8 2</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> (iter1.hasNext()) &#123;</span><br><span class=\"line\">  System.out.print(iter1.next() + <span class=\"string\">&quot; &quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">System.out.println();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 输出结果：3 8</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> (iter2.hasNext()) &#123;</span><br><span class=\"line\">  System.out.print(iter1.next() + <span class=\"string\">&quot; &quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">System.out.println();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 输出结果：8</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> (iter3.hasNext()) &#123;</span><br><span class=\"line\">  System.out.print(iter1.next() + <span class=\"string\">&quot; &quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">System.out.println();</span><br></pre></td></tr></table></figure>\n\n<p>如果要你来实现上面的功能，你会如何做呢？下面是一份骨架代码。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> ArrayList&lt;E&gt; implements List&lt;E&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">// <span class=\"doctag\">TODO:</span> 成员变量、私有函数等随便你定义</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(E obj)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//<span class=\"doctag\">TODO:</span> 由你来完善</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">(E obj)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span> 由你来完善</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> Iterator&lt;E&gt; <span class=\"title\">iterator</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> SnapshotArrayIterator(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SnapshotArrayIterator</span>&lt;<span class=\"title\">E</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Iterator</span>&lt;<span class=\"title\">E</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// <span class=\"doctag\">TODO:</span> 成员变量、私有函数等随便你定义</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasNext</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span> 由你来完善</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123;<span class=\"comment\">//返回当前元素，并且游标后移一位</span></span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span> 由你来完善</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>解决方案一</p>\n<p>在迭代器类中定义一个成员变量snapshot来存储快照，每当创建迭代器的时候，都拷贝一份容器中的元素到快照中，后续的遍历操作都基于这个迭代器自己持有的快照来进行。</p>\n<p>这个解决方案虽然简单，但是每次创建迭代器的时候，都要拷贝一份数据到快照中，会增加内存的消耗。不过，Java中的拷贝属于浅拷贝，容器中的对象并非真的拷贝了多份，而只是拷贝了对象的引用而已。</p>\n<p>解决方案二</p>\n<p>可以在容器中，为每个元素保存两个时间戳，一个是添加时间，一个是删除时间，当元素被添加到集合中时，将当前时间赋值给添加时间，将删除时间设置成最大长整型。当元素被删除时，将删除时间更新为当前时间，表示已经删除。这是一种标记删除，并不是真正的从容器中删除。</p>\n<p>同时，每个迭代器也保存一个迭代器创建时间戳，也就是迭代器对应的快照的创建时间戳。当使用迭代器遍历的时候，只有满足添加时间 &lt; 快照时间 &lt; 删除时间的元素，才是属于这个迭代器的快照。</p>\n<p>如果元素的添加时间大于快照时间，说明元素在创建了迭代器之后才加入的，不属于这个迭代器的快照；如果元素的删除时间小于快照时间，说明元素在创建迭代器之前就被删除了，也不属于这个迭代器的快照。</p>\n<p>但是这种方案又引入了另外一个问题，ArrayList底层依赖数组这种数据结构，原本可以支持快速的随机访问，在O(1)时间复杂度内获取下标为i的元素，但现在删除并非真正的删除，只是通过时间戳来标记删除，这就导致无法支持按照下标快速随机访问了。</p>\n<p>如何解决让容器既支持快照遍历，又支持随机访问？</p>\n<p>在ArrayList中存储两个数组，一个支持标记删除，用来实现快照遍历功能。一个不支持标记删除，用来支持随机访问。</p>\n<p>只掌握了知识，没锻炼能力，遇到实际的问题还是没法自己去分析、思考、解决。</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cm1m304ww000131b40rkgczjb","category_id":"cm1m304x1000331b4e1dp1t5a","_id":"cm1m304x9000e31b49ddy9dgw"},{"post_id":"cm1m304wz000231b4daaw7tqi","category_id":"cm1m304x1000331b4e1dp1t5a","_id":"cm1m304xb000k31b48033cxit"},{"post_id":"cm1m304x2000531b4crlshtzu","category_id":"cm1m304x9000d31b43kcj2unx","_id":"cm1m304xe000r31b4atu5e6pe"},{"post_id":"cm1m304x3000631b47d4ga9t5","category_id":"cm1m304xb000l31b4ayyr1opi","_id":"cm1m304xg000y31b4ew47co1s"},{"post_id":"cm1m304x4000731b4gojt2dw2","category_id":"cm1m304xe000s31b42ky333es","_id":"cm1m304xi001731b4de4x5arz"},{"post_id":"cm1m304x7000a31b42nvdgz84","category_id":"cm1m304xe000s31b42ky333es","_id":"cm1m304xl001d31b47t4vd6sp"},{"post_id":"cm1m304x8000c31b41amw023m","category_id":"cm1m304xe000s31b42ky333es","_id":"cm1m304xn001j31b4gbkmb8hz"},{"post_id":"cm1m304xa000h31b40ybvboak","category_id":"cm1m304xe000s31b42ky333es","_id":"cm1m304xp001q31b409shbki6"},{"post_id":"cm1m304xb000j31b4ew2t1fdy","category_id":"cm1m304xe000s31b42ky333es","_id":"cm1m304xr001w31b4hqsb40a7"},{"post_id":"cm1m304xr001u31b493crgfaj","category_id":"cm1m304xp001p31b4h39l71uc","_id":"cm1m304xu002431b4c4pgg0oo"},{"post_id":"cm1m304xc000o31b48qahgksa","category_id":"cm1m304xp001p31b4h39l71uc","_id":"cm1m304xv002931b4cx5rf6wz"},{"post_id":"cm1m304xr001x31b4aieq7omv","category_id":"cm1m304xp001p31b4h39l71uc","_id":"cm1m304xv002c31b414pc7xuv"},{"post_id":"cm1m304xs002131b4ae7sb952","category_id":"cm1m304xp001p31b4h39l71uc","_id":"cm1m304xw002g31b44gqfbc61"},{"post_id":"cm1m304xd000q31b428tc3gue","category_id":"cm1m304xp001p31b4h39l71uc","_id":"cm1m304xx002i31b44rf9f2qt"},{"post_id":"cm1m304xt002331b4h7za026y","category_id":"cm1m304xp001p31b4h39l71uc","_id":"cm1m304xy002m31b4d9fpd3va"},{"post_id":"cm1m304xu002831b4eh9lby49","category_id":"cm1m304xp001p31b4h39l71uc","_id":"cm1m304xy002o31b438354rs0"},{"post_id":"cm1m304xe000v31b410je3ode","category_id":"cm1m304xu002531b49db63tcz","_id":"cm1m304xz002s31b4cv5i342u"},{"post_id":"cm1m304xv002b31b4eqsn1r6q","category_id":"cm1m304xp001p31b4h39l71uc","_id":"cm1m304xz002u31b4132yaw1a"},{"post_id":"cm1m304xf000x31b4h8ep846d","category_id":"cm1m304xp001p31b4h39l71uc","_id":"cm1m304y0002y31b435gaboi0"},{"post_id":"cm1m304xg001231b4disr86p9","category_id":"cm1m304xp001p31b4h39l71uc","_id":"cm1m304y0003031b40gro0ttn"},{"post_id":"cm1m304xh001431b43ncne0zc","category_id":"cm1m304xp001p31b4h39l71uc","_id":"cm1m304y0003331b44vdp4tvo"},{"post_id":"cm1m304xk001931b44zdm7dru","category_id":"cm1m304xp001p31b4h39l71uc","_id":"cm1m304y1003631b4dpxg7ly6"},{"post_id":"cm1m304xk001b31b4hrzcgurc","category_id":"cm1m304xp001p31b4h39l71uc","_id":"cm1m304y1003931b45byrezli"},{"post_id":"cm1m304xl001e31b4coou3bub","category_id":"cm1m304xp001p31b4h39l71uc","_id":"cm1m304y2003b31b47qh70svh"},{"post_id":"cm1m304xm001h31b4aqu086up","category_id":"cm1m304xp001p31b4h39l71uc","_id":"cm1m304y2003d31b44ft4bpte"},{"post_id":"cm1m304xn001k31b47cnwe93g","category_id":"cm1m304xp001p31b4h39l71uc","_id":"cm1m304y2003f31b4gngn2ov9"},{"post_id":"cm1m304xo001n31b47t9n2xnw","category_id":"cm1m304xp001p31b4h39l71uc","_id":"cm1m304y3003g31b4dkd718n5"},{"post_id":"cm1m304xp001r31b45h430wa0","category_id":"cm1m304xp001p31b4h39l71uc","_id":"cm1m304y3003h31b46jb7d61m"},{"post_id":"cm1m304y6003i31b445mrf0st","category_id":"cm1m304xp001p31b4h39l71uc","_id":"cm1m304y8003o31b42bfldshl"},{"post_id":"cm1m304y7003j31b467d47zo6","category_id":"cm1m304xp001p31b4h39l71uc","_id":"cm1m304y9003r31b42tla8bfv"},{"post_id":"cm1m304y7003l31b4cz8oa60y","category_id":"cm1m304x1000331b4e1dp1t5a","_id":"cm1m304ya003u31b47fvg6zer"},{"post_id":"cm1m304y8003n31b43edt3ult","category_id":"cm1m304x1000331b4e1dp1t5a","_id":"cm1m304ya003x31b4b24n4h9g"},{"post_id":"cm1m304y9003q31b470pi3tfy","category_id":"cm1m304xb000l31b4ayyr1opi","_id":"cm1m304yb004031b41w097m6d"},{"post_id":"cm1m304y9003t31b43wrm8bau","category_id":"cm1m304xe000s31b42ky333es","_id":"cm1m304yc004331b440azgvn1"},{"post_id":"cm1m304ya003w31b4ckhh1ndt","category_id":"cm1m304xp001p31b4h39l71uc","_id":"cm1m304yc004531b40mzo8tw5"},{"post_id":"cm1m304ya003z31b42xb5azxi","category_id":"cm1m304xp001p31b4h39l71uc","_id":"cm1m304yc004731b48gkjgx0j"},{"post_id":"cm1m304yb004231b47ghacufz","category_id":"cm1m304xp001p31b4h39l71uc","_id":"cm1m304yc004931b43wu67pj8"},{"post_id":"cm1m304yd004d31b42qxg8i7d","category_id":"cm1m304xp001p31b4h39l71uc","_id":"cm1m304ye004h31b42nukcvc0"},{"post_id":"cm1m304yd004e31b4h5rmhcbb","category_id":"cm1m304xp001p31b4h39l71uc","_id":"cm1m304ye004i31b48d2nb8vd"}],"PostTag":[{"post_id":"cm1m304x4000731b4gojt2dw2","tag_id":"cm1m304x2000431b482p01rqc","_id":"cm1m304x8000b31b4bm2hdumr"},{"post_id":"cm1m304x7000a31b42nvdgz84","tag_id":"cm1m304x2000431b482p01rqc","_id":"cm1m304xa000g31b4b7n14xz9"},{"post_id":"cm1m304x8000c31b41amw023m","tag_id":"cm1m304x2000431b482p01rqc","_id":"cm1m304xb000i31b49osbdw3k"},{"post_id":"cm1m304xa000h31b40ybvboak","tag_id":"cm1m304x2000431b482p01rqc","_id":"cm1m304xc000n31b4akzx42oi"},{"post_id":"cm1m304ww000131b40rkgczjb","tag_id":"cm1m304x2000431b482p01rqc","_id":"cm1m304xd000p31b4dlk0b4do"},{"post_id":"cm1m304ww000131b40rkgczjb","tag_id":"cm1m304x4000931b44l3v6w8f","_id":"cm1m304xe000u31b46crkez9m"},{"post_id":"cm1m304ww000131b40rkgczjb","tag_id":"cm1m304x9000f31b46hcyg4ax","_id":"cm1m304xf000w31b49wvmayfk"},{"post_id":"cm1m304xb000j31b4ew2t1fdy","tag_id":"cm1m304x2000431b482p01rqc","_id":"cm1m304xg001031b4cjr33l52"},{"post_id":"cm1m304wz000231b4daaw7tqi","tag_id":"cm1m304x2000431b482p01rqc","_id":"cm1m304xh001331b4gdx4ggk6"},{"post_id":"cm1m304wz000231b4daaw7tqi","tag_id":"cm1m304x4000931b44l3v6w8f","_id":"cm1m304xi001531b4e2ps0srg"},{"post_id":"cm1m304x2000531b4crlshtzu","tag_id":"cm1m304xg000z31b4gzuo0xmv","_id":"cm1m304xk001a31b4a8mw6iwn"},{"post_id":"cm1m304x3000631b47d4ga9t5","tag_id":"cm1m304xi001831b4709b1mpv","_id":"cm1m304xm001g31b4h6oz9a18"},{"post_id":"cm1m304xm001h31b4aqu086up","tag_id":"cm1m304xm001f31b48v7oato6","_id":"cm1m304xo001m31b44ebgcoem"},{"post_id":"cm1m304xc000o31b48qahgksa","tag_id":"cm1m304xm001f31b48v7oato6","_id":"cm1m304xp001o31b4fz4s53vv"},{"post_id":"cm1m304xn001k31b47cnwe93g","tag_id":"cm1m304xm001f31b48v7oato6","_id":"cm1m304xq001t31b4f78qfny0"},{"post_id":"cm1m304xo001n31b47t9n2xnw","tag_id":"cm1m304xm001f31b48v7oato6","_id":"cm1m304xr001v31b4fnon5rt0"},{"post_id":"cm1m304xd000q31b428tc3gue","tag_id":"cm1m304xm001f31b48v7oato6","_id":"cm1m304xs002031b4g0zr2wnh"},{"post_id":"cm1m304xp001r31b45h430wa0","tag_id":"cm1m304xm001f31b48v7oato6","_id":"cm1m304xt002231b49nrw102e"},{"post_id":"cm1m304xr001u31b493crgfaj","tag_id":"cm1m304xm001f31b48v7oato6","_id":"cm1m304xu002731b4fiut8kac"},{"post_id":"cm1m304xe000v31b410je3ode","tag_id":"cm1m304xp001s31b45z1r6e71","_id":"cm1m304xv002a31b48kjz9swi"},{"post_id":"cm1m304xr001x31b4aieq7omv","tag_id":"cm1m304xm001f31b48v7oato6","_id":"cm1m304xw002f31b4cwpb1cw7"},{"post_id":"cm1m304xs002131b4ae7sb952","tag_id":"cm1m304xm001f31b48v7oato6","_id":"cm1m304xx002h31b42hdr0cg3"},{"post_id":"cm1m304xf000x31b4h8ep846d","tag_id":"cm1m304xm001f31b48v7oato6","_id":"cm1m304xy002l31b4hgs3gjjh"},{"post_id":"cm1m304xt002331b4h7za026y","tag_id":"cm1m304xm001f31b48v7oato6","_id":"cm1m304xy002n31b4cter6ded"},{"post_id":"cm1m304xu002831b4eh9lby49","tag_id":"cm1m304xm001f31b48v7oato6","_id":"cm1m304xy002r31b43bmhfpyr"},{"post_id":"cm1m304xg001231b4disr86p9","tag_id":"cm1m304xm001f31b48v7oato6","_id":"cm1m304xz002t31b4by1shbew"},{"post_id":"cm1m304xv002b31b4eqsn1r6q","tag_id":"cm1m304xm001f31b48v7oato6","_id":"cm1m304xz002x31b40mrt3cqg"},{"post_id":"cm1m304xh001431b43ncne0zc","tag_id":"cm1m304xm001f31b48v7oato6","_id":"cm1m304y0002z31b4h9ji50qo"},{"post_id":"cm1m304xk001931b44zdm7dru","tag_id":"cm1m304xm001f31b48v7oato6","_id":"cm1m304y0003231b4bnuhb1lq"},{"post_id":"cm1m304xk001b31b4hrzcgurc","tag_id":"cm1m304xm001f31b48v7oato6","_id":"cm1m304y1003431b4da334ao9"},{"post_id":"cm1m304xl001e31b4coou3bub","tag_id":"cm1m304xm001f31b48v7oato6","_id":"cm1m304y1003731b4b9ag59z0"},{"post_id":"cm1m304y6003i31b445mrf0st","tag_id":"cm1m304xm001f31b48v7oato6","_id":"cm1m304y7003k31b4gm5faokg"},{"post_id":"cm1m304y7003j31b467d47zo6","tag_id":"cm1m304xm001f31b48v7oato6","_id":"cm1m304y8003m31b48uq6e8ej"},{"post_id":"cm1m304y7003l31b4cz8oa60y","tag_id":"cm1m304x2000431b482p01rqc","_id":"cm1m304y8003p31b4em5s6a1l"},{"post_id":"cm1m304y7003l31b4cz8oa60y","tag_id":"cm1m304x4000931b44l3v6w8f","_id":"cm1m304y9003s31b4bla7dt8y"},{"post_id":"cm1m304y7003l31b4cz8oa60y","tag_id":"cm1m304x9000f31b46hcyg4ax","_id":"cm1m304ya003v31b45966g0w0"},{"post_id":"cm1m304y8003n31b43edt3ult","tag_id":"cm1m304x2000431b482p01rqc","_id":"cm1m304ya003y31b4bkw47lrn"},{"post_id":"cm1m304y8003n31b43edt3ult","tag_id":"cm1m304x4000931b44l3v6w8f","_id":"cm1m304yb004131b48q703nxi"},{"post_id":"cm1m304y8003n31b43edt3ult","tag_id":"cm1m304x9000f31b46hcyg4ax","_id":"cm1m304yc004431b48ojj3vl5"},{"post_id":"cm1m304y9003q31b470pi3tfy","tag_id":"cm1m304xi001831b4709b1mpv","_id":"cm1m304yc004631b4gs6whb78"},{"post_id":"cm1m304y9003t31b43wrm8bau","tag_id":"cm1m304x2000431b482p01rqc","_id":"cm1m304yc004831b40jf14qy7"},{"post_id":"cm1m304ya003w31b4ckhh1ndt","tag_id":"cm1m304xm001f31b48v7oato6","_id":"cm1m304yc004a31b40f3108gm"},{"post_id":"cm1m304ya003z31b42xb5azxi","tag_id":"cm1m304xm001f31b48v7oato6","_id":"cm1m304yc004b31b42i9q7xkb"},{"post_id":"cm1m304yb004231b47ghacufz","tag_id":"cm1m304xm001f31b48v7oato6","_id":"cm1m304yc004c31b46vrmahlu"},{"post_id":"cm1m304yd004d31b42qxg8i7d","tag_id":"cm1m304xm001f31b48v7oato6","_id":"cm1m304ye004f31b4102d1tbe"},{"post_id":"cm1m304yd004e31b4h5rmhcbb","tag_id":"cm1m304xm001f31b48v7oato6","_id":"cm1m304ye004g31b44hn2ddm9"}],"Tag":[{"name":"JDK","_id":"cm1m304x2000431b482p01rqc"},{"name":"JUC","_id":"cm1m304x4000931b44l3v6w8f"},{"name":"AQS","_id":"cm1m304x9000f31b46hcyg4ax"},{"name":"JVM","_id":"cm1m304xg000z31b4gzuo0xmv"},{"name":"问题排查","_id":"cm1m304xi001831b4709b1mpv"},{"name":"设计模式之美","_id":"cm1m304xm001f31b48v7oato6"},{"name":"消息队列","_id":"cm1m304xp001s31b45z1r6e71"}]}}