<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">


<link rel="stylesheet" href="/blog/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"vqianxiao.github.io","root":"/blog/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="设计模式之观察者模式">
<meta property="og:type" content="article">
<meta property="og:title" content="设计模式之观察者模式">
<meta property="og:url" content="https://vqianxiao.github.io/blog/2021/06/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/index.html">
<meta property="og:site_name" content="言风的博客">
<meta property="og:description" content="设计模式之观察者模式">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/ce/c6/ce842666fa3dc92bb8f4f2d8e75d12c6.jpg">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/bf/45/bf7ef52a40b1e35b18f369265caca645.jpg">
<meta property="article:published_time" content="2021-06-02T05:26:10.000Z">
<meta property="article:modified_time" content="2021-06-02T05:26:10.000Z">
<meta property="article:author" content="言风">
<meta property="article:tag" content="设计模式之美">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://static001.geekbang.org/resource/image/ce/c6/ce842666fa3dc92bb8f4f2d8e75d12c6.jpg">

<link rel="canonical" href="https://vqianxiao.github.io/blog/2021/06/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>设计模式之观察者模式 | 言风的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">言风的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">世界上并没有完美的程序，但我们并不因此而沮丧，因为写程序本来就是一个不断追求完美的过程。</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://vqianxiao.github.io/blog/2021/06/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="言风">
      <meta itemprop="description" content="让自己更值钱，你值得更好的自己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="言风的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          设计模式之观察者模式
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-06-02 13:26:10" itemprop="dateCreated datePublished" datetime="2021-06-02T13:26:10+08:00">2021-06-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/" itemprop="url" rel="index"><span itemprop="name">设计模式之美</span></a>
                </span>
            </span>

          
            <div class="post-description">设计模式之观察者模式</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>根据应用场景的不同，观察者模式会对应不同的代码实现方式：有同步阻塞的实现方式，也有异步非阻塞的实现方式；有进程内的实现方式，也有跨进程的实现方式。</p>
<p>观察者模式（Observer Design Pattern）也被称为发布订阅模式（Publish-Subscribe Design Pattern）。Gof的《设计模式》中定义如下：</p>
<blockquote>
<p>Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.</p>
</blockquote>
<p>翻译成中文就是：在对象之间定义一个一对多的依赖，当一个对象状态改变的时候，所有依赖的对象都会自动收到通知。</p>
<p>一般情况下，被依赖的对象叫做被观察者（Observable），依赖的对象叫做观察者（Observer）。</p>
<p>观察者模式是一个比较抽象的模式，根据不同的应用场景和需求，有完全不同的实现方式。下面是最常见的实现方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer observer)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer observer)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">(Observer observer)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(Message message)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> List&lt;Observer&gt; observers = <span class="keyword">new</span> ArrayList&lt;Observer&gt;();</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">    observers.add(observer);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">    observers.remove(observer);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(Observer observer : observers) &#123;</span><br><span class="line">      observer.update(message);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteObserverOne</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//TODO 获取消息通知 执行自己的逻辑</span></span><br><span class="line">    System.out.println(<span class="string">&quot;ConcreteObserverTwo is notified&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteObserverTwo</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//TODO 获取消息通知 执行自己的逻辑</span></span><br><span class="line">    System.out.println(<span class="string">&quot;ConcreteObserverTwo is notified&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ConcreteSubject subject = <span class="keyword">new</span> ConcreteSubject();</span><br><span class="line">    subject.registerObserver(<span class="keyword">new</span> ConcreteObserverOne());</span><br><span class="line">    subject.registerObserver(<span class="keyword">new</span> ConcreteObserverTwo());</span><br><span class="line">    subject.notifyObservers(<span class="keyword">new</span> Message());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码算是观察者模式的“模版代码”，只能反映大体的设计思路。在真实的软件开发中，并不需要照搬上面的模版代码，观察者模式的实现方法各式各样，函数、类的命名等会根据业务场景的不同有很大的差别，比如register函数还可以叫做attach,remove函数还可以叫做detach等。不过万变不离其宗，设计思路都是差不多的。</p>
<p>那么什么情况下需要用到这种设计模式？假设我们在开发一个P2P投资理财系统，用户注册成功之后，我们会给用户发放投资体验金。代码实现大致是下面这个样子的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> UserService userService; <span class="comment">//依赖注入</span></span><br><span class="line">  <span class="keyword">private</span> PromotionService promotionService; <span class="comment">//依赖注入</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> Long <span class="title">register</span> <span class="params">(String telephone,String password)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//省略输入参数的校验代码</span></span><br><span class="line">    <span class="comment">//省略userService.register()异常的try-catch代码</span></span><br><span class="line">    <span class="keyword">long</span> userId = userService.register(telephone,password);</span><br><span class="line">    promotionService.issueNewUserExperienceCash(userId);</span><br><span class="line">    <span class="keyword">return</span> userId;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然注册接口做了两件事情，注册和发放体验金，违反单一职责原则，但是如果没有扩展和修改的需求，现在的代码实现是可以接受的。如果非得用观察者模式，就需要引入更多的类和更加复杂的代码结构，反倒是一种过度设计。</p>
<p>相反如果需求频繁变动，比如，用户注册成功之后，不再发放体验金，而是改为发放优惠券，并且还要给用户发送一封“欢迎注册成功”的站内信。这种情况下，我们就需要频繁地修改register()函数中的代码，违反开闭原则。而且，如果注册成功之后需要执行的后续操作越来越多，那register()函数的逻辑会变得越来越复杂，也就影响到代码的可读性和可维护性。</p>
<p>这个时候，观察者模式就能派上用场了。利用观察者模式，我对上面的代码进行了重构。重构之后的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RegObserver</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">handleRegSuccess</span><span class="params">(<span class="keyword">long</span> userId)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegPromotionObserver</span> <span class="keyword">implements</span> <span class="title">RegObserver</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> PromotionService promotionService; <span class="comment">//依赖注入</span></span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRegSuccess</span><span class="params">(<span class="keyword">long</span> userId)</span> </span>&#123;</span><br><span class="line">    promotionService.issueNewUserExperienceCash(userId);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegNotificationObserver</span> <span class="keyword">implements</span> <span class="title">RegObserver</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> NotificationService notificationService;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRegSuccess</span><span class="params">(<span class="keyword">long</span> userId)</span> </span>&#123;</span><br><span class="line">    notificationService.sendInboxMessage(userId,<span class="string">&quot;Welcome...&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> UserService userService; <span class="comment">//依赖注入</span></span><br><span class="line">  <span class="keyword">private</span> List&lt;RegObserver&gt; regObservers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//一次性设置好，之后也不可能动态的修改</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRegObservers</span><span class="params">(List&lt;RegObserver&gt; observers)</span> </span>&#123;</span><br><span class="line">    regObservers.addAll(observers);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> Long <span class="title">register</span><span class="params">(String telephone,String password)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//省略输入参数的校验代码</span></span><br><span class="line">    <span class="comment">//省略userService.register()异常的try-catch代码</span></span><br><span class="line">    <span class="keyword">long</span> userId = userService.register(telephone, password);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (RegObserver observer : regObservers) &#123;</span><br><span class="line">      observer.handleRegSuccess(userId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> userId;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当需要添加新的观察者的时候，比如注册成功后，推送用户注册信息给大数据征信系统，基于观察者模式的代码实现，UserController类的register()函数完全不需要修改，只需要再添加一个实现了RegObserver接口的类，并且通过setRegObservers()函数将它注册到UserController类中即可。</p>
<p>实际上，设计模式要干的事情就是解耦。创建型模式是将创建和使用代码解耦，结构型模式是将不同功能代码解耦，行为型模式是将不同的行为代码解耦，具体到观察者模式，它是将观察者和被观察者代码解耦。借助设计模式，我们利用更好的代码结构，将一大坨代码拆分成职责更单一的小类，让其满足开闭原则、高内聚送偶合等特性，以此来控制和应对代码的复杂性，提高代码的可扩展性。</p>
<h5 id="基于不同应用场景的不同实现方式"><a href="#基于不同应用场景的不同实现方式" class="headerlink" title="基于不同应用场景的不同实现方式"></a>基于不同应用场景的不同实现方式</h5><p>观察者模式的应用场景非常广泛，小到代码层面的解耦，大到架构层面的系统解耦，再或者一些产品的设计思路，都有这种模式的影子，比如邮件订阅、RSS Feeds，本质上都是观察者模式。</p>
<p>之前的实现方式，从上面的分类方式上来看，它是一种同步阻塞的实现方式。观察者和被观察者代码在同一个线程内执行，被观察者一直阻塞，直到所有的观察者代码都执行完成之后，才执行后续的代码。对照上面讲到的用户注册的例子，register()函数依次调用执行每个观察者的handleRegSuccess()函数，等到都执行完成之后，才会返回结果给客户端。</p>
<p>如果注册接口是一个调用比较频繁的接口，对性能非常敏感，希望接口的响应时间仅可能短，那我们可以将同步阻塞的实现方式改为异步非阻塞的实现方式，以此来减少响应时间。具体来说，当userService.register()函数执行完成之后，我们启动一个新的线程来执行观察者的handleRegSuccess()函数，这样userController.register()函数就不需要等到所有的handleRegSuccess()函数都执行完成之后才返回结果给客户端。</p>
<p>如何实现一个异步非阻塞的观察者模式呢？最简单的做法是，在每个handleRegSuccess()函数中，创建一个新的线程执行代码。不过还有更优雅的实现方式，就是基于EventBus来实现。后面详细讲Google Guava EventBus框架的设计思想。</p>
<p>刚刚的两个场景，不管是同步阻塞实现方式还是异步非阻塞实现方式，都是进程内的实现方式。如果用户注册成功之后，我们需要发送用户信息给大数据征信系统，而大数据征信系统是一个独立的系统，跟它之间的交互是跨不同进程的，那如何实现一个跨进程的观察者模式呢？</p>
<p>如果大数据征信系统提供了发送用户注册信息的RPC接口，可以沿用之前的实现思路，在handleRegSuccess()函数中调用RPC接口来发送数据。还有更加优雅，更常用的实现方式，就是基于消息队列（Message Queue 比如ActiveMQ）来实现。</p>
<p>这种实现方式也有弊端，就是需要引入一个新的系统（消息队列），增加了维护成本。不过好处也非常明显，在原来的实现中，观察者需要注册到被观察者中，被观察者需要依次遍历观察者来发送消息。而基于消息队列的方式，被观察者和观察者解耦更加彻底，两部分的耦合更小。被观察者完全不感知观察者，同理，观察者也完全不感知被观察者。被观察者直管发送消息到消息队列，观察者只管从消息队列中读取消息来执行相应的逻辑。</p>
<h5 id="异步非阻塞观察者模式的简易实现"><a href="#异步非阻塞观察者模式的简易实现" class="headerlink" title="异步非阻塞观察者模式的简易实现"></a>异步非阻塞观察者模式的简易实现</h5><p>实现异步非阻塞观察者模式，如果只是实现一个简易版本，不考虑任何通用型、复用性，实际上是非常容易的。</p>
<p>有两种实现方式，第一种：在每个HandleRegSuccess()函数中创建一个新的线程执行代码逻辑；另一种：在UserController的register()函数中使用线程池来执行每个观察者的handleRegSuccess()函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种实现方式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegPromotionObserver</span> <span class="keyword">implements</span> <span class="title">RegObserver</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> PromotionService promotionService; <span class="comment">//依赖注入</span></span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRegSuccess</span><span class="params">(Long userId)</span> </span>&#123;</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        promotionService.issueNewUserExperienceCash(userId);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    thread.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种实现方式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> UserService userService; <span class="comment">//依赖注入</span></span><br><span class="line">  <span class="keyword">private</span> List&lt;RegObserver&gt; regObservers = <span class="keyword">new</span> ArrayList();</span><br><span class="line">  <span class="keyword">private</span> Executor executor;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">UserController</span><span class="params">(Executor executor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.executor = executor;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> Long <span class="title">register</span><span class="params">(String telephone,String password)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//省略输入参数的校验代码</span></span><br><span class="line">    <span class="comment">//省略userService.register()异常的try-cache代码</span></span><br><span class="line">    <span class="keyword">long</span> userId = userService.register(telephone,password);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(RegObserver observer : regObservers) &#123;</span><br><span class="line">      executor.execute(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          observer.handleRegSuccess(userId);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> userId;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一种方式，频繁地藏剑和销毁线程比较耗时，并且并发线程数无法控制，创建过多线程会导致堆栈溢出。第二种实现方式，虽然利用了线程池解决了第一种方式的问题，但线程池、异步执行逻辑都耦合在了register()函数中，增加了这部分代码的维护成本。</p>
<p>如果需求极端一点，要求在同步阻塞和异步非阻塞之间灵活切换，那就要不停地修改UserController的代码。除此之外，如果在项目中，不止一个业务模块需要用到异步非阻塞观察者模式，那这样的代码实现也无法做到复用。</p>
<p>框架的作用有：隐藏实现细节，降低开发难度，做到代码复用，解耦业务与非业务代码，让程序员聚焦业务开发。</p>
<h5 id="EventBus框架功能需求介绍"><a href="#EventBus框架功能需求介绍" class="headerlink" title="EventBus框架功能需求介绍"></a>EventBus框架功能需求介绍</h5><p>EventBus翻译为“事件总线”，它提供了实现观察者模式的骨架代码。Google Guava EventBus就是一个比较著名的EventBus框架，它不仅仅支持异步非阻塞模式，同时也支持同步阻塞模式。使用Guava EventBus重新实现上面的例子。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> UserService userService; <span class="comment">//依赖注入</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> EventBus eventBus;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_EVENTBUS_THREAD_POOL_SIZE = <span class="number">20</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">UserController</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//eventBus = new EventBus(); //同步阻塞模式</span></span><br><span class="line">    eventBus = <span class="keyword">new</span> AsyncEventBus(Executors.newFixedThreadpool(DEFAULT_EVENTBUS_THREAD_POOL_SIZE)); <span class="comment">//异步非阻塞模式</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRegObservers</span><span class="params">(List&lt;Object&gt; observers)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(Object observer : observers) &#123;</span><br><span class="line">      eventBus.register(observer);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> Long <span class="title">register</span><span class="params">(String telephone,String password)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//省略输入参数的校验代码</span></span><br><span class="line">    <span class="comment">//省略userService.register() 异常try-catch代码</span></span><br><span class="line">    <span class="keyword">long</span> userId = userService.register(telephone,password);</span><br><span class="line">    </span><br><span class="line">    eventBus.post(userId);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> userId;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegPromotionObserver</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> PromotionService promotionService; <span class="comment">//依赖注入</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Subscribe</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRegSuccess</span><span class="params">(Long userId)</span> </span>&#123;</span><br><span class="line">      promotionService.issueNewUserExperienceCashh(userId);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegNotificationObserver</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> NotificationService notificationService; <span class="comment">//依赖注入</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Subscribe</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRegSuccess</span><span class="params">(Long userId)</span> </span>&#123;</span><br><span class="line">      notificationService.sendInboxMessage(userId, <span class="string">&quot;...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>利用EventBus框架实现的观察者模式，从大的流程上来说，思路大致一样，都需要定义Observer，并且通过register()函数注册Observer，也都是通过调用某个函数(EventBus中的post()函数)来给Observer发送消息（在EventBus中消息被称作事件event）。</p>
<p>但是细节上又有区别，基于EventBus，我们不需要定义Observer接口，任意类型的对象都可以注册到EventBus中，通过@Subscribe注解来标明类中哪个函数可以接受被观察者发送的消息。</p>
<p>下面详细讲解下，Guava EventBus的几个主要的类和函数</p>
<ul>
<li>EventBus、AsyncEventBus</li>
</ul>
<p>Guava EventBus对外暴露的所有可调用接口，都封装在EventBus类中。其中EventBus类中实现了同步阻塞的观察者模式，AsyncEventBus继承自EventBus，提供了异步非阻塞的观察者模式。使用方式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EventBus eventBus = <span class="keyword">new</span> EventBus(); <span class="comment">// 同步阻塞模式</span></span><br><span class="line">EventBus eventBus = <span class="keyword">new</span> AsyncEventBus(Executors.newFixedThreadPool(<span class="number">8</span>))；<span class="comment">// 异步阻塞模式</span></span><br></pre></td></tr></table></figure>

<ul>
<li>register()函数</li>
</ul>
<p>EventBus类提供了register()函数来注册观察者。具体函数定义如下。它可以接受任何类型（Object）的观察者，而在经典的观察者模式的实现中，register()函数必须接受同一Observer接口的类对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Object object)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>unregister()函数</li>
</ul>
<p>相对于register()函数，unregister()函数用来从EventBus中删除某个观察者。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unregister</span><span class="params">(Object object)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>post()函数</li>
</ul>
<p>EventBus类提供了post()函数，用来给观察者发送消息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">post</span><span class="params">(Object object)</span></span>;</span><br></pre></td></tr></table></figure>

<p>跟观察者模式的不同之处在于，当调用post()函数发送消息的时候，并非把消息发送给所有的观察者，而是发送给可匹配的观察者。所谓的可匹配指的是，能接受的消息类型是发送消息（post函数定义中的event）类型的父类。</p>
<p>比如，AObserver能接收的消息类型是XMsg，BObserver能接收的消息类型是YMsg，CObserver能接收的消息类型是ZMsg。其中，XMsg是YMsg的父类。当我们如下发送消息的时候，相应能接收到消息的可匹配观察者如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">XMsg xMsg = new XMsg();</span><br><span class="line">YMsg yMsg = new YMsg();</span><br><span class="line">ZMsg zMsg = new ZMsg();</span><br><span class="line">post(xMsg); =&gt; AObserver接收到消息</span><br><span class="line">post(yMsg); =&gt; AObserver、BObserver接收到消息</span><br><span class="line">post(zMsg); =&gt; CObserver接收到消息</span><br></pre></td></tr></table></figure>

<p>可能会比较疑惑，每个Observer能接收的消息类型是在哪里定义的，来看下Guava EventBus最特别的一个地方，就是@Subscribe注解。</p>
<ul>
<li>@Subscribe注解</li>
</ul>
<p>EventBus通过@Subscribe注解来标明，某个函数能接收哪种类型的消息。具体代码如下。子DObserver类中，我们通过@Subscribe注解了两个函数f1()、f2()。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DObserver</span> </span>&#123;</span><br><span class="line">  <span class="comment">//省略其他属性和方法</span></span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Subscribe</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">(PMsg event)</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="meta">@Subscribe</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">(QMsg event)</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当通过register()函数将DObserver类对象注册到EventBus的时候，EventBus会根据@Subscribe注解找到f1()和f2()，并且将两个函数能接收的消息类型纪录下来（PMsg-&gt;f1,QMsg-&gt;f2）。当我们通过post()函数发送消息（比如QMsg消息）的时候，EventBus会通过之前的纪录（QMsg-&gt;f2）,调用相应的函数（f2）。</p>
<h5 id="手把手实现一个EventBus框架"><a href="#手把手实现一个EventBus框架" class="headerlink" title="手把手实现一个EventBus框架"></a>手把手实现一个EventBus框架</h5><p>EventBus中两个核心函数register()和post()的实现原理。弄懂了它们，基本上就弄懂了整个EventBus框架。下面两张图是这两个函数的实现原理图。<br><img src="https://static001.geekbang.org/resource/image/ce/c6/ce842666fa3dc92bb8f4f2d8e75d12c6.jpg" alt="img"></p>
<p><img src="https://static001.geekbang.org/resource/image/bf/45/bf7ef52a40b1e35b18f369265caca645.jpg" alt="img"></p>
<p>从图中看出，最关键的数据结构是Observer注册表，记录了消息类型和可接收消息函数的对应关系。当调用register()函数注册观察者的时候，Eventbus通过解析@Subscribe注解，生成Observer注册表。当调用post()函数发送消息的时候，EventBus通过这册表找到相应的可接受消息的函数，然后通过Java的反射语法来动态地创建对象、执行函数。对于同步阻塞模式，EventBus在一个线程内依次执行相应的函数。对于异步非阻塞模式，EventBus通过一个线程池来执行相应的函数。</p>
<p>原理弄懂了，实现起来就简单多了。整个小框架代码实现包括5个类：EventBus、AsyncEventBus、Subscribe、ObserverAction、ObserverRegistry。</p>
<h5 id="1-Subscribe"><a href="#1-Subscribe" class="headerlink" title="1.Subscribe"></a>1.Subscribe</h5><p>Subscribe是一个注解，用于表明观察者中的哪个函数可以接收消息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Beta</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Subscribe &#123;&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-ObserverAction"><a href="#2-ObserverAction" class="headerlink" title="2.ObserverAction"></a>2.ObserverAction</h5><p>ObserverAction类用来表示@Subscribe注解的方法，其中，target表示观察者类，method表示方法。它主要用在ObserverRegistry观察者注册表中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserverAction</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Object target;</span><br><span class="line">  <span class="keyword">private</span> Method method;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ObserverAction</span><span class="params">(Object target,Method method)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.target = Preconditions.checkNotNull(target);</span><br><span class="line">    <span class="keyword">this</span>.method = method;</span><br><span class="line">    <span class="keyword">this</span>.method.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Object event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      method.invoke(target,event);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException | IllegalAccessException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-ObserverRegistry"><a href="#3-ObserverRegistry" class="headerlink" title="3.ObserverRegistry"></a>3.ObserverRegistry</h5><p>ObserverRegistry类就是前面讲到的Observer注册表，是最复杂的一个类，框架中几乎所有的核心逻辑都在这个类中。这个类中大量使用了Java的反射语法，比较有技巧的是CopyOnWriteArraySet的使用。</p>
<p>CopyOnWriteArraySet，顾名思义，在写入数据的时候，会创建一个新的set，并且将原始数据clone到新的set中，在新的set中写入数据完成之后，再用新的set替换老的set。这样就能保证写入数据的时候，不影响数据的读操作，以此来解决读写并发问题。除此之外，CopyOnWriteArraySet还通过加锁的方式，避免了并发写冲突。具体的作用可以看下CopyOnWriteArraySet类的源码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserverRegistry</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> ConcurrentMap&lt;Class&lt;?&gt;, CopyOnWriteArraySet&lt;ObserverAction&gt;&gt; registry = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Object observer)</span> </span>&#123;</span><br><span class="line">    Map&lt;Class&lt;?&gt;, Collection&lt;ObserverAction&gt;&gt; observerActions = findAllObserverActions(observer);</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Class&lt;?&gt;, Collection&lt;ObserverAction&gt;&gt; entry : observerActions.entrySet()) &#123;</span><br><span class="line">      Class&lt;?&gt; eventType = entry.getKey();</span><br><span class="line">      Collection&lt;ObserverAction&gt; eventActions = entry.getValue();</span><br><span class="line">      CopyOnWriteArraySet&lt;ObserverAction&gt; registeredEventActions = registry.get(eventType);</span><br><span class="line">      <span class="keyword">if</span> (registeredEventActions == <span class="keyword">null</span>) &#123;</span><br><span class="line">        registry.putIfAbsent(eventType, <span class="keyword">new</span> CopyOnWriteArraySet&lt;&gt;());</span><br><span class="line">        registeredEventActions = registry.get(eventType);</span><br><span class="line">      &#125;</span><br><span class="line">      registeredEventActions.addAll(eventActions);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;ObserverAction&gt; <span class="title">getMatchedObserverActions</span><span class="params">(Object event)</span> </span>&#123;</span><br><span class="line">    List&lt;ObserverAction&gt; matchedObservers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Class&lt;?&gt; postedEventType = event.getClass();</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Class&lt;?&gt;, CopyOnWriteArraySet&lt;ObserverAction&gt;&gt; entry : registry.entrySet()) &#123;</span><br><span class="line">      Class&lt;?&gt; eventType = entry.getKey();</span><br><span class="line">      Collection&lt;ObserverAction&gt; eventActions = entry.getValue();</span><br><span class="line">      <span class="keyword">if</span> (eventType.isAssignableFrom(postedEventType)) &#123;</span><br><span class="line">        matchedObservers.addAll(eventActions);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> matchedObservers;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Map&lt;Class&lt;?&gt;, Collection&lt;ObserverAction&gt;&gt; findAllObserverActions(Object observer) &#123;</span><br><span class="line">    Map&lt;Class&lt;?&gt;, Collection&lt;ObserverAction&gt;&gt; observerActions = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    Class&lt;?&gt; clazz = observer.getClass();</span><br><span class="line">    <span class="keyword">for</span> (Method method : getAnnotatedMethods(clazz)) &#123;</span><br><span class="line">      Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">      Class&lt;?&gt; eventType = parameterTypes[<span class="number">0</span>];</span><br><span class="line">      <span class="keyword">if</span> (!observerActions.containsKey(eventType)) &#123;</span><br><span class="line">        observerActions.put(eventType, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">      &#125;</span><br><span class="line">      observerActions.get(eventType).add(<span class="keyword">new</span> ObserverAction(observer, method));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> observerActions;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> List&lt;Method&gt; <span class="title">getAnnotatedMethods</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">    List&lt;Method&gt; annotatedMethods = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Method method : clazz.getDeclaredMethods()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (method.isAnnotationPresent(Subscribe.class)) &#123;</span><br><span class="line">        Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">        Preconditions.checkArgument(parameterTypes.length == <span class="number">1</span>,</span><br><span class="line">                <span class="string">&quot;Method %s has @Subscribe annotation but has %s parameters.&quot;</span></span><br><span class="line">                        + <span class="string">&quot;Subscriber methods must have exactly 1 parameter.&quot;</span>,</span><br><span class="line">                method, parameterTypes.length);</span><br><span class="line">        annotatedMethods.add(method);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> annotatedMethods;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-EventBus"><a href="#4-EventBus" class="headerlink" title="4.EventBus"></a>4.EventBus</h5><p>EventBus实现的是阻塞同步的观察者模式。看代码可能会疑惑，明明用到了线程池Executor。实际上，MoreExecutors.directExecutor()是Googld Guava提供的工具类，看似是多线程，实际上是单线程。之所以这么实现，是为了跟AsyncEventBus统一代码逻辑，做到代码复用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventBus</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Executor executor;</span><br><span class="line">  <span class="keyword">private</span> ObserverRegistry registry = <span class="keyword">new</span> ObserverRegistry();</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">EventBus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(MoreExecutors.directExecutor());</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="title">EventBus</span><span class="params">(Executor executor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.executor = executor;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">    registry.register(object);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">post</span><span class="params">(Object event)</span> </span>&#123;</span><br><span class="line">    List&lt;ObserverAction&gt; observerActions = registry.getMatchedObserverActions(event);</span><br><span class="line">    <span class="keyword">for</span>(ObserverAction observerAction : observerActions) &#123;</span><br><span class="line">      executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          observerAction.execute(event);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-AsyncEventBus"><a href="#5-AsyncEventBus" class="headerlink" title="5.AsyncEventBus"></a>5.AsyncEventBus</h5><p>有了EventBus，AsyncEventBus的实现就非常简单了。为了实现异步非阻塞的观察者模式，它就不能再继续使用MoreExecutors.directExecutor()了，而是需要在构造函数中，由调用者注入线程池。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncEventBus</span> <span class="keyword">extends</span> <span class="title">EventBus</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">AsyncEventBus</span> <span class="params">(Executor executor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(executor);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，用了不到200行代码。就实现了一个凑活能用的EventBus，功能上来说，和Google Guava EventBus几乎一样。如果查看 <a target="_blank" rel="noopener" href="https://github.com/google/guava">Google Guava EventBus源码</a> ，实现细节上，它做了很多优化，比如在注册表中查找消息可匹配函数的算法。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/blog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/" rel="tag"># 设计模式之美</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/blog/2021/06/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/" rel="prev" title="设计模式之享元模式">
      <i class="fa fa-chevron-left"></i> 设计模式之享元模式
    </a></div>
      <div class="post-nav-item">
    <a href="/blog/2021/06/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/" rel="next" title="设计模式之策略模式">
      设计模式之策略模式 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E4%B8%8D%E5%90%8C%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E7%9A%84%E4%B8%8D%E5%90%8C%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="nav-number">1.</span> <span class="nav-text">基于不同应用场景的不同实现方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E9%9D%9E%E9%98%BB%E5%A1%9E%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%AE%80%E6%98%93%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.</span> <span class="nav-text">异步非阻塞观察者模式的简易实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#EventBus%E6%A1%86%E6%9E%B6%E5%8A%9F%E8%83%BD%E9%9C%80%E6%B1%82%E4%BB%8B%E7%BB%8D"><span class="nav-number">3.</span> <span class="nav-text">EventBus框架功能需求介绍</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%89%8B%E6%8A%8A%E6%89%8B%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAEventBus%E6%A1%86%E6%9E%B6"><span class="nav-number">4.</span> <span class="nav-text">手把手实现一个EventBus框架</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-Subscribe"><span class="nav-number">5.</span> <span class="nav-text">1.Subscribe</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-ObserverAction"><span class="nav-number">6.</span> <span class="nav-text">2.ObserverAction</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-ObserverRegistry"><span class="nav-number">7.</span> <span class="nav-text">3.ObserverRegistry</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-EventBus"><span class="nav-number">8.</span> <span class="nav-text">4.EventBus</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-AsyncEventBus"><span class="nav-number">9.</span> <span class="nav-text">5.AsyncEventBus</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">言风</p>
  <div class="site-description" itemprop="description">让自己更值钱，你值得更好的自己</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blog/archives/">
        
          <span class="site-state-item-count">39</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">言风</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/blog/lib/anime.min.js"></script>
  <script src="/blog/lib/velocity/velocity.min.js"></script>
  <script src="/blog/lib/velocity/velocity.ui.min.js"></script>

<script src="/blog/js/utils.js"></script>

<script src="/blog/js/motion.js"></script>


<script src="/blog/js/schemes/muse.js"></script>


<script src="/blog/js/next-boot.js"></script>




  















  

  

</body>
</html>
